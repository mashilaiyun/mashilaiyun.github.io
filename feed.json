{
    "version": "https://jsonfeed.org/version/1",
    "title": "msl的博客",
    "description": "随笔",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/07/23/first/",
            "url": "http://example.com/2023/07/23/first/",
            "title": "first",
            "date_published": "2023-07-23T13:10:05.000Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/23/VS-code%E4%B8%8A%E5%85%B3%E4%BA%8EC-C-%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/",
            "url": "http://example.com/2023/07/23/VS-code%E4%B8%8A%E5%85%B3%E4%BA%8EC-C-%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/",
            "title": "VS code上关于C/C++的环境配置",
            "date_published": "2023-07-23T12:25:29.000Z",
            "content_html": "<h1 id=\"vs-code-cc编译配置\"><a class=\"markdownIt-Anchor\" href=\"#vs-code-cc编译配置\">#</a> VS code   C/C++ 编译配置</h1>\n<h4 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h4>\n<p>前两天有同学问我如何用 VScode 搭建 C 语言的环境。</p>\n<p>接下来直接动手搭建 C 和 C++ 的环境。</p>\n<h4 id=\"vs-code简单介绍\"><a class=\"markdownIt-Anchor\" href=\"#vs-code简单介绍\">#</a> VS Code 简单介绍</h4>\n<p>VS code 是一个微软旗下的一个广受欢迎的开源文本编辑器，相较于其他编辑器，VS code 有着非常多的优点而让开发者们对其爱不释手。</p>\n<blockquote>\n<p>比如炫酷的主题、漂亮的外观、集成了终端以及轻量级的体积等等等等，VS code 最厉害的地方在于他有着成熟的插件市场（我们下面马上就要用到）以满足开发者的各种开发需求，得益于这个插件市场，我们可以把 VS code 打造成各种开发环境。</p>\n</blockquote>\n<p>VS code 的下载也很简单，直接去官网下载安装即可。</p>\n<h4 id=\"mingw简单介绍和下载配置\"><a class=\"markdownIt-Anchor\" href=\"#mingw简单介绍和下载配置\">#</a> MinGW 简单介绍和下载配置</h4>\n<p>需要注意的一点是，VS code 只是一个文本编辑器，本质上和 Windows 的记事本是一个东西，它不是一个编译器，它只是一个编辑器，编辑器是无法编译运行程序的，这是编译器的工作。</p>\n<p>那么为了让我们能够在 VS code 里面编译并运行 C/CPP 文件，我们需要去额外安装 C 和 C++ 的编译器：GCC。</p>\n<p>Windows 平台上的 GCC 移植版本是 MinGW。我们用 MinGW 其实也就是用里面的 GCC 来编译我们写的 C/C++ 文件。</p>\n<p>进去之后，选择 files：</p>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/EHHQdUR0vqiaCPWltkFDa30a3PELlOmBticvbVLkboZ38icP9yDKakNNJHFQOPmBjBBJWrDibBSdAwPfWbWR2MjOEg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\"></p>\n<p>下载 MinGW 的压缩包：</p>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/EHHQdUR0vqiaCPWltkFDa30a3PELlOmBtSXmplRpb6Y6Yx1L1ibEkzWXzF5v6cia1fw0wsofs5JyezcACqm7yx5YA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\"></p>\n<p>下载过程由于是从外网下载，会比较慢，可以多试几次或者挂代理，另外根据笔者的经验来看外网的东西一般中午下载起来会比较快。</p>\n<p>下载好了之后把他放在一个没有中文和空格的目录下解压，然后配置环境变量。</p>\n<blockquote>\n<p>在 Win10 的搜索栏（快捷键 win+S）搜索环境变量会弹出系统属性，点击环境变量 —— 上方的用户变量里面找到 Path—— 点击编辑 —— 点击新建，然后把你的 MinGW 的 bin 路径复制进去（如：D:\\development\\MinGW\\bin），然后一路确定。</p>\n</blockquote>\n<p>这样环境变量就配置好了，我们可以随便找一个路径打开一个 cmd 输入：gcc --version 来验证一下：</p>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/EHHQdUR0vqiaCPWltkFDa30a3PELlOmBtumvSe6bSoE6DCbYWjH8urskbEgTpz79ibSdMF8vm2XBIPITztv684rw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\"></p>\n<p>接下来我们配置 VScode</p>\n<h4 id=\"vscode配置\"><a class=\"markdownIt-Anchor\" href=\"#vscode配置\">#</a> VScode 配置</h4>\n<p>打开 VScode，然后打开左边的插件市场，下载并安装两个插件：</p>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/EHHQdUR0vqiaCPWltkFDa30a3PELlOmBtOP9X3rJ5ugqwdSAHs7lvunSjEedgQ0hNyhT4XAddOgG1MsXcicUYNlg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\"></p>\n<p>● Chinese：中文汉化插件，VScode 默认是英文界面，为了方便咱给他改成中文的。在搜索栏搜索 Chinese，选则中文简体点击右下角的安装（我这里安装过了所以没有那个安装按钮）。</p>\n<p>● C/C++：一款 C/C++ 语法高亮的代码插件。安装方式和 Chinese 一样。</p>\n<p>搞定之后我们来写一个 C 文件测试一下，点击左上角的文件 —— 打开文件夹 —— 选择一个空文件夹打开，然后右键 —— 新建文件：</p>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/EHHQdUR0vqiaCPWltkFDa30a3PELlOmBteuxib55rIYernlqTGxmGA1bma85YHdiabfWssQSq1PMMzLFOyF3icZGJQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\"></p>\n<p>随便起个名（如 Hello.c），随便写点代码，比如经典的 Hello World：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello World!&quot;</span>);    </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们编译他，点击最上方的终端–&gt; 配置默认生成任务（也可以用快捷键 ctrl+shift+b）然后你会看到这样一个选项：</p>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/EHHQdUR0vqiaCPWltkFDa30a3PELlOmBt84cuNhDjic3QOeaSAcE2IoiahMl8UIOonztA7mscJdCr9mSIAfmuPhlg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\"></p>\n<p>这是让我们选择用什么来编辑这个文件，由于我们写的是 C 文件，应该用能够编译 C 文件的编译器（也就是我们上文配置的 MinGW 里面的 GCC）。</p>\n<p>我们点击这里的 C/C++ 编辑器，然后就会发现我们这里生成了一个 Hello.exe 文件和 .vs code 文件夹。</p>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/EHHQdUR0vqiaCPWltkFDa30a3PELlOmBtQcIAsIwU6xNQBLiboQFXc06ibicBP1HRWtTgqVOq3icqeZYXCjdhcj6u7Q/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\"></p>\n<p>打开一个终端（终端 —— 新终端），输入.\\Hello.exe 来运行这个文件，你会发现终端成功输出 Hello World，这代表成功运行。</p>\n<p>至于这个.vscode 文件夹，是当前文件夹里的一些配置文件（比如这里的 task.json，它其中写入了使用什么编译器，编译器的路径等信息）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class=\"line\">    &quot;tasks&quot;: [</span><br><span class=\"line\">        &#123;//这个大括号里是‘构建（build）’任务</span><br><span class=\"line\">            &quot;label&quot;: &quot;build&quot;, //任务名称，可以更改，不过不建议改</span><br><span class=\"line\">            &quot;type&quot;: &quot;shell&quot;, //任务类型，process是vsc把预定义变量和转义解析后直接全部传给command；shell相当于先打开shell再输入命令，所以args还会经过shell再解析一遍</span><br><span class=\"line\">            &quot;command&quot;: &quot;gcc&quot;, //编译命令，这里是gcc，编译c++的话换成g++</span><br><span class=\"line\">            &quot;args&quot;: [    //方括号里是传给gcc命令的一系列参数，用于实现一些功能</span><br><span class=\"line\">                &quot;$&#123;file&#125;&quot;, //指定要编译的是当前文件</span><br><span class=\"line\">                &quot;-o&quot;, //指定输出文件的路径和名称</span><br><span class=\"line\">                &quot;$&#123;fileDirname&#125;\\\\bin\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;, //承接上一步的-o，让可执行文件输出到源码文件所在的文件夹下的bin文件夹内，并且让它的名字和源码文件相同</span><br><span class=\"line\">                &quot;-g&quot;, //生成和调试有关的信息</span><br><span class=\"line\">                //&quot;-Wall&quot;, // 开启额外警告</span><br><span class=\"line\">                //&quot;-static-libgcc&quot;,  // 静态链接libgcc</span><br><span class=\"line\">                &quot;-fexec-charset=GBK&quot;, // 生成的程序使用GBK编码，不加这一条会导致Win下输出中文乱码</span><br><span class=\"line\">                &quot;-std=c11&quot;, // 语言标准，可根据自己的需要进行修改，写c++要换成c++的语言标准，比如c++11</span><br><span class=\"line\">            ],</span><br><span class=\"line\">            &quot;group&quot;: &#123;  //group表示‘组’，我们可以有很多的task，然后把他们放在一个‘组’里</span><br><span class=\"line\">                &quot;kind&quot;: &quot;build&quot;,//表示这一组任务类型是构建</span><br><span class=\"line\">                &quot;isDefault&quot;: true//表示这个任务是当前这组任务中的默认任务</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &quot;presentation&quot;: &#123; //执行这个任务时的一些其他设定</span><br><span class=\"line\">                &quot;echo&quot;: true,//表示在执行任务时在终端要有输出</span><br><span class=\"line\">                &quot;reveal&quot;: &quot;always&quot;, //执行任务时是否跳转到终端面板，可以为always，silent，never</span><br><span class=\"line\">                &quot;focus&quot;: false, //设为true后可以使执行task时焦点聚集在终端，但对编译来说，设为true没有意义，因为运行的时候才涉及到输入</span><br><span class=\"line\">                &quot;panel&quot;: &quot;new&quot; //每次执行这个task时都新建一个终端面板，也可以设置为shared，共用一个面板，不过那样会出现‘任务将被终端重用’的提示，比较烦人 </span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &quot;problemMatcher&quot;: &quot;$gcc&quot; //捕捉编译时编译器在终端里显示的报错信息，将其显示在vs code的‘问题’面板里</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;//这个大括号里是‘运行(run)’任务，一些设置与上面的构建任务性质相同</span><br><span class=\"line\">            &quot;label&quot;: &quot;run&quot;,</span><br><span class=\"line\">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class=\"line\">            &quot;dependsOn&quot;: &quot;build&quot;, //任务依赖，因为要运行必须先构建，所以执行这个任务前必须先执行build任务，</span><br><span class=\"line\">            &quot;command&quot;: &quot;$&#123;fileDirname&#125;\\\\bin\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;, //执行exe文件，只需要指定这个exe文件在哪里就好</span><br><span class=\"line\">            &quot;group&quot;: &#123;</span><br><span class=\"line\">                &quot;kind&quot;: &quot;test&quot;, //这一组是‘测试’组，将run任务放在test组里方便我们用快捷键执行</span><br><span class=\"line\">                &quot;isDefault&quot;: true</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &quot;presentation&quot;: &#123;</span><br><span class=\"line\">                &quot;echo&quot;: true,</span><br><span class=\"line\">                &quot;reveal&quot;: &quot;always&quot;,</span><br><span class=\"line\">                &quot;focus&quot;: true, //这个就设置为true了，运行任务后将焦点聚集到终端，方便进行输入</span><br><span class=\"line\">                &quot;panel&quot;: &quot;new&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"调试程序\"><a class=\"markdownIt-Anchor\" href=\"#调试程序\">#</a> 调试程序</h4>\n<p>接下来我们说调试，VS code 的调试快捷键是 F5，按下 F5，会出现调试器选择界面：</p>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/EHHQdUR0vqiaCPWltkFDa30a3PELlOmBtD8AeNkojQU2xkicIic6CDdtBicQzicywCTVuia849xTU9z4NlCyyxiaIJIfQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\"></p>\n<p>选择 GDB，再选择 gcc，你会发现终端那里跳转到了调试控制台，并且 .vscode 文件夹下面又多了一个 launch.json 文件，上文我们已经说过了 .vscode 文件夹存放当前工作文件夹的一些配置文件。</p>\n<blockquote>\n<p>例如 task.json 其实是编译运行的配置文件，这里的 launch.json 文件就是调试相关的配置文件，详解如下：</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class=\"line\">    &quot;configurations&quot;: [</span><br><span class=\"line\">        &#123; //这个大括号里是我们的‘调试(Debug)’配置</span><br><span class=\"line\">            &quot;name&quot;: &quot;Debug&quot;, // 配置名称</span><br><span class=\"line\">            &quot;type&quot;: &quot;cppdbg&quot;,  // 配置类型，cppdbg对应cpptools提供的调试功能；可以认为此处只能是cppdbg</span><br><span class=\"line\">            &quot;request&quot;: &quot;launch&quot;,  // 请求配置类型，可以为launch（启动）或attach（附加）</span><br><span class=\"line\">            &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\\\bin\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;,  // 将要进行调试的程序的路径</span><br><span class=\"line\">            &quot;args&quot;: [],  // 程序调试时传递给程序的命令行参数，这里设为空即可</span><br><span class=\"line\">            &quot;stopAtEntry&quot;: false,  // 设为true时程序将暂停在程序入口处，相当于在main上打断点</span><br><span class=\"line\">            &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;,  // 调试程序时的工作目录，此处为源码文件所在目录</span><br><span class=\"line\">            &quot;environment&quot;: [],  // 环境变量，这里设为空即可</span><br><span class=\"line\">            &quot;externalConsole&quot;: false, // 为true时使用单独的cmd窗口，跳出小黑框；设为false则是用vscode的内置终端，建议用内置终端</span><br><span class=\"line\">            &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;, // 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡，新手调试用不到</span><br><span class=\"line\">            &quot;MIMode&quot;: &quot;gdb&quot;, // 指定连接的调试器，gdb是minGW中的调试程序</span><br><span class=\"line\">            &quot;miDebuggerPath&quot;: &quot;C:\\\\Program Files\\\\mingw64\\\\bin\\\\gdb.exe&quot;, // 指定调试器所在路径，如果你的minGW装在别的地方，则要改成你自己的路径，注意间隔是\\\\</span><br><span class=\"line\">            &quot;preLaunchTask&quot;: &quot;build&quot; // 调试开始前执行的任务，我们在调试前要编译构建。与tasks.json的label相对应，名字要一样</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来试着调试程序，按下 F9 是为当前所在行设置断点。当然你也可以将 launch.json 文件中的 “stopAtEntry”: false 改为 true。</p>\n<p>这样程序会在 main 函数开始暂停，相当于在 main 函数的起步打断点，进入调试之后 VS code 会给出一个调试工具，长这样：</p>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/EHHQdUR0vqiaCPWltkFDa30a3PELlOmBtfcQKp8YiapMT0CjeVzaicTYYMw2tvFaWHnEvJPZxO7kRicja24OXYbfaQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\"></p>\n<p>从左到右一次为：</p>\n<p>● 继续（F5）</p>\n<p>● 单步跳过（F10）</p>\n<p>● 单步调试（F11）</p>\n<p>● 单步跳出（shift+F11）</p>\n<p>● 重启（shift+ctrl+F5）</p>\n<p>● 停止（shift+F5）</p>\n<p>同时你可以在左边的变量区域监视变量变化情况，这些都是基本的调试功能，这里不再阐述。</p>\n<h4 id=\"结束语\"><a class=\"markdownIt-Anchor\" href=\"#结束语\">#</a> 结束语</h4>\n<p>到这里为止我们已经把 VS code 打造成了一个 C 和 C++ 的开发环境，并尝试了编译运行和调试。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/23/vim%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8/",
            "url": "http://example.com/2023/07/23/vim%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8/",
            "title": "vim上的一些使用",
            "date_published": "2023-07-23T12:24:37.000Z",
            "content_html": "<h1 id=\"vim-上的一些简单操作\"><a class=\"markdownIt-Anchor\" href=\"#vim-上的一些简单操作\">#</a> Vim 上的一些简单操作</h1>\n<h2 id=\"vi简介\"><a class=\"markdownIt-Anchor\" href=\"#vi简介\">#</a> vi 简介</h2>\n<blockquote>\n<p>vi 编辑器是所有 Unix 及 Linux 系统下标准的编辑器，它的强大不逊色于任何的文本编辑器。是 UNIX 操作系统和类 UNIX 操作系统中最通用的全屏幕纯文本编辑器。Linux 中的 vi 编辑器叫 vim，它是 vi 的增强版，与 vi 编辑器完全兼容，而且实现了很多增强功能。Vi 也是 Linux 中最基本的文本编辑器，学会它后，你可以在 Linux 的世界里畅行无阻。</p>\n</blockquote>\n<p>vi 可以分为三种模式，分别是 <code>命令模式</code> （command mode）、 <code>插入模式</code> （Insert mode）和 <code>底行模式</code> （last line mode），各模式的功能区分如下：</p>\n<ul>\n<li><strong>命令行模式（command mode）</strong>　　控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入 Insert mode 下，或者到 last line mode。</li>\n<li><strong>插入模式（Insert mode）</strong>　　只有在 Insert mode 下，才可以做文字输入，按「ESC」键可回到命令行模式。</li>\n<li><strong>底行模式（last line mode）</strong>　　将文件保存或退出 vi，也可以设置编辑环境，如寻找字符串、列出行号等等</li>\n</ul>\n<p><em>有时我们将底行模式（last line mode）也算入命令行模式 command mode）。</em></p>\n<h2 id=\"vi基本操作\"><a class=\"markdownIt-Anchor\" href=\"#vi基本操作\">#</a> vi 基本操作</h2>\n<ul>\n<li>进入 vi 在系统终端中输入 vi 和文件名称后，就进入 vi：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi myfile</span><br></pre></td></tr></table></figure>\n<p>进入 vi 之后，默认是处于<strong>命令行模式（command mode）</strong>，要切换到 <strong>插入模式（Insert mode）</strong> 才能够编辑和输入。初次使用 vi 的人都会想先用上下左右键移动光标，进入 vi 后，先转换到<strong>插入模式（Insert mode）</strong> 再进行编辑。</p>\n<ul>\n<li>切换至插入模式（Insert mode）编辑文件 在 <strong>命令行模式（command mode）</strong> 下按一下字母 <code>i</code>  就可以进入<strong>插入模式（Insert mode）</strong>，这时候你就可以开始输入文字了。同样按 <code>a</code>  进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字；按 <code>o</code>  进入插入模式后，是插入新的一行，从行首开始输入文字。</li>\n<li>Insert 的切换 如果处于<strong>插入模式（Insert mode）</strong>，按一下<strong> ESC</strong> 键就可以转到<strong>命令行模式（command mode）</strong>。</li>\n<li>退出 vi 及保存文件 在 ** 命令行模式（command mode）** 下，按一下 <code>:</code>  冒号键，例如： <code>:w filename</code>  （输入 w filename 以指定的文件名 filename 保存） <code>:wq</code>  (输入「wq」，存盘并退出 vi) <code>:q!</code>  (输入 q!， 不存盘强制退出 vi)</li>\n</ul>\n<h3 id=\"移动光标\"><a class=\"markdownIt-Anchor\" href=\"#移动光标\">#</a> 移动光标</h3>\n<p>可以直接用键盘上的光标来上下左右移动，同样 vi 是用小写英文字母 h、j、k、l，分别控制光标左、下、上、右移一格。</p>\n<ul>\n<li>ctrl+b：屏幕往 &quot;后&quot; 移动一页</li>\n<li>ctrl+f：屏幕往 &quot;前&quot; 移动一页</li>\n<li>ctrl+u：屏幕往 &quot;后&quot; 移动半页</li>\n<li>ctrl+d：屏幕往 &quot;前&quot; 移动半页</li>\n<li>^：移动到光标所在行的 &quot;行首&quot;</li>\n<li>w：光标跳到下个字的开头</li>\n<li>e：光标跳到下个字的字尾</li>\n<li>b：光标回到上个字的开头</li>\n<li>#l：光标移到该行的第 #个位置，如：1l,23l</li>\n</ul>\n<h3 id=\"定位\"><a class=\"markdownIt-Anchor\" href=\"#定位\">#</a> 定位</h3>\n<ul>\n<li>:set nu：每行显示行号</li>\n<li>:set nonu：取消显示行号</li>\n<li>0：单行首</li>\n<li>$：单行末</li>\n<li>H：屏幕顶</li>\n<li>M：屏幕中</li>\n<li>L：屏幕末行</li>\n<li>gg：文件首行</li>\n<li>G：移动到文章的最后</li>\n<li>n<space>：向后 n 个字符</li>\n<li>n<Enter>：向下 n 行</li>\n<li>nG = 文件第 n 行</li>\n</ul>\n<h3 id=\"删除\"><a class=\"markdownIt-Anchor\" href=\"#删除\">#</a> 删除</h3>\n<ul>\n<li>x：每按一次，删除光标所在位置的 &quot;后面&quot; 一个字符。</li>\n<li>#x：例如 6x 表示删除光标所在位置的 &quot;后面&quot;6 个字符。</li>\n<li>X：大写的 X，每按一次，删除光标所在位置的 &quot;前面&quot; 一个字符。</li>\n<li>#X：例如 20X 表示删除光标所在位置的 &quot;前面&quot;20 个字符。</li>\n<li>dd：删除光标所在行。</li>\n<li>#dd：从光标所在行开始删除 #行</li>\n</ul>\n<h3 id=\"复制\"><a class=\"markdownIt-Anchor\" href=\"#复制\">#</a> 复制</h3>\n<ul>\n<li>yw：将光标所在之处到字尾的字符复制到缓冲区中。</li>\n<li>#yw：复制 #个字到缓冲区</li>\n<li>yy：复制光标所在行到缓冲区。</li>\n<li>#yy：例如 6yy 表示拷贝从光标所在的该行 &quot;往下数&quot;6 行文字。</li>\n<li>p：将缓冲区内的字符贴到光标所在位置。注意：所有与 &quot;y&quot; 有关的复制命令都必须与 &quot;p&quot; 配合才能完成复制与粘贴功能。</li>\n</ul>\n<h3 id=\"查找\"><a class=\"markdownIt-Anchor\" href=\"#查找\">#</a> 查找</h3>\n<ul>\n<li>/str：向下查 str</li>\n<li>n：向下查下一个 str</li>\n<li>？str：向上查 str</li>\n<li>N：向上查下一个 str</li>\n</ul>\n<p>针对光标停留处的特定的单词，可以使用快捷键进行向上和向下的搜索， <code>Shift + 8</code> ，即 * 键，直接对光标停留处的单词进行向下搜索； <code>Shift + 3</code> ，即 #键，直接对光标停留处的单词进行向上搜索。</p>\n<h3 id=\"撤销及恢复\"><a class=\"markdownIt-Anchor\" href=\"#撤销及恢复\">#</a> 撤销及恢复</h3>\n<ul>\n<li>u：相当于 windows 中的 &quot;ctrl+z&quot;，undo</li>\n<li>ctrl+r：相当于 windows 中的 &quot;ctrl+y&quot;, 于 &quot;ctrl+z&quot; 相反</li>\n<li>.：点儿表示重复作刚才的动作</li>\n</ul>\n<h3 id=\"保存\"><a class=\"markdownIt-Anchor\" href=\"#保存\">#</a> 保存</h3>\n<ul>\n<li>:w：写入硬盘</li>\n<li>:w!：强制写入</li>\n<li>:q：离开 vi</li>\n<li>:q!：强制离开 vi，不存</li>\n<li>:wq：存盘并离开 vi</li>\n<li>:wq!：存盘并强制离开</li>\n</ul>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<blockquote>\n<p>好了，以上就是 vi 编辑器中常用的操作，熟练操作后你会发现 vi 编辑器原来是如此的丝滑。熟练使用 vi 编辑器会使你在平时的 Linux 系统操作中提高效率，达到事半功倍的效果。无它，为手熟而！平常中使用多了，自然而然的就熟练起来，其他技术也是一样。</p>\n</blockquote>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/03/Bash-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/",
            "url": "http://example.com/2023/07/03/Bash-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/",
            "title": "Bash 常用命令",
            "date_published": "2023-07-03T14:15:10.000Z",
            "content_html": "<h1 id=\"bash-常用命令\"><a class=\"markdownIt-Anchor\" href=\"#bash-常用命令\">#</a> Bash 常用命令</h1>\n<h2 id=\"基础常用命令\"><a class=\"markdownIt-Anchor\" href=\"#基础常用命令\">#</a> 基础常用命令</h2>\n<ul>\n<li><code>某个命令 --h</code> ，对这个命令进行解释</li>\n<li><code>某个命令 --help</code> ，解释这个命令 (更详细)</li>\n<li><code>man某个命令</code> ，文档式解释这个命令 (更更详细)(执行该命令后，还可以按 /+ 关键字进行查询结果的搜索)</li>\n<li><code>Ctrl + c</code> ，结束命令</li>\n<li><code>TAB键</code> ，自动补全命令（按一次自动补全，连续按两次，提示所有以输入开头字母的所有命令）</li>\n<li><code>键盘上下键</code> ，输入临近的历史命令</li>\n<li><code>history</code> ，查看所有的历史命令</li>\n<li><code>Ctrl + r</code> ，进入历史命令的搜索功能模式</li>\n<li><code>clear</code> ，清除屏幕里面的所有命令</li>\n<li><code>pwd</code> ，显示当前目录路径（常用）</li>\n<li><code>firefox&amp;</code> ，最后后面的 <strong>&amp;</strong> 符号，表示使用后台方式打开 Firefox，然后显示该进程的 PID 值</li>\n<li><code>jobs</code> ，查看后台运行的程序列表</li>\n<li><code>ifconfig</code> ，查看内网 IP 等信息（常用）</li>\n<li><code>curl ifconfig.me</code> ，查看外网 IP 信息</li>\n<li><code>curl ip.cn</code> ，查看外网 IP 信息</li>\n<li><code>locate 搜索关键字</code> ，快速搜索系统文件 / 文件夹（类似 Windows 上的 everything 索引式搜索）（常用）\n<ul>\n<li><code>updatedb</code> ，配合上面的 locate，给 locate 的索引更新（locate 默认是一天更新一次索引）（常用）</li>\n</ul>\n</li>\n<li><code>date</code> ，查看系统时间（常用）\n<ul>\n<li><code>date -s20080103</code> ，设置日期（常用）</li>\n<li><code>date -s18:24</code> ，设置时间，如果要同时更改 BIOS 时间，再执行  <code>hwclock --systohc</code> （常用）</li>\n</ul>\n</li>\n<li><code>cal</code> ，在终端中查看日历，肯定没有农历显示的</li>\n<li><code>uptime</code> ，查看系统已经运行了多久，当前有几个用户等信息（常用）</li>\n<li><code>cat 文件路名</code> ，显示文件内容（属于打印语句）</li>\n<li><code>cat -n 文件名</code> ，显示文件，并每一行内容都编号</li>\n<li><code>more 文件名</code> ，用分页的方式查看文件内容（按 space 翻下一页，按 <em>Ctrl + B</em> 返回上页）</li>\n<li><code>less</code>  文件名，用分页的方式查看文件内容（带上下翻页）\n<ul>\n<li>按 <strong>j</strong> 向下移动，按 <strong>k</strong> 向上移动</li>\n<li>按 <strong>/</strong> 后，输入要查找的字符串内容，可以对文件进行向下查询，如果存在多个结果可以按 <strong>n</strong> 调到下一个结果出</li>\n<li>按 <strong>？</strong> 后，输入要查找的字符串内容，可以对文件进行向上查询，如果存在多个结果可以按 <strong>n</strong> 调到下一个结果出</li>\n</ul>\n</li>\n<li><code>shutdown</code>\n<ul>\n<li><code>shutdown -hnow</code> ，立即关机</li>\n<li><code>shutdown -h+10</code> ，10 分钟后关机</li>\n<li><code>shutdown -h23:30</code> ，23:30 关机</li>\n<li><code>shutdown -rnew</code> ，立即重启</li>\n</ul>\n</li>\n<li><code>poweroff</code> ，立即关机（常用）</li>\n<li><code>reboot</code> ，立即重启（常用）</li>\n<li><code>zip mytest.zip /opt/test/</code> ，把 /opt 目录下的 test/ 目录进行压缩，压缩成一个名叫 mytest 的 zip 文件\n<ul>\n<li><code>unzip mytest.zip</code> ，对 mytest.zip 这个文件进行解压，解压到当前所在目录</li>\n<li><code>unzip mytest.zip -d /opt/setups/</code> ，对 mytest.zip 这个文件进行解压，解压到 /opt/setups/ 目录下</li>\n</ul>\n</li>\n<li><code>tar -cvf mytest.tar mytest/</code> ，对 mytest/ 目录进行归档处理（归档和压缩不一样）</li>\n<li><code>tar -xvf mytest.tar</code> ，释放 mytest.tar 这个归档文件，释放到当前目录\n<ul>\n<li><code>tar -xvf mytest.tar -C /opt/setups/</code> ，释放 mytest.tar 这个归档文件，释放到 /opt/setups/ 目录下</li>\n</ul>\n</li>\n<li><code>last</code> ，显示最近登录的帐户及时间</li>\n<li><code>lastlog</code> ，显示系统所有用户各自在最近登录的记录，如果没有登录过的用户会显示 <strong>从未登陆过</strong></li>\n<li><code>ls</code> ，列出当前目录下的所有没有隐藏的文件 / 文件夹。\n<ul>\n<li><code>ls -a</code> ，列出包括以。号开头的隐藏文件 / 文件夹（也就是所有文件）</li>\n<li><code>ls -R</code> ，显示出目录下以及其所有子目录的文件 / 文件夹（递归地方式，不显示隐藏的文件）</li>\n<li><code>ls -a -R</code> ，显示出目录下以及其所有子目录的文件 / 文件夹（递归地方式，显示隐藏的文件）</li>\n<li><code>ls -al</code> ，列出目录下所有文件（包含隐藏）的权限、所有者、文件大小、修改时间及名称（也就是显示详细信息）</li>\n<li><code>ls -ld 目录名</code> ，显示该目录的基本信息</li>\n<li><code>ls -t</code> ，依照文件最后修改时间的顺序列出文件名。</li>\n<li><code>ls -F</code> ，列出当前目录下的文件名及其类型。以 <strong>/</strong> 结尾表示为目录名，以 <strong>*</strong> 结尾表示为可执行文件，以 <strong>@</strong> 结尾表示为符号连接</li>\n<li><code>ls -lg</code> ，同上，并显示出文件的所有者工作组名。</li>\n<li><code>ls -lh</code> ，查看文件夹类文件详细信息，文件大小，文件修改时间</li>\n<li><code>ls /opt | head -5</code> ，显示 opt 目录下前 5 条记录</li>\n<li><code>ls -l | grep '.jar'</code> ，查找当前目录下所有 jar 文件</li>\n<li><code>ls -l /opt |grep &quot;^-&quot;|wc -l</code> ，统计 opt 目录下文件的个数，不会递归统计</li>\n<li><code>ls -lR /opt |grep &quot;^-&quot;|wc -l</code> ，统计 opt 目录下文件的个数，会递归统计</li>\n<li><code>ls -l /opt |grep &quot;^d&quot;|wc -l</code> ，统计 opt 目录下目录的个数，不会递归统计</li>\n<li><code>ls -lR /opt |grep &quot;^d&quot;|wc -l</code> ，统计 opt 目录下目录的个数，会递归统计</li>\n<li><code>ls -lR /opt |grep &quot;js&quot;|wc -l</code> ，统计 opt 目录下 js 文件的个数，会递归统计</li>\n<li><code>ls -l</code> ，列出目录下所有文件的权限、所有者、文件大小、修改时间及名称（也就是显示详细信息，不显示隐藏文件）。显示出来的效果如下：</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rwxr-xr-x. 1 <span class=\"attribute\">root</span> root <span class=\"number\">4096</span> <span class=\"number\">3</span>月 <span class=\"number\">26</span> <span class=\"number\">10</span>:<span class=\"number\">57</span>，其中最前面的 - 表示这是一个普通文件</span><br><span class=\"line\">lrwxrwxrwx. <span class=\"number\">1</span> root root <span class=\"number\">4096</span> <span class=\"number\">3</span>月 <span class=\"number\">26</span> <span class=\"number\">10</span>:<span class=\"number\">57</span>，其中最前面的 l 表示这是一个链接文件，类似 Windows 的快捷方式</span><br><span class=\"line\">drwxr-xr-x. <span class=\"number\">5</span> root root <span class=\"number\">4096</span> <span class=\"number\">3</span>月 <span class=\"number\">26</span> <span class=\"number\">10</span>:<span class=\"number\">57</span>，其中最前面的 d 表示这是一个目录</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>cd</code> ，目录切换\n<ul>\n<li><code>cd ..</code> ，改变目录位置至当前目录的父目录 (上级目录)。</li>\n<li><code>cd ~</code> ，改变目录位置至用户登录时的工作目录。</li>\n<li><code>cd 回车</code> ，回到家目录</li>\n<li><code>cd -</code> ，上一个工作目录</li>\n<li><code>cd dir1/</code> ，改变目录位置至 dir1 目录下。</li>\n<li><code>cd ~user</code> ，改变目录位置至用户的工作目录。</li>\n<li><code>cd ../user</code> ，改变目录位置至相对路径 user 的目录下。</li>\n<li><code>cd /../..</code> ，改变目录位置至绝对路径的目录位置下。</li>\n</ul>\n</li>\n<li><code>cp 源文件 目标文件</code> ，复制文件\n<ul>\n<li><code>cp -r 源文件夹 目标文件夹</code> ，复制文件夹</li>\n<li><code>cp -r -v 源文件夹 目标文件夹</code> ，复制文件夹 (显示详细信息，一般用于文件夹很大，需要查看复制进度的时候)</li>\n<li><code>cp /usr/share/easy-rsa/2.0/keys/&#123;ca.crt,server.&#123;crt,key&#125;,dh2048.pem,ta.key&#125; /etc/openvpn/keys/</code> ，复制同目录下花括号中的文件</li>\n</ul>\n</li>\n<li><code>tar cpf - . | tar xpf - -C /opt</code> ，复制当前所有文件到 /opt 目录下，一般如果文件夹文件多的情况下用这个更好，用 cp 比较容易出问题</li>\n<li><code>mv 文件 目标文件夹</code> ，移动文件到目标文件夹\n<ul>\n<li><code>mv 文件</code> ，不指定目录重命名后的名字，用来重命名文件</li>\n</ul>\n</li>\n<li><code>touch 文件名</code> ，创建一个空白文件 / 更新已有文件的时间 (后者少用)</li>\n<li><code>mkdir 文件夹名</code> ，创建文件夹</li>\n<li><code>mkdir -p /opt/setups/nginx/conf/</code> ，创建一个名为 conf 文件夹，如果它的上级目录 nginx 没有也会跟着一起生成，如果有则跳过</li>\n<li><code>rmdir 文件夹名</code> ，删除文件夹 (只能删除文件夹里面是没有东西的文件夹)</li>\n<li><code>rm 文件</code> ，删除文件\n<ul>\n<li><code>rm -r 文件夹</code> ，删除文件夹</li>\n<li><code>rm -r -i 文件夹</code> ，在删除文件夹里的文件会提示 (要的话，在提示后面输入 yes)</li>\n<li><code>rm -r -f 文件夹</code> ，强制删除</li>\n<li><code>rm -r -f 文件夹1/ 文件夹2/ 文件夹3/</code>  删除多个</li>\n</ul>\n</li>\n<li><code>find</code> ，高级查找\n<ul>\n<li><code>find . -name *lin*</code> ，其中。代表在当前目录找，-name 表示匹配文件名 / 文件夹名，*lin* 用通配符搜索含有 lin 的文件或是文件夹</li>\n<li><code>find . -iname *lin*</code> ，其中。代表在当前目录找，-iname 表示匹配文件名 / 文件夹名（忽略大小写差异），*lin* 用通配符搜索含有 lin 的文件或是文件夹</li>\n<li><code>find / -name *.conf</code> ，其中 / 代表根目录查找，*.conf 代表搜索后缀会.conf 的文件</li>\n<li><code>find /opt -name .oh-my-zsh</code> ，其中 /opt 代表目录名，.oh-my-zsh 代表搜索的是隐藏文件 / 文件夹名字为 oh-my-zsh 的</li>\n<li><code>find /opt -type f -iname .oh-my-zsh</code> ，其中 /opt 代表目录名，-type f 代表只找文件，.oh-my-zsh 代表搜索的是隐藏文件名字为 oh-my-zsh 的</li>\n<li><code>find /opt -type d -iname .oh-my-zsh</code> ，其中 /opt 代表目录名，-type d 代表只找目录，.oh-my-zsh 代表搜索的是隐藏文件夹名字为 oh-my-zsh 的</li>\n<li><code>find . -name &quot;lin*&quot; -exec ls -l &#123;&#125; \\;</code> ，当前目录搜索 lin 开头的文件，然后用其搜索后的结果集，再执行 ls -l 的命令（这个命令可变，其他命令也可以），其中 -exec 和 {} ; 都是固定格式</li>\n<li><code>find /opt -type f -size +800M  -print0 | xargs -0 du -h | sort -nr</code> ，找出 /opt 目录下大于 800 M 的文件</li>\n<li><code>find / -name &quot;*tower*&quot; -exec rm &#123;&#125; \\;</code> ，找到文件并删除</li>\n<li><code>find / -name &quot;*tower*&quot; -exec mv &#123;&#125; /opt \\;</code> ，找到文件并移到 opt 目录</li>\n<li><code>find . -name &quot;*&quot; |xargs grep &quot;youmeek&quot;</code> ，递归查找当前文件夹下所有文件内容中包含 youmeek 的文件</li>\n<li><code>find . -size 0 | xargs rm -f &amp;</code> ，删除当前目录下文件大小为 0 的文件</li>\n<li><code>du -hm --max-depth=2 | sort -nr | head -12</code> ，找出系统中占用容量最大的前 12 个目录</li>\n</ul>\n</li>\n<li><code>cat /etc/resolv.conf</code> ，查看 DNS 设置</li>\n<li><code>netstat -tlunp</code> ，查看当前运行的服务，同时可以查看到：运行的程序已使用端口情况</li>\n<li><code>env</code> ，查看所有系统变量</li>\n<li><code>export</code> ，查看所有系统变量</li>\n<li><code>echo</code>\n<ul>\n<li><code>echo $JAVA_HOME</code> ，查看指定系统变量的值，这里查看的是自己配置的 JAVA_HOME。</li>\n<li><code>echo &quot;字符串内容&quot;</code> ，输出 “字符串内容”</li>\n<li><code>echo &gt; aa.txt</code> ，清空 aa.txt 文件内容（类似的还有： <code>: &gt; aa.txt</code> ，其中：是一个占位符，不产生任何输出）</li>\n</ul>\n</li>\n<li><code>unset $JAVA_HOME</code> ，删除指定的环境变量</li>\n<li><code>ln -s /opt/data /opt/logs/data</code> ，表示给 /opt/logs 目录下创建一个名为 data 的软链接，该软链接指向到 /opt/data</li>\n<li><code>grep</code>\n<ul>\n<li><code>shell grep -H '安装' *.sh</code> ，查找当前目录下所有 sh 类型文件中，文件内容包含  <code>安装</code>  的当前行内容</li>\n<li><code>grep 'test' java*</code> ，显示当前目录下所有以 java 开头的文件中包含 test 的行</li>\n<li><code>grep 'test' spring.ini docker.sh</code> ，显示当前目录下 spring.ini <span class=\"exturl\" data-url=\"aHR0cDovL2RvY2tlci5zaA==\">docker.sh</span> 两个文件中匹配 test 的行</li>\n</ul>\n</li>\n<li><code>ps</code>\n<ul>\n<li><code>ps –ef|grep java</code> ，查看当前系统中有关 java 的所有进程</li>\n<li><code>ps -ef|grep --color java</code> ，高亮显示当前系统中有关 java 的所有进程</li>\n</ul>\n</li>\n<li><code>kill</code>\n<ul>\n<li><code>kill 1234</code> ，结束 pid 为 1234 的进程</li>\n<li><code>kill -9 1234</code> ，强制结束 pid 为 1234 的进程（慎重）</li>\n<li><code>killall java</code> ，结束同一进程组内的所有为 java 进程</li>\n<li><code>ps -ef|grep hadoop|grep -v grep|cut -c 9-15|xargs kill -9</code> ，结束包含关键字 hadoop 的所有进程</li>\n</ul>\n</li>\n<li><code>head</code>\n<ul>\n<li><code>head -n 10 spring.ini</code> ，查看当前文件的前 10 行内容</li>\n</ul>\n</li>\n<li><code>tail</code>\n<ul>\n<li><code>tail -n 10 spring.ini</code> ，查看当前文件的后 10 行内容</li>\n<li><code>tail -200f 文件名</code> ，查看文件被更新的新内容尾 200 行，如果文件还有在新增可以动态查看到（一般用于查看日记文件）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"用户-权限-相关命令\"><a class=\"markdownIt-Anchor\" href=\"#用户-权限-相关命令\">#</a> 用户、权限 - 相关命令</h2>\n<ul>\n<li>\n<p>使用 pem 证书登录： <code>ssh -i /opt/mykey.pem root@192.168.0.70</code></p>\n<ul>\n<li>证书权限不能太大，不然无法使用： <code>chmod 600 mykey.pem</code></li>\n</ul>\n</li>\n<li>\n<p><code>hostname</code> ，查看当前登陆用户全名</p>\n</li>\n<li>\n<p><code>cat /etc/group</code> ，查看所有组</p>\n</li>\n<li>\n<p><code>cat /etc/passwd</code> ，查看所有用户</p>\n</li>\n<li>\n<p><code>groups youmeek</code> ，查看 youmeek 用户属于哪个组</p>\n</li>\n<li>\n<p><code>useradd youmeek -g judasn</code> ，添加用户并绑定到 judasn 组下</p>\n</li>\n<li>\n<p><code>userdel -r youmeek</code> ，删除名字为 youmeek 的用户</p>\n<ul>\n<li>参数： <code>-r</code> ，表示删除用户的时候连同用户的家目录一起删除</li>\n</ul>\n</li>\n<li>\n<p>修改普通用户 youmeek 的权限跟 root 权限一样：</p>\n<ul>\n<li>\n<p>常用方法（原理是把该用户加到可以直接使用 sudo 的一个权限状态而已）：</p>\n<ul>\n<li>编辑配置文件： <code>vim /etc/sudoers</code></li>\n<li>找到 98 行（预估），有一个： <code>root    ALL=(ALL)   ALL</code> ，在这一行下面再增加一行，效果如下：</li>\n</ul>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">root</span>    ALL=(ALL)   ALL</span><br><span class=\"line\">youmeek    ALL=(ALL)   ALL</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>另一种方法：</p>\n<ul>\n<li>编辑系统用户的配置文件： <code>vim /etc/passwd</code> ，找到 <strong>root</strong> 和 <strong>youmeek</strong> 各自开头的那一行，比如 root 是： <code>root:x:0:0:root:/root:/bin/zsh</code> ，这个代表的含义为：<em>用户名：密码：UserId:GroupId: 描述：家目录：登录使用的 shell</em></li>\n<li>通过这两行对比，我们可以直接修改 youmeek 所在行的 UserId 值 和 GroupId 值，都改为 0。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>groupadd judasn</code> ，添加一个名为 judasn 的用户组</p>\n</li>\n<li>\n<p><code>groupdel judasn</code> ，删除一个名为 judasn 的用户组（前提：先删除组下面的所有用户）</p>\n</li>\n<li>\n<p><code>usermod 用户名 -g 组名</code> ，把用户修改到其他组下</p>\n</li>\n<li>\n<p><code>passwd youmeek</code> ，修改 youmeek 用户的密码（前提：只有 root 用户才有修改其他用户的权限，其他用户只能修改自己的）</p>\n</li>\n<li>\n<p><code>chmod 777 文件名/目录</code> ，给指定文件增加最高权限，系统中的所有人都可以进行读写。</p>\n<ul>\n<li>linux 的权限分为 rwx。r 代表：可读，w 代表：可写，x 代表：可执行</li>\n<li>这三个权限都可以转换成数值表示，r = 4，w = 2，x = 1，- = 0，所以总和是 7，也就是最大权限。第一个 7 是所属主（user）的权限，第二个 7 是所属组（group）的权限，最后一位 7 是非本群组用户（others）的权限。</li>\n<li><code>chmod -R 777 目录</code>  表示递归目录下的所有文件夹，都赋予 777 权限</li>\n<li><code>chown myUsername:myGroupName myFile</code>  表示修改文件所属用户、组</li>\n<li><code>chown -R myUsername:myGroupName myFolder</code>  表示递归修改指定目录下的所有文件权限</li>\n</ul>\n</li>\n<li>\n<p><code>su</code> ：切换到 root 用户，终端目录还是原来的地方（常用）</p>\n<ul>\n<li><code>su -</code> ：切换到 root 用户，其中 <strong>-</strong> 号另起一个终端并切换账号</li>\n<li><code>su 用户名</code> ，切换指定用户帐号登陆，终端目录还是原来地方。</li>\n<li><code>su - 用户名</code> ，切换到指定用户帐号登陆，其中 <strong>-</strong> 号另起一个终端并切换账号</li>\n</ul>\n</li>\n<li>\n<p><code>exit</code> ，注销当前用户（常用）</p>\n</li>\n<li>\n<p><code>sudo 某个命令</code> ，使用管理员权限使用命令，使用 sudo 回车之后需要输入当前登录账号的密码。（常用）</p>\n</li>\n<li>\n<p><code>passwd</code> ，修改当前用户密码（常用）</p>\n</li>\n<li>\n<p>添加临时账号，并指定用户根目录，并只有可读权限方法</p>\n<ul>\n<li>添加账号并指定根目录（用户名 tempuser）： <code>useradd -d /data/logs -m tempuser</code></li>\n<li>设置密码： <code>passwd tempuser</code>  回车设置密码</li>\n<li>删除用户（该用户必须退出 SSH 才能删除成功），也会同时删除组： <code>userdel tempuser</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"磁盘管理\"><a class=\"markdownIt-Anchor\" href=\"#磁盘管理\">#</a> 磁盘管理</h2>\n<ul>\n<li><code>df -h</code> ，自动以合适的磁盘容量单位查看磁盘大小和使用空间\n<ul>\n<li><code>df -k</code> ，以磁盘容量单位 K 为数值结果查看磁盘使用情况</li>\n<li><code>df -m</code> ，以磁盘容量单位 M 为数值结果查看磁盘使用情况</li>\n</ul>\n</li>\n<li><code>du -sh /opt</code> ，查看 opt 这个文件夹大小 （h 的意思 human-readable 用人类可读性较好方式显示，系统会自动调节单位，显示合适大小的单位）</li>\n<li><code>du -sh ./*</code> ，查看当前目录下所有文件夹大小 （h 的意思 human-readable 用人类可读性较好方式显示，系统会自动调节单位，显示合适大小的单位）</li>\n<li><code>du -sh /opt/setups/</code> ，显示 /opt/setups/ 目录所占硬盘空间大小（s 表示 –summarize 仅显示总计，即当前目录的大小。h 表示 –human-readable 以 KB，MB，GB 为单位，提高信息的可读性）</li>\n<li><code>mount /dev/sdb5 /newDir/</code> ，把分区 sdb5 挂载在根目录下的一个名为 newDir 的空目录下，需要注意的是：这个目录最好为空，不然已有的那些文件将看不到，除非卸载挂载。\n<ul>\n<li>挂载好之后，通过： <code>df -h</code> ，查看挂载情况。</li>\n</ul>\n</li>\n<li><code>umount /newDir/</code> ，卸载挂载，用目录名\n<ul>\n<li>如果这样卸载不了可以使用： <code>umount -l /newDir/</code></li>\n</ul>\n</li>\n<li><code>umount /dev/sdb5</code> ，卸载挂载，用分区名</li>\n</ul>\n<h2 id=\"wget-下载文件\"><a class=\"markdownIt-Anchor\" href=\"#wget-下载文件\">#</a> wget 下载文件</h2>\n<ul>\n<li>常规下载： <code>wget http://www.gitnavi.com/index.html</code></li>\n<li>自动断点下载： <code>wget -c http://www.gitnavi.com/index.html</code></li>\n<li>后台下载： <code>wget -b http://www.gitnavi.com/index.html</code></li>\n<li>伪装代理名称下载： <code>wget --user-agent=&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16&quot; http://www.gitnavi.com/index.html</code></li>\n<li>限速下载： <code>wget --limit-rate=300k http://www.gitnavi.com/index.html</code></li>\n<li>批量下载： <code>wget -i /opt/download.txt</code> ，一个下载地址一行</li>\n<li>后台批量下载： <code>wget -b -c -i /opt/download.txt</code> ，一个下载地址一行</li>\n</ul>\n<h2 id=\"资料\"><a class=\"markdownIt-Anchor\" href=\"#资料\">#</a> 资料</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3dlbmt1LmJhaWR1LmNvbS92aWV3LzFhZDE5YmQyMjZmZmY3MDVjYzE3MGFmMy5odG1s\">http://wenku.baidu.com/view/1ad19bd226fff705cc170af3.html</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbnppbmcvYXJ0aWNsZS9kZXRhaWxzLzkxNjYwNTc=\">http://blog.csdn.net/nzing/article/details/9166057</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2xpbnV4dG9vbHMtcnN0LnJlYWR0aGVkb2NzLmlvL3poX0NOL2xhdGVzdC90b29sL3dnZXQuaHRtbA==\">http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/wget.html</span></li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/",
            "url": "http://example.com/2023/07/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/",
            "title": "计算机网络（二）",
            "date_published": "2023-07-03T14:07:18.000Z",
            "content_html": "<blockquote>\n<h1 id=\"目录结构\"><a class=\"markdownIt-Anchor\" href=\"#目录结构\">#</a> 目录结构</h1>\n</blockquote>\n<h3 id=\"1-计算机概述\"><a class=\"markdownIt-Anchor\" href=\"#1-计算机概述\">#</a> 1. <a href=\"#%E4%B8%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%BF%B0\">计算机概述 </a></h3>\n<h3 id=\"2-物理层\"><a class=\"markdownIt-Anchor\" href=\"#2-物理层\">#</a> 2. <a href=\"#%E4%BA%8C%E7%89%A9%E7%90%86%E5%B1%82\">物理层 </a></h3>\n<h3 id=\"3-数据链路层\"><a class=\"markdownIt-Anchor\" href=\"#3-数据链路层\">#</a> 3. <a href=\"#%E4%B8%89%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82\">数据链路层 </a></h3>\n<h3 id=\"4-网络层\"><a class=\"markdownIt-Anchor\" href=\"#4-网络层\">#</a> 4. <a href=\"#%E5%9B%9B%E7%BD%91%E7%BB%9C%E5%B1%82\">网络层 </a></h3>\n<h3 id=\"5-运输层\"><a class=\"markdownIt-Anchor\" href=\"#5-运输层\">#</a> 5. <a href=\"#%E4%BA%94%E8%BF%90%E8%BE%93%E5%B1%82\">运输层 </a></h3>\n<h3 id=\"6-应用层\"><a class=\"markdownIt-Anchor\" href=\"#6-应用层\">#</a> 6. <a href=\"#%E5%85%AD%E5%BA%94%E7%94%A8%E5%B1%82\">应用层</a></h3>\n<h2 id=\"一计算机概述\"><a class=\"markdownIt-Anchor\" href=\"#一计算机概述\">#</a> 一计算机概述</h2>\n<h3 id=\"font-color0033331基本术语font\"><a class=\"markdownIt-Anchor\" href=\"#font-color0033331基本术语font\">#</a> <font color=\"#003333\">（1），基本术语<font></h3>\n<h4 id=\"font-color99cc33-结点-nodefont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-结点-nodefont\">#</a> <font  color=\"#99CC33\">  结点 （node）：<font></h4>\n<pre><code>网络中的结点可以是计算机，集线器，交换机或路由器等。\n</code></pre>\n<h4 id=\"font-color99cc33-链路link\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-链路link\">#</a> <font  color=\"#99CC33\">  链路（link  ）：</h4>\n<pre><code>从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。\n</code></pre>\n<h4 id=\"font-color99cc33-主机host\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-主机host\">#</a> <font  color=\"#99CC33\"> 主机（host）：</h4>\n<pre><code>连接在因特网上的计算机.\n</code></pre>\n<h4 id=\"font-color99cc33-ispinternet-service-provider\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-ispinternet-service-provider\">#</a> <font  color=\"#99CC33\"> ISP（Internet Service Provider）：</h4>\n<pre><code>因特网服务提供者（提供商）.\n</code></pre>\n<h4 id=\"font-color99cc33-ixpinternet-exchange-point\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-ixpinternet-exchange-point\">#</a> <font  color=\"#99CC33\"> IXP（Internet eXchange Point）：</h4>\n<pre><code>互联网交换点IXP的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。.\n</code></pre>\n<h4 id=\"font-color99cc33-rfcrequest-for-comments\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-rfcrequest-for-comments\">#</a> <font  color=\"#99CC33\"> RFC(Request For Comments)</h4>\n<pre><code>意思是“请求评议”，包含了关于Internet几乎所有的重要的文字资料。\n</code></pre>\n<h4 id=\"font-color99cc33-广域网wanwide-area-network\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-广域网wanwide-area-network\">#</a> <font  color=\"#99CC33\"> 广域网 WAN（Wide Area Network）</h4>\n<pre><code>任务是通过长距离运送主机发送的数据\n</code></pre>\n<h4 id=\"font-color99cc33-城域网manmetropolitan-area-network\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-城域网manmetropolitan-area-network\">#</a> <font  color=\"#99CC33\"> 城域网 MAN（Metropolitan Area Network）</h4>\n<pre><code>用来讲多个局域网进行互连\n</code></pre>\n<h4 id=\"font-color99cc33-局域网lanlocal-area-network\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-局域网lanlocal-area-network\">#</a> <font  color=\"#99CC33\"> 局域网 LAN（Local Area Network）</h4>\n<pre><code> 学校或企业大多拥有多个互连的局域网\n</code></pre>\n<h4 id=\"font-color99cc33-个人区域网panpersonal-area-network\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-个人区域网panpersonal-area-network\">#</a> <font  color=\"#99CC33\"> 个人区域网 PAN（Personal Area Network）</h4>\n<pre><code>在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络  \n</code></pre>\n<h4 id=\"font-color99cc33-端系统end-system\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-端系统end-system\">#</a> <font  color=\"#99CC33\">  端系统（end system）：</h4>\n<pre><code>处在因特网边缘的部分即是连接在因特网上的所有的主机.\n</code></pre>\n<h4 id=\"font-color99cc33-分组packet\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-分组packet\">#</a> <font  color=\"#99CC33\"> 分组（packet ）：</h4>\n<pre><code>因特网中传送的数据单元。由首部header和数据段组成。分组又称为包，首部可称为包头。\n</code></pre>\n<h4 id=\"font-color99cc33-存储转发store-and-forward\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-存储转发store-and-forward\">#</a> <font  color=\"#99CC33\"> 存储转发（store and forward ）:</h4>\n<pre><code>路由器收到一个分组，先存储下来，再检查气首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去。\n</code></pre>\n<h4 id=\"font-color99cc33-带宽bandwidth\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-带宽bandwidth\">#</a> <font  color=\"#99CC33\"> 带宽（bandwidth）：</h4>\n<pre><code>在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为b/s。\n</code></pre>\n<h4 id=\"font-color99cc33-吞吐量throughput\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-吞吐量throughput\">#</a> <font  color=\"#99CC33\"> 吞吐量（throughput ）：</h4>\n<pre><code>表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。\n</code></pre>\n<h3 id=\"font-color0033332重要知识点总结font\"><a class=\"markdownIt-Anchor\" href=\"#font-color0033332重要知识点总结font\">#</a> <font color=\"#003333\">（2），重要知识点总结<font></h3>\n<p><font color=\"#999999\">1，计算机网络（简称网络）把许多计算机连接在一起，而互联网把许多网络连接在一起，是网络的网络。</p>\n<p><font color=\"#999999\">2，小写字母 i 开头的 internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。</p>\n<p><font color=\"#999999\">大写字母 I 开头的 Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用 TCP/IP 协议作为通信规则，其前身为 ARPANET。Internet 的推荐译名为因特网，现在一般流行称为互联网。</p>\n<p><font color=\"#999999\">3，路由器是实现分组交换的关键构件，其任务是转发受到的分组，这是网络核心部分最重要的功能。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后在进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据端的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组有称为包。分组是在互联网中传送的数据单元，正式由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点。</p>\n<p><font color=\"#999999\">4，互联网按工作方式可划分为边缘部分和核心部分。主机在网络的边缘部分，其作用是进行信息处理。由大量网络和连接这些网络的路由西组成边缘部分，其作用是提供连通性和交换。</p>\n<p><font color=\"#999999\">5，计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户 - 服务器方式（C/S 方式）和对等连接方式（P2P 方式）。</p>\n<p><font color=\"#999999\">6，客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。</p>\n<p><font color=\"#999999\">7，按照作用范围的不同，计算机网络分为广域网 WAN，城域网 MAN, 局域网 LAN，个人区域网 PAN。</p>\n<p><font color=\"#999999\">8，计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。</p>\n<p><font color=\"#999999\">9，网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。</p>\n<p><font color=\"#999999\">10，五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是 TCP 和 UDP 协议，网络层最重要的协议是 IP 协议。</p>\n<h2 id=\"二物理层\"><a class=\"markdownIt-Anchor\" href=\"#二物理层\">#</a> 二物理层</h2>\n<h3 id=\"font-color0033331基本术语font-2\"><a class=\"markdownIt-Anchor\" href=\"#font-color0033331基本术语font-2\">#</a> <font color=\"#003333\">（1），基本术语<font></h3>\n<h4 id=\"font-color99cc33数据datafont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33数据datafont\">#</a> <font  color=\"#99CC33\">数据（data）：<font></h4>\n<pre><code>运送消息的实体。\n</code></pre>\n<h4 id=\"font-color99cc33信号signalfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33信号signalfont\">#</a> <font  color=\"#99CC33\">信号（signal）：<font></h4>\n<pre><code>数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。\n</code></pre>\n<h4 id=\"font-color99cc33码元-code-font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33码元-code-font\">#</a> <font  color=\"#99CC33\">码元（ code）： <font></h4>\n<pre><code>在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。\n</code></pre>\n<h4 id=\"font-color99cc33单工simplex-font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33单工simplex-font\">#</a> <font  color=\"#99CC33\">单工（simplex ）：<font></h4>\n<pre><code>只能有一个方向的通信而没有反方向的交互。\n</code></pre>\n<h4 id=\"font-color99cc33半双工half-duplex-font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33半双工half-duplex-font\">#</a> <font  color=\"#99CC33\">半双工（half duplex ）：<font></h4>\n<pre><code>通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。\n</code></pre>\n<h4 id=\"font-color99cc33全双工full-duplex-font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33全双工full-duplex-font\">#</a> <font  color=\"#99CC33\">全双工（full duplex）： <font></h4>\n<pre><code>通信的双方可以同时发送和接收信息。\n</code></pre>\n<h4 id=\"font-color99cc33奈氏准则font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33奈氏准则font\">#</a> <font  color=\"#99CC33\">奈氏准则：<font></h4>\n<pre><code>在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。\n</code></pre>\n<h4 id=\"font-color99cc33基带信号baseband-signalfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33基带信号baseband-signalfont\">#</a> <font  color=\"#99CC33\">基带信号（baseband signal）：<font></h4>\n<pre><code>来自信源的信号。指没有经过调制的数字信号或模拟信号。\n</code></pre>\n<h4 id=\"font-color99cc33-带通频带信号bandpass-signalfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-带通频带信号bandpass-signalfont\">#</a> <font  color=\"#99CC33\"> 带通（频带）信号（bandpass signal）：<font></h4>\n<pre><code>把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。\n</code></pre>\n<h4 id=\"font-color99cc33-调制modulation-font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-调制modulation-font\">#</a> <font  color=\"#99CC33\"> 调制（modulation  ）：<font></h4>\n<pre><code>对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。\n</code></pre>\n<h4 id=\"font-color99cc33信噪比signal-to-noise-ratio-font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33信噪比signal-to-noise-ratio-font\">#</a> <font  color=\"#99CC33\">信噪比（signal-to-noise ratio ）：<font></h4>\n<pre><code>指信号的平均功率和噪声的平均功率之比，记为S/N。信噪比（dB）=10*log10（S/N）\n</code></pre>\n<h4 id=\"font-color99cc33信道复用channel-multiplexing-font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33信道复用channel-multiplexing-font\">#</a> <font  color=\"#99CC33\">信道复用（channel multiplexing ）：<font></h4>\n<pre><code>指多个用户共享同一个信道。（并不一定是同时）\n</code></pre>\n<h4 id=\"font-color99cc33比特率bit-rate-font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33比特率bit-rate-font\">#</a> <font  color=\"#99CC33\">比特率（bit rate ）：<font></h4>\n<pre><code>单位时间（每秒）内传送的比特数。\n</code></pre>\n<h4 id=\"font-color99cc33波特率baud-ratefont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33波特率baud-ratefont\">#</a> <font  color=\"#99CC33\">波特率（baud rate）：<font></h4>\n<pre><code>单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。\n</code></pre>\n<h4 id=\"font-color99cc33复用multiplexingfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33复用multiplexingfont\">#</a> <font  color=\"#99CC33\">复用（multiplexing）：<font></h4>\n<pre><code>共享信道的方法\n</code></pre>\n<h4 id=\"font-color99cc33adslasymmetric-digital-subscriber-line-font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33adslasymmetric-digital-subscriber-line-font\">#</a> <font  color=\"#99CC33\">ADSL（Asymmetric Digital Subscriber Line    ）： <font></h4>\n<pre><code>非对称数字用户线。\n</code></pre>\n<h4 id=\"font-color99cc33光纤同轴混合网hfc网font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33光纤同轴混合网hfc网font\">#</a> <font  color=\"#99CC33\">光纤同轴混合网（HFC 网）:<font></h4>\n<pre><code>在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网\n</code></pre>\n<h3 id=\"font-color0033332重要知识点总结font-2\"><a class=\"markdownIt-Anchor\" href=\"#font-color0033332重要知识点总结font-2\">#</a> <font color=\"#003333\">（2），重要知识点总结<font></h3>\n<p><font color=\"#999999\">1，物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</font></p>\n<p><font color=\"#999999\">2，一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。</font></p>\n<p><font color=\"#999999\">3，通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电器或电磁的表现。</font></p>\n<p><font color=\"#999999\">4，根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。</font></p>\n<p><font color=\"#999999\">5，根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。</font></p>\n<p><font color=\"#999999\">6，来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。</font></p>\n<p><font color=\"#999999\">7，要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。</font></p>\n<p><font color=\"#999999\">8，传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。</font></p>\n<p><font color=\"#999999\">9，为了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络 PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络 EPON 和吉比特无源光网络 GPON。</font></p>\n<h3 id=\"font-color0033333最重要的知识点font\"><a class=\"markdownIt-Anchor\" href=\"#font-color0033333最重要的知识点font\">#</a> <font color=\"#003333\">（3），最重要的知识点<font></h3>\n<h4 id=\"font-color0033331物理层的任务font\"><a class=\"markdownIt-Anchor\" href=\"#font-color0033331物理层的任务font\">#</a> <font color=\"#003333\"><strong>①，物理层的任务</strong><font></h4>\n<p><font color=\"#999999\">透明地传送比特流。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能能的各种可能事件的出现顺序）。</font></p>\n<h4 id=\"拓展\"><a class=\"markdownIt-Anchor\" href=\"#拓展\">#</a> 拓展：</h4>\n<p><font color=\"#999999\">物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。</font></p>\n<h4 id=\"font-color0033332几种常用的信道复用技术font\"><a class=\"markdownIt-Anchor\" href=\"#font-color0033332几种常用的信道复用技术font\">#</a> <font color=\"#003333\"><strong>②，几种常用的信道复用技术</strong><font></h4>\n<p><img data-src=\"https://user-gold-cdn.xitu.io/2018/4/1/1627f7a170ec6611?w=1247&amp;h=425&amp;f=png&amp;s=36746\" alt=\"这里写图片描述\"></p>\n<h3 id=\"font-color0033333几种常用的宽带接入技术主要是adsl和fttxfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color0033333几种常用的宽带接入技术主要是adsl和fttxfont\">#</a> <font color=\"#003333\"><strong>③，几种常用的宽带接入技术，主要是 ADSL 和 FTTx</strong><font></h3>\n<p><font color=\"#999999\">用户到互联网的宽带接入方法有非对称数字用户线 ADSL（用数字技术对现有的模拟电话线进行改造，而不需要重新布线。ASDL 的快速版本是甚高速数字用户线 VDSL。），光纤同轴混合网 HFC（是在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网）和 FTTx（即光纤到・・・・・・）。</font></p>\n<h2 id=\"三数据链路层\"><a class=\"markdownIt-Anchor\" href=\"#三数据链路层\">#</a> 三数据链路层</h2>\n<h3 id=\"font-color0033331基本术语font-3\"><a class=\"markdownIt-Anchor\" href=\"#font-color0033331基本术语font-3\">#</a> <font color=\"#003333\">（1），基本术语<font></h3>\n<h4 id=\"font-color99cc33-链路linkfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-链路linkfont\">#</a> <font  color=\"#99CC33\"> 链路（link）：<font></h4>\n<pre><code>一个结点到相邻结点的一段物理链路\n</code></pre>\n<h4 id=\"font-color99cc33-数据链路data-linkfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-数据链路data-linkfont\">#</a> <font  color=\"#99CC33\"> 数据链路（data link）：<font></h4>\n<pre><code>把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路\n</code></pre>\n<h4 id=\"font-color99cc33-循环冗余检验crccyclic-redundancy-checkfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-循环冗余检验crccyclic-redundancy-checkfont\">#</a> <font  color=\"#99CC33\"> 循环冗余检验 CRC（Cyclic Redundancy Check）：<font></h4>\n<pre><code>为了保证数据传输的可靠性，CRC是数据链路层广泛使用的一种检错技术\n</code></pre>\n<h4 id=\"font-color99cc33-帧framefont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-帧framefont\">#</a> <font  color=\"#99CC33\">  帧（frame）：<font></h4>\n<pre><code>一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。\n</code></pre>\n<h4 id=\"font-color99cc33-mtumaximum-transfer-uint-font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-mtumaximum-transfer-uint-font\">#</a> <font  color=\"#99CC33\"> MTU（Maximum Transfer Uint  ）：<font></h4>\n<pre><code>最大传送单元。帧的数据部分的的长度上限。\n</code></pre>\n<h4 id=\"font-color99cc33-误码率berbit-error-rate-font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-误码率berbit-error-rate-font\">#</a> <font  color=\"#99CC33\"> 误码率 BER（Bit Error Rate ）：<font></h4>\n<pre><code>在一段时间内，传输错误的比特占所传输比特总数的比率。\n</code></pre>\n<h4 id=\"font-color99cc33-ppppoint-to-point-protocol-font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-ppppoint-to-point-protocol-font\">#</a> <font  color=\"#99CC33\"> PPP（Point-to-Point Protocol  ）：<font></h4>\n<pre><code>点对点协议。即用户计算机和ISP进行通信时所使用的数据链路层协议。以下是PPP帧的示意图:\n</code></pre>\n<p><img data-src=\"https://user-gold-cdn.xitu.io/2018/4/1/1627f8291c6b032c?w=624&amp;h=359&amp;f=jpeg&amp;s=44271\" alt=\"PPP\"></p>\n<h4 id=\"font-color99cc33-mac地址media-access-control或者medium-access-controlfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-mac地址media-access-control或者medium-access-controlfont\">#</a> <font  color=\"#99CC33\"> MAC 地址（Media Access Control 或者 Medium Access Control）：<font></h4>\n<pre><code>意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。\n在OSI模型中，第三层网络层负责 IP地址，第二层数据链路层则负责 MAC地址。\n因此一个主机会有一个MAC地址，而每个网络位置会有一个专属于它的IP地址  。\n地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处”\n</code></pre>\n<h4 id=\"font-color99cc33-网桥bridgefont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-网桥bridgefont\">#</a> <font  color=\"#99CC33\"> 网桥（bridge）：<font></h4>\n<pre><code> 一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。\n</code></pre>\n<h4 id=\"font-color99cc33-交换机switch-font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-交换机switch-font\">#</a> <font  color=\"#99CC33\"> 交换机（switch ）：<font></h4>\n<pre><code>广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥\n</code></pre>\n<h3 id=\"font-color0033332重要知识点总结font-3\"><a class=\"markdownIt-Anchor\" href=\"#font-color0033332重要知识点总结font-3\">#</a> <font color=\"#003333\">（2），重要知识点总结<font></h3>\n<p><font color=\"#999999\">1，链路是从一个结点到相邻节点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</font></p>\n<p><font color=\"#999999\">2，数据链路层使用的主要是<strong>点对点信道</strong>和<strong>广播信道</strong>两种。</font></p>\n<p><font color=\"#999999\">3，数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong></font></p>\n<p><font color=\"#999999\">4，<strong>循环冗余检验 CRC</strong> 是一种检错方法，而帧检验序列 FCS 是添加在数据后面的冗余码</font></p>\n<p><font color=\"#999999\">5，<strong>点对点协议 PPP</strong> 是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议</font></p>\n<p><font color=\"#999999\"> 6，PPPoE 是为宽带上网的主机使用的链路层协议</font></p>\n<p><font color=\"#999999\">7，局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。</font></p>\n<p><font color=\"#999999\">8，共向媒体通信资源的方法有二：一是静态划分信道 (各种复用技术)，而是动态媒体接入控制，又称为多点接入（随即接入或受控接入）</font></p>\n<p><font color=\"#999999\">9，计算机与外接局域网通信需要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。<strong>计算器的硬件地址就在适配器的 ROM 中</strong>。</font></p>\n<p><font color=\"#999999\">10，以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</font></p>\n<p><font color=\"#999999\">11，以太网采用的协议是具有冲突检测的<strong>载波监听多点接入 CSMA/CD</strong>。协议的特点是：<strong>发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。</strong> 因此，每一个站点在自己发送数据之后的一小段时间内，存在这遭遇碰撞的可能性。以太网上的各站点平等的争用以太网信道</font></p>\n<p><font color=\"#999999\">12，以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</font></p>\n<p><font color=\"#999999\">13，使用集线器可以在物理层扩展以太网（扩展后的以太网任然是一个网络）</font></p>\n<h3 id=\"font-color0033333最重要的知识点font-2\"><a class=\"markdownIt-Anchor\" href=\"#font-color0033333最重要的知识点font-2\">#</a> <font color=\"#003333\">（3），最重要的知识点<font></h3>\n<h4 id=\"1-font-color999999数据链路层的点对点信道和广播信道的特点以及这两种信道所使用的协议ppp协议以及csmacd协议的特点font\"><a class=\"markdownIt-Anchor\" href=\"#1-font-color999999数据链路层的点对点信道和广播信道的特点以及这两种信道所使用的协议ppp协议以及csmacd协议的特点font\">#</a> ① <font color=\"#999999\">数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（PPP 协议以及 CSMA/CD 协议）的特点<font></h4>\n<h4 id=\"2-font-color999999数据链路层的三个基本问题封装成帧透明传输差错检测font\"><a class=\"markdownIt-Anchor\" href=\"#2-font-color999999数据链路层的三个基本问题封装成帧透明传输差错检测font\">#</a> ② <font color=\"#999999\">数据链路层的三个基本问题：<strong>封装成帧</strong>，<strong>透明传输</strong>，<strong>差错检测</strong><font></h4>\n<h4 id=\"3-font-color999999以太网的mac层硬件地址font\"><a class=\"markdownIt-Anchor\" href=\"#3-font-color999999以太网的mac层硬件地址font\">#</a> ③ <font color=\"#999999\">以太网的 MAC 层硬件地址<font></h4>\n<h4 id=\"4-font-color999999适配器转发器集线器网桥以太网交换机的作用以及适用场合font\"><a class=\"markdownIt-Anchor\" href=\"#4-font-color999999适配器转发器集线器网桥以太网交换机的作用以及适用场合font\">#</a> ④ <font color=\"#999999\">适配器，转发器，集线器，网桥，以太网交换机的作用以及适用场合<font></h4>\n<h2 id=\"font-color003333-id4四网络层font\"><a class=\"markdownIt-Anchor\" href=\"#font-color003333-id4四网络层font\">#</a> <font color=\"#003333\" id=\"4\">四网络层<font></h2>\n<h3 id=\"font-color0033331基本术语font-4\"><a class=\"markdownIt-Anchor\" href=\"#font-color0033331基本术语font-4\">#</a> <font color=\"#003333\">（1），基本术语<font></h3>\n<h4 id=\"font-color99cc33虚电路virtual-circuitfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33虚电路virtual-circuitfont\">#</a> <font  color=\"#99CC33\">虚电路（Virtual Circuit）：<font></h4>\n<pre><code>在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。\n</code></pre>\n<h4 id=\"font-color99cc33ipinternet-protocol-font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33ipinternet-protocol-font\">#</a> <font  color=\"#99CC33\">IP（Internet Protocol ）：<font></h4>\n<pre><code>网际协议 IP 是 TCP/IP体系中两个最主要的协议之一，是TCP/IP体系结构网际层的核心。配套的有ARP，RARP，ICMP，IGMP。\n</code></pre>\n<p><img data-src=\"https://user-gold-cdn.xitu.io/2018/4/1/1627f92f98436286?w=453&amp;h=331&amp;f=jpeg&amp;s=27535\" alt=\"这里写图片描述\"></p>\n<h4 id=\"font-color99cc33arpaddress-resolution-protocolfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33arpaddress-resolution-protocolfont\">#</a> <font  color=\"#99CC33\">ARP（Address Resolution Protocol）：<font></h4>\n<pre><code>地址解析协议\n</code></pre>\n<h4 id=\"font-color99cc33icmpinternet-control-message-protocol-font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33icmpinternet-control-message-protocol-font\">#</a> <font  color=\"#99CC33\">ICMP（Internet Control Message Protocol ）：<font></h4>\n<pre><code>网际控制报文协议  （ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。）\n</code></pre>\n<h4 id=\"font-color99cc33子网掩码subnet-mask-font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33子网掩码subnet-mask-font\">#</a> <font  color=\"#99CC33\">子网掩码（subnet mask ）：<font></h4>\n<pre><code>它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。\n</code></pre>\n<h4 id=\"font-color99cc33-cidr-classless-inter-domain-routing-font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-cidr-classless-inter-domain-routing-font\">#</a> <font  color=\"#99CC33\"> CIDR（ Classless Inter-Domain Routing ）：<font></h4>\n<pre><code>无分类域间路由选择  （特点是消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号）\n</code></pre>\n<h4 id=\"font-color99cc33默认路由default-routefont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33默认路由default-routefont\">#</a> <font  color=\"#99CC33\">默认路由（default route）：<font></h4>\n<pre><code>当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。\n</code></pre>\n<h4 id=\"font-color99cc33路由选择算法virtual-circuitfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33路由选择算法virtual-circuitfont\">#</a> <font  color=\"#99CC33\">路由选择算法（Virtual Circuit）：<font></h4>\n<pre><code>路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。\n</code></pre>\n<h3 id=\"font-color0033332重要知识点总结font-4\"><a class=\"markdownIt-Anchor\" href=\"#font-color0033332重要知识点总结font-4\">#</a> <font color=\"#003333\">（2），重要知识点总结<font></h3>\n<p><font color=\"#999999\">1，TCP/IP 协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限所传送的分组可能出错，丢失，重复和失序。进程之间通信的可靠性由运输层负责</font></p>\n<p><font color=\"#999999\">2，在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</font></p>\n<p><font color=\"#999999\">3，分类的 IP 地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明 IP 地址的类别。IP 地址市一中分等级的地址结构。IP 地址管理机构分配 IP 地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的 IP 地址</font></p>\n<p><font color=\"#999999\">4，IP 数据报分为首部和数据两部分。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP 首部中的生存时间给出了 IP 数据报在互联网中所能经过的最大路由器数。可防止 IP 数据报在互联网中无限制的兜圈子。</font></p>\n<p><font color=\"#999999\">5，地址解析协议 ARP 把 IP 地址解析为硬件地址。ARP 的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去广播方式发送 ARP 请求分组</font></p>\n<p><font color=\"#999999\">6，无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好办法。CIDR 记法把 IP 地址后面加上斜线 “/”，然后写上前缀所所占的位数。前缀（或网络前缀用来指明网络），前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的 IP 地址组成一个 “CIDR 地址块”，IP 地址分配都以 CIDR 地址块为单位。</font></p>\n<p><font color=\"#999999\">7， 网际控制报文协议是 IP 层的协议.ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去。使用 ICMP 数据报并不是为了实现可靠传输。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种   ICMP 差错报告报文和 ICMP 询问报文。</font></p>\n<p><font color=\"#999999\">8，要解决 IP 地址耗尽的问题，最根本的办法是采用具有更大地址弓箭的新版本 IP 协议 - IPv6。IPv6 所带来的变化有①更大的地址空间（采用 128 位地址）②灵活的首部格式③改进的选项④支持即插即用⑤支持资源的预分配⑥IPv6 的首部改为 8 字节对齐。另外 IP 数据报的目的地址可以是以下三种基本类型地址之一：单播，多播和任播</font></p>\n<p><font color=\"#999999\">9，虚拟专用网络 VPN 利用公用的互联网作为本机构专用网之间的通信载体。VPN 内使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送的数据都需要加密</font></p>\n<p><font color=\"#999999\">10， MPLS 的特点是：①支持面向连接的服务质量②支持流量工程，平衡网络负载③有效的支持虚拟专用网 VPN。MPLS 在入口节点给每一个 IP 数据报打上固定长度的 “标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。</font></p>\n<h3 id=\"font-color0033333最重要知识点font\"><a class=\"markdownIt-Anchor\" href=\"#font-color0033333最重要知识点font\">#</a> <font color=\"#003333\">（3），最重要知识点<font></h3>\n<h4 id=\"1-font-color999999虚拟互联网络的概念\"><a class=\"markdownIt-Anchor\" href=\"#1-font-color999999虚拟互联网络的概念\">#</a> ① <font color=\"#999999\">虚拟互联网络的概念</h4>\n<h4 id=\"2-font-color999999ip地址和物理地址的关系\"><a class=\"markdownIt-Anchor\" href=\"#2-font-color999999ip地址和物理地址的关系\">#</a> ② <font color=\"#999999\">IP 地址和物理地址的关系</h4>\n<h4 id=\"3-font-color999999-传统的分类的ip地址包括子网掩码和误分类域间路由选择cidr\"><a class=\"markdownIt-Anchor\" href=\"#3-font-color999999-传统的分类的ip地址包括子网掩码和误分类域间路由选择cidr\">#</a> ③ <font color=\"#999999\"> 传统的分类的 IP 地址（包括子网掩码）和误分类域间路由选择 CIDR</h4>\n<h4 id=\"4-font-color999999-路由选择协议的工作原理\"><a class=\"markdownIt-Anchor\" href=\"#4-font-color999999-路由选择协议的工作原理\">#</a> ④ <font color=\"#999999\">  路由选择协议的工作原理</h4>\n<h2 id=\"font-color003333-id5五运输层font\"><a class=\"markdownIt-Anchor\" href=\"#font-color003333-id5五运输层font\">#</a> <font color=\"#003333\" id=\"5\">五运输层<font></h2>\n<h3 id=\"font-color0033331基本术语font-5\"><a class=\"markdownIt-Anchor\" href=\"#font-color0033331基本术语font-5\">#</a> <font color=\"#003333\">（1），基本术语<font></h3>\n<h4 id=\"font-color99cc33进程processfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33进程processfont\">#</a> <font  color=\"#99CC33\">进程（process）：<font></h4>\n<pre><code>指计算机中正在运行的程序实体\n</code></pre>\n<h4 id=\"font-color99cc33应用进程互相通信font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33应用进程互相通信font\">#</a> <font  color=\"#99CC33\">应用进程互相通信：<font></h4>\n<pre><code>一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）\n</code></pre>\n<h4 id=\"font-color99cc33传输层的复用与分用font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33传输层的复用与分用font\">#</a> <font  color=\"#99CC33\">传输层的复用与分用：<font></h4>\n<pre><code>复用指发送方不同的进程都可以通过统一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。 \n</code></pre>\n<h4 id=\"font-color99cc33tcptransmission-control-protocolfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33tcptransmission-control-protocolfont\">#</a> <font  color=\"#99CC33\">TCP（Transmission Control Protocol）：<font></h4>\n<pre><code>传输控制协议\n</code></pre>\n<h4 id=\"font-color99cc33udpuser-datagram-protocolfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33udpuser-datagram-protocolfont\">#</a> <font  color=\"#99CC33\">UDP（User Datagram Protocol）：<font></h4>\n<pre><code>用户数据报协议\n</code></pre>\n<h4 id=\"font-color99cc33端口portlinkfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33端口portlinkfont\">#</a> <font  color=\"#99CC33\">端口（port）（link）：<font></h4>\n<pre><code>端口的目的是为了确认对方机器是那个进程在于自己进行交互，比如MSN和QQ的端口不同，如果没有端口就可能出现QQ进程和MSN交互错误。端口又称协议端口号。 \n</code></pre>\n<h4 id=\"font-color99cc33停止等待协议linkfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33停止等待协议linkfont\">#</a> <font  color=\"#99CC33\">停止等待协议（link）：<font></h4>\n<pre><code>指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。\n</code></pre>\n<h4 id=\"font-color99cc33流量控制linkfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33流量控制linkfont\">#</a> <font  color=\"#99CC33\">流量控制（link）：<font></h4>\n<pre><code>就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。\n</code></pre>\n<h4 id=\"font-color99cc33拥塞控制linkfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33拥塞控制linkfont\">#</a> <font  color=\"#99CC33\">拥塞控制（link）：<font></h4>\n<pre><code>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。\n</code></pre>\n<h3 id=\"font-color0033332重要知识点总结font-5\"><a class=\"markdownIt-Anchor\" href=\"#font-color0033332重要知识点总结font-5\">#</a> <font color=\"#003333\">（2），重要知识点总结<font></h3>\n<p><font color=\"#999999\">1，运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。</p>\n<p>2，网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</p>\n<p>3，运输层的两个重要协议是用户数据报协议 UDP 和传输控制协议 TCP。按照 OSI 的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元 TPDU（Transport Protocol Data Unit）。但在 TCP/IP 体系中，则根据所使用的协议是 TCP 或 UDP，分别称之为 TCP 报文段或 UDP 用户数据报。</p>\n<p>4，UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式。 TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务，这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</p>\n<p>5，硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP 和 TCP 的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到 IP 层交上来的运输层报文时，就能够 根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方 IP 地址而且要知道对方的端口号 (为了找到对方计算机中的应用进程)）</p>\n<p>6，运输层用一个 16 位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由 TCP 和 UDP 来完成。</p>\n<p>7，运输层的端口号分为服务器端使用的端口号（0<sub>1023 指派给熟知端口，1024</sub>49151 是登记端口号）和客户端暂时使用的端口号（49152~65535）</p>\n<p>8，UDP 的主要特点是①无连接②尽最大努力交付③面向报文④无拥塞控制⑤支持一对一，一对多，多对一和多对多的交互通信⑥首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</p>\n<p>9，TCP 的主要特点是①面向连接②每一条 TCP 连接只能是一对一的③提供可靠交付④提供全双工通信⑤面向字节流</p>\n<p>10，TCP 用主机的 IP 地址加上主机上的端口号作为 TCP 连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP 地址：端口号）来表示。每一条 TCP 连接唯一被通信两端的两个端点所确定。</p>\n<p>11，停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p>\n<p>12，为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。</p>\n<p>13，停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>\n<p>14，TCP 报文段的前 20 个字节是固定的，后面有 4n 字节是根据需要增加的选项。因此，TCP 首部的最小长度是 20 字节。</p>\n<p>15，TCP 使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不晕与发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>\n<p>16，在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>\n<p>17，为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口 cwnd 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>\n<p>18，TCP 的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>\n<p>19，运输连接的三个阶段，即：连接建立，数据传送和连接释放。</p>\n<p>20，主动发起 TCP 连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP 连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。</p>\n<p>21，TCP 的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了 TCP 连接</p>\n<h3 id=\"font-color0033333最重要的知识点font-3\"><a class=\"markdownIt-Anchor\" href=\"#font-color0033333最重要的知识点font-3\">#</a> <font color=\"#003333\">（3），最重要的知识点<font></h3>\n<h4 id=\"1-font-color999999端口和套接字的意义font\"><a class=\"markdownIt-Anchor\" href=\"#1-font-color999999端口和套接字的意义font\">#</a> ① <font color=\"#999999\">端口和套接字的意义<font></h4>\n<h4 id=\"2-font-color999999无连接udp的特点font\"><a class=\"markdownIt-Anchor\" href=\"#2-font-color999999无连接udp的特点font\">#</a> ② <font color=\"#999999\">无连接 UDP 的特点<font></h4>\n<h4 id=\"3-font-color999999面向连接tcp的特点font\"><a class=\"markdownIt-Anchor\" href=\"#3-font-color999999面向连接tcp的特点font\">#</a> ③ <font color=\"#999999\">面向连接 TCP 的特点<font></h4>\n<h4 id=\"4-font-color999999在不可靠的网络上实现可靠传输的工作原理停止等待协议和arq协议font\"><a class=\"markdownIt-Anchor\" href=\"#4-font-color999999在不可靠的网络上实现可靠传输的工作原理停止等待协议和arq协议font\">#</a> ④ <font color=\"#999999\">在不可靠的网络上实现可靠传输的工作原理，停止等待协议和 ARQ 协议<font></h4>\n<h4 id=\"1-font-color999999tcp的滑动窗口流量控制拥塞控制和连接管理font\"><a class=\"markdownIt-Anchor\" href=\"#1-font-color999999tcp的滑动窗口流量控制拥塞控制和连接管理font\">#</a> ① <font color=\"#999999\">TCP 的滑动窗口，流量控制，拥塞控制和连接管理<font></h4>\n<h2 id=\"font-color003333-id6六应用层font\"><a class=\"markdownIt-Anchor\" href=\"#font-color003333-id6六应用层font\">#</a> <font color=\"#003333\" id=\"6\">六应用层<font></h2>\n<h3 id=\"font-color0033331基本术语font-6\"><a class=\"markdownIt-Anchor\" href=\"#font-color0033331基本术语font-6\">#</a> <font color=\"#003333\">（1），基本术语<font></h3>\n<h4 id=\"font-color99cc33-域名系统dnsfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-域名系统dnsfont\">#</a> <font  color=\"#99CC33\">  域名系统（DNS）：<font></h4>\n<pre><code>DNS（Domain Name System，域名系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。\n通过域名，最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。在RFC文档中RFC 2181对DNS有规范说明，RFC 2136对DNS的动态更新进行说明，RFC 2308对DNS查询的反向缓存进行说明。\n</code></pre>\n<h4 id=\"font-color99cc33-文件传输协议ftpfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-文件传输协议ftpfont\">#</a> <font  color=\"#99CC33\"> 文件传输协议（FTP）：<font></h4>\n<pre><code> FTP 是File TransferProtocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。\n 基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念：&quot;下载&quot;（Download）和&quot;上传&quot;（Upload）。\n &quot;下载&quot;文件就是从远程主机拷贝文件至自己的计算机上；&quot;上传&quot;文件就是将文件从自己的计算机中拷贝至远程主机上。用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。\n</code></pre>\n<h4 id=\"font-color99cc33-简单文件传输协议tftpfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-简单文件传输协议tftpfont\">#</a> <font  color=\"#99CC33\"> 简单文件传输协议（TFTP）：<font></h4>\n<pre><code>TFTP（Trivial File Transfer Protocol,简单文件传输协议）是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。\n</code></pre>\n<h4 id=\"font-color99cc33-远程终端协议telenetfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-远程终端协议telenetfont\">#</a> <font  color=\"#99CC33\"> 远程终端协议（TELENET）：<font></h4>\n<pre><code>Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。\n在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。\n可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。\n</code></pre>\n<h4 id=\"font-color99cc33-万维网wwwfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-万维网wwwfont\">#</a> <font  color=\"#99CC33\"> 万维网（WWW）：<font></h4>\n<pre><code>WWW是环球信息网的缩写，（亦作“Web”、“WWW”、“'W3'”，英文全称为“World Wide Web”），中文名字为“万维网”，&quot;环球网&quot;等，常简称为Web。分为Web客户端和Web服务器程序。\nWWW可以让Web客户端（常用浏览器）访问浏览Web服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。\n万维网联盟（英语：World Wide Web Consortium，简称W3C），又称W3C理事会。1994年10月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。\n万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。\n</code></pre>\n<h4 id=\"font-color99cc33-万维网的大致工作工程font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-万维网的大致工作工程font\">#</a> <font  color=\"#99CC33\"> 万维网的大致工作工程：<font></h4>\n<p><img data-src=\"https://user-gold-cdn.xitu.io/2018/4/1/1627ff96a96087af?w=839&amp;h=610&amp;f=jpeg&amp;s=86703\" alt=\"万维网的大致工作工程\"></p>\n<h4 id=\"font-color99cc33-统一资源定位符urlfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-统一资源定位符urlfont\">#</a> <font  color=\"#99CC33\"> 统一资源定位符（URL）：<font></h4>\n<pre><code>统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 \n</code></pre>\n<h4 id=\"font-color99cc33-超文本传输协议httpfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-超文本传输协议httpfont\">#</a> <font  color=\"#99CC33\"> 超文本传输协议（HTTP）：<font></h4>\n<pre><code>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。\n设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。\n</code></pre>\n<h4 id=\"font-color99cc33-代理服务器proxy-serverfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-代理服务器proxy-serverfont\">#</a> <font  color=\"#99CC33\"> 代理服务器（Proxy Server）：<font></h4>\n<pre><code> 代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。\n 代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按URL的地址再次去互联网访问该资源。\n 代理服务器可在客户端或服务器工作，也可以在中间系统工作。 \n</code></pre>\n<h4 id=\"font-color99cc33-http请求头font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33-http请求头font\">#</a> <font  color=\"#99CC33\"> http 请求头：<font></h4>\n<pre><code>http请求头，HTTP客户程序（例如浏览器），向服务器发送请求的时候必须指明请求类型（一般是GET或者POST）。如有必要，客户程序还可以选择发送其他的请求头。\n- Accept：浏览器可接受的MIME类型。\n- Accept-Charset：浏览器可接受的字符集。\n- Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。\n- Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。\n- Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。\n- Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。\n- Content-Length：表示请求消息正文的长度。\n- Cookie：这是最重要的请求头信息之一\n- From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。\n- Host：初始URL中的主机和端口。\n- If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。\n- Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。\n- Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。\n- User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。\n</code></pre>\n<h4 id=\"font-color99cc33简单邮件传输协议smtpfont\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33简单邮件传输协议smtpfont\">#</a> <font  color=\"#99CC33\">简单邮件传输协议 (SMTP)：<font></h4>\n<pre><code> SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。\n SMTP协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。\n 通过SMTP协议所指定的服务器,就可以把E-mail寄到收信人的服务器上了，整个过程只要几分钟。SMTP服务器则是遵循SMTP协议的发送邮件服务器，用来发送或中转发出的电子邮件。\n</code></pre>\n<h4 id=\"font-color99cc33搜索引擎font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33搜索引擎font\">#</a> <font  color=\"#99CC33\">搜索引擎：<font></h4>\n<pre><code> 搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。\n 搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。\n</code></pre>\n<h4 id=\"font-color99cc33全文索引font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33全文索引font\">#</a> <font  color=\"#99CC33\">全文索引：<font></h4>\n<pre><code> 全文索引技术是目前搜索引擎的关键技术。\n试想在1M大小的文件中搜索一个词，可能需要几秒，在100M的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。\n所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。\n</code></pre>\n<h4 id=\"font-color99cc33目录索引font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33目录索引font\">#</a> <font  color=\"#99CC33\">目录索引：<font></h4>\n<pre><code>目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。\n</code></pre>\n<h4 id=\"font-color99cc33垂直搜索引擎font\"><a class=\"markdownIt-Anchor\" href=\"#font-color99cc33垂直搜索引擎font\">#</a> <font  color=\"#99CC33\">垂直搜索引擎：<font></h4>\n<pre><code>垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。\n垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。\n其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。\n</code></pre>\n<h3 id=\"font-color0033332重要知识点总结font-6\"><a class=\"markdownIt-Anchor\" href=\"#font-color0033332重要知识点总结font-6\">#</a> <font color=\"#003333\">（2），重要知识点总结<font></h3>\n<p><font color=\"#999999\">1，文件传输协议（FTP）使用 TCP 可靠的运输服务。FTP 使用客户服务器方式。一个 FTP 服务器进程可以同时为多个用户提供服务。在进进行文件传输时，FTP 的客户和服务器之间要先建立两个并行的 TCP 连接：控制连接和数据连接。实际用于传输文件的是数据连接。</p>\n<p><font color=\"#999999\">2，万维网客户程序与服务器之间进行交互使用的协议时超文本传输协议 HTTP。HTTP 使用 TCP 连接进行可靠传输。但 HTTP 本身是无连接、无状态的。HTTP/1.1 协议使用了持续连接（分为非流水线方式和流水线方式）</p>\n<p><font color=\"#999999\">3，电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器读取，相当于电子邮箱。</p>\n<p><font color=\"#999999\">4，一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和 IMAP）。用户代理和邮件服务器都要运行这些协议。</p>\n<h3 id=\"font-color0033333最重要知识点总结font\"><a class=\"markdownIt-Anchor\" href=\"#font-color0033333最重要知识点总结font\">#</a> <font color=\"#003333\">（3），最重要知识点总结<font></h3>\n<h4 id=\"1-font-color999999域名系统-从域名解析出ip地址font\"><a class=\"markdownIt-Anchor\" href=\"#1-font-color999999域名系统-从域名解析出ip地址font\">#</a> ① <font color=\"#999999\">域名系统 - 从域名解析出 IP 地址<font></h4>\n<h4 id=\"2-font-color999999访问一个网站大致的过程font\"><a class=\"markdownIt-Anchor\" href=\"#2-font-color999999访问一个网站大致的过程font\">#</a> ② <font color=\"#999999\">访问一个网站大致的过程<font></h4>\n<h4 id=\"3-font-color999999系统调用和应用编程接口概念font\"><a class=\"markdownIt-Anchor\" href=\"#3-font-color999999系统调用和应用编程接口概念font\">#</a> ③ <font color=\"#999999\">系统调用和应用编程接口概念<font></h4>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/03/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/",
            "url": "http://example.com/2023/07/03/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/",
            "title": "数据通信",
            "date_published": "2023-07-03T14:06:51.000Z",
            "content_html": "<blockquote>\n<h2 id=\"rpc\"><a class=\"markdownIt-Anchor\" href=\"#rpc\">#</a> RPC</h2>\n</blockquote>\n<p><strong>RPC（Remote Procedure Call）— 远程过程调用</strong> ，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC 协议假定某些传输协议的存在，如 TCP 或 UDP，为通信程序之间携带信息数据。在 OSI 网络通信模型中，RPC 跨越了传输层和应用层。RPC 使得开发分布式程序就像开发本地程序一样简单。</p>\n<p><strong>RPC 采用客户端（服务调用方）/ 服务器端（服务提供方）模式，</strong> 都运行在自己的 JVM 中。客户端只需要引入要使用的接口，接口的实现和运行都在服务器端。RPC 主要依赖的技术包括序列化、反序列化和数据传输协议，这是一种定义与实现相分离的设计。</p>\n<p><strong>目前 Java 使用比较多的 RPC 方案主要有 RMI（JDK 自带）、Hessian、Dubbo 以及 Thrift 等。</strong></p>\n<p><strong>注意： RPC 主要指内部服务之间的调用，RESTful 也可以用于内部服务之间的调用，但其主要用途还在于外部系统提供服务，因此没有将其包含在本知识点内。</strong></p>\n<h3 id=\"常见rpc框架\"><a class=\"markdownIt-Anchor\" href=\"#常见rpc框架\">#</a> 常见 RPC 框架：</h3>\n<ul>\n<li>\n<p><strong>RMI（JDK 自带）：</strong> JDK 自带的 RPC</p>\n<p>详细内容可以参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xteTg2MjYzL2FydGljbGUvZGV0YWlscy83MjU5NDc2MA==\">从懵逼到恍然大悟之 Java 中 RMI 的使用</span></p>\n</li>\n<li>\n<p><strong>Dubbo:</strong> Dubbo 是 阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring 框架无缝集成。</p>\n<p>详细内容可以参考：</p>\n<ul>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3MjcyL2FydGljbGUvZGV0YWlscy83OTg2Mjg5OQ==\"> 高性能优秀的服务框架 - dubbo 介绍</span></p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvdXNoYW9saW4vYXJ0aWNsZS9kZXRhaWxzLzc2NDA4Mzk5\">Dubbo 是什么？能做什么？</span></p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Hessian：</strong> Hessian 是一个轻量级的 remotingonhttp 工具，使用简单的方法提供了 RMI 的功能。 相比 WebService，Hessian 更简单、快捷。采用的是二进制 RPC 协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。</p>\n<p>详细内容可以参考： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bndlaV9weXcvYXJ0aWNsZS9kZXRhaWxzLzc0MDAyMzUx\">Hessian 的使用以及理解</span></p>\n</li>\n<li>\n<p><strong>Thrift：</strong>  Apache Thrift 是 Facebook 开源的跨语言的 RPC 通信框架，目前已经捐献给 Apache 基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于 thrift 研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。</p>\n<p>详细内容可以参考： <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vemV6ZS9wLzg2Mjg1ODUuaHRtbA==\">【Java】分布式 RPC 通信框架 Apache Thrift 使用总结</span></p>\n</li>\n</ul>\n<h3 id=\"如何进行选择\"><a class=\"markdownIt-Anchor\" href=\"#如何进行选择\">#</a> 如何进行选择：</h3>\n<ul>\n<li><strong>是否允许代码侵入：</strong>  即需要依赖相应的代码生成器生成代码，比如 Thrift。</li>\n<li><strong>是否需要长连接获取高性能：</strong>  如果对于性能需求较高的 haul，那么可以果断选择基于 TCP 的 Thrift、Dubbo。</li>\n<li><strong>是否需要跨越网段、跨越防火墙：</strong> 这种情况一般选择基于 HTTP 协议的 Hessian 和 Thrift 的 HTTP Transport。</li>\n</ul>\n<p>此外，Google 推出的基于 HTTP2.0 的 gRPC 框架也开始得到应用，其序列化协议基于 Protobuf，网络框架使用的是 Netty4, 但是其需要生成代码，可扩展性也比较差。</p>\n<blockquote>\n<h2 id=\"消息中间件\"><a class=\"markdownIt-Anchor\" href=\"#消息中间件\">#</a> 消息中间件</h2>\n</blockquote>\n<p><strong>消息中间件，也可以叫做中央消息队列或者是消息队列（区别于本地消息队列，本地消息队列指的是 JVM 内的队列实现）</strong>，是一种独立的队列系统，消息中间件经常用来解决内部服务之间的 <strong>异步调用问题</strong> 。请求服务方把请求队列放到队列中即可返回，然后等待服务提供方去队列中获取请求进行处理，之后通过回调等机制把结果返回给请求服务方。</p>\n<p>异步调用只是消息中间件一个非常常见的应用场景。此外，常用的消息队列应用场景还偷如下几个：</p>\n<ul>\n<li><strong>解耦 ：</strong> 一个业务的非核心流程需要依赖其他系统，但结果并不重要，有通知即可。</li>\n<li><strong>最终一致性 ：</strong> 指的是两个系统的状态保持一致，可以有一定的延迟，只要最终达到一致性即可。经常用在解决分布式事务上。</li>\n<li><strong>广播 ：</strong> 消息队列最基本的功能。生产者只负责生产消息，订阅者接收消息。</li>\n<li><strong>错峰和流控</strong></li>\n</ul>\n<p>具体可以参考：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3MjcyL2FydGljbGUvZGV0YWlscy84MDAyOTkxOA==\">《消息队列深入解析》</span></p>\n<p>当前使用较多的消息队列有 ActiveMQ（性能差，不推荐使用）、RabbitMQ、RocketMQ、Kafka 等等，我们之前提高的 redis 数据库也可以实现消息队列，不过不推荐，redis 本身设计就不是用来做消息队列的。</p>\n<ul>\n<li>\n<p><strong>ActiveMQ：</strong> ActiveMQ 是 Apache 出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持 JMS1.1 和 J2EE 1.4 规范的 JMSProvider 实现，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的 J2EE 应用中间仍然扮演着特殊的地位。</p>\n<p>具体可以参考：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3MjcyL2FydGljbGUvZGV0YWlscy84MDAzMTcwMg==\">《消息队列 ActiveMQ 的使用详解》</span></p>\n</li>\n<li>\n<p><strong>RabbitMQ:</strong> RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗</p>\n<blockquote>\n<p>AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。</p>\n</blockquote>\n<p>具体可以参考：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83OWNhMDgxMTZkNTc=\">《消息队列之 RabbitMQ》</span></p>\n</li>\n<li>\n<p><strong>RocketMQ：</strong></p>\n<p>具体可以参考：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC84MjQwNjZkNzBkYTg=\">《RocketMQ 实战之快速入门》</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2ptLnRhb2Jhby5vcmcvMjAxNy8wMS8xMi9yb2NrZXRtcS1xdWljay1zdGFydC1pbi0xMC1taW51dGVzLw==\">《十分钟入门 RocketMQ》</span> （阿里中间件团队博客）</p>\n</li>\n<li>\n<p><strong>Kafka</strong>：Kafka 是一个分布式的、可分区的、可复制的、基于发布 / 订阅的消息系统，Kafka 主要用于大数据领域，当然在分布式系统中也有应用。目前市面上流行的消息队列 RocketMQ 就是阿里借鉴 Kafka 的原理、用 Java 开发而得。</p>\n<p>具体可以参考：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2Jvb2suNTFjdG8uY29tL2FydC8yMDE4MDEvNTY1MjQ0Lmh0bQ==\">《Kafka 应用场景》</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpVNE5EUTRNelU1T0E9PSZhbXA7bWlkPTIyNDc0ODQxMDYmYW1wO2lkeD0xJmFtcDtzbj1hYTE5OTk4OTVkMDA5ZDkxZWIzNjkyYTNlNjQyOWQxOCZhbXA7Y2hrc209ZmQ5ODU0YWJjYWVmZGRiZDExMDFjYTVkYzJjN2M3ODNkNzE3MTMyMGQ2MzAwZDliMmQ4ZTY4YjdlZjhhYmQyYjAyZWEwM2UwMzYwMCNyZA==\">《初谈 Kafka》</span></p>\n</li>\n</ul>\n<p><strong>推荐阅读：</strong></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpVNU9UTXlPREF5Tmc9PSZhbXA7bWlkPTIyNDc0ODQ3MjEmYW1wO2lkeD0xJmFtcDtzbj0xMWU0ZTI5ODg2ZTU4MWRkMzI4MzExZDMwOGNjYzA2OCZhbXA7Y2hrc209ZmViN2QxNDRjOWMwNTg1Mjk0NjViMDJhNGUyNmEyNWVmNzZiNjBiZTg5ODRhY2U5ZTRhMGY1ZDNkOThjYTUyZTAxNGVjYjczYjA2MSZhbXA7c2NlbmU9MjEjd2VjaGF0X3JlZGlyZWN0\">《Kafka、RabbitMQ、RocketMQ 等消息中间件的对比 —— 消息发送性能和区别》</span></p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/",
            "url": "http://example.com/2023/07/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/",
            "title": "计算机网络基础",
            "date_published": "2023-07-03T14:05:51.000Z",
            "content_html": "<!-- MarkdownTOC -->\n<ul>\n<li><a href=\"#%E4%B8%80-osi%E4%B8%8Etcpip%E5%90%84%E5%B1%82%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8A%9F%E8%83%BD%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE\">一 OSI 与 TCP/IP 各层的结构与功能，都有哪些协议</a>\n<ul>\n<li><a href=\"#%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\">五层协议的体系结构</a></li>\n<li><a href=\"#1-%E5%BA%94%E7%94%A8%E5%B1%82\">1 应用层</a>\n<ul>\n<li><a href=\"#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F\">域名系统</a></li>\n<li><a href=\"#http%E5%8D%8F%E8%AE%AE\">HTTP 协议</a></li>\n</ul>\n</li>\n<li><a href=\"#2-%E8%BF%90%E8%BE%93%E5%B1%82\">2 运输层</a>\n<ul>\n<li><a href=\"#%E8%BF%90%E8%BE%93%E5%B1%82%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E4%BB%A5%E4%B8%8B%E4%B8%A4%E7%A7%8D%E5%8D%8F%E8%AE%AE\">运输层主要使用以下两种协议</a></li>\n<li><a href=\"#udp-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9\">UDP 的主要特点</a></li>\n<li><a href=\"#tcp-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9\">TCP 的主要特点</a></li>\n</ul>\n</li>\n<li><a href=\"#3-%E7%BD%91%E7%BB%9C%E5%B1%82\">3 网络层</a></li>\n<li><a href=\"#4-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82\">4 数据链路层</a></li>\n<li><a href=\"#5-%E7%89%A9%E7%90%86%E5%B1%82\">5 物理层</a></li>\n<li><a href=\"#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B\">总结一下</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BA%8C-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%9D%A2%E8%AF%95%E5%B8%B8%E5%AE%A2\">二 TCP 三次握手和四次挥手 (面试常客)</a>\n<ul>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B\">为什么要三次握手</a></li>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BC%A0%E5%9B%9E-syn\">为什么要传回 SYN</a></li>\n<li><a href=\"#%E4%BC%A0%E4%BA%86-syn%E4%B8%BA%E5%95%A5%E8%BF%98%E8%A6%81%E4%BC%A0-ack\">传了 SYN, 为啥还要传 ACK</a></li>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\">为什么要四次挥手</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%B8%89-tcp%E3%80%81udp-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB\">三 TCP、UDP 协议的区别</a></li>\n<li><a href=\"#%E5%9B%9B-tcp-%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93\">四 TCP 协议如何保证可靠传输</a>\n<ul>\n<li><a href=\"#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE\">停止等待协议</a></li>\n<li><a href=\"#%E8%87%AA%E5%8A%A8%E9%87%8D%E4%BC%A0%E8%AF%B7%E6%B1%82-arq-%E5%8D%8F%E8%AE%AE\">自动重传请求 ARQ 协议</a></li>\n<li><a href=\"#%E8%BF%9E%E7%BB%ADarq%E5%8D%8F%E8%AE%AE\">连续 ARQ 协议</a></li>\n<li><a href=\"#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3\">滑动窗口</a></li>\n<li><a href=\"#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6\">流量控制</a></li>\n<li><a href=\"#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6\">拥塞控制</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BA%94-%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5url%E5%9C%B0%E5%9D%80---%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%88%E9%9D%A2%E8%AF%95%E5%B8%B8%E5%AE%A2%EF%BC%89\">五  在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程（面试常客）</a></li>\n<li><a href=\"#%E5%85%AD-%E7%8A%B6%E6%80%81%E7%A0%81\">六 状态码</a></li>\n<li><a href=\"#%E4%B8%83-%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8Ehttp%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB\">七 各种协议与 HTTP 协议之间的关系</a></li>\n<li><a href=\"#%E5%85%AB-http%E9%95%BF%E8%BF%9E%E6%8E%A5%E3%80%81%E7%9F%AD%E8%BF%9E%E6%8E%A5\">八  HTTP 长连接、短连接</a></li>\n<li><a href=\"#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E\">写在最后</a>\n<ul>\n<li><a href=\"#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%9B%9E%E9%A1%BE\">计算机网络常见问题回顾</a></li>\n<li><a href=\"#%E5%BB%BA%E8%AE%AE\">建议</a></li>\n</ul>\n</li>\n</ul>\n<!-- /MarkdownTOC -->\n<p>相对与上一个版本的计算机网路面试知识总结，这个版本增加了 “TCP 协议如何保证可靠传输” 包括超时重传、停止等待协议、滑动窗口、流量控制、拥塞控制等内容并且对一些已有内容做了补充。</p>\n<h2 id=\"一-osi与tcpip各层的结构与功能都有哪些协议\"><a class=\"markdownIt-Anchor\" href=\"#一-osi与tcpip各层的结构与功能都有哪些协议\">#</a> 一 OSI 与 TCP/IP 各层的结构与功能，都有哪些协议</h2>\n<h3 id=\"五层协议的体系结构\"><a class=\"markdownIt-Anchor\" href=\"#五层协议的体系结构\">#</a> 五层协议的体系结构</h3>\n<p>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p>\n<p><img data-src=\"https://user-gold-cdn.xitu.io/2018/7/29/164e5307471e8eba?w=633&amp;h=344&amp;f=png&amp;s=164623\" alt=\"五层协议的体系结构\"></p>\n<p>结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。</p>\n<h3 id=\"1-应用层\"><a class=\"markdownIt-Anchor\" href=\"#1-应用层\">#</a> 1 应用层</h3>\n<p><strong>应用层 (application-layer）的任务是通过应用进程间的交互来完成特定网络应用。<strong>应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如</strong>域名系统 DNS</strong>，支持万维网应用的 <strong>HTTP 协议</strong>，支持电子邮件的 <strong>SMTP 协议</strong>等等。我们把应用层交互的数据单元称为报文。</p>\n<h4 id=\"域名系统\"><a class=\"markdownIt-Anchor\" href=\"#域名系统\">#</a> 域名系统</h4>\n<blockquote>\n<p>域名系统 (Domain Name System 缩写 DNS，Domain Name 被译为域名) 是因特网的一项核心服务，它作为可以将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5pYm0uY29t\">www.ibm.com</span>、Oracle 公司的域名是 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcmFjbGUuY29t\">www.oracle.com</span>、Cisco 公司的域名是 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jaXNjby5jb20=\">www.cisco.com</span> 等。</p>\n</blockquote>\n<h4 id=\"http协议\"><a class=\"markdownIt-Anchor\" href=\"#http协议\">#</a> HTTP 协议</h4>\n<blockquote>\n<p>超文本传输协议（HTTP，HyperText Transfer Protocol) 是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p>\n</blockquote>\n<h3 id=\"2-运输层\"><a class=\"markdownIt-Anchor\" href=\"#2-运输层\">#</a> 2 运输层</h3>\n<p><strong>运输层 (transport layer) 的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的” 是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>\n<h4 id=\"运输层主要使用以下两种协议\"><a class=\"markdownIt-Anchor\" href=\"#运输层主要使用以下两种协议\">#</a> 运输层主要使用以下两种协议</h4>\n<ol>\n<li><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li>\n<li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li>\n</ol>\n<h4 id=\"udp-的主要特点\"><a class=\"markdownIt-Anchor\" href=\"#udp-的主要特点\">#</a> UDP 的主要特点</h4>\n<ol>\n<li>UDP 是无连接的；</li>\n<li>UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</li>\n<li>UDP 是面向报文的；</li>\n<li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；</li>\n<li>UDP 支持一对一、一对多、多对一和多对多的交互通信；</li>\n<li>UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</li>\n</ol>\n<h4 id=\"tcp-的主要特点\"><a class=\"markdownIt-Anchor\" href=\"#tcp-的主要特点\">#</a> TCP 的主要特点</h4>\n<ol>\n<li>TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</li>\n<li>每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的（一对一）；</li>\n<li>TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li>\n<li>TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li>\n<li>面向字节流。TCP 中的 “流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流” 的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li>\n</ol>\n<h3 id=\"3-网络层\"><a class=\"markdownIt-Anchor\" href=\"#3-网络层\">#</a> 3 网络层</h3>\n<p><strong>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p>\n<p>这里要注意：<strong>不要把运输层的 “用户数据报 UDP” 和网络层的 “ IP 数据报” 弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用 “分组” 来表示。</p>\n<p>这里强调指出，网络层中的 “网络” 二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p>\n<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong> IP 层</strong>。</p>\n<h3 id=\"4-数据链路层\"><a class=\"markdownIt-Anchor\" href=\"#4-数据链路层\">#</a> 4 数据链路层</h3>\n<p><strong>数据链路层 (data link layer) 通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装程帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>\n<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。<br>\n控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>\n<h3 id=\"5-物理层\"><a class=\"markdownIt-Anchor\" href=\"#5-物理层\">#</a> 5 物理层</h3>\n<p>在物理层上所传送的数据单位是比特。<br>\n<strong>物理层 (physical layer) 的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流” 表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>\n<p>在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的 TCP/IP 并不一定单指 TCP 和 IP 这两个具体的协议，而往往表示互联网所使用的整个 TCP/IP 协议族。</p>\n<h3 id=\"总结一下\"><a class=\"markdownIt-Anchor\" href=\"#总结一下\">#</a> 总结一下</h3>\n<p>上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下。图片来源：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3BlbmdfMjAwNS9hcnRpY2xlL2RldGFpbHMvNzA2NDg2OQ==\">https://blog.csdn.net/yaopeng_2005/article/details/7064869</span><br>\n<img data-src=\"https://user-gold-cdn.xitu.io/2018/7/29/164e529309f0fa33?w=1120&amp;h=1587&amp;f=gif&amp;s=225325\" alt=\"七层体系结构图\"></p>\n<h2 id=\"二-tcp-三次握手和四次挥手面试常客\"><a class=\"markdownIt-Anchor\" href=\"#二-tcp-三次握手和四次挥手面试常客\">#</a> 二 TCP 三次握手和四次挥手 (面试常客)</h2>\n<p>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。</p>\n<p><strong>漫画图解：</strong></p>\n<p>图片来源：《图解 HTTP》<br>\n<img data-src=\"https://user-gold-cdn.xitu.io/2018/5/8/1633e127396541f1?w=864&amp;h=439&amp;f=png&amp;s=226095\" alt=\"TCP三次握手\"></p>\n<p><strong>简单示意图：</strong><br>\n<img data-src=\"https://user-gold-cdn.xitu.io/2018/5/8/1633e14233d95972?w=542&amp;h=427&amp;f=jpeg&amp;s=15088\" alt=\"TCP三次握手\"></p>\n<ul>\n<li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li>\n<li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li>\n<li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li>\n</ul>\n<h3 id=\"为什么要三次握手\"><a class=\"markdownIt-Anchor\" href=\"#为什么要三次握手\">#</a> 为什么要三次握手</h3>\n<p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>\n<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常</p>\n<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常</p>\n<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常</p>\n<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>\n<h3 id=\"为什么要传回-syn\"><a class=\"markdownIt-Anchor\" href=\"#为什么要传回-syn\">#</a> 为什么要传回 SYN</h3>\n<p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>\n<blockquote>\n<p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK (Acknowledgement [汉译：确认字符，在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。]）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>\n</blockquote>\n<h3 id=\"传了-syn为啥还要传-ack\"><a class=\"markdownIt-Anchor\" href=\"#传了-syn为啥还要传-ack\">#</a> 传了 SYN, 为啥还要传 ACK</h3>\n<p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p>\n<p><img data-src=\"https://user-gold-cdn.xitu.io/2018/5/8/1633e1676e2ac0a3?w=500&amp;h=340&amp;f=jpeg&amp;s=13406\" alt=\"TCP四次挥手\"></p>\n<p>断开一个 TCP 连接则需要 “四次挥手”：</p>\n<ul>\n<li>客户端 - 发送一个 FIN，用来关闭客户端到服务器的数据传送</li>\n<li>服务器 - 收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号</li>\n<li>服务器 - 关闭与客户端的连接，发送一个 FIN 给客户端</li>\n<li>客户端 - 发回 ACK 报文确认，并将确认序号设置为收到序号加 1</li>\n</ul>\n<h3 id=\"为什么要四次挥手\"><a class=\"markdownIt-Anchor\" href=\"#为什么要四次挥手\">#</a> 为什么要四次挥手</h3>\n<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>\n<p>举个例子：A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说 “我说完了”，A 回答 “知道了”，这样通话才算结束。</p>\n<p>上面讲的比较概括，推荐一篇讲的比较细致的文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F6Y3N1L2FydGljbGUvZGV0YWlscy83Mjg2MTg5MQ==\">https://blog.csdn.net/qzcsu/article/details/72861891</span></p>\n<h2 id=\"三-tcp-udp-协议的区别\"><a class=\"markdownIt-Anchor\" href=\"#三-tcp-udp-协议的区别\">#</a> 三 TCP、UDP 协议的区别</h2>\n<p><img data-src=\"https://user-gold-cdn.xitu.io/2018/4/19/162db5e97e9a9e01?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"TCP、UDP协议的区别\"></p>\n<p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p>\n<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>\n<h2 id=\"四-tcp-协议如何保证可靠传输\"><a class=\"markdownIt-Anchor\" href=\"#四-tcp-协议如何保证可靠传输\">#</a> 四 TCP 协议如何保证可靠传输</h2>\n<ol>\n<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>\n<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>\n<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>\n<li>TCP 的接收端会丢弃重复的数据。</li>\n<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>\n<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>\n<li><strong>停止等待协议</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 <strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>\n</ol>\n<h3 id=\"停止等待协议\"><a class=\"markdownIt-Anchor\" href=\"#停止等待协议\">#</a> 停止等待协议</h3>\n<ul>\n<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；</li>\n<li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li>\n</ul>\n<p><strong>1) 无差错情况:</strong></p>\n<p><img data-src=\"https://user-gold-cdn.xitu.io/2018/8/16/16541fa8c3816a90?w=514&amp;h=473&amp;f=png&amp;s=9924\" alt=\"\"></p>\n<p>发送方发送分组，接收方在规定时间内收到，并且回复确认。发送方再次发送。</p>\n<p><strong>2) 出现差错情况（超时重传）:</strong><br>\n<img data-src=\"https://user-gold-cdn.xitu.io/2018/8/16/16541faefdf249ab?w=953&amp;h=480&amp;f=png&amp;s=19163\" alt=\"\"><br>\n 停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>\n<p><strong>3) 确认丢失和确认迟到</strong></p>\n<ul>\n<li>\n<p><strong>确认丢失</strong>：确认消息在传输过程丢失<br>\n<img data-src=\"https://user-gold-cdn.xitu.io/2018/8/16/16541fb6941a7165?w=918&amp;h=461&amp;f=png&amp;s=19841\" alt=\"\"><br>\n当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：</p>\n<pre><code>1. 丢弃这个重复的M1消息，不向上层交付。\n2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。\n</code></pre>\n</li>\n<li>\n<p><strong>确认迟到</strong> ：确认消息在传输过程中迟到<br>\n<img data-src=\"https://user-gold-cdn.xitu.io/2018/8/16/16541fdd85929e6b?w=899&amp;h=450&amp;f=png&amp;s=23165\" alt=\"\"><br>\n A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：<br>\n1. A 收到重复的确认后，直接丢弃。<br>\n2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</p>\n</li>\n</ul>\n<h3 id=\"自动重传请求-arq-协议\"><a class=\"markdownIt-Anchor\" href=\"#自动重传请求-arq-协议\">#</a> 自动重传请求 ARQ 协议</h3>\n<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。</p>\n<p><strong>优点：</strong> 简单</p>\n<p><strong>缺点：</strong> 信道利用率低</p>\n<h3 id=\"连续arq协议\"><a class=\"markdownIt-Anchor\" href=\"#连续arq协议\">#</a> 连续 ARQ 协议</h3>\n<p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>\n<p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p>\n<p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>\n<h3 id=\"滑动窗口\"><a class=\"markdownIt-Anchor\" href=\"#滑动窗口\">#</a> 滑动窗口</h3>\n<ul>\n<li>TCP 利用滑动窗口实现流量控制的机制。</li>\n<li>滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。</li>\n<li>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</li>\n</ul>\n<h3 id=\"流量控制\"><a class=\"markdownIt-Anchor\" href=\"#流量控制\">#</a> 流量控制</h3>\n<ul>\n<li>TCP 利用滑动窗口实现流量控制。</li>\n<li>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</li>\n<li>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</li>\n</ul>\n<h3 id=\"拥塞控制\"><a class=\"markdownIt-Anchor\" href=\"#拥塞控制\">#</a> 拥塞控制</h3>\n<p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>\n<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口 (cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>\n<p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>\n<ul>\n<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。<br>\n<img data-src=\"https://user-gold-cdn.xitu.io/2018/8/10/1652348ada2c8fd0?w=1050&amp;h=560&amp;f=jpeg&amp;s=112611\" alt=\"\"></li>\n<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.</li>\n<li><strong>快重传与快恢复：</strong><br>\n在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。<br>\n<img data-src=\"https://user-gold-cdn.xitu.io/2018/8/10/165234f0303d174b?w=1174&amp;h=648&amp;f=png&amp;s=109568\" alt=\"快重传与快恢复\"></li>\n</ul>\n<h2 id=\"五-在浏览器中输入url地址-显示主页的过程面试常客\"><a class=\"markdownIt-Anchor\" href=\"#五-在浏览器中输入url地址-显示主页的过程面试常客\">#</a> 五  在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程（面试常客）</h2>\n<p>百度好像最喜欢问这个问题。</p>\n<blockquote>\n<p>打开一个网页，整个过程会使用哪些协议</p>\n</blockquote>\n<p>图解（图片来源：《图解 HTTP》）：</p>\n<p><img data-src=\"https://user-gold-cdn.xitu.io/2018/4/19/162db5e985aabdbe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"状态码\"></p>\n<p>总体来说分为以下几个过程:</p>\n<ol>\n<li>DNS 解析</li>\n<li>TCP 连接</li>\n<li>发送 HTTP 请求</li>\n<li>服务器处理请求并返回 HTTP 报文</li>\n<li>浏览器解析渲染页面</li>\n<li>连接结束</li>\n</ol>\n<p>具体可以参考下面这篇文章：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNjg3OTcwMA==\">https://segmentfault.com/a/1190000006879700</span></li>\n</ul>\n<h2 id=\"六-状态码\"><a class=\"markdownIt-Anchor\" href=\"#六-状态码\">#</a> 六 状态码</h2>\n<p><img data-src=\"https://user-gold-cdn.xitu.io/2018/5/8/1633e19dba27ed00?w=673&amp;h=218&amp;f=png&amp;s=72968\" alt=\"状态码\"></p>\n<h2 id=\"七-各种协议与http协议之间的关系\"><a class=\"markdownIt-Anchor\" href=\"#七-各种协议与http协议之间的关系\">#</a> 七 各种协议与 HTTP 协议之间的关系</h2>\n<p>一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。</p>\n<p>图片来源：《图解 HTTP》</p>\n<p><img data-src=\"https://user-gold-cdn.xitu.io/2018/5/8/1633ead316d07713?w=841&amp;h=1193&amp;f=png&amp;s=609513\" alt=\"各种协议与HTTP协议之间的关系\"></p>\n<h2 id=\"八-http长连接-短连接\"><a class=\"markdownIt-Anchor\" href=\"#八-http长连接-短连接\">#</a> 八  HTTP 长连接、短连接</h2>\n<p>在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。</p>\n<p>而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Connection:keep-alive</span><br></pre></td></tr></table></figure>\n<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>\n<p><strong>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</strong></p>\n<p>—— <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ290b2RzcC9wLzYzNjYxNjMuaHRtbA==\">《HTTP 长连接、短连接究竟是什么？》</span></p>\n<h2 id=\"写在最后\"><a class=\"markdownIt-Anchor\" href=\"#写在最后\">#</a> 写在最后</h2>\n<h3 id=\"计算机网络常见问题回顾\"><a class=\"markdownIt-Anchor\" href=\"#计算机网络常见问题回顾\">#</a> 计算机网络常见问题回顾</h3>\n<ul>\n<li>①TCP 三次握手和四次挥手、</li>\n<li>②在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程</li>\n<li>③HTTP 和 HTTPS 的区别</li>\n<li>④TCP、UDP 协议的区别</li>\n<li>⑤常见的状态码。</li>\n</ul>\n<h3 id=\"建议\"><a class=\"markdownIt-Anchor\" href=\"#建议\">#</a> 建议</h3>\n<p>非常推荐大家看一下 《图解 HTTP》 这本书，这本书页数不多，但是内容很是充实，不管是用来系统的掌握网络方面的一些知识还是说纯粹为了应付面试都有很大帮助。下面的一些文章只是参考。大二学习这门课程的时候，我们使用的教材是 《计算机网络第七版》（谢希仁编著），不推荐大家看这本教材，书非常厚而且知识偏理论，不确定大家能不能心平气和的读完。</p>\n<h3 id=\"参考\"><a class=\"markdownIt-Anchor\" href=\"#参考\">#</a> 参考</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE2MjA5MDc3L2FydGljbGUvZGV0YWlscy81MjcxODI1MA==\">https://blog.csdn.net/qq_16209077/article/details/52718250</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ppeGlhb211d3UvYXJ0aWNsZS9kZXRhaWxzLzYwOTY1NDY2\">https://blog.csdn.net/zixiaomuwu/article/details/60965466</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1cm5fX2JhY2svYXJ0aWNsZS9kZXRhaWxzLzczNzQzNjQx\">https://blog.csdn.net/turn__back/article/details/73743641</span></li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/03/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/",
            "url": "http://example.com/2023/07/03/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/",
            "title": "Linux基础知识",
            "date_published": "2023-07-02T16:51:04.000Z",
            "content_html": "<blockquote>\n<blockquote>\n<p>学习 Linux 之前，我们先来简单的认识一下操作系统。</p>\n</blockquote>\n<h2 id=\"一-从认识操作系统开始\"><a class=\"markdownIt-Anchor\" href=\"#一-从认识操作系统开始\">#</a> 一 从认识操作系统开始</h2>\n<h3 id=\"11-操作系统简介\"><a class=\"markdownIt-Anchor\" href=\"#11-操作系统简介\">#</a> 1.1  操作系统简介</h3>\n<p>我通过以下四点介绍什么操作系统：</p>\n<ul>\n<li><strong>操作系统（Operation System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石；</strong></li>\n<li><strong>操作系统本质上是运行在计算机上的软件程序 ；</strong></li>\n<li><strong>为用户提供一个与系统交互的操作界面 ；</strong></li>\n<li><strong>操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。</strong></li>\n</ul>\n<p><img data-src=\"https://user-gold-cdn.xitu.io/2018/7/3/1645ee3dc5cf626e?w=862&amp;h=637&amp;f=png&amp;s=23899\" alt=\"操作系统分内核与外壳\"></p>\n<h3 id=\"12-操作系统简单分类\"><a class=\"markdownIt-Anchor\" href=\"#12-操作系统简单分类\">#</a> 1.2  操作系统简单分类</h3>\n<ol>\n<li><strong>Windows:</strong> 目前最流行的个人桌面操作系统 ，不做多的介绍，大家都清楚。</li>\n<li><strong>Unix：</strong> 最早的多用户、多任务操作系统。按照操作系统的分类，属于分时操作系统。Unix 大多被用在服务器、工作站，现在也有用在个人计算机上。它在创建互联网、计算机网络或客户端 / 服务器模型方面发挥着非常重要的作用。<br>\n<img data-src=\"https://user-gold-cdn.xitu.io/2018/7/3/1645ee83f036846d?w=1075&amp;h=475&amp;f=png&amp;s=914462\" alt=\"Unix\"></li>\n<li><strong>Linux:</strong> Linux 是一套免费使用和自由传播的类 Unix 操作系统.Linux 存在着许多不同的 Linux 版本，但它们都使用了 <strong>Linux 内核</strong> 。Linux 可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。严格来讲，Linux 这个词本身只表示 Linux 内核，但实际上人们已经习惯了用 Linux 来形容整个基于 Linux 内核，并且使用 GNU 工程各种工具和数据库的操作系统。</li>\n</ol>\n<p><img data-src=\"https://user-gold-cdn.xitu.io/2018/7/3/1645eeb8e843f29d?w=426&amp;h=240&amp;f=png&amp;s=32650\" alt=\"Linux\"></p>\n<h2 id=\"二-初探linux\"><a class=\"markdownIt-Anchor\" href=\"#二-初探linux\">#</a> 二  初探 Linux</h2>\n<h3 id=\"21-linux简介\"><a class=\"markdownIt-Anchor\" href=\"#21-linux简介\">#</a> 2.1 Linux 简介</h3>\n<p>我们上面已经介绍到了 Linux，我们这里只强调三点。</p>\n<ul>\n<li><strong>类 Unix 系统：</strong> Linux 是一种自由、开放源码的类似 Unix 的操作系统</li>\n<li><strong>Linux 内核：</strong> 严格来说，Linux 这个词本身只表示 Linux 内核</li>\n<li><strong>Linux 之父：</strong> 一个编程领域的传奇式人物。他是 Linux 内核的最早作者，随后发起了这个开源项目，担任 Linux 内核的首要架构师与项目协调者，是当今世界最著名的电脑程序员、黑客之一。他还发起了 Git 这个开源项目，并为主要的开发者。</li>\n</ul>\n<p><img data-src=\"https://user-gold-cdn.xitu.io/2018/7/3/1645ef0a5a4f137f?w=270&amp;h=376&amp;f=png&amp;s=193487\" alt=\"Linux\"></p>\n<h3 id=\"22-linux诞生简介\"><a class=\"markdownIt-Anchor\" href=\"#22-linux诞生简介\">#</a> 2.2  Linux 诞生简介</h3>\n<ul>\n<li>1991 年，芬兰的业余计算机爱好者 Linus Torvalds 编写了一款类似 Minix 的系统（基于微内核架构的类 Unix 操作系统）被 ftp 管理员命名为 Linux 加入到自由软件基金的 GNU 计划中；</li>\n<li>Linux 以一只可爱的企鹅作为标志，象征着敢作敢为、热爱生活。</li>\n</ul>\n<h3 id=\"23-linux的分类\"><a class=\"markdownIt-Anchor\" href=\"#23-linux的分类\">#</a> 2.3 Linux 的分类</h3>\n<p><strong>Linux 根据原生程度，分为两种：</strong></p>\n<ol>\n<li><strong>内核版本：</strong> Linux 不是一个操作系统，严格来讲，Linux 只是一个操作系统中的内核。内核是什么？内核建立了计算机软件与硬件之间通讯的平台，内核提供系统服务，比如文件管理、虚拟内存、设备 I/O 等；</li>\n<li><strong>发行版本：</strong> 一些组织或公司在内核版基础上进行二次开发而重新发行的版本。Linux 发行版本有很多种（ubuntu 和 CentOS 用的都很多，初学建议选择 CentOS），如下图所示：<br>\n<img data-src=\"https://user-gold-cdn.xitu.io/2018/7/3/1645efa7048fd018?w=548&amp;h=274&amp;f=png&amp;s=99213\" alt=\"Linux发行版本\"></li>\n</ol>\n<h2 id=\"三-linux文件系统概览\"><a class=\"markdownIt-Anchor\" href=\"#三-linux文件系统概览\">#</a> 三  Linux 文件系统概览</h2>\n<h3 id=\"31-linux文件系统简介\"><a class=\"markdownIt-Anchor\" href=\"#31-linux文件系统简介\">#</a> 3.1 Linux 文件系统简介</h3>\n<p><strong>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong></p>\n<p>也就是说在 LINUX 系统中有一个重要的概念：<strong>一切都是文件</strong>。其实这是 UNIX 哲学的一个体现，而 Linux 是重写 UNIX 而来，所以这个概念也就传承了下来。在 UNIX 系统中，把一切资源都看作是文件，包括硬件设备。UNIX 系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。</p>\n<h3 id=\"32-文件类型与目录结构\"><a class=\"markdownIt-Anchor\" href=\"#32-文件类型与目录结构\">#</a> 3.2 文件类型与目录结构</h3>\n<p><strong>Linux 支持 5 种文件类型 ：</strong><br>\n<img data-src=\"https://user-gold-cdn.xitu.io/2018/7/3/1645f1a7d64def1a?w=901&amp;h=547&amp;f=png&amp;s=72692\" alt=\"文件类型\"></p>\n<p><strong>Linux 的目录结构如下：</strong></p>\n<p>Linux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：<br>\n<img data-src=\"https://user-gold-cdn.xitu.io/2018/7/3/1645f1c65676caf6?w=823&amp;h=315&amp;f=png&amp;s=15226\" alt=\"Linux的目录结构\"></p>\n<p><strong>常见目录说明：</strong></p>\n<ul>\n<li><strong>/bin：</strong> 存放二进制可执行文件 (ls,cat,mkdir 等)，常用命令一般都在这里；</li>\n<li><strong>/etc：</strong>  存放系统管理和配置文件；</li>\n<li><strong>/home：</strong>  存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是 /home/user，可以用～user 表示；</li>\n<li><strong>/usr ：</strong> 用于存放系统应用程序；</li>\n<li><strong>/opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；</li>\n<li><strong>/proc：</strong>  虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li>\n<li><strong>/root：</strong>\t超级用户（系统管理员）的主目录（特权阶级<sup> o</sup>）；</li>\n<li><strong>/sbin:</strong>\t存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；</li>\n<li><strong>/dev：</strong>\t用于存放设备文件；</li>\n<li><strong>/mnt：</strong>\t系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li>\n<li><strong>/boot：</strong>\t存放用于系统引导时使用的各种文件；</li>\n<li><strong>/lib ：</strong>      存放着和系统运行相关的库文件 ；</li>\n<li><strong>/tmp：</strong>\t用于存放各种临时文件，是公用的临时文件存储点；</li>\n<li><strong>/var：</strong>\t用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li>\n<li><strong>/lost+found：</strong>\t这个目录平时是空的，系统非正常关机而留下 “无家可归” 的文件（windows 下叫什么.chk）就在这里。</li>\n</ul>\n<h2 id=\"四-linux基本命令\"><a class=\"markdownIt-Anchor\" href=\"#四-linux基本命令\">#</a> 四  Linux 基本命令</h2>\n<p>下面只是给出了一些比较常用的命令。推荐一个 Linux 命令快查网站，非常不错，大家如果遗忘某些命令或者对某些命令不理解都可以在这里得到解决。</p>\n<p>Linux 命令大全：<span class=\"exturl\" data-url=\"aHR0cDovL21hbi5saW51eGRlLm5ldC8=\">http://man.linuxde.net/</span></p>\n<h3 id=\"41-目录切换命令\"><a class=\"markdownIt-Anchor\" href=\"#41-目录切换命令\">#</a> 4.1 目录切换命令</h3>\n<ul>\n<li><strong> <code>cd usr</code> ：</strong>\t\t切换到该目录下 usr 目录</li>\n<li><strong> <code>cd ..（或cd../）</code> ：</strong>\t切换到上一层目录</li>\n<li><strong> <code>cd /</code> ：</strong>\t\t切换到系统根目录</li>\n<li><strong> <code>cd ~</code> ：</strong>\t\t切换到用户主目录</li>\n<li><strong> <code>cd -</code> ：</strong>\t\t切换到上一个所在目录</li>\n</ul>\n<h3 id=\"42-目录的操作命令增删改查\"><a class=\"markdownIt-Anchor\" href=\"#42-目录的操作命令增删改查\">#</a> 4.2 目录的操作命令（增删改查）</h3>\n<ol>\n<li>\n<p><strong> <code>mkdir 目录名称</code> ：</strong> 增加目录</p>\n</li>\n<li>\n<p><strong> <code>ls或者ll</code> </strong>（ll 是 ls -l 的缩写，ll 命令以看到该目录下的所有目录和文件的详细信息）：查看目录信息</p>\n</li>\n<li>\n<p><strong> <code>find 目录 参数</code> ：</strong> 寻找目录（查）</p>\n<p>示例：</p>\n<ul>\n<li>列出当前目录及子目录下所有文件和文件夹:  <code>find .</code></li>\n<li>在 <code>/home</code>  目录下查找以.txt 结尾的文件名: <code>find /home -name &quot;*.txt&quot;</code></li>\n<li>同上，但忽略大小写:  <code>find /home -iname &quot;*.txt&quot;</code></li>\n<li>当前目录及子目录下查找所有以.txt 和.pdf 结尾的文件: <code>find . \\( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \\)</code>  或 <code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; </code></li>\n</ul>\n</li>\n<li>\n<p><strong> <code>mv 目录名称 新目录名称</code> ：</strong> 修改目录的名称（改）</p>\n<p>注意：mv 的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行\t重命名的操作。mv 命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到 mv 命令的另一个用法。</p>\n</li>\n<li>\n<p><strong> <code>mv 目录名称 目录的新位置</code> ：</strong>  移动目录的位置 — 剪切（改）</p>\n<p>注意：mv 语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外 mv 与 cp 的结果不同，mv 好像文件 “搬家”，文件个数并未增加。而 cp 对文件进行复制，文件个数增加了。</p>\n</li>\n<li>\n<p><strong> <code>cp -r 目录名称 目录拷贝的目标位置</code> ：</strong> 拷贝目录（改），-r 代表递归拷贝</p>\n<p>注意：cp 命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不\t用写 - r 递归</p>\n</li>\n<li>\n<p><strong> <code>rm [-rf] 目录</code> :</strong> 删除目录（删）</p>\n<p>注意：rm 不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆，\t无论删除任何目录或文件，都直接使用 <code>rm -rf</code>  目录 / 文件 / 压缩包</p>\n</li>\n</ol>\n<h3 id=\"43-文件的操作命令增删改查\"><a class=\"markdownIt-Anchor\" href=\"#43-文件的操作命令增删改查\">#</a> 4.3 文件的操作命令（增删改查）</h3>\n<ol>\n<li>\n<p><strong> <code>touch 文件名称</code> :</strong>  文件的创建（增）</p>\n</li>\n<li>\n<p><strong> <code>cat/more/less/tail 文件名称</code> </strong> 文件的查看（查）</p>\n<ul>\n<li><strong> <code>cat</code> ：</strong> 只能显示最后一屏内容</li>\n<li><strong> <code>more</code> ：</strong> 可以显示百分比，回车可以向下一行，\t空格可以向下一页，q 可以退出查看</li>\n<li><strong> <code>less</code> ：</strong> 可以使用键盘上的 PgUp 和 PgDn 向上\t和向下翻页，q 结束查看</li>\n<li><strong> <code>tail-10</code>  ：</strong> 查看文件的后 10 行，Ctrl+C 结束</li>\n</ul>\n<p>注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如 tomcat 的日志文件，\t会随着程序的运行，日志会变化，可以使用 tail -f catalina-2016-11-11.log 监控\t文\t件的变化</p>\n</li>\n<li>\n<p><strong> <code>vim 文件</code> ：</strong>  修改文件的内容（改）</p>\n<p>vim 编辑器是 Linux 中的强大组件，是 vi 编辑器的加强版，vim 编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用 vim 编辑修改文件的方式基本会使用就可以了。</p>\n<p><strong>在实际开发中，使用 vim 编辑器主要作用就是修改配置文件，下面是一般步骤：</strong></p>\n<p>vim 文件 ------&gt; 进入文件 -----&gt; 命令模式 ------&gt; 按 i 进入编辑模式 -----&gt; 编辑文件\t-------&gt; 按 Esc 进入底行模式 -----&gt; 输入:wq/q! （输入 wq 代表写入内容并退出，即保存；输入 q! 代表强制退出不保存。）</p>\n</li>\n<li>\n<p><strong> <code>rm -rf 文件</code> ：</strong> 删除文件（删）</p>\n<p>同目录删除：熟记  <code>rm -rf</code>  文件 即可</p>\n</li>\n</ol>\n<h3 id=\"44-压缩文件的操作命令\"><a class=\"markdownIt-Anchor\" href=\"#44-压缩文件的操作命令\">#</a> 4.4 压缩文件的操作命令</h3>\n<p><strong>1）打包并压缩文件：</strong></p>\n<p>Linux 中的打包文件一般是以.tar 结尾的，压缩的命令一般是以.gz 结尾的。</p>\n<p>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。<br>\n命令：<strong> <code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code> </strong><br>\n其中：</p>\n<p>z：调用 gzip 压缩命令进行压缩</p>\n<p>c：打包文件</p>\n<p>v：显示运行过程</p>\n<p>f：指定文件名</p>\n<p>比如：加入 test 目录下有三个文件分别是 :aaa.txt bbb.txt ccc.txt, 如果我们要打包 test 目录并指定压缩后的压缩包名称为 test.tar.gz 可以使用命令：<strong> <code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code>  或： <code>tar -zcvf test.tar.gz       /test/</code> </strong></p>\n<p><strong>2）解压压缩包：</strong></p>\n<p>命令：tar [-xvf] 压缩文件</p>\n<p>其中：x：代表解压</p>\n<p>示例：</p>\n<p>1 将 /test 下的 test.tar.gz 解压到当前目录下可以使用命令：<strong> <code>tar -xvf test.tar.gz</code> </strong></p>\n<p>2 将 /test 下的 test.tar.gz 解压到根目录 /usr 下:<strong> <code>tar -xvf xxx.tar.gz -C /usr</code> </strong>（- C 代表指定解压的位置）</p>\n<h3 id=\"45-linux的权限命令\"><a class=\"markdownIt-Anchor\" href=\"#45-linux的权限命令\">#</a> 4.5 Linux 的权限命令</h3>\n<p>操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在 Linux 中权限一般分为读 (readable)、写 (writable) 和执行 (excutable)，分为三组。分别对应文件的属主 (owner)，属组 (group) 和其他用户 (other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。通过 <strong> <code>ls -l</code> </strong> 命令我们可以\t查看某个目录下的文件或目录的权限</p>\n<p>示例：在随意某个目录下 <code>ls -l</code></p>\n<p><img data-src=\"https://user-gold-cdn.xitu.io/2018/7/5/1646955be781daaa?w=589&amp;h=228&amp;f=png&amp;s=16360\" alt=\"\"></p>\n<p>第一列的内容的信息解释如下：</p>\n<p><img data-src=\"https://user-gold-cdn.xitu.io/2018/7/5/16469565b6951791?w=489&amp;h=209&amp;f=png&amp;s=39791\" alt=\"\"></p>\n<blockquote>\n<p>下面将详细讲解文件的类型、Linux 中权限以及文件有所有者、所在组、其它组具体是什么？</p>\n</blockquote>\n<p><strong>文件的类型：</strong></p>\n<ul>\n<li>d： 代表目录</li>\n<li>-： 代表文件</li>\n<li>l： 代表链接（可以认为是 window 中的快捷方式）</li>\n</ul>\n<p><strong>Linux 中权限分为以下几种：</strong></p>\n<ul>\n<li>r：代表权限是可读，r 也可以用数字 4 表示</li>\n<li>w：代表权限是可写，w 也可以用数字 2 表示</li>\n<li>x：代表权限是可执行，x 也可以用数字 1 表示</li>\n</ul>\n<p><strong>文件和目录权限的区别：</strong></p>\n<p>对文件和目录而言，读写执行表示不同的意义。</p>\n<p>对于文件：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">权限名称</th>\n<th style=\"text-align:right\">可执行操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">r</td>\n<td style=\"text-align:right\">可以使用 cat 查看文件的内容</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">w</td>\n<td style=\"text-align:right\">可以修改文件的内容</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">x</td>\n<td style=\"text-align:right\">可以将其运行为二进制文件</td>\n</tr>\n</tbody>\n</table>\n<p>对于目录：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">权限名称</th>\n<th style=\"text-align:right\">可执行操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">r</td>\n<td style=\"text-align:right\">可以查看目录下列表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">w</td>\n<td style=\"text-align:right\">可以创建和删除目录下文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">x</td>\n<td style=\"text-align:right\">可以使用 cd 进入目录</td>\n</tr>\n</tbody>\n</table>\n<p><strong>在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。</strong></p>\n<ul>\n<li>\n<p><strong>所有者</strong></p>\n<p>一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用 ls ‐ahl 命令可以看到文件的所有者 也可以使用 chown 用户名  文件名来修改文件的所有者 。</p>\n</li>\n<li>\n<p><strong>文件所在组</strong></p>\n<p>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组 用 ls ‐ahl 命令可以看到文件的所有组 也可以使用 chgrp  组名  文件名来修改文件所在的组。</p>\n</li>\n<li>\n<p><strong>其它组</strong></p>\n<p>除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组</p>\n</li>\n</ul>\n<blockquote>\n<p>我们再来看看如何修改文件 / 目录的权限。</p>\n</blockquote>\n<p><strong>修改文件 / 目录的权限的命令： <code>chmod</code> </strong></p>\n<p>示例：修改 /test 下的 aaa.txt 的权限为属主有全部权限，属主所在的组有读写权限，<br>\n其他用户只有读的权限</p>\n<p><strong> <code>chmod u=rwx,g=rw,o=r aaa.txt</code> </strong></p>\n<p><img data-src=\"https://user-gold-cdn.xitu.io/2018/7/5/164697447dc6ecac?w=525&amp;h=246&amp;f=png&amp;s=12362\" alt=\"\"></p>\n<p>上述示例还可以使用数字表示：</p>\n<p>chmod 764 aaa.txt</p>\n<p><strong>补充一个比较常用的东西:</strong></p>\n<p>假如我们装了一个 zookeeper，我们每次开机到要求其自动启动该怎么办？</p>\n<ol>\n<li>新建一个脚本 zookeeper</li>\n<li>为新建的脚本 zookeeper 添加可执行权限，命令是: <code>chmod +x zookeeper</code></li>\n<li>把 zookeeper 这个脚本添加到开机启动项里面，命令是： <code> chkconfig --add  zookeeper</code></li>\n<li>如果想看看是否添加成功，命令是： <code>chkconfig --list</code></li>\n</ol>\n<h3 id=\"46-linux-用户管理\"><a class=\"markdownIt-Anchor\" href=\"#46-linux-用户管理\">#</a> 4.6 Linux 用户管理</h3>\n<p>Linux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>\n<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>\n<p><strong>Linux 用户管理相关命令:</strong></p>\n<ul>\n<li><code>useradd 选项 用户名</code> ：添加用户账号</li>\n<li><code>userdel 选项 用户名</code> ：删除用户帐号</li>\n<li><code>usermod 选项 用户名</code> ：修改帐号</li>\n<li><code>passwd 用户名</code> ：更改或创建用户的密码</li>\n<li><code>passwd -S 用户名</code> ：显示用户账号密码信息</li>\n<li><code>passwd -d 用户名</code> ：清除用户密码</li>\n</ul>\n<p>useradd 命令用于 Linux 中创建的新的系统用户。useradd 可用来建立用户帐号。帐号建好之后，再用 passwd 设定帐号的密码．而可用 userdel 删除帐号。使用 useradd 指令所建立的帐号，实际上是保存在 /etc/passwd 文本文件中。</p>\n<p>passwd 命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p>\n<h3 id=\"47-linux系统用户组的管理\"><a class=\"markdownIt-Anchor\" href=\"#47-linux系统用户组的管理\">#</a> 4.7 Linux 系统用户组的管理</h3>\n<p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同，如 Linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>\n<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对 /etc/group 文件的更新。</p>\n<p><strong>Linux 系统用户组的管理相关命令:</strong></p>\n<ul>\n<li><code>groupadd 选项 用户组</code> ：增加一个新的用户组</li>\n<li><code>groupdel 用户组</code> ：要删除一个已有的用户组</li>\n<li><code>groupmod 选项 用户组</code> ：修改用户组的属性</li>\n</ul>\n<h3 id=\"48-其他常用命令\"><a class=\"markdownIt-Anchor\" href=\"#48-其他常用命令\">#</a> 4.8 其他常用命令</h3>\n<ul>\n<li>\n<p><strong> <code>pwd</code> ：</strong> 显示当前所在位置</p>\n</li>\n<li>\n<p><strong> <code>grep 要搜索的字符串 要搜索的文件 --color</code> ：</strong> 搜索命令，–color 代表高亮显示</p>\n</li>\n<li>\n<p><strong> <code>ps -ef</code> / <code>ps aux</code> ：</strong> 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<strong> <code>ps aux|grep redis</code> </strong> （查看包括 redis 字符串的进程）</p>\n<p>注意：如果直接用 ps（（Process Status））命令，会显示所有进程的状态，通常结合 grep 命令查看某进程的状态。</p>\n</li>\n<li>\n<p><strong> <code>kill -9 进程的pid</code> ：</strong> 杀死进程（-9 表示强制终止。）</p>\n<p>先用 ps 查找进程，然后用 kill 杀掉</p>\n</li>\n<li>\n<p><strong>网络通信命令：</strong></p>\n<ul>\n<li>查看当前系统的网卡信息：ifconfig</li>\n<li>查看与某台机器的连接情况：ping</li>\n<li>查看当前系统的端口使用：netstat -an</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>shutdown</code> ：</strong>   <code>shutdown -h now</code> ： 指定现在立即关机； <code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code> : 指定 5 分钟后关机，同时送出警告信息给登入用户。</p>\n</li>\n<li>\n<p><strong> <code>reboot</code> ：</strong>  <strong> <code>reboot</code> ：</strong>  重开机。<strong> <code>reboot -w</code> ：</strong> 做个重开机的模拟（只有纪录并不会真的重开机）。</p>\n</li>\n</ul>\n</blockquote>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/03/shell/",
            "url": "http://example.com/2023/07/03/shell/",
            "title": "shell",
            "date_published": "2023-07-02T16:50:42.000Z",
            "content_html": "<!-- MarkdownTOC -->\n<ul>\n<li><a href=\"#shell-%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8\">Shell 编程入门</a>\n<ul>\n<li><a href=\"#%E8%B5%B0%E8%BF%9B-shell-%E7%BC%96%E7%A8%8B%E7%9A%84%E5%A4%A7%E9%97%A8\">走进 Shell 编程的大门</a>\n<ul>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6shell\">为什么要学 Shell？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-shell\">什么是 Shell？</a></li>\n<li><a href=\"#shell-%E7%BC%96%E7%A8%8B%E7%9A%84-hello-world\">Shell 编程的 Hello World</a></li>\n</ul>\n</li>\n<li><a href=\"#shell-%E5%8F%98%E9%87%8F\">Shell 变量</a>\n<ul>\n<li><a href=\"#shell-%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E4%BB%8B%E7%BB%8D\">Shell 编程中的变量介绍</a></li>\n<li><a href=\"#shell-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A5%E9%97%A8\">Shell 字符串入门</a></li>\n<li><a href=\"#shell-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C\">Shell 字符串常见操作</a></li>\n<li><a href=\"#shell-%E6%95%B0%E7%BB%84\">Shell 数组</a></li>\n</ul>\n</li>\n<li><a href=\"#shell-%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6\">Shell 基本运算符</a>\n<ul>\n<li><a href=\"#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6\">算数运算符</a></li>\n<li><a href=\"#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6\">关系运算符</a></li>\n<li><a href=\"#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6\">逻辑运算符</a></li>\n<li><a href=\"#%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E7%AC%A6\">布尔运算符</a></li>\n<li><a href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%90%E7%AE%97%E7%AC%A6\">字符串运算符</a></li>\n<li><a href=\"#%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E8%BF%90%E7%AE%97%E7%AC%A6\">文件相关运算符</a></li>\n</ul>\n</li>\n<li><a href=\"#shell%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6\">shell 流程控制</a>\n<ul>\n<li><a href=\"#if-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5\">if 条件语句</a></li>\n<li><a href=\"#for-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5\">for 循环语句</a></li>\n<li><a href=\"#while-%E8%AF%AD%E5%8F%A5\">while 语句</a></li>\n</ul>\n</li>\n<li><a href=\"#shell-%E5%87%BD%E6%95%B0\">shell 函数</a>\n<ul>\n<li><a href=\"#%E4%B8%8D%E5%B8%A6%E5%8F%82%E6%95%B0%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0\">不带参数没有返回值的函数</a></li>\n<li><a href=\"#%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0\">有返回值的函数</a></li>\n<li><a href=\"#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0\">带参数的函数</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /MarkdownTOC -->\n<h1 id=\"shell-编程入门\"><a class=\"markdownIt-Anchor\" href=\"#shell-编程入门\">#</a> Shell 编程入门</h1>\n<h2 id=\"走进-shell-编程的大门\"><a class=\"markdownIt-Anchor\" href=\"#走进-shell-编程的大门\">#</a> 走进 Shell 编程的大门</h2>\n<h3 id=\"为什么要学shell\"><a class=\"markdownIt-Anchor\" href=\"#为什么要学shell\">#</a> 为什么要学 Shell？</h3>\n<p>学一个东西，我们大部分情况都是往实用性方向着想。从工作角度来讲，学习 Shell 是为了提高我们自己工作效率，提高产出，让我们在更少的时间完成更多的事情。</p>\n<p>很多人会说 Shell 编程属于运维方面的知识了，应该是运维人员来做，我们做后端开发的没必要学。我觉得这种说法大错特错，相比于专门做 Linux 运维的人员来说，我们对 Shell 编程掌握程度的要求要比他们低，但是 shell 编程也是我们必须要掌握的！</p>\n<p>目前 Linux 系统下最流行的运维自动化语言就是 Shell 和 Python 了。</p>\n<p>两者之间，Shell 几乎是 IT 企业必须使用的运维自动化编程语言，特别是在运维工作中的服务监控、业务快速部署、服务启动停止、数据备份及处理、日制分析等环节里，shell 是不可缺的。Python 更适合处理复杂的业务逻辑，以及开发复杂的运维软件工具，实现通过 web 访问等。Shell 是一个命令解释器，解释执行用户所输入的命令和程序。一输入命令，就立即回应的交互的对话方式。</p>\n<p>另外，了解 shell 编程也是大部分互联网公司招聘后端开发人员的要求。下图是我截取的一些知名互联网公司对于 Shell 编程的要求。</p>\n<p><img data-src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-16/60190220.jpg\" alt=\"大型互联网公司对于shell编程技能的要求\"></p>\n<h3 id=\"什么是-shell\"><a class=\"markdownIt-Anchor\" href=\"#什么是-shell\">#</a> 什么是 Shell？</h3>\n<p>简单来说 “Shell 编程就是对一堆 Linux 命令的逻辑化处理”。</p>\n<p>W3Cschool 上的一篇文章是这样介绍 Shell 的，如下图所示。<br>\n<img data-src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-26/19456505.jpg\" alt=\"什么是 Shell？\"></p>\n<h3 id=\"shell-编程的-hello-world\"><a class=\"markdownIt-Anchor\" href=\"#shell-编程的-hello-world\">#</a> Shell 编程的 Hello World</h3>\n<p>学习任何一门编程语言第一件事就是输出 HelloWord 了！下面我会从新建文件到 shell 代码编写来说下 Shell 编程如何输出 Hello World。</p>\n<p>(1) 新建一个文件 <span class=\"exturl\" data-url=\"aHR0cDovL2hlbGxvd29ybGQuc2g=\">helloworld.sh</span> : <code>touch helloworld.sh</code> ，扩展名为 sh（sh 代表 Shell）（扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了）</p>\n<p>(2) 使脚本具有执行权限： <code>chmod +x helloworld.sh</code></p>\n<p>(3) 使用 vim 命令修改 helloworld.sh 文件： <code>vim helloworld.sh</code>  (vim 文件 ------&gt; 进入文件 -----&gt; 命令模式 ------&gt; 按 i 进入编辑模式 -----&gt; 编辑文件 -------&gt; 按 Esc 进入底行模式 -----&gt; 输入:wq/q! （输入 wq 代表写入内容并退出，即保存；输入 q! 代表强制退出不保存。）)</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2hlbGxvd29ybGQuc2g=\">helloworld.sh</span> 内容如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">第一个shell小程序,<span class=\"built_in\">echo</span> 是linux中的输出命令。</span></span><br><span class=\"line\">echo  &quot;helloworld!&quot;</span><br></pre></td></tr></table></figure>\n<p>shell 中 # 符号表示注释。<strong>shell 的第一行比较特殊，一般都会以 #! 开始来指定使用的 shell 类型。在 linux 中，除了 bash shell 以外，还有很多版本的 shell， 例如 zsh、dash 等等… 不过 bash shell 还是我们使用最多的。</strong></p>\n<p>(4) 运行脚本: <code>./helloworld.sh</code>  。（注意，一定要写成  <code>./helloworld.sh</code>  ，而不是  <code>helloworld.sh</code>  ，运行其它二进制的程序也一样，直接写  <code>helloworld.sh</code>  ，linux 系统会去 PATH 里寻找有没有叫 <span class=\"exturl\" data-url=\"aHR0cDovL3Rlc3Quc2g=\">test.sh</span> 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成  <code>helloworld.sh</code>  是会找不到命令的，要用 <code>./helloworld.sh</code>  告诉系统说，就在当前目录找。）</p>\n<p><img data-src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-16/55296212.jpg\" alt=\"shell 编程Hello World\"></p>\n<h2 id=\"shell-变量\"><a class=\"markdownIt-Anchor\" href=\"#shell-变量\">#</a> Shell 变量</h2>\n<h3 id=\"shell-编程中的变量介绍\"><a class=\"markdownIt-Anchor\" href=\"#shell-编程中的变量介绍\">#</a> Shell 编程中的变量介绍</h3>\n<p><strong>Shell 编程中一般分为三种变量：</strong></p>\n<ol>\n<li><strong>我们自己定义的变量（自定义变量）:</strong> 仅在当前 Shell 实例中有效，其他 Shell 启动的程序不能访问局部变量。</li>\n<li><strong>Linux 已定义的环境变量</strong>（环境变量， 例如：$PATH, $HOME 等…, 这类变量我们可以直接使用），使用  <code>env</code>  命令可以查看所有的环境变量，而 set 命令既可以查看环境变量也可以查看自定义变量。</li>\n<li><strong>Shell 变量</strong> ：Shell 变量是由 Shell 程序设置的特殊变量。Shell 变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了 Shell 的正常运行</li>\n</ol>\n<p><strong>常用的环境变量:</strong></p>\n<blockquote>\n<p>PATH 决定了 shell 将到哪些目录中寻找命令或程序<br>\n HOME 当前用户主目录<br>\n HISTSIZE　历史记录数<br>\n LOGNAME 当前用户的登录名<br>\n HOSTNAME　指主机的名称<br>\n SHELL 当前用户 Shell 类型<br>\n LANGUGE 　语言相关的环境变量，多语言可以修改此环境变量<br>\n MAIL　当前用户的邮件存放目录<br>\n PS1　基本提示符，对于 root 用户是 #，对于普通用户是 $</p>\n</blockquote>\n<p><strong>使用 Linux 已定义的环境变量：</strong></p>\n<p>比如我们要看当前用户目录可以使用： <code>echo $HOME</code>  命令；如果我们要看当前用户 Shell 类型 可以使用 <code>echo $SHELL</code>  命令。可以看出，使用方法非常简单。</p>\n<p><strong>使用自己定义的变量：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">自定义变量hello</span></span><br><span class=\"line\">hello=&quot;hello world&quot;</span><br><span class=\"line\">echo $hello</span><br><span class=\"line\">echo  &quot;helloworld!&quot;</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-17/19835037.jpg\" alt=\"使用自己定义的变量\"></p>\n<p><strong>Shell 编程中的变量名的命名的注意事项：</strong></p>\n<ul>\n<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头，但是可以使用下划线（_）开头。</li>\n<li>中间不能有空格，可以使用下划线（_）。</li>\n<li>不能使用标点符号。</li>\n<li>不能使用 bash 里的关键字（可用 help 命令查看保留关键字）。</li>\n</ul>\n<h3 id=\"shell-字符串入门\"><a class=\"markdownIt-Anchor\" href=\"#shell-字符串入门\">#</a> Shell 字符串入门</h3>\n<p>字符串是 shell 编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号。这点和 Java 中有所不同。</p>\n<p><strong>单引号字符串：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\">name=&#x27;SnailClimb&#x27;</span><br><span class=\"line\">hello=&#x27;Hello, I  am &#x27;$name&#x27;!&#x27;</span><br><span class=\"line\">echo $hello</span><br></pre></td></tr></table></figure>\n<p>输出内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello, I am SnailClimb!</span><br></pre></td></tr></table></figure>\n<p><strong>双引号字符串：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\">name=&#x27;SnailClimb&#x27;</span><br><span class=\"line\">hello=&quot;Hello, I  am &quot;$name&quot;!&quot;</span><br><span class=\"line\">echo $hello</span><br></pre></td></tr></table></figure>\n<p>输出内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello, I am SnailClimb!</span><br></pre></td></tr></table></figure>\n<h3 id=\"shell-字符串常见操作\"><a class=\"markdownIt-Anchor\" href=\"#shell-字符串常见操作\">#</a> Shell 字符串常见操作</h3>\n<p><strong>拼接字符串：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\">name=&quot;SnailClimb&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">使用双引号拼接</span></span><br><span class=\"line\">greeting=&quot;hello, &quot;$name&quot; !&quot;</span><br><span class=\"line\">greeting_1=&quot;hello, $&#123;name&#125; !&quot;</span><br><span class=\"line\">echo $greeting  $greeting_1</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">使用单引号拼接</span></span><br><span class=\"line\">greeting_2=&#x27;hello, &#x27;$name&#x27; !&#x27;</span><br><span class=\"line\">greeting_3=&#x27;hello, $&#123;name&#125; !&#x27;</span><br><span class=\"line\">echo $greeting_2  $greeting_3</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<p><img data-src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-17/51148933.jpg\" alt=\"输出结果\"></p>\n<p><strong>获取字符串长度：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">获取字符串长度</span></span><br><span class=\"line\">name=&quot;SnailClimb&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">第一种方式</span></span><br><span class=\"line\">echo $&#123;#name&#125; #输出 10</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">第二种方式</span></span><br><span class=\"line\">expr length &quot;$name&quot;;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p>使用 expr 命令时，表达式中的运算符左右必须包含空格，如果不包含空格，将会输出表达式本身:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expr 5+6    // 直接输出 5+6</span><br><span class=\"line\">expr 5 + 6       // 输出 11</span><br></pre></td></tr></table></figure>\n<p>对于某些运算符，还需要我们使用符号 &quot;&quot; 进行转义，否则就会提示语法错误。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expr 5 * 6       // 输出错误</span><br><span class=\"line\">expr 5 \\* 6      // 输出30</span><br></pre></td></tr></table></figure>\n<p><strong>截取子字符串:</strong></p>\n<p>简单的字符串截取：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">从字符串第 1 个字符开始往后截取 10 个字符</span></span><br><span class=\"line\">str=&quot;SnailClimb is a great man&quot;</span><br><span class=\"line\">echo $&#123;str:0:10&#125; #输出:SnailClimb</span><br></pre></td></tr></table></figure>\n<p>根据表达式截取：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!bin/bash</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">author:amau</span></span><br><span class=\"line\"></span><br><span class=\"line\">var=&quot;http://www.runoob.com/linux/linux-shell-variable.html&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">s1=$&#123;var%%t*&#125;#h</span><br><span class=\"line\">s2=$&#123;var%t*&#125;#http://www.runoob.com/linux/linux-shell-variable.h</span><br><span class=\"line\">s3=$&#123;var%%.*&#125;#http://www</span><br><span class=\"line\">s4=$&#123;var#*/&#125;#/www.runoob.com/linux/linux-shell-variable.html</span><br><span class=\"line\">s5=$&#123;var##*/&#125;#linux-shell-variable.html</span><br></pre></td></tr></table></figure>\n<h3 id=\"shell-数组\"><a class=\"markdownIt-Anchor\" href=\"#shell-数组\">#</a> Shell 数组</h3>\n<p>bash 支持一维数组（不支持多维数组），并且没有限定数组的大小。我下面给了大家一个关于数组操作的 Shell 代码示例，通过该示例大家可以知道如何创建数组、获取数组长度、获取 / 删除特定位置的数组元素、删除整个数组以及遍历数组。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\">array=(1 2 3 4 5);</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">获取数组长度</span></span><br><span class=\"line\">length=$&#123;#array[@]&#125;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">或者</span></span><br><span class=\"line\">length2=$&#123;#array[*]&#125;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">输出数组长度</span></span><br><span class=\"line\">echo $length #输出：5</span><br><span class=\"line\">echo $length2 #输出：5</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">输出数组第三个元素</span></span><br><span class=\"line\">echo $&#123;array[2]&#125; #输出：3</span><br><span class=\"line\">unset array[1]# 删除下表为1的元素也就是删除第二个元素</span><br><span class=\"line\">for i in $&#123;array[@]&#125;;do echo $i ;done # 遍历数组，输出： 1 3 4 5 </span><br><span class=\"line\">unset arr_number; # 删除数组中的所有元素</span><br><span class=\"line\">for i in $&#123;array[@]&#125;;do echo $i ;done # 遍历数组，数组元素为空，没有任何输出内容</span><br></pre></td></tr></table></figure>\n<h2 id=\"shell-基本运算符\"><a class=\"markdownIt-Anchor\" href=\"#shell-基本运算符\">#</a> Shell 基本运算符</h2>\n<blockquote>\n<p>说明：图片来自《菜鸟教程》</p>\n</blockquote>\n<p>Shell 编程支持下面几种运算符</p>\n<ul>\n<li>算数运算符</li>\n<li>关系运算符</li>\n<li>布尔运算符</li>\n<li>字符串运算符</li>\n<li>文件测试运算符</li>\n</ul>\n<h3 id=\"算数运算符\"><a class=\"markdownIt-Anchor\" href=\"#算数运算符\">#</a> 算数运算符</h3>\n<p><img data-src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/4937342.jpg\" alt=\"算数运算符\"></p>\n<p>我以加法运算符做一个简单的示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\">a=3;b=3;</span><br><span class=\"line\">val=`expr $a + $b`</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">输出：Total value : 6</span></span><br><span class=\"line\">echo &quot;Total value : $val</span><br></pre></td></tr></table></figure>\n<h3 id=\"关系运算符\"><a class=\"markdownIt-Anchor\" href=\"#关系运算符\">#</a> 关系运算符</h3>\n<p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>\n<p><img data-src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/64391380.jpg\" alt=\"shell关系运算符\"></p>\n<p>通过一个简单的示例演示关系运算符的使用，下面 shell 程序的作用是当 score=100 的时候输出 A 否则输出 B。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\">score=90;</span><br><span class=\"line\">maxscore=100;</span><br><span class=\"line\">if [ $score -eq $maxscore ]</span><br><span class=\"line\">then</span><br><span class=\"line\">   echo &quot;A&quot;</span><br><span class=\"line\">else</span><br><span class=\"line\">   echo &quot;B&quot;</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">B</span><br></pre></td></tr></table></figure>\n<h3 id=\"逻辑运算符\"><a class=\"markdownIt-Anchor\" href=\"#逻辑运算符\">#</a> 逻辑运算符</h3>\n<p><img data-src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/60545848.jpg\" alt=\"逻辑运算符\"></p>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\">a=$(( 1 &amp;&amp; 0))</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">输出：0；逻辑与运算只有相与的两边都是1，与的结果才是1；否则与的结果是0</span></span><br><span class=\"line\">echo $a;</span><br></pre></td></tr></table></figure>\n<h3 id=\"布尔运算符\"><a class=\"markdownIt-Anchor\" href=\"#布尔运算符\">#</a> 布尔运算符</h3>\n<p><img data-src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/93961425.jpg\" alt=\"布尔运算符\"></p>\n<p>这里就不做演示了，应该挺简单的。</p>\n<h3 id=\"字符串运算符\"><a class=\"markdownIt-Anchor\" href=\"#字符串运算符\">#</a> 字符串运算符</h3>\n<p><img data-src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/309094.jpg\" alt=\" 字符串运算符\"></p>\n<p>简单示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\">a=&quot;abc&quot;;</span><br><span class=\"line\">b=&quot;efg&quot;;</span><br><span class=\"line\">if [ $a = $b ]</span><br><span class=\"line\">then</span><br><span class=\"line\">   echo &quot;a 等于 b&quot;</span><br><span class=\"line\">else</span><br><span class=\"line\">   echo &quot;a 不等于 b&quot;</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a 不等于 b</span><br></pre></td></tr></table></figure>\n<h3 id=\"文件相关运算符\"><a class=\"markdownIt-Anchor\" href=\"#文件相关运算符\">#</a> 文件相关运算符</h3>\n<p><img data-src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/60359774.jpg\" alt=\"文件相关运算符\"></p>\n<p>使用方式很简单，比如我们定义好了一个文件路径 <code>file=&quot;/usr/learnshell/test.sh&quot;</code>  如果我们想判断这个文件是否可读，可以这样 <code>if [ -r $file ]</code>  如果想判断这个文件是否可写，可以这样 <code>-w $file</code> ，是不是很简单。</p>\n<h2 id=\"shell流程控制\"><a class=\"markdownIt-Anchor\" href=\"#shell流程控制\">#</a> shell 流程控制</h2>\n<h3 id=\"if-条件语句\"><a class=\"markdownIt-Anchor\" href=\"#if-条件语句\">#</a> if 条件语句</h3>\n<p>简单的 if else-if else 的条件语句示例</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\">a=3;</span><br><span class=\"line\">b=9;</span><br><span class=\"line\">if [ $a = $b ]</span><br><span class=\"line\">then</span><br><span class=\"line\">   echo &quot;a 等于 b&quot;</span><br><span class=\"line\">elif [ $a &gt; $b ]</span><br><span class=\"line\">then</span><br><span class=\"line\">   echo &quot;a 大于 b&quot;</span><br><span class=\"line\">else</span><br><span class=\"line\">   echo &quot;a 小于 b&quot;</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a 大于 b</span><br></pre></td></tr></table></figure>\n<p>相信大家通过上面的示例就已经掌握了 shell 编程中的 if 条件语句。不过，还要提到的一点是，不同于我们常见的 Java 以及 PHP 中的 if 条件语句，shell  if 条件语句中不能包含空语句也就是什么都不做的语句。</p>\n<h3 id=\"for-循环语句\"><a class=\"markdownIt-Anchor\" href=\"#for-循环语句\">#</a> for 循环语句</h3>\n<p>通过下面三个简单的示例认识 for 循环语句最基本的使用，实际上 for 循环语句的功能比下面你看到的示例展现的要大得多。</p>\n<p><strong>输出当前列表中的数据：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for loop in 1 2 3 4 5</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo &quot;The value is: $loop&quot;</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p><strong>产生 10 个随机数：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\">for i in &#123;0..9&#125;;</span><br><span class=\"line\">do </span><br><span class=\"line\">   echo $RANDOM;</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p><strong>输出 1 到 5:</strong></p>\n<p>通常情况下 shell 变量调用需要加 $, 但是 for 的 (()) 中不需要，下面来看一个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\">for((i=1;i&lt;=5;i++));do</span><br><span class=\"line\">    echo $i;</span><br><span class=\"line\">done;</span><br></pre></td></tr></table></figure>\n<h3 id=\"while-语句\"><a class=\"markdownIt-Anchor\" href=\"#while-语句\">#</a> while 语句</h3>\n<p><strong>基本的 while 循环语句：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\">int=1</span><br><span class=\"line\">while(( $int&lt;=5 ))</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo $int</span><br><span class=\"line\">    let &quot;int++&quot;</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p><strong>while 循环可用于读取键盘信息：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &#x27;按下 &lt;CTRL-D&gt; 退出&#x27;</span><br><span class=\"line\">echo -n &#x27;输入你最喜欢的电影: &#x27;</span><br><span class=\"line\">while read FILM</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo &quot;是的！$FILM 是一个好电影&quot;</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>输出内容:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">按下 &lt;CTRL-D&gt; 退出</span><br><span class=\"line\">输入你最喜欢的电影: 变形金刚</span><br><span class=\"line\">是的！变形金刚 是一个好电影</span><br></pre></td></tr></table></figure>\n<p><strong>无线循环：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while true</span><br><span class=\"line\">do</span><br><span class=\"line\">    command</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h2 id=\"shell-函数\"><a class=\"markdownIt-Anchor\" href=\"#shell-函数\">#</a> shell 函数</h2>\n<h3 id=\"不带参数没有返回值的函数\"><a class=\"markdownIt-Anchor\" href=\"#不带参数没有返回值的函数\">#</a> 不带参数没有返回值的函数</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\">function()&#123;</span><br><span class=\"line\">    echo &quot;这是我的第一个 shell 函数!&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是我的第一个 shell 函数!</span><br></pre></td></tr></table></figure>\n<h3 id=\"有返回值的函数\"><a class=\"markdownIt-Anchor\" href=\"#有返回值的函数\">#</a> 有返回值的函数</h3>\n<p><strong>输入两个数字之后相加并返回结果：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\">funWithReturn()&#123;</span><br><span class=\"line\">    echo &quot;输入第一个数字: &quot;</span><br><span class=\"line\">    read aNum</span><br><span class=\"line\">    echo &quot;输入第二个数字: &quot;</span><br><span class=\"line\">    read anotherNum</span><br><span class=\"line\">    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;</span><br><span class=\"line\">    return $(($aNum+$anotherNum))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">funWithReturn</span><br><span class=\"line\">echo &quot;输入的两个数字之和为 $?&quot;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入第一个数字: </span><br><span class=\"line\">1</span><br><span class=\"line\">输入第二个数字: </span><br><span class=\"line\">2</span><br><span class=\"line\">两个数字分别为 1 和 2 !</span><br><span class=\"line\">输入的两个数字之和为 3</span><br></pre></td></tr></table></figure>\n<h3 id=\"带参数的函数\"><a class=\"markdownIt-Anchor\" href=\"#带参数的函数\">#</a> 带参数的函数</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\">funWithParam()&#123;</span><br><span class=\"line\">    echo &quot;第一个参数为 $1 !&quot;</span><br><span class=\"line\">    echo &quot;第二个参数为 $2 !&quot;</span><br><span class=\"line\">    echo &quot;第十个参数为 $10 !&quot;</span><br><span class=\"line\">    echo &quot;第十个参数为 $&#123;10&#125; !&quot;</span><br><span class=\"line\">    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;</span><br><span class=\"line\">    echo &quot;参数总数有 $# 个!&quot;</span><br><span class=\"line\">    echo &quot;作为一个字符串输出所有参数 $* !&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一个参数为 1 !</span><br><span class=\"line\">第二个参数为 2 !</span><br><span class=\"line\">第十个参数为 10 !</span><br><span class=\"line\">第十个参数为 34 !</span><br><span class=\"line\">第十一个参数为 73 !</span><br><span class=\"line\">参数总数有 11 个!</span><br><span class=\"line\">作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/02/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "url": "http://example.com/2023/07/02/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "title": "Linux学习笔记",
            "date_published": "2023-07-02T10:31:19.000Z",
            "content_html": "<h1 id=\"linux\"><a class=\"markdownIt-Anchor\" href=\"#linux\">#</a> Linux</h1>\n<!-- GFM-TOC -->\n<ul>\n<li><a href=\"#linux\">Linux</a>\n<ul>\n<li><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></li>\n<li><a href=\"#%E4%B8%80%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%A6%82%E5%BF%B5\">一、常用操作以及概念</a>\n<ul>\n<li><a href=\"#%E5%BF%AB%E6%8D%B7%E9%94%AE\">快捷键</a></li>\n<li><a href=\"#%E6%B1%82%E5%8A%A9\">求助</a></li>\n<li><a href=\"#%E5%85%B3%E6%9C%BA\">关机</a></li>\n<li><a href=\"#path\">PATH</a></li>\n<li><a href=\"#sudo\">sudo</a></li>\n<li><a href=\"#%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7\">包管理工具</a></li>\n<li><a href=\"#%E5%8F%91%E8%A1%8C%E7%89%88\">发行版</a></li>\n<li><a href=\"#vim-%E4%B8%89%E4%B8%AA%E6%A8%A1%E5%BC%8F\">VIM 三个模式</a></li>\n<li><a href=\"#gnu\">GNU</a></li>\n<li><a href=\"#%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE\">开源协议</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BA%8C%E7%A3%81%E7%9B%98\">二、磁盘</a>\n<ul>\n<li><a href=\"#%E7%A3%81%E7%9B%98%E6%8E%A5%E5%8F%A3\">磁盘接口</a></li>\n<li><a href=\"#%E7%A3%81%E7%9B%98%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D\">磁盘的文件名</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%B8%89%E5%88%86%E5%8C%BA\">三、分区</a>\n<ul>\n<li><a href=\"#%E5%88%86%E5%8C%BA%E8%A1%A8\">分区表</a></li>\n<li><a href=\"#%E5%BC%80%E6%9C%BA%E6%A3%80%E6%B5%8B%E7%A8%8B%E5%BA%8F\">开机检测程序</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9B%9B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\">四、文件系统</a>\n<ul>\n<li><a href=\"#%E5%88%86%E5%8C%BA%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\">分区与文件系统</a></li>\n<li><a href=\"#%E7%BB%84%E6%88%90\">组成</a></li>\n<li><a href=\"#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96\">文件读取</a></li>\n<li><a href=\"#%E7%A3%81%E7%9B%98%E7%A2%8E%E7%89%87\">磁盘碎片</a></li>\n<li><a href=\"#block\">block</a></li>\n<li><a href=\"#inode\">inode</a></li>\n<li><a href=\"#%E7%9B%AE%E5%BD%95\">目录</a></li>\n<li><a href=\"#%E6%97%A5%E5%BF%97\">日志</a></li>\n<li><a href=\"#%E6%8C%82%E8%BD%BD\">挂载</a></li>\n<li><a href=\"#%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE\">目录配置</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BA%94%E6%96%87%E4%BB%B6\">五、文件</a>\n<ul>\n<li><a href=\"#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7\">文件属性</a></li>\n<li><a href=\"#%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\">文件与目录的基本操作</a></li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90\">修改权限</a></li>\n<li><a href=\"#%E9%BB%98%E8%AE%A4%E6%9D%83%E9%99%90\">默认权限</a></li>\n<li><a href=\"#%E7%9B%AE%E5%BD%95%E7%9A%84%E6%9D%83%E9%99%90\">目录的权限</a></li>\n<li><a href=\"#%E9%93%BE%E6%8E%A5\">链接</a></li>\n<li><a href=\"#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9\">获取文件内容</a></li>\n<li><a href=\"#%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2\">指令与文件搜索</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%85%AD%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%89%93%E5%8C%85\">六、压缩与打包</a>\n<ul>\n<li><a href=\"#%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%90%8D\">压缩文件名</a></li>\n<li><a href=\"#%E5%8E%8B%E7%BC%A9%E6%8C%87%E4%BB%A4\">压缩指令</a></li>\n<li><a href=\"#%E6%89%93%E5%8C%85\">打包</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%B8%83bash\">七、Bash</a>\n<ul>\n<li><a href=\"#%E7%89%B9%E6%80%A7\">特性</a></li>\n<li><a href=\"#%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C\">变量操作</a></li>\n<li><a href=\"#%E6%8C%87%E4%BB%A4%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F\">指令搜索顺序</a></li>\n<li><a href=\"#%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91\">数据流重定向</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%85%AB%E7%AE%A1%E9%81%93%E6%8C%87%E4%BB%A4\">八、管道指令</a>\n<ul>\n<li><a href=\"#%E6%8F%90%E5%8F%96%E6%8C%87%E4%BB%A4\">提取指令</a></li>\n<li><a href=\"#%E6%8E%92%E5%BA%8F%E6%8C%87%E4%BB%A4\">排序指令</a></li>\n<li><a href=\"#%E5%8F%8C%E5%90%91%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91\">双向输出重定向</a></li>\n<li><a href=\"#%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4\">字符转换指令</a></li>\n<li><a href=\"#%E5%88%86%E5%8C%BA%E6%8C%87%E4%BB%A4\">分区指令</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%B9%9D%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\">九、正则表达式</a>\n<ul>\n<li><a href=\"#grep\">grep</a></li>\n<li><a href=\"#printf\">printf</a></li>\n<li><a href=\"#awk\">awk</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%8D%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86\">十、进程管理</a>\n<ul>\n<li><a href=\"#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B\">查看进程</a></li>\n<li><a href=\"#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81\">进程状态</a></li>\n<li><a href=\"#sigchld\">SIGCHLD</a></li>\n<li><a href=\"#wait\">wait()</a></li>\n<li><a href=\"#waitpid\">waitpid()</a></li>\n<li><a href=\"#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B\">孤儿进程</a></li>\n<li><a href=\"#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B\">僵尸进程</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\">参考资料</a><!-- GFM-TOC -->\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>为了便于理解，本文从常用操作和概念开始讲起。虽然已经尽量做到简化，但是涉及到的内容还是有点多。在面试中，Linux 知识点相对于网络和操作系统等知识点而言不是那么重要，只需要重点掌握一些原理和命令即可。为了方便大家准备面试，在此先将一些比较重要的知识点列出来：</p>\n<ul>\n<li>能简单使用 cat，grep，cut 等命令进行一些操作；</li>\n<li>文件系统相关的原理，inode 和 block 等概念，数据恢复；</li>\n<li>硬链接与软链接；</li>\n<li>进程管理相关，僵尸进程与孤儿进程，SIGCHLD 。</li>\n</ul>\n<h2 id=\"一-常用操作以及概念\"><a class=\"markdownIt-Anchor\" href=\"#一-常用操作以及概念\">#</a> 一、常用操作以及概念</h2>\n<h3 id=\"快捷键\"><a class=\"markdownIt-Anchor\" href=\"#快捷键\">#</a> 快捷键</h3>\n<ul>\n<li>Tab：命令和文件名补全；</li>\n<li>Ctrl+C：中断正在运行的程序；</li>\n<li>Ctrl+D：结束键盘输入（End Of File，EOF）</li>\n</ul>\n<h3 id=\"求助\"><a class=\"markdownIt-Anchor\" href=\"#求助\">#</a> 求助</h3>\n<h4 id=\"1-help\"><a class=\"markdownIt-Anchor\" href=\"#1-help\">#</a> 1. --help</h4>\n<p>指令的基本用法与选项介绍。</p>\n<h4 id=\"2-man\"><a class=\"markdownIt-Anchor\" href=\"#2-man\">#</a> 2. man</h4>\n<p>man 是 manual 的缩写，将指令的具体信息显示出来。</p>\n<p>当执行  <code>man date</code>  时，有 DATE (1) 出现，其中的数字代表指令的类型，常用的数字及其类型如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">代号</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td>用户在 shell 环境中可以操作的指令或者可执行文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td>配置文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td>系统管理员可以使用的管理指令</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3-info\"><a class=\"markdownIt-Anchor\" href=\"#3-info\">#</a> 3. info</h4>\n<p>info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以跳转。</p>\n<h4 id=\"4-doc\"><a class=\"markdownIt-Anchor\" href=\"#4-doc\">#</a> 4. doc</h4>\n<p>/usr/share/doc 存放着软件的一整套说明文件。</p>\n<h3 id=\"关机\"><a class=\"markdownIt-Anchor\" href=\"#关机\">#</a> 关机</h3>\n<h4 id=\"1-who\"><a class=\"markdownIt-Anchor\" href=\"#1-who\">#</a> 1. who</h4>\n<p>在关机前需要先使用 who 命令查看有没有其它用户在线。</p>\n<h4 id=\"2-sync\"><a class=\"markdownIt-Anchor\" href=\"#2-sync\">#</a> 2. sync</h4>\n<p>为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行 sync 同步操作。</p>\n<h4 id=\"3-shutdown\"><a class=\"markdownIt-Anchor\" href=\"#3-shutdown\">#</a> 3. shutdown</h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## shutdown [-krhc] 时间 [信息]</span><br><span class=\"line\">-k ： 不会关机，只是发送警告信息，通知所有在线的用户</span><br><span class=\"line\">-r ： 将系统的服务停掉后就重新启动</span><br><span class=\"line\">-h ： 将系统的服务停掉后就立即关机</span><br><span class=\"line\">-c ： 取消已经在进行的 shutdown</span><br></pre></td></tr></table></figure>\n<h3 id=\"path\"><a class=\"markdownIt-Anchor\" href=\"#path\">#</a> PATH</h3>\n<p>可以在环境变量 PATH 中声明可执行文件的路径，路径之间用：分隔。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin</span><br></pre></td></tr></table></figure>\n<h3 id=\"sudo\"><a class=\"markdownIt-Anchor\" href=\"#sudo\">#</a> sudo</h3>\n<p>sudo 允许一般用户使用 root 可执行的命令，不过只有在 /etc/sudoers 配置文件中添加的用户才能使用该指令。</p>\n<h3 id=\"包管理工具\"><a class=\"markdownIt-Anchor\" href=\"#包管理工具\">#</a> 包管理工具</h3>\n<p>RPM 和 DPKG 为最常见的两类软件包管理工具：</p>\n<ul>\n<li>RPM 全称为 Redhat Package Manager，最早由 Red Hat 公司制定实施，随后被 GNU 开源操作系统接受并成为许多 Linux 系统的既定软件标准。YUM 基于 RPM，具有依赖管理和软件升级功能。</li>\n<li>与 RPM 竞争的是基于 Debian 操作系统的 DEB 软件包管理工具 DPKG，全称为 Debian Package，功能方面与 RPM 相似。</li>\n</ul>\n<h3 id=\"发行版\"><a class=\"markdownIt-Anchor\" href=\"#发行版\">#</a> 发行版</h3>\n<p>Linux 发行版是 Linux 内核及各种应用软件的集成版本。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">基于的包管理工具</th>\n<th style=\"text-align:center\">商业发行版</th>\n<th style=\"text-align:center\">社区发行版</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">RPM</td>\n<td style=\"text-align:center\">Red Hat</td>\n<td style=\"text-align:center\">Fedora / CentOS</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DPKG</td>\n<td style=\"text-align:center\">Ubuntu</td>\n<td style=\"text-align:center\">Debian</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"vim-三个模式\"><a class=\"markdownIt-Anchor\" href=\"#vim-三个模式\">#</a> VIM 三个模式</h3>\n<div align=\"center\"> <img data-src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191209002818626.png\"/> </div><br>\n<ul>\n<li>一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容；</li>\n<li>编辑模式（Insert mode）：按下 “i” 等按键之后进入，可以对文本进行编辑；</li>\n<li>指令列模式（Bottom-line mode）：按下 “:” 按键之后进入，用于保存退出等操作。</li>\n</ul>\n<p>在指令列模式下，有以下命令用于离开或者保存文件。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">命令</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">:w</td>\n<td style=\"text-align:center\">写入磁盘</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">:w!</td>\n<td style=\"text-align:center\">当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">:q</td>\n<td style=\"text-align:center\">离开</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">:q!</td>\n<td style=\"text-align:center\">强制离开不保存</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">:wq</td>\n<td style=\"text-align:center\">写入磁盘后离开</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">:wq!</td>\n<td style=\"text-align:center\">强制写入磁盘后离开</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"gnu\"><a class=\"markdownIt-Anchor\" href=\"#gnu\">#</a> GNU</h3>\n<p>GNU 计划，译为革奴计划，它的目标是创建一套完全自由的操作系统，称为 GNU，其内容软件完全以 GPL 方式发布。其中 GPL 全称为 GNU 通用公共许可协议（GNU General Public License），包含了以下内容：</p>\n<ul>\n<li>以任何目的运行此程序的自由；</li>\n<li>再复制的自由；</li>\n<li>改进此程序，并公开发布改进的自由。</li>\n</ul>\n<h3 id=\"开源协议\"><a class=\"markdownIt-Anchor\" href=\"#开源协议\">#</a> 开源协议</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jaG9vc2VhbGljZW5zZS5jb20v\">Choose an open source license</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTEvMDUvaG93X3RvX2Nob29zZV9mcmVlX3NvZnR3YXJlX2xpY2Vuc2VzLmh0bWw=\">如何选择开源许可证？</span></li>\n</ul>\n<h2 id=\"二-磁盘\"><a class=\"markdownIt-Anchor\" href=\"#二-磁盘\">#</a> 二、磁盘</h2>\n<h3 id=\"磁盘接口\"><a class=\"markdownIt-Anchor\" href=\"#磁盘接口\">#</a> 磁盘接口</h3>\n<h4 id=\"1-ide\"><a class=\"markdownIt-Anchor\" href=\"#1-ide\">#</a> 1. IDE</h4>\n<p>IDE（ATA）全称 Advanced Technology Attachment，接口速度最大为 133MB/s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被 SATA 所取代。</p>\n<div align=\"center\"> <img data-src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/924914c0-660c-4e4a-bbc0-1df1146e7516.jpg\" width=\"400\"/> </div><br>\n<h4 id=\"2-sata\"><a class=\"markdownIt-Anchor\" href=\"#2-sata\">#</a> 2. SATA</h4>\n<p>SATA 全称 Serial ATA，也就是使用串口的 ATA 接口，抗干扰性强，且对数据线的长度要求比 ATA 低很多，支持热插拔等功能。SATA-II 的接口速度为 300MB/s，而 SATA-III 标准可达到 600MB/s 的传输速度。SATA 的数据线也比 ATA 的细得多，有利于机箱内的空气流通，整理线材也比较方便。</p>\n<div align=\"center\"> <img data-src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f9f2a16b-4843-44d1-9759-c745772e9bcf.jpg\" width=\"\"/> </div><br>\n<h4 id=\"3-scsi\"><a class=\"markdownIt-Anchor\" href=\"#3-scsi\">#</a> 3. SCSI</h4>\n<p>SCSI 全称是 Small Computer System Interface（小型机系统接口），SCSI 硬盘广为工作站以及个人电脑以及服务器所使用，因此会使用较为先进的技术，如碟片转速 15000rpm 的高转速，且传输时 CPU 占用率较低，但是单价也比相同容量的 ATA 及 SATA 硬盘更加昂贵。</p>\n<div align=\"center\"> <img data-src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f0574025-c514-49f5-a591-6d6a71f271f7.jpg\" width=\"\"/> </div><br>\n<h4 id=\"4-sas\"><a class=\"markdownIt-Anchor\" href=\"#4-sas\">#</a> 4. SAS</h4>\n<p>SAS（Serial Attached SCSI）是新一代的 SCSI 技术，和 SATA 硬盘相同，都是采取序列式技术以获得更高的传输速度，可达到 6Gb/s。此外也通过缩小连接线改善系统内部空间等。</p>\n<div align=\"center\"> <img data-src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6729baa0-57d7-4817-b3aa-518cbccf824c.jpg\" width=\"\"/> </div><br>\n<h3 id=\"磁盘的文件名\"><a class=\"markdownIt-Anchor\" href=\"#磁盘的文件名\">#</a> 磁盘的文件名</h3>\n<p>Linux 中每个硬件都被当做一个文件，包括磁盘。磁盘以磁盘接口类型进行命名，常见磁盘的文件名如下：</p>\n<ul>\n<li>IDE 磁盘：/dev/hd [a-d]</li>\n<li>SATA/SCSI/SAS 磁盘：/dev/sd [a-p]</li>\n</ul>\n<p>其中文件名后面的序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关。</p>\n<h2 id=\"三-分区\"><a class=\"markdownIt-Anchor\" href=\"#三-分区\">#</a> 三、分区</h2>\n<h3 id=\"分区表\"><a class=\"markdownIt-Anchor\" href=\"#分区表\">#</a> 分区表</h3>\n<p>磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表。</p>\n<h4 id=\"1-mbr\"><a class=\"markdownIt-Anchor\" href=\"#1-mbr\">#</a> 1. MBR</h4>\n<p>MBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。</p>\n<p>分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩展分区（Extended）。其中扩展分区只有一个，它使用其它扇区来记录额外的分区表，因此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。</p>\n<p>Linux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如 /dev/sda1。注意，逻辑分区的编号从 5 开始。</p>\n<h4 id=\"2-gpt\"><a class=\"markdownIt-Anchor\" href=\"#2-gpt\">#</a> 2. GPT</h4>\n<p>扇区是磁盘的最小存储单位，旧磁盘的扇区大小通常为 512 bytes，而最新的磁盘支持 4 k。GPT 为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address, LBA），LBA 默认大小为 512 bytes。</p>\n<p>GPT 第 1 个区块记录了主要开机记录（MBR），紧接着是 33 个区块记录分区信息，并把最后的 33 个区块用于对分区信息进行备份。这 33 个区块第一个为 GPT 表头纪录，这个部份纪录了分区表本身的位置与大小和备份分区的位置，同时放置了分区表的校验码 (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，可以使用备份分区进行恢复。</p>\n<p>GPT 没有扩展分区概念，都是主分区，每个 LBA 可以分 4 个分区，因此总共可以分 4 * 32 = 128 个分区。</p>\n<p>MBR 不支持 2.2 TB 以上的硬盘，GPT 则最多支持到 2<sup>33</sup> TB = 8 ZB。</p>\n<div align=\"center\"> <img data-src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/GUID_Partition_Table_Scheme.svg.png\" width=\"400\"/> </div><br>\n<h3 id=\"开机检测程序\"><a class=\"markdownIt-Anchor\" href=\"#开机检测程序\">#</a> 开机检测程序</h3>\n<h4 id=\"1-bios\"><a class=\"markdownIt-Anchor\" href=\"#1-bios\">#</a> 1. BIOS</h4>\n<p>BIOS（Basic Input/Output System，基本输入输出系统），它是一个固件（嵌入在硬件中的软件），BIOS 程序存放在断电后内容不会丢失的只读内存中。</p>\n<div align=\"center\"> <img data-src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/50831a6f-2777-46ea-a571-29f23c85cc21.jpg\"/> </div><br>\n<p>BIOS 是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁盘第一个扇区的主要开机记录（MBR），由主要开机记录（MBR）执行其中的开机管理程序，这个开机管理程序会加载操作系统的核心文件。</p>\n<p>主要开机记录（MBR）中的开机管理程序提供以下功能：选单、载入核心文件以及转交其它开机管理程序。转交这个功能可以用来实现多重引导，只需要将另一个操作系统的开机管理程序安装在其它分区的启动扇区上，在启动开机管理程序时，就可以通过选单选择启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统。</p>\n<p>下图中，第一扇区的主要开机记录（MBR）中的开机管理程序提供了两个选单：M1、M2，M1 指向了 Windows 操作系统，而 M2 指向其它分区的启动扇区，里面包含了另外一个开机管理程序，提供了一个指向 Linux 的选单。</p>\n<div align=\"center\"> <img data-src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f900f266-a323-42b2-bc43-218fdb8811a8.jpg\" width=\"600\"/> </div><br>\n<p>安装多重引导，最好先安装 Windows 再安装 Linux。因为安装 Windows 时会覆盖掉主要开机记录（MBR），而 Linux 可以选择将开机管理程序安装在主要开机记录（MBR）或者其它分区的启动扇区，并且可以设置开机管理程序的选单。</p>\n<h4 id=\"2-uefi\"><a class=\"markdownIt-Anchor\" href=\"#2-uefi\">#</a> 2. UEFI</h4>\n<p>BIOS 不可以读取 GPT 分区表，而 UEFI 可以。</p>\n<h2 id=\"四-文件系统\"><a class=\"markdownIt-Anchor\" href=\"#四-文件系统\">#</a> 四、文件系统</h2>\n<h3 id=\"分区与文件系统\"><a class=\"markdownIt-Anchor\" href=\"#分区与文件系统\">#</a> 分区与文件系统</h3>\n<p>对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统。</p>\n<h3 id=\"组成\"><a class=\"markdownIt-Anchor\" href=\"#组成\">#</a> 组成</h3>\n<p>最主要的几个组成部分如下：</p>\n<ul>\n<li>inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；</li>\n<li>block：记录文件的内容，文件太大时，会占用多个 block。</li>\n</ul>\n<p>除此之外还包括：</p>\n<ul>\n<li>superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</li>\n<li>block bitmap：记录 block 是否被使用的位图。</li>\n</ul>\n<div align=\"center\"> <img data-src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/BSD_disk.png\" width=\"800\"/> </div><br>\n<h3 id=\"文件读取\"><a class=\"markdownIt-Anchor\" href=\"#文件读取\">#</a> 文件读取</h3>\n<p>对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。</p>\n<div align=\"center\"> <img data-src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/12a65cc6-20e0-4706-9fe6-3ba49413d7f6.png\" width=\"500px\"> </div><br>\n<p>而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。</p>\n<div align=\"center\"> <img data-src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5b718e86-7102-4bb6-8ca5-d1dd791530c5.png\" width=\"500px\"> </div><br>\n<h3 id=\"磁盘碎片\"><a class=\"markdownIt-Anchor\" href=\"#磁盘碎片\">#</a> 磁盘碎片</h3>\n<p>指一个文件内容所在的 block 过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能。</p>\n<h3 id=\"block\"><a class=\"markdownIt-Anchor\" href=\"#block\">#</a> block</h3>\n<p>在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">大小</th>\n<th style=\"text-align:center\">1KB</th>\n<th style=\"text-align:center\">2KB</th>\n<th style=\"text-align:center\">4KB</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">最大单一文件</td>\n<td style=\"text-align:center\">16GB</td>\n<td style=\"text-align:center\">256GB</td>\n<td style=\"text-align:center\">2TB</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">最大文件系统</td>\n<td style=\"text-align:center\">2TB</td>\n<td style=\"text-align:center\">8TB</td>\n<td style=\"text-align:center\">16TB</td>\n</tr>\n</tbody>\n</table>\n<p>一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。</p>\n<h3 id=\"inode\"><a class=\"markdownIt-Anchor\" href=\"#inode\">#</a> inode</h3>\n<p>inode 具体包含以下信息：</p>\n<ul>\n<li>权限 (read/write/excute)；</li>\n<li>拥有者与群组 (owner/group)；</li>\n<li>容量；</li>\n<li>建立或状态改变的时间 (ctime)；</li>\n<li>最近读取时间 (atime)；</li>\n<li>最近修改时间 (mtime)；</li>\n<li>定义文件特性的旗标 (flag)，如 SetUID…；</li>\n<li>该文件真正内容的指向 (pointer)。</li>\n</ul>\n<p>inode 具有以下特点：</p>\n<ul>\n<li>每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)；</li>\n<li>每个文件都仅会占用一个 inode。</li>\n</ul>\n<p>inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用让 inode 记录的引用 block 块记录引用信息。</p>\n<div align=\"center\"> <img data-src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/inode_with_signatures.jpg\" width=\"600\"/> </div><br>\n<h3 id=\"目录\"><a class=\"markdownIt-Anchor\" href=\"#目录\">#</a> 目录</h3>\n<p>建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。</p>\n<p>可以看到文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的写权限有关。</p>\n<h3 id=\"日志\"><a class=\"markdownIt-Anchor\" href=\"#日志\">#</a> 日志</h3>\n<p>如果突然断电，那么文件系统会发生错误，例如断电前只修改了 block bitmap，而还没有将数据真正写入 block 中。</p>\n<p>ext3/ext4 文件系统引入了日志功能，可以利用日志来修复文件系统。</p>\n<h3 id=\"挂载\"><a class=\"markdownIt-Anchor\" href=\"#挂载\">#</a> 挂载</h3>\n<p>挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据。</p>\n<h3 id=\"目录配置\"><a class=\"markdownIt-Anchor\" href=\"#目录配置\">#</a> 目录配置</h3>\n<p>为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下：</p>\n<ul>\n<li>/ (root, 根目录)</li>\n<li>/usr (unix software resource)：所有系统默认软件都会安装到这个目录；</li>\n<li>/var (variable)：存放系统或程序运行过程中的数据文件。</li>\n</ul>\n<div align=\"center\"> <img data-src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/linux-filesystem.png\" width=\"\"/> </div><br>\n<h2 id=\"五-文件\"><a class=\"markdownIt-Anchor\" href=\"#五-文件\">#</a> 五、文件</h2>\n<h3 id=\"文件属性\"><a class=\"markdownIt-Anchor\" href=\"#文件属性\">#</a> 文件属性</h3>\n<p>用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。</p>\n<p>使用 ls 查看一个文件时，会显示一个文件的信息，例如  <code>drwxr-xr-x 3 root root 17 May 6 00:14 .config</code> ，对这个信息的解释如下：</p>\n<ul>\n<li>drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段</li>\n<li>3：链接数</li>\n<li>root：文件拥有者</li>\n<li>root：所属群组</li>\n<li>17：文件大小</li>\n<li>May 6 00:14：文件最后被修改的时间</li>\n<li>.config：文件名</li>\n</ul>\n<p>常见的文件类型及其含义有：</p>\n<ul>\n<li>d：目录</li>\n<li>-：文件</li>\n<li>l：链接文件</li>\n</ul>\n<p>9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。</p>\n<p>文件时间有以下三种：</p>\n<ul>\n<li>modification time (mtime)：文件的内容更新就会更新；</li>\n<li>status time (ctime)：文件的状态（权限、属性）更新就会更新；</li>\n<li>access time (atime)：读取文件时就会更新。</li>\n</ul>\n<h3 id=\"文件与目录的基本操作\"><a class=\"markdownIt-Anchor\" href=\"#文件与目录的基本操作\">#</a> 文件与目录的基本操作</h3>\n<h4 id=\"1-ls\"><a class=\"markdownIt-Anchor\" href=\"#1-ls\">#</a> 1. ls</h4>\n<p>列出文件或者目录的信息，目录的信息就是其中包含的文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## ls [-aAdfFhilnrRSt] file|dir</span><br><span class=\"line\">-a ：列出全部的文件</span><br><span class=\"line\">-d ：仅列出目录本身</span><br><span class=\"line\">-l ：以长数据串行列出，包含文件的属性与权限等等数据</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-cd\"><a class=\"markdownIt-Anchor\" href=\"#2-cd\">#</a> 2. cd</h4>\n<p>更换当前目录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd [相对路径或绝对路径]</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-mkdir\"><a class=\"markdownIt-Anchor\" href=\"#3-mkdir\">#</a> 3. mkdir</h4>\n<p>创建目录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## mkdir [-mp] 目录名称</span><br><span class=\"line\">-m ：配置目录权限</span><br><span class=\"line\">-p ：递归创建目录</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-rmdir\"><a class=\"markdownIt-Anchor\" href=\"#4-rmdir\">#</a> 4. rmdir</h4>\n<p>删除目录，目录必须为空。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rmdir [-p] 目录名称</span><br><span class=\"line\">-p ：递归删除目录</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-touch\"><a class=\"markdownIt-Anchor\" href=\"#5-touch\">#</a> 5. touch</h4>\n<p>更新文件时间或者建立新文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## touch [-acdmt] filename</span><br><span class=\"line\">-a ： 更新 atime</span><br><span class=\"line\">-c ： 更新 ctime，若该文件不存在则不建立新文件</span><br><span class=\"line\">-m ： 更新 mtime</span><br><span class=\"line\">-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=&quot;日期或时间&quot;</span><br><span class=\"line\">-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-cp\"><a class=\"markdownIt-Anchor\" href=\"#6-cp\">#</a> 6. cp</h4>\n<p>复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp [-adfilprsu] source destination</span><br><span class=\"line\">-a ：相当于 -dr --preserve=all</span><br><span class=\"line\">-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身</span><br><span class=\"line\">-i ：若目标文件已经存在时，在覆盖前会先询问</span><br><span class=\"line\">-p ：连同文件的属性一起复制过去</span><br><span class=\"line\">-r ：递归复制</span><br><span class=\"line\">-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制</span><br><span class=\"line\">--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了</span><br></pre></td></tr></table></figure>\n<h4 id=\"7-rm\"><a class=\"markdownIt-Anchor\" href=\"#7-rm\">#</a> 7. rm</h4>\n<p>删除文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## rm [-fir] 文件或目录</span><br><span class=\"line\">-r ：递归删除</span><br></pre></td></tr></table></figure>\n<h4 id=\"8-mv\"><a class=\"markdownIt-Anchor\" href=\"#8-mv\">#</a> 8. mv</h4>\n<p>移动文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## mv [-fiu] source destination</span><br><span class=\"line\">## mv [options] source1 source2 source3 .... directory</span><br><span class=\"line\">-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</span><br></pre></td></tr></table></figure>\n<h3 id=\"修改权限\"><a class=\"markdownIt-Anchor\" href=\"#修改权限\">#</a> 修改权限</h3>\n<p>可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## chmod [-R] xyz dirname/filename</span><br></pre></td></tr></table></figure>\n<p>示例：将 .bashrc 文件的权限修改为 -rwxr-xr–。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## chmod 754 .bashrc</span><br></pre></td></tr></table></figure>\n<p>也可以使用符号来设定权限。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## chmod [ugoa]  [+-=] [rwx] dirname/filename</span><br><span class=\"line\">- u：拥有者</span><br><span class=\"line\">- g：所属群组</span><br><span class=\"line\">- o：其他人</span><br><span class=\"line\">- a：所有人</span><br><span class=\"line\">- +：添加权限</span><br><span class=\"line\">- -：移除权限</span><br><span class=\"line\">- =：设定权限</span><br></pre></td></tr></table></figure>\n<p>示例：为 .bashrc 文件的所有用户添加写权限。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## chmod a+w .bashrc</span><br></pre></td></tr></table></figure>\n<h3 id=\"默认权限\"><a class=\"markdownIt-Anchor\" href=\"#默认权限\">#</a> 默认权限</h3>\n<ul>\n<li>文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。</li>\n<li>目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。</li>\n</ul>\n<p>可以通过 umask 设置或者查看默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r–。</p>\n<h3 id=\"目录的权限\"><a class=\"markdownIt-Anchor\" href=\"#目录的权限\">#</a> 目录的权限</h3>\n<p>文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。</p>\n<p>目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。</p>\n<h3 id=\"链接\"><a class=\"markdownIt-Anchor\" href=\"#链接\">#</a> 链接</h3>\n<div align=\"center\"> <img data-src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1e46fd03-0cda-4d60-9b1c-0c256edaf6b2.png\" width=\"450px\"> </div><br>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## ln [-sf] source_filename dist_filename</span><br><span class=\"line\">-s ：默认是实体链接，加 -s 为符号链接</span><br><span class=\"line\">-f ：如果目标文件存在时，先删除目标文件</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-实体链接\"><a class=\"markdownIt-Anchor\" href=\"#1-实体链接\">#</a> 1. 实体链接</h4>\n<p>在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。</p>\n<p>删除任意一个条目，文件还是存在，只要引用数量不为 0。</p>\n<p>有以下限制：不能跨越文件系统、不能对目录进行链接。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## ln /etc/crontab .</span><br><span class=\"line\">## ll -i /etc/crontab crontab</span><br><span class=\"line\">34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab</span><br><span class=\"line\">34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-符号链接\"><a class=\"markdownIt-Anchor\" href=\"#2-符号链接\">#</a> 2. 符号链接</h4>\n<p>符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。</p>\n<p>当源文件被删除了，链接文件就打不开了。</p>\n<p>因为记录的是路径，所以可以为目录建立符号链接。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## ll -i /etc/crontab /root/crontab2</span><br><span class=\"line\">34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab</span><br><span class=\"line\">53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取文件内容\"><a class=\"markdownIt-Anchor\" href=\"#获取文件内容\">#</a> 获取文件内容</h3>\n<h4 id=\"1-cat\"><a class=\"markdownIt-Anchor\" href=\"#1-cat\">#</a> 1. cat</h4>\n<p>取得文件内容。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## cat [-AbEnTv] filename</span><br><span class=\"line\">-n ：打印出行号，连同空白行也会有行号，-b 不会</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-tac\"><a class=\"markdownIt-Anchor\" href=\"#2-tac\">#</a> 2. tac</h4>\n<p>是 cat 的反向操作，从最后一行开始打印。</p>\n<h4 id=\"3-more\"><a class=\"markdownIt-Anchor\" href=\"#3-more\">#</a> 3. more</h4>\n<p>和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。</p>\n<h4 id=\"4-less\"><a class=\"markdownIt-Anchor\" href=\"#4-less\">#</a> 4. less</h4>\n<p>和 more 类似，但是多了一个向前翻页的功能。</p>\n<h4 id=\"5-head\"><a class=\"markdownIt-Anchor\" href=\"#5-head\">#</a> 5. head</h4>\n<p>取得文件前几行。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## head [-n number] filename</span><br><span class=\"line\">-n ：后面接数字，代表显示几行的意思</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-tail\"><a class=\"markdownIt-Anchor\" href=\"#6-tail\">#</a> 6. tail</h4>\n<p>是 head 的反向操作，只是取得是后几行。</p>\n<h4 id=\"7-od\"><a class=\"markdownIt-Anchor\" href=\"#7-od\">#</a> 7. od</h4>\n<p>以字符或者十六进制的形式显示二进制文件。</p>\n<h3 id=\"指令与文件搜索\"><a class=\"markdownIt-Anchor\" href=\"#指令与文件搜索\">#</a> 指令与文件搜索</h3>\n<h4 id=\"1-which\"><a class=\"markdownIt-Anchor\" href=\"#1-which\">#</a> 1. which</h4>\n<p>指令搜索。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## which [-a] command</span><br><span class=\"line\">-a ：将所有指令列出，而不是只列第一个</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-whereis\"><a class=\"markdownIt-Anchor\" href=\"#2-whereis\">#</a> 2. whereis</h4>\n<p>文件搜索。速度比较快，因为它只搜索几个特定的目录。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## whereis [-bmsu] dirname/filename</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-locate\"><a class=\"markdownIt-Anchor\" href=\"#3-locate\">#</a> 3. locate</h4>\n<p>文件搜索。可以用关键字或者正则表达式进行搜索。</p>\n<p>locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## locate [-ir] keyword</span><br><span class=\"line\">-r：正则表达式</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-find\"><a class=\"markdownIt-Anchor\" href=\"#4-find\">#</a> 4. find</h4>\n<p>文件搜索。可以使用文件的属性和权限进行搜索。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## find [basedir] [option]</span><br><span class=\"line\">example: find . -name &quot;shadow*&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>① 与时间有关的选项</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-mtime  n ：列出在 n 天前的那一天修改过内容的文件</span><br><span class=\"line\">-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件</span><br><span class=\"line\">-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件</span><br><span class=\"line\">-newer file ： 列出比 file 更新的文件</span><br></pre></td></tr></table></figure>\n<p>+4、4 和 -4 的指示的时间范围如下：</p>\n<div align=\"center\"> <img data-src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/658fc5e7-79c0-4247-9445-d69bf194c539.png\" width=\"\"/> </div><br>\n<p><strong>② 与文件拥有者和所属群组有关的选项</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-uid n</span><br><span class=\"line\">-gid n</span><br><span class=\"line\">-user name</span><br><span class=\"line\">-group name</span><br><span class=\"line\">-nouser ：搜索拥有者不存在 /etc/passwd 的文件</span><br><span class=\"line\">-nogroup：搜索所属群组不存在于 /etc/group 的文件</span><br></pre></td></tr></table></figure>\n<p><strong>③ 与文件权限和名称有关的选项</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-name filename</span><br><span class=\"line\">-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k</span><br><span class=\"line\">-type TYPE</span><br><span class=\"line\">-perm mode  ：搜索权限等于 mode 的文件</span><br><span class=\"line\">-perm -mode ：搜索权限包含 mode 的文件</span><br><span class=\"line\">-perm /mode ：搜索权限包含任一 mode 的文件</span><br></pre></td></tr></table></figure>\n<h2 id=\"六-压缩与打包\"><a class=\"markdownIt-Anchor\" href=\"#六-压缩与打包\">#</a> 六、压缩与打包</h2>\n<h3 id=\"压缩文件名\"><a class=\"markdownIt-Anchor\" href=\"#压缩文件名\">#</a> 压缩文件名</h3>\n<p>Linux 底下有很多压缩文件名，常见的如下：</p>\n<table>\n<thead>\n<tr>\n<th>扩展名</th>\n<th>压缩程序</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*.Z</td>\n<td>compress</td>\n</tr>\n<tr>\n<td>*.zip</td>\n<td>zip</td>\n</tr>\n<tr>\n<td>*.gz</td>\n<td>gzip</td>\n</tr>\n<tr>\n<td>*.bz2</td>\n<td>bzip2</td>\n</tr>\n<tr>\n<td>*.xz</td>\n<td>xz</td>\n</tr>\n<tr>\n<td>*.tar</td>\n<td>tar 程序打包的数据，没有经过压缩</td>\n</tr>\n<tr>\n<td>*.tar.gz</td>\n<td>tar 程序打包的文件，经过 gzip 的压缩</td>\n</tr>\n<tr>\n<td>*.tar.bz2</td>\n<td>tar 程序打包的文件，经过 bzip2 的压缩</td>\n</tr>\n<tr>\n<td>*.tar.xz</td>\n<td>tar 程序打包的文件，经过 xz 的压缩</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"压缩指令\"><a class=\"markdownIt-Anchor\" href=\"#压缩指令\">#</a> 压缩指令</h3>\n<h4 id=\"1-gzip\"><a class=\"markdownIt-Anchor\" href=\"#1-gzip\">#</a> 1. gzip</h4>\n<p>gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。</p>\n<p>经过 gzip 压缩过，源文件就不存在了。</p>\n<p>有 9 个不同的压缩等级可以使用。</p>\n<p>可以使用 zcat、zmore、zless 来读取压缩文件的内容。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gzip [-cdtv#] filename</span><br><span class=\"line\">-c ：将压缩的数据输出到屏幕上</span><br><span class=\"line\">-d ：解压缩</span><br><span class=\"line\">-t ：检验压缩文件是否出错</span><br><span class=\"line\">-v ：显示压缩比等信息</span><br><span class=\"line\">-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-bzip2\"><a class=\"markdownIt-Anchor\" href=\"#2-bzip2\">#</a> 2. bzip2</h4>\n<p>提供比 gzip 更高的压缩比。</p>\n<p>查看命令：bzcat、bzmore、bzless、bzgrep。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ bzip2 [-cdkzv#] filename</span><br><span class=\"line\">-k ：保留源文件</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-xz\"><a class=\"markdownIt-Anchor\" href=\"#3-xz\">#</a> 3. xz</h4>\n<p>提供比 bzip2 更佳的压缩比。</p>\n<p>可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。</p>\n<p>查看命令：xzcat、xzmore、xzless、xzgrep。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ xz [-dtlkc#] filename</span><br></pre></td></tr></table></figure>\n<h3 id=\"打包\"><a class=\"markdownIt-Anchor\" href=\"#打包\">#</a> 打包</h3>\n<p>压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  ==打包压缩</span><br><span class=\"line\">$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看</span><br><span class=\"line\">$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩</span><br><span class=\"line\">-z ：使用 zip；</span><br><span class=\"line\">-j ：使用 bzip2；</span><br><span class=\"line\">-J ：使用 xz；</span><br><span class=\"line\">-c ：新建打包文件；</span><br><span class=\"line\">-t ：查看打包文件里面有哪些文件；</span><br><span class=\"line\">-x ：解打包或解压缩的功能；</span><br><span class=\"line\">-v ：在压缩/解压缩的过程中，显示正在处理的文件名；</span><br><span class=\"line\">-f : filename：要处理的文件；</span><br><span class=\"line\">-C 目录 ： 在特定目录解压缩。</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">使用方式</th>\n<th>命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">打包压缩</td>\n<td>tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">查 看</td>\n<td>tar -jtv -f filename.tar.bz2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">解压缩</td>\n<td>tar -jxv -f filename.tar.bz2 -C 要解压缩的目录</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"七-bash\"><a class=\"markdownIt-Anchor\" href=\"#七-bash\">#</a> 七、Bash</h2>\n<p>可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种。</p>\n<h3 id=\"特性\"><a class=\"markdownIt-Anchor\" href=\"#特性\">#</a> 特性</h3>\n<ul>\n<li>命令历史：记录使用过的命令</li>\n<li>命令与文件补全：快捷键：tab</li>\n<li>命名别名：例如 ll 是 ls -al 的别名</li>\n<li>shell scripts</li>\n<li>通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件</li>\n</ul>\n<h3 id=\"变量操作\"><a class=\"markdownIt-Anchor\" href=\"#变量操作\">#</a> 变量操作</h3>\n<p>对一个变量赋值直接使用 =。</p>\n<p>对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式；</p>\n<p>输出变量使用 echo 命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ x=abc</span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"variable\">$x</span></span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;x&#125;</span></span><br></pre></td></tr></table></figure>\n<p>变量内容如果有空格，必须使用双引号或者单引号。</p>\n<ul>\n<li>双引号内的特殊字符可以保留原本特性，例如 x=“lang is $LANG”，则 x 的值为 lang is zh_TW.UTF-8；</li>\n<li>单引号内的特殊字符就是特殊字符本身，例如 x=‘lang is $LANG’，则 x 的值为 lang is $LANG。</li>\n</ul>\n<p>可以使用 `指令` 或者 $(指令) 的方式将指令的执行结果赋值给变量。例如 version=$(uname -r)，则 version 的值为 4.15.0-22-generic。</p>\n<p>可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。</p>\n<p>Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ declare [-aixr] variable</span><br><span class=\"line\">-a ： 定义为数组类型</span><br><span class=\"line\">-i ： 定义为整数类型</span><br><span class=\"line\">-x ： 定义为环境变量</span><br><span class=\"line\">-r ： 定义为 readonly 类型</span><br></pre></td></tr></table></figure>\n<p>使用 [ ] 来对数组进行索引操作：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ array[1]=a</span><br><span class=\"line\">$ array[2]=b</span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;array[1]&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"指令搜索顺序\"><a class=\"markdownIt-Anchor\" href=\"#指令搜索顺序\">#</a> 指令搜索顺序</h3>\n<ul>\n<li>以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ；</li>\n<li>由别名找到该指令来执行；</li>\n<li>由 Bash 内置的指令来执行；</li>\n<li>按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行。</li>\n</ul>\n<h3 id=\"数据流重定向\"><a class=\"markdownIt-Anchor\" href=\"#数据流重定向\">#</a> 数据流重定向</h3>\n<p>重定向指的是使用文件代替标准输入、标准输出和标准错误输出。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">代码</th>\n<th style=\"text-align:center\">运算符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">标准输入 (stdin)</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">&lt; 或 &lt;&lt;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">标准输出 (stdout)</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">&gt; 或 &gt;&gt;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">标准错误输出 (stderr)</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2&gt; 或 2&gt;&gt;</td>\n</tr>\n</tbody>\n</table>\n<p>其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。</p>\n<p>可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。</p>\n<p>如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ find /home -name .bashrc &gt; list 2&gt;&amp;1</span><br></pre></td></tr></table></figure>\n<h2 id=\"八-管道指令\"><a class=\"markdownIt-Anchor\" href=\"#八-管道指令\">#</a> 八、管道指令</h2>\n<p>管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。</p>\n<p>在命令之间使用 | 分隔各个管道命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">ls</span> -al /etc | less</span><br></pre></td></tr></table></figure>\n<h3 id=\"提取指令\"><a class=\"markdownIt-Anchor\" href=\"#提取指令\">#</a> 提取指令</h3>\n<p>cut 对数据进行切分，取出想要的部分。</p>\n<p>切分过程一行一行地进行。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cut</span><br><span class=\"line\">-d ：分隔符</span><br><span class=\"line\">-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间</span><br><span class=\"line\">-c ：以字符为单位取出区间</span><br></pre></td></tr></table></figure>\n<p>示例 1：last 显示登入者的信息，取出用户名。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ last</span><br><span class=\"line\">root pts/1 192.168.201.101 Sat Feb 7 12:35 still logged in</span><br><span class=\"line\">root pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)</span><br><span class=\"line\">root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)</span><br><span class=\"line\"></span><br><span class=\"line\">$ last | cut -d &#x27; &#x27; -f 1</span><br></pre></td></tr></table></figure>\n<p>示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ export</span><br><span class=\"line\">declare -x HISTCONTROL=&quot;ignoredups&quot;</span><br><span class=\"line\">declare -x HISTSIZE=&quot;1000&quot;</span><br><span class=\"line\">declare -x HOME=&quot;/home/dmtsai&quot;</span><br><span class=\"line\">declare -x HOSTNAME=&quot;study.centos.vbird&quot;</span><br><span class=\"line\">.....(其他省略).....</span><br><span class=\"line\"></span><br><span class=\"line\">$ export | cut -c 12-</span><br></pre></td></tr></table></figure>\n<h3 id=\"排序指令\"><a class=\"markdownIt-Anchor\" href=\"#排序指令\">#</a> 排序指令</h3>\n<p><strong>sort</strong>   用于排序。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sort [-fbMnrtuk] [file or stdin]</span><br><span class=\"line\">-f ：忽略大小写</span><br><span class=\"line\">-b ：忽略最前面的空格</span><br><span class=\"line\">-M ：以月份的名字来排序，例如 JAN，DEC</span><br><span class=\"line\">-n ：使用数字</span><br><span class=\"line\">-r ：反向排序</span><br><span class=\"line\">-u ：相当于 unique，重复的内容只出现一次</span><br><span class=\"line\">-t ：分隔符，默认为 tab</span><br><span class=\"line\">-k ：指定排序的区间</span><br></pre></td></tr></table></figure>\n<p>示例：/etc/passwd 文件内容以：来分隔，要求以第三列进行排序。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat /etc/passwd | sort -t &#x27;:&#x27; -k 3</span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br><span class=\"line\">dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash</span><br><span class=\"line\">alex:x:1001:1002::/home/alex:/bin/bash</span><br><span class=\"line\">arod:x:1002:1003::/home/arod:/bin/bash</span><br></pre></td></tr></table></figure>\n<p><strong>uniq</strong>   可以将重复的数据只取一个。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ uniq [-ic]</span><br><span class=\"line\">-i ：忽略大小写</span><br><span class=\"line\">-c ：进行计数</span><br></pre></td></tr></table></figure>\n<p>示例：取得每个人的登录总次数</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ last | cut -d &#x27; &#x27; -f 1 | sort | uniq -c</span><br><span class=\"line\">1</span><br><span class=\"line\">6 (unknown</span><br><span class=\"line\">47 dmtsai</span><br><span class=\"line\">4 reboot</span><br><span class=\"line\">7 root</span><br><span class=\"line\">1 wtmp</span><br></pre></td></tr></table></figure>\n<h3 id=\"双向输出重定向\"><a class=\"markdownIt-Anchor\" href=\"#双向输出重定向\">#</a> 双向输出重定向</h3>\n<p>输出重定向会将输出内容重定向到文件中，而   <strong>tee</strong>   不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tee [-a] file</span><br></pre></td></tr></table></figure>\n<h3 id=\"字符转换指令\"><a class=\"markdownIt-Anchor\" href=\"#字符转换指令\">#</a> 字符转换指令</h3>\n<p><strong>tr</strong>   用来删除一行中的字符，或者对字符进行替换。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tr [-ds] SET1 ...</span><br><span class=\"line\">-d ： 删除行中 SET1 这个字符串</span><br></pre></td></tr></table></figure>\n<p>示例，将 last 输出的信息所有小写转换为大写。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ last | tr &#x27;[a-z]&#x27; &#x27;[A-Z]&#x27;</span><br></pre></td></tr></table></figure>\n<p><strong>col</strong>   将 tab 字符转为空格字符。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ col [-xb]</span><br><span class=\"line\">-x ： 将 tab 键转换成对等的空格键</span><br></pre></td></tr></table></figure>\n<p><strong>expand</strong>   将 tab 转换一定数量的空格，默认是 8 个。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ expand [-t] file</span><br><span class=\"line\">-t ：tab 转为空格的数量</span><br></pre></td></tr></table></figure>\n<p><strong>join</strong>   将有相同数据的那一行合并在一起。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ join [-ti12] file1 file2</span><br><span class=\"line\">-t ：分隔符，默认为空格</span><br><span class=\"line\">-i ：忽略大小写的差异</span><br><span class=\"line\">-1 ：第一个文件所用的比较字段</span><br><span class=\"line\">-2 ：第二个文件所用的比较字段</span><br></pre></td></tr></table></figure>\n<p><strong>paste</strong>   直接将两行粘贴在一起。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ paste [-d] file1 file2</span><br><span class=\"line\">-d ：分隔符，默认为 tab</span><br></pre></td></tr></table></figure>\n<h3 id=\"分区指令\"><a class=\"markdownIt-Anchor\" href=\"#分区指令\">#</a> 分区指令</h3>\n<p><strong>split</strong>   将一个文件划分成多个文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ split [-bl] file PREFIX</span><br><span class=\"line\">-b ：以大小来进行分区，可加单位，例如 b, k, m 等</span><br><span class=\"line\">-l ：以行数来进行分区。</span><br><span class=\"line\">- PREFIX ：分区文件的前导名称</span><br></pre></td></tr></table></figure>\n<h2 id=\"九-正则表达式\"><a class=\"markdownIt-Anchor\" href=\"#九-正则表达式\">#</a> 九、正则表达式</h2>\n<h3 id=\"grep\"><a class=\"markdownIt-Anchor\" href=\"#grep\">#</a> grep</h3>\n<p>g/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ grep [-acinv] [--color=auto] 搜寻字符串 filename</span><br><span class=\"line\">-c ： 统计匹配到行的个数</span><br><span class=\"line\">-i ： 忽略大小写</span><br><span class=\"line\">-n ： 输出行号</span><br><span class=\"line\">-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行</span><br><span class=\"line\">--color=auto ：找到的关键字加颜色显示</span><br></pre></td></tr></table></figure>\n<p>示例：把含有 the 字符串的行提取出来（注意默认会有 --color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串）</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ grep -n &#x27;the&#x27; regular_express.txt</span><br><span class=\"line\">8:I can&#x27;t finish the test.</span><br><span class=\"line\">12:the symbol &#x27;*&#x27; is represented as start.</span><br><span class=\"line\">15:You are the best is mean you are the no. 1.</span><br><span class=\"line\">16:The world Happy is the same with &quot;glad&quot;.</span><br><span class=\"line\">18:google is the best tools for search keyword</span><br></pre></td></tr></table></figure>\n<p>示例：正则表达式 a {m,n} 用来匹配字符 a m~n 次，这里需要将 { 和 } 进行转义，因为它们在 shell 是有特殊意义的。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ grep -n &#x27;a\\&#123;2,5\\&#125;&#x27; regular_express.txt</span><br></pre></td></tr></table></figure>\n<h3 id=\"printf\"><a class=\"markdownIt-Anchor\" href=\"#printf\">#</a> printf</h3>\n<p>用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ printf &#x27;%10s %5i %5i %5i %8.2f \\n&#x27; $(cat printf.txt)</span><br><span class=\"line\">    DmTsai    80    60    92    77.33</span><br><span class=\"line\">     VBird    75    55    80    70.00</span><br><span class=\"line\">       Ken    60    90    70    73.33</span><br></pre></td></tr></table></figure>\n<h3 id=\"awk\"><a class=\"markdownIt-Anchor\" href=\"#awk\">#</a> awk</h3>\n<p>是由 Alfred Aho，Peter Weinberger 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。</p>\n<p>awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。</p>\n<p>示例：取出最近五个登录用户的用户名和 IP。首先用 last -n 5 取出用最近五个登录用户的所有信息，可以看到用户名和 IP 分别在第 1 列和第 3 列，我们用 $1 和 $3 就能取出这两个字段，然后用 print 进行打印。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ last -n 5</span><br><span class=\"line\">dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in</span><br><span class=\"line\">dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)</span><br><span class=\"line\">dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)</span><br><span class=\"line\">dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)</span><br><span class=\"line\">dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ last -n 5 | awk &#x27;&#123;print $1 &quot;\\t&quot; $3&#125;&#x27;</span><br><span class=\"line\">dmtsai   192.168.1.100</span><br><span class=\"line\">dmtsai   192.168.1.100</span><br><span class=\"line\">dmtsai   192.168.1.100</span><br><span class=\"line\">dmtsai   192.168.1.100</span><br><span class=\"line\">dmtsai   Fri</span><br></pre></td></tr></table></figure>\n<p>可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ awk &#x27;条件类型 1 &#123;动作 1&#125; 条件类型 2 &#123;动作 2&#125; ...&#x27; filename</span><br></pre></td></tr></table></figure>\n<p>示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat /etc/passwd | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; $3 &lt; 10 &#123;print $1 &quot;\\t &quot; $3&#125;&#x27;</span><br><span class=\"line\">root 0</span><br><span class=\"line\">bin 1</span><br><span class=\"line\">daemon 2</span><br></pre></td></tr></table></figure>\n<p>awk 变量：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">变量名称</th>\n<th>代表意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">NF</td>\n<td>每一行拥有的字段总数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NR</td>\n<td>目前所处理的是第几行数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">FS</td>\n<td>目前的分隔字符，默认是空格键</td>\n</tr>\n</tbody>\n</table>\n<p>示例：显示正在处理的行号以及每一行有多少字段</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ last -n 5 | awk &#x27;&#123;print $1 &quot;\\t lines: &quot; NR &quot;\\t columns: &quot; NF&#125;&#x27;</span><br><span class=\"line\">dmtsai lines: 1 columns: 10</span><br><span class=\"line\">dmtsai lines: 2 columns: 10</span><br><span class=\"line\">dmtsai lines: 3 columns: 10</span><br><span class=\"line\">dmtsai lines: 4 columns: 10</span><br><span class=\"line\">dmtsai lines: 5 columns: 9</span><br></pre></td></tr></table></figure>\n<h2 id=\"十-进程管理\"><a class=\"markdownIt-Anchor\" href=\"#十-进程管理\">#</a> 十、进程管理</h2>\n<h3 id=\"查看进程\"><a class=\"markdownIt-Anchor\" href=\"#查看进程\">#</a> 查看进程</h3>\n<h4 id=\"1-ps\"><a class=\"markdownIt-Anchor\" href=\"#1-ps\">#</a> 1. ps</h4>\n<p>查看某个时间点的进程信息。</p>\n<p>示例：查看自己的进程</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## ps -l</span></span><br></pre></td></tr></table></figure>\n<p>示例：查看系统所有进程</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## ps aux</span></span><br></pre></td></tr></table></figure>\n<p>示例：查看特定的进程</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## ps aux | grep threadx</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-pstree\"><a class=\"markdownIt-Anchor\" href=\"#2-pstree\">#</a> 2. pstree</h4>\n<p>查看进程树。</p>\n<p>示例：查看所有进程树</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## pstree -A</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-top\"><a class=\"markdownIt-Anchor\" href=\"#3-top\">#</a> 3. top</h4>\n<p>实时显示进程信息。</p>\n<p>示例：两秒钟刷新一次</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## top -d 2</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"4-netstat\"><a class=\"markdownIt-Anchor\" href=\"#4-netstat\">#</a> 4. netstat</h4>\n<p>查看占用端口的进程</p>\n<p>示例：查看特定端口的进程</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## netstat -anp | grep port</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"进程状态\"><a class=\"markdownIt-Anchor\" href=\"#进程状态\">#</a> 进程状态</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">R</td>\n<td>running or runnable (on run queue)<br>正在执行或者可执行，此时进程位于执行队列中。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D</td>\n<td>uninterruptible sleep (usually I/O)<br>不可中断阻塞，通常为 IO 阻塞。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">S</td>\n<td>interruptible sleep (waiting for an event to complete) <br> 可中断阻塞，此时进程正在等待某个事件完成。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Z</td>\n<td>zombie (terminated but not reaped by its parent)<br>僵死，进程已经终止但是尚未被其父进程获取信息。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">T</td>\n<td>stopped (either by a job control signal or because it is being traced) <br> 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><br></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<div align=\"center\"> <img data-src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2bab4127-3e7d-48cc-914e-436be859fb05.png\" width=\"490px\"/> </div><br>\n<h3 id=\"sigchld\"><a class=\"markdownIt-Anchor\" href=\"#sigchld\">#</a> SIGCHLD</h3>\n<p>当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：</p>\n<ul>\n<li>得到 SIGCHLD 信号；</li>\n<li>waitpid () 或者 wait () 调用会返回。</li>\n</ul>\n<p>其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。</p>\n<p>在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait () 和 waitpid () 来获得一个已经退出的子进程的信息。</p>\n<div align=\"center\"> <!-- <img data-src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/flow.png\" width=\"\"/> --> </div><br>\n<h3 id=\"wait\"><a class=\"markdownIt-Anchor\" href=\"#wait\">#</a> wait()</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">pid_t</span> <span class=\"title function_\">wait</span><span class=\"params\">(<span class=\"type\">int</span> *status)</span></span><br></pre></td></tr></table></figure>\n<p>父进程调用 wait () 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait () 函数会销毁子进程并返回。</p>\n<p>如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。</p>\n<p>参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。</p>\n<h3 id=\"waitpid\"><a class=\"markdownIt-Anchor\" href=\"#waitpid\">#</a> waitpid()</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">pid_t</span> <span class=\"title function_\">waitpid</span><span class=\"params\">(<span class=\"type\">pid_t</span> pid, <span class=\"type\">int</span> *status, <span class=\"type\">int</span> options)</span></span><br></pre></td></tr></table></figure>\n<p>作用和 wait () 完全相同，但是多了两个可由用户控制的参数 pid 和 options。</p>\n<p>pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait () 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。</p>\n<p>options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid () 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。</p>\n<h3 id=\"孤儿进程\"><a class=\"markdownIt-Anchor\" href=\"#孤儿进程\">#</a> 孤儿进程</h3>\n<p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</p>\n<p>孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。</p>\n<p>由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p>\n<h3 id=\"僵尸进程\"><a class=\"markdownIt-Anchor\" href=\"#僵尸进程\">#</a> 僵尸进程</h3>\n<p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait () 或 waitpid () 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait () 或 waitpid ()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p>\n<p>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。</p>\n<p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>\n<p>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p>\n<h2 id=\"参考资料\"><a class=\"markdownIt-Anchor\" href=\"#参考资料\">#</a> 参考资料</h2>\n<ul>\n<li>鸟哥。鸟 哥 的 Linux 私 房 菜 基 础 篇 第 三 版 [J]. 2009.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC9sLWNuLXJwbWRwa2cvaW5kZXguaHRtbA==\">Linux 平台上的软件包管理</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2xpdWJpZ2Jpbi5naXRodWIuaW8vMjAxNi8wMy8xMS9MaW51eC0lRTQlQjklOEIlRTUlQUUlODglRTYlOEElQTQlRTglQkYlOUIlRTclQTglOEIlRTMlODAlODElRTUlODMlQjUlRTYlQUQlQkIlRTglQkYlOUIlRTclQTglOEIlRTQlQjglOEUlRTUlQUQlQTQlRTUlODQlQkYlRTglQkYlOUIlRTclQTglOEIv\">Linux 之守护进程、僵死进程与孤儿进程</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTg1ODk5L3doYXQtaXMtdGhlLWRpZmZlcmVuY2UtYmV0d2Vlbi1hLXN5bWJvbGljLWxpbmstYW5kLWEtaGFyZC1saW5r\">What is the difference between a symbolic link and a hard link?</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pZGVhLnBvcGNvdW50Lm9yZy8yMDEyLTEyLTExLWxpbnV4LXByb2Nlc3Mtc3RhdGVzLw==\">Linux process states</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR1VJRF9QYXJ0aXRpb25fVGFibGU=\">GUID Partition Table</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tldmluaGcvYXJ0aWNsZS9kZXRhaWxzLzcwMDE3MTk=\">详解 wait 和 waitpid 函数</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW5sZXNvZnR3YXJlL2FydGljbGUvZGV0YWlscy82MDA5MTEw\">IDE、SATA、SCSI、SAS、FC、SSD 硬盘类型介绍</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5tcGNodW50ZXIuY29tL3MzMDAwL2FrYWktaWItMzAxcy1zY3NpLWludGVyZmFjZS1mb3ItczI4MDBzMzAwMC8=\">Akai IB-301S SCSI Interface for S2800,S3000</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGFyYWxsZWxfQVRB\">Parallel ATA</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy50aGVzc2RyZXZpZXcuY29tL291ci1yZXZpZXdzL2FkYXRhLXhwZy1zeDkwMC0yNTZnYi1zYXRhLTMtc3NkLXJldmlldy1leHBhbmRlZC1jYXBhY2l0eS1hbmQtc2FuZGZvcmNlLWRyaXZlbi1zcGVlZC80Lw==\">ADATA XPG SX900 256GB SATA 3 SSD Review – Expanded Capacity and SandForce Driven Speed</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9ncy5jaXNjby5jb20vZGF0YWNlbnRlci9kZWNvZGluZy11Y3MtaW52aWN0YS1wYXJ0LTE=\">Decoding UCS Invicta – Part 1</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUExJUFDJUU3JTlCJTk4\">硬盘</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5kaWZmZXJlbmNlYmV0d2Vlbi5pbmZvL2RpZmZlcmVuY2UtYmV0d2Vlbi1zYXMtYW5kLXNhdGE=\">Difference between SAS and SATA</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQklPUw==\">BIOS</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3MucnV0Z2Vycy5lZHUvfnB4ay80MTYvbm90ZXMvMTMtZnMtc3R1ZGllcy5odG1s\">File system design case studies</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbGFzc2VzLnNvZS51Y3NjLmVkdS9jbXBzMTExL0ZhbGwwOC9wcm9qNC5zaHRtbA==\">Programming Project #4</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3dlYi5jcy51Y2xhLmVkdS9jbGFzc2VzL2ZhbGwxNC9jczExMS9zY3JpYmUvMTFhL2luZGV4Lmh0bWw=\">FILE SYSTEM DESIGN</span></li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/",
            "url": "http://example.com/2023/07/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/",
            "title": "操作系统",
            "date_published": "2023-07-02T10:30:49.000Z",
            "content_html": "<h1 id=\"计算机操作系统-概述\"><a class=\"markdownIt-Anchor\" href=\"#计算机操作系统-概述\">#</a> 计算机操作系统 - 概述</h1>\n<!-- GFM-TOC -->\n<ul>\n<li><a href=\"#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E6%A6%82%E8%BF%B0\">计算机操作系统 - 概述</a>\n<ul>\n<li><a href=\"#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81\">基本特征</a>\n<ul>\n<li><a href=\"#1-%E5%B9%B6%E5%8F%91\">1. 并发</a></li>\n<li><a href=\"#2-%E5%85%B1%E4%BA%AB\">2. 共享</a></li>\n<li><a href=\"#3-%E8%99%9A%E6%8B%9F\">3. 虚拟</a></li>\n<li><a href=\"#4-%E5%BC%82%E6%AD%A5\">4. 异步</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD\">基本功能</a>\n<ul>\n<li><a href=\"#1-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86\">1. 进程管理</a></li>\n<li><a href=\"#2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\">2. 内存管理</a></li>\n<li><a href=\"#3-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86\">3. 文件管理</a></li>\n<li><a href=\"#4-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86\">4. 设备管理</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\">系统调用</a></li>\n<li><a href=\"#%E5%AE%8F%E5%86%85%E6%A0%B8%E5%92%8C%E5%BE%AE%E5%86%85%E6%A0%B8\">宏内核和微内核</a>\n<ul>\n<li><a href=\"#1-%E5%AE%8F%E5%86%85%E6%A0%B8\">1. 宏内核</a></li>\n<li><a href=\"#2-%E5%BE%AE%E5%86%85%E6%A0%B8\">2. 微内核</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%B8%AD%E6%96%AD%E5%88%86%E7%B1%BB\">中断分类</a>\n<ul>\n<li><a href=\"#1-%E5%A4%96%E4%B8%AD%E6%96%AD\">1. 外中断</a></li>\n<li><a href=\"#2-%E5%BC%82%E5%B8%B8\">2. 异常</a></li>\n<li><a href=\"#3-%E9%99%B7%E5%85%A5\">3. 陷入</a><!-- GFM-TOC -->\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"基本特征\"><a class=\"markdownIt-Anchor\" href=\"#基本特征\">#</a> 基本特征</h2>\n<h3 id=\"1-并发\"><a class=\"markdownIt-Anchor\" href=\"#1-并发\">#</a> 1. 并发</h3>\n<p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p>\n<p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p>\n<p>操作系统通过引入进程和线程，使得程序能够并发运行。</p>\n<h3 id=\"2-共享\"><a class=\"markdownIt-Anchor\" href=\"#2-共享\">#</a> 2. 共享</h3>\n<p>共享是指系统中的资源可以被多个并发进程共同使用。</p>\n<p>有两种共享方式：互斥共享和同时共享。</p>\n<p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p>\n<h3 id=\"3-虚拟\"><a class=\"markdownIt-Anchor\" href=\"#3-虚拟\">#</a> 3. 虚拟</h3>\n<p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>\n<p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p>\n<p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p>\n<p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p>\n<h3 id=\"4-异步\"><a class=\"markdownIt-Anchor\" href=\"#4-异步\">#</a> 4. 异步</h3>\n<p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p>\n<h2 id=\"基本功能\"><a class=\"markdownIt-Anchor\" href=\"#基本功能\">#</a> 基本功能</h2>\n<h3 id=\"1-进程管理\"><a class=\"markdownIt-Anchor\" href=\"#1-进程管理\">#</a> 1. 进程管理</h3>\n<p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p>\n<h3 id=\"2-内存管理\"><a class=\"markdownIt-Anchor\" href=\"#2-内存管理\">#</a> 2. 内存管理</h3>\n<p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p>\n<h3 id=\"3-文件管理\"><a class=\"markdownIt-Anchor\" href=\"#3-文件管理\">#</a> 3. 文件管理</h3>\n<p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p>\n<h3 id=\"4-设备管理\"><a class=\"markdownIt-Anchor\" href=\"#4-设备管理\">#</a> 4. 设备管理</h3>\n<p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p>\n<p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p>\n<h2 id=\"系统调用\"><a class=\"markdownIt-Anchor\" href=\"#系统调用\">#</a> 系统调用</h2>\n<p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p>\n<div align=\"center\"> <img data-src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/tGPV0.png\" width=\"600\"/> </div><br>\n<p>Linux 的系统调用主要有以下这些：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Task</th>\n<th>Commands</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">进程控制</td>\n<td>fork(); exit(); wait();</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">进程通信</td>\n<td>pipe(); shmget(); mmap();</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">文件操作</td>\n<td>open(); read(); write();</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">设备操作</td>\n<td>ioctl(); read(); write();</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">信息维护</td>\n<td>getpid(); alarm(); sleep();</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">安全</td>\n<td>chmod(); umask(); chown();</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"宏内核和微内核\"><a class=\"markdownIt-Anchor\" href=\"#宏内核和微内核\">#</a> 宏内核和微内核</h2>\n<h3 id=\"1-宏内核\"><a class=\"markdownIt-Anchor\" href=\"#1-宏内核\">#</a> 1. 宏内核</h3>\n<p>宏内核是将操作系统功能作为一个紧密结合的整体放到内核。</p>\n<p>由于各模块共享信息，因此有很高的性能。</p>\n<h3 id=\"2-微内核\"><a class=\"markdownIt-Anchor\" href=\"#2-微内核\">#</a> 2. 微内核</h3>\n<p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p>\n<p>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p>\n<p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p>\n<div align=\"center\"> <img data-src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2_14_microkernelArchitecture.jpg\"/> </div><br>\n<h2 id=\"中断分类\"><a class=\"markdownIt-Anchor\" href=\"#中断分类\">#</a> 中断分类</h2>\n<h3 id=\"1-外中断\"><a class=\"markdownIt-Anchor\" href=\"#1-外中断\">#</a> 1. 外中断</h3>\n<p>由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入 / 输出处理已经完成，处理器能够发送下一个输入 / 输出请求。此外还有时钟中断、控制台中断等。</p>\n<h3 id=\"2-异常\"><a class=\"markdownIt-Anchor\" href=\"#2-异常\">#</a> 2. 异常</h3>\n<p>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p>\n<h3 id=\"3-陷入\"><a class=\"markdownIt-Anchor\" href=\"#3-陷入\">#</a> 3. 陷入</h3>\n<p>在用户程序中使用系统调用。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/02/C-%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6/",
            "url": "http://example.com/2023/07/02/C-%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6/",
            "title": "C++学习进阶",
            "date_published": "2023-07-02T10:30:23.000Z",
            "content_html": "<h1 id=\"a-namemainac-核心指导方针\"><a class=\"markdownIt-Anchor\" href=\"#a-namemainac-核心指导方针\">#</a> <a name=\"main\"></a>C++ 核心指导方针</h1>\n<p>2022/10/6</p>\n<p>编辑：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbQ==\">Bjarne Stroustrup</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2hlcmJzdXR0ZXIuY29tLw==\">Herb Sutter</span></li>\n</ul>\n<p>翻译</p>\n<ul>\n<li>李一楠 (li_yinan AT 163 DOT com)</li>\n</ul>\n<p>本文档是处于持续改进之中的在线文档。<br>\n本文档作为开源项目，发布版本为 0.8。<br>\n复制，使用，修改，以及创建本项目的衍生物，受到一份 MIT 风格的版权授权。<br>\n向本项目作出贡献需要同意一份贡献者授权。详情参见附属的 <a href=\"LICENSE\">LICENSE</a> 文件。<br>\n我们将本项目开放给 “友好用户” 进行使用，复制，修改，以及生产衍生物，并希望能够获得建设性的资源投入。</p>\n<p>十分欢迎大家提出意见和改进建议。<br>\n随着我们的知识增长，随着语言和可用的程序库的改进，我们计划对这份文档不断进行修改和扩充。<br>\n当提出您的意见时，请关注<a href=\"#S-introduction\">导言</a>部分，其中概述了我们的目标和所采用的一般方法。<br>\n贡献者的列表请参见<a href=\"#SS-ack\">这里</a>。</p>\n<p>已知问题：</p>\n<ul>\n<li>仍未对规则集合的完整性、一致性和可强制实施性加以全面的检查。</li>\n<li>三问号 (???) 用于标记已知的信息缺失。</li>\n<li>需要更新参考部分；许多前 C++11 的源代码都过于老旧。</li>\n<li><a href=\"#S-unclassified\">To-do: 未分类的规则原型</a> 是一份基本上保持最新状态的 to-do 列表。</li>\n</ul>\n<p>您可以<a href=\"#S-abstract\">阅读本指南的范围和结构的说明</a>，或者直接跳转到：</p>\n<ul>\n<li><a href=\"#S-introduction\">In: 导言</a></li>\n<li><a href=\"#S-philosophy\">P: 理念</a></li>\n<li><a href=\"#S-interfaces\">I: 接口</a></li>\n<li><a href=\"#S-functions\">F: 函数</a></li>\n<li><a href=\"#S-class\">C: 类和类层次</a></li>\n<li><a href=\"#S-enum\">Enum: 枚举</a></li>\n<li><a href=\"#S-resource\">R: 资源管理</a></li>\n<li><a href=\"#S-expr\">ES: 表达式和语句</a></li>\n<li><a href=\"#S-performance\">Per: 性能</a></li>\n<li><a href=\"#S-concurrency\">CP: 并发与并行</a></li>\n<li><a href=\"#S-errors\">E: 错误处理</a></li>\n<li><a href=\"#S-const\">Con: 常量和不可变性</a></li>\n<li><a href=\"#S-templates\">T: 模板和泛型编程</a></li>\n<li><a href=\"#S-cpl\">CPL: C 风格的编程</a></li>\n<li><a href=\"#S-source\">SF: 源文件</a></li>\n<li><a href=\"#sl-the-standard-library\">SL: 标准库</a></li>\n</ul>\n<p>配套章节：</p>\n<ul>\n<li><a href=\"#S-A\">A: 架构相关理念</a></li>\n<li><a href=\"#S-not\">NR: 伪规则和错误的看法</a></li>\n<li><a href=\"#S-references\">RF: 参考资料</a></li>\n<li><a href=\"#S-profile\">PRO: 剖面配置</a></li>\n<li><a href=\"#gsl-guidelines-support-library\">GSL: 指导方针支持库</a></li>\n<li><a href=\"#S-naming\">NL: 命名和代码布局建议</a></li>\n<li><a href=\"#S-faq\">FAQ: 常见问题的解答</a></li>\n<li><a href=\"#S-libraries\">附录 A: 程序库</a></li>\n<li><a href=\"#S-modernizing\">附录 B: 代码的现代化转换</a></li>\n<li><a href=\"#S-discussion\">附录 C: 相关讨论</a></li>\n<li><a href=\"#S-tools\">附录 D: 支持工具</a></li>\n<li><a href=\"#S-glossary\">词汇表</a></li>\n<li><a href=\"#S-unclassified\">To-do: 未分类的规则原型</a></li>\n</ul>\n<p>您可以查看有关某个具体的语言特性的一些规则：</p>\n<ul>\n<li>赋值：<br>\n<a href=\"#Rc-regular\">正规类型</a> –<br>\n<a href=\"#Rc-initialize\">优先采用初始化</a> –<br>\n<a href=\"#Rc-copy-semantic\">复制</a> –<br>\n<a href=\"#Rc-move-semantic\">移动</a> –<br>\n<a href=\"#Rc-matched\">以及其他操作</a> –<br>\n<a href=\"#Rc-eqdefault\">缺省操作</a></li>\n<li><code>class</code> ：<br>\n<a href=\"#Rc-org\">数据</a> –<br>\n<a href=\"#Rc-struct\">不变式</a> –<br>\n<a href=\"#Rc-member\">成员</a> –<br>\n<a href=\"#Rc-helper\">辅助函数</a> –<br>\n<a href=\"#SS-concrete\">具体类型</a> –<br>\n<a href=\"#S-ctor\">构造函数，=，和析构函数</a> –<br>\n<a href=\"#SS-hier\">类层次</a> –<br>\n<a href=\"#SS-overload\">运算符</a></li>\n<li><code>concept</code> ：<br>\n<a href=\"#SS-concepts\">规则</a> –<br>\n<a href=\"#Rt-raise\">泛型编程中</a> –<br>\n<a href=\"#Rt-concepts\">模板实参</a> –<br>\n<a href=\"#Rt-low\">语义</a></li>\n<li>构造函数：<br>\n<a href=\"#Rc-struct\">不变式</a> –<br>\n<a href=\"#Rc-ctor\">建立不变式</a> –<br>\n<a href=\"#Rc-throw\"> <code>throw</code> </a> –<br>\n<a href=\"#Rc-default0\">缺省操作</a> –<br>\n<a href=\"#Rc-default\">不需要</a> –<br>\n<a href=\"#Rc-explicit\"> <code>explicit</code> </a> –<br>\n<a href=\"#Rc-delegating\">委派</a> –<br>\n<a href=\"#Rc-ctor-virtual\"> <code>virtual</code> </a></li>\n<li>派生  <code>class</code> ：<br>\n<a href=\"#Rh-domain\">何时使用</a> –<br>\n<a href=\"#Rh-abstract\">作为接口</a> –<br>\n<a href=\"#Rh-dtor\">析构函数</a> –<br>\n<a href=\"#Rh-copy\">复制</a> –<br>\n<a href=\"#Rh-get\">取值和设值</a> –<br>\n<a href=\"#Rh-mi-interface\">多继承</a> –<br>\n<a href=\"#Rh-using\">重载</a> –<br>\n<a href=\"#Rc-copy-virtual\">分片</a> –<br>\n<a href=\"#Rh-dynamic_cast\"> <code>dynamic_cast</code> </a></li>\n<li>析构函数：<br>\n<a href=\"#Rc-matched\">以及构造函数</a> –<br>\n<a href=\"#Rc-dtor\">何时需要？</a> –<br>\n<a href=\"#Rc-dtor-fail\">不可失败</a></li>\n<li>异常：<br>\n<a href=\"#S-errors\">错误</a> –<br>\n<a href=\"#Re-throw\"> <code>throw</code> </a> –<br>\n<a href=\"#Re-errors\">仅用于错误</a> –<br>\n<a href=\"#Re-noexcept\"> <code>noexcept</code> </a> –<br>\n<a href=\"#Re-catch\">最少化  <code>try</code> </a> –<br>\n<a href=\"#Re-no-throw-codes\">无异常如何？</a></li>\n<li><code>for</code> ：<br>\n<a href=\"#Res-for-range\">范围式  <code>for</code>  和  <code>for</code> </a> –<br>\n<a href=\"#Res-for-while\"> <code>for</code>  和  <code>while</code> </a> –<br>\n<a href=\"#Res-for-init\"> <code>for</code>  - 初始化式</a> –<br>\n<a href=\"#Res-empty\">空循环体</a> –<br>\n<a href=\"#Res-loop-counter\">循环变量</a> –<br>\n<a href=\"#Res-???\">循环变量的类型？？？</a></li>\n<li>函数：<br>\n<a href=\"#Rf-package\">命名</a> –<br>\n<a href=\"#Rf-logical\">单操作</a> –<br>\n<a href=\"#Rf-noexcept\">不能抛出异常</a> –<br>\n<a href=\"#Rf-smart\">实参</a> –<br>\n<a href=\"#Rf-conventional\">实参传递</a> –<br>\n<a href=\"#Rf-out-multi\">多返回值</a> –<br>\n<a href=\"#Rf-return-ptr\">指针</a> –<br>\n<a href=\"#Rf-capture-vs-overload\">lambda</a></li>\n<li><code>inline</code> :<br>\n<a href=\"#Rf-inline\"> 小型函数</a> –<br>\n<a href=\"#Rs-inline\">头文件中</a></li>\n<li>初始化：<br>\n<a href=\"#Res-always\">总是</a> –<br>\n<a href=\"#Res-list\">优先采用  <code>&#123;&#125;</code> </a> –<br>\n<a href=\"#Res-lambda-init\">lambda</a> –<br>\n<a href=\"#Rc-in-class-initializer\">类内初始化式</a> –<br>\n<a href=\"#Rc-initialize\">类成员</a> –<br>\n<a href=\"#Rc-factory\">工厂函数</a></li>\n<li>lambda 表达式：<br>\n<a href=\"#SS-lambdas\">何时使用</a></li>\n<li>运算符：<br>\n<a href=\"#Ro-conventional\">约定</a> –<br>\n<a href=\"#Ro-conversion\">避免转换运算符</a> –<br>\n<a href=\"#Ro-lambda\">与 lambda</a></li>\n<li><code>public</code> ,  <code>private</code> , 和  <code>protected</code> ：<br>\n<a href=\"#Rc-private\">信息隐藏</a> –<br>\n<a href=\"#Rh-public\">一致性</a> –<br>\n<a href=\"#Rh-protected\"> <code>protected</code> </a></li>\n<li><code>static_assert</code> ：<br>\n<a href=\"#Rp-compile-time\">编译时检查</a> –<br>\n<a href=\"#Rt-check-class\">和概念</a></li>\n<li><code>struct</code> ：<br>\n<a href=\"#Rc-org\">用于组织数据</a> –<br>\n<a href=\"#Rc-struct\">没有不变式时使用</a> –<br>\n<a href=\"#Rc-class\">不能有私有成员</a></li>\n<li><code>template</code> ：<br>\n<a href=\"#Rt-raise\">抽象</a> –<br>\n<a href=\"#Rt-cont\">容器</a> –<br>\n<a href=\"#Rt-concepts\">概念</a></li>\n<li><code>unsigned</code> ：<br>\n<a href=\"#Res-mix\">和  <code>signed</code> </a> –<br>\n<a href=\"#Res-unsigned\">位操作</a></li>\n<li><code>virtual</code> ：<br>\n<a href=\"#Ri-abstract\">接口</a> –<br>\n<a href=\"#Rc-concrete\">非  <code>virtual</code> </a> –<br>\n<a href=\"#Rc-dtor-virtual\">析构函数</a> –<br>\n<a href=\"#Rc-dtor-fail\">不能失败</a></li>\n</ul>\n<p>您可以查看用于表达这些规则的一些设计概念：</p>\n<ul>\n<li>断言：???</li>\n<li>错误：???</li>\n<li>异常：异常保证 (???)</li>\n<li>故障：???</li>\n<li>不变式：???</li>\n<li>泄漏：???</li>\n<li>程序库：???</li>\n<li>前条件：???</li>\n<li>后条件：???</li>\n<li>资源：???</li>\n</ul>\n<h1 id=\"a-names-abstracta概要\"><a class=\"markdownIt-Anchor\" href=\"#a-names-abstracta概要\">#</a> <a name=\"S-abstract\"></a>概要</h1>\n<p>本文档是一组有关如何更好使用 C++ 的指导方针的集合。<br>\n本文档的目标是帮助人们更有效地使用现代 C++。<br>\n所谓 “现代 C++” 的含义是指有效使用 ISO C++ 标准（目前是 C<ins>20，但几乎所有的推荐也适用于 C</ins>17，C<ins>14 和 C</ins>11）。<br>\n换句话说，如果你从现在开始算起，五年后你的代码看起来是怎么样的？十年呢？</p>\n<p>这些指导方针所关注的是一些相对高层次的问题，比如接口，资源管理，内存管理，以及并发等等。<br>\n这样的规则会对应用的架构，以及程序库的设计都造成影响。<br>\n如果遵循这些规则，代码将会是静态类型安全的，没有资源泄露，并且能够捕捉到比当今的代码通常所能捕捉到的多得多的编程逻辑错误。<br>\n还能更快速地运行 —— 你不必牺牲程序的正确性。</p>\n<p>我们对于如命名约定和缩进风格一类的低层次的问题不那么关注。<br>\n当然，对程序员有帮助的任何话题都是可接受的。</p>\n<p>我们最初的规则集合强调的是（各种形式的）安全性以及简单性。<br>\n它们也许有些过于严格了。<br>\n我们预期将会引入更多的例外情况， 以便使它们更好地适应现实世界的需要。<br>\n我们也需要更多的规则。</p>\n<p>您可能会发现，有的规则与您的预期相反，甚至是与您的经验相违背。<br>\n其实如果我们没建议您在任何方面改变您的编码风格，那其实就是我们的失败！<br>\n请您尝试验证或者证伪这些规则吧！<br>\n尤其是，我们十分期望让一些规则能够建立在真实的测量数据上，或者是一些更好的例子之上。</p>\n<p>您可能会觉得一些规则很显然，甚至没有什么价值。<br>\n但请记住，指导方针的目的之一就在于帮助那些经验不足的，或来自其他背景或使用其他语言的人，能够迅速行动起来。</p>\n<p>这里的许多规则有意设计成可以由分析工具提供支持的。<br>\n违反规则的代码会打上标记，以引用（或者链接）到相关的规则。<br>\n您在开始编码前并不需要记住所有这些规则。<br>\n一种看待这些指导方针的方式，是一份恰好可以让人类读懂的针对这些工具的规范文件。</p>\n<p>这些规则都是为了逐步引入一个代码库而设计的。<br>\n我们计划建立这样的工具，并希望其他人也能提供它们。</p>\n<p>十分欢迎大家提出意见和改进建议。<br>\n随着我们的知识增长，随着语言和可用的程序库的改进，我们计划对这份文档不断进行修改和扩充。</p>\n<h1 id=\"a-names-introductionain-导言\"><a class=\"markdownIt-Anchor\" href=\"#a-names-introductionain-导言\">#</a> <a name=\"S-introduction\"></a>In: 导言</h1>\n<p>本文档是一组核心指导方针，针对现代 C++（目前为 C<ins>20 和 C</ins>17），还考虑到了语言将来有希望的增强，以及 ISO 技术规范（TS）。<br>\n其目标是帮助 C++ 程序员编写更简单、更高效、更加可维护的代码。</p>\n<p>导言概览：</p>\n<ul>\n<li><a href=\"#SS-readers\">In.target: 目标读者</a></li>\n<li><a href=\"#SS-aims\">In.aims: 目标</a></li>\n<li><a href=\"#SS-non\">In.not: 非目标</a></li>\n<li><a href=\"#SS-force\">In.force: 强制实施</a></li>\n<li><a href=\"#SS-struct\">In.struct: 本文档的结构</a></li>\n<li><a href=\"#SS-sec\">In.sec: 主要章节</a></li>\n</ul>\n<h2 id=\"a-namess-readersaintarget-目标读者\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-readersaintarget-目标读者\">#</a> <a name=\"SS-readers\"></a>In.target: 目标读者</h2>\n<p>所有 C++ 程序员。其中也包括<a href=\"#S-cpl\">考虑采用 C 语言的程序员</a>。</p>\n<h2 id=\"a-namess-aimsainaims-目标\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-aimsainaims-目标\">#</a> <a name=\"SS-aims\"></a>In.aims: 目标</h2>\n<p>本文档的目标是帮助开发者采用现代 C++（目前是 C++17），并在各个代码库之间达成更加统一的编码风格。</p>\n<p>我们并不妄想这些规则中的每一条都能有效地在任何代码库中进行实施。对老旧系统进行升级是很困难的。不过我们确实认为，采纳了一条规则的程序总会比不这样做的程序更加不易出错也更加便于维护。通常，采用规则也会带来更快速或更容易的初始开发活动。<br>\n就我们所能说的，这些规则能够使得代码的性能，相对于更传统的技术来说同样好甚至更好；它们都是依照零开销原则设立的 ——“不使用就没有负担”（“what you don’t use, you don’t pay for”）或 “当恰当地使用抽象机制时，所得的性能至少与使用低级语言构造手工编码的结果一样好”。<br>\n我们认为这些规则对新代码来说是理想的，也有很多机会在老代码中实施，并试图尽可能接近并灵活地对这些理想情况进行近似。<br>\n请记住：</p>\n<h3 id=\"a-namer0ain0-不要慌张\"><a class=\"markdownIt-Anchor\" href=\"#a-namer0ain0-不要慌张\">#</a> <a name=\"R0\"></a>In.0: 不要慌张！</h3>\n<p>请花些时间理解一下指南规则对你的程序能够造成的影响。</p>\n<p>这些指导方针都是遵循 “超集的子集” 原则（<a href=\"#Stroustrup05\">Stroustrup05</a>）而设计的。<br>\n它们并非仅仅定义了 C++ 的一个可以使用的子集（以获得比如说可靠性，安全性，性能，或者别的什么）。<br>\n它们强烈地推崇使用一些简单的 “扩展”（<a href=\"#gsl-guidelines-support-library\">程序库组件</a>），<br>\n使得最易出错的 C++ 特性变得不再必须，并且可以（通过这些规则）禁止再使用它们。</p>\n<p>这些规则都强调静态类型安全性和资源安全性。<br>\n鉴于此，它们强调了进行范围检查，避免对  <code>nullptr</code>  解引用，避免悬挂指针，以及（通过 RAII）系统性地使用异常的可能性。<br>\n部分地为达成这点，也部分地为了最小化会带来错误的晦涩难懂的代码，这些规则同样强调了简单性，以及将必须的复杂性隐藏于经过充分说明的接口后面。</p>\n<p>有许多规则都是约定性质的。<br>\n我们认为，那些单纯说 “禁止这样！” 而又不提供替代方案的规则是不可取的。<br>\n但这样的后果就是让一些规则只能以启发式方法，而不是精确地和机械化地进行验证检查。<br>\n还有一些规则所表达的是一些一般性的原则。对于这些一般性规则，我们会提供一些更精细和更特定的规则来进行不完全的检查。</p>\n<p>这些指导方针所关注的是 C++ 的核心部分及其使用方式。<br>\n我们认为大多数的大型团体，特定的应用领域，甚至一些大型项目都会需要更多的规则，也许是更多的限制规则，或是更多的库支持。<br>\n例如说，硬实时开发人员通常都无法随意使用自由存储（动态内存），并且在选择程序库上也有许多限制。<br>\n我们鼓励各方开发这样的专门规则，以作为我们的核心指导方针的补充。<br>\n请构建你自己的基础程序库并使用它，而不要把你的开发层次降低到汇编代码之中。</p>\n<p>这些规则的设计使其能够进行<a href=\"#S-modernizing\">渐进式的采纳</a>。</p>\n<p>一些规则的目标是提升各种形式的安全性，而另外一些的目标是减少意外的发生，还有许多则同时兼顾。<br>\n目标是避免意外事故的指导方针通常会禁止完全合法的 C++ 用法。<br>\n不管怎样，每当存在两种达成效果的方式，其中一种被证实是常见的错误来源，而另外一种并非如此时，我们都会努力引导程序员采纳后者。</p>\n<h2 id=\"a-namess-nonainnot-非目标\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-nonainnot-非目标\">#</a> <a name=\"SS-non\"></a>In.not: 非目标</h2>\n<p>我们没打算让这些规则保持精简或正交。<br>\n特别地说，一般性规则可以很简单，但却没办法强制实施。<br>\n而且要搞清楚一条一般性规则所造成的影响通常是很困难的。<br>\n通常更专门的规则都更易于理解清楚，也更易于实施，但如果没有那些一般性规则的话，它们不过是一大堆特殊情况而已。<br>\n我们既要提供能够帮到新手的规则，也要提供能够支持专家使用的规则。<br>\n其中的一些规则是完全可以强制实行的，而另外的一些则是基于启发式方案的规则。</p>\n<p>并不需要像读书一样从头到尾地阅读这些规则。<br>\n您可以利用链接来进行浏览。<br>\n不过，这些规则的主要预期用途是作为工具的检查目标。<br>\n就是说，由工具来查找规则的违反情况，然后工具会返回指向所违反的规则的链接。<br>\n而规则之中则提供了其理由，违反规则的潜在后果的例子，以及一些改正建议。</p>\n<p>这些指导方针并不是用来替代 C++ 的教程材料的。<br>\n如果您需要针对某个经验水平的教程，请参见<a href=\"#S-references\">参考资料</a>。</p>\n<p>本文档并不是一份如何把老旧 C++ 代码转化为更加现代的代码的指南。<br>\n而是旨在以一种具体化的方式来阐明对于新代码的设想。<br>\n当然，对于进行代码现代化转换，使其恢复活力或者升级的可行方式，可以参考<a href=\"#S-modernizing\">代码现代化章节</a>。<br>\n重要的是，这些规则是允许渐进式采纳的：对大型代码库进行一次性全部转化通常都是不可行的。</p>\n<p>这些指导方针并不会对于语言技术的每个细节上都保持完整和精确。<br>\n如果需要，请参考 C++ 标准，关于语言定义上的最终文本，其中包括一般性规则的每种例外情况，也包括所有特性。</p>\n<p>这些规则不是为了强迫你使用 C++ 的某个阉割子集来编写代码的。<br>\n它们<em>尤其着重</em>避免去定义一种像（比如）Java 一样的 C++ 子集。<br>\n它们也避免去定义一个单一的所谓 “真正的 C++” 的语言。<br>\n我们重视语言的表达能力和不打折扣的性能。</p>\n<p>这些规则并不是价值观中立的。<br>\n它们旨在使代码变得相对于现有大多数 C++ 代码来说更简单，并且更加正确和安全，又不会有任何性能损失。<br>\n它们旨在约束对那些完全合法的，但却与错误、虚假的复杂性以及不良性能有关的 C++ 代码的使用。</p>\n<p>这些规则并未精炼到人们（或机器）可以无脑实施的程度。<br>\n“强制实施” 部分试图做到这点，但相对于给出一些精确但却错误的东西来说，<br>\n我们更倾向于使得一条规则或者定义略微含糊，并允许不同的解读。<br>\n有时候，只有经历时间和经验的凝炼才能带来精确性。<br>\n设计（还）并不是数学的某种形式。</p>\n<p>这些规则并不完美。<br>\n某条规则可能有害，因其可能制止了在特定情形中有益的事物。<br>\n某条规则可能有害，因其可能无法制止在特定情形中会导致某种严重错误的事物。<br>\n某条规则可能有许多害处，因其含混，有歧义，无法实施，或者对一个问题给出了所有的解决方案。<br>\n完全满足 “无害” 的准则是不可能的。<br>\n相对来讲，我们的目标并没那么大野心：“对大多数数程序员有最多的好处”；<br>\n如果某条规则使你无法工作，你反对它，忽略掉它，但请不要削弱它，除非它已经变得没有意义。<br>\n同样，也请给出改进的建议。</p>\n<h2 id=\"a-namess-forceainforce-强制实施\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-forceainforce-强制实施\">#</a> <a name=\"SS-force\"></a>In.force: 强制实施</h2>\n<p>无法强制实施的规则对于大型代码库来说是难以操作的。<br>\n所有规则都强制实施，则仅对于一个小的规则集合，或者对于某些特定用户群来说是可行的。</p>\n<ul>\n<li>但我们需要大量的规则，需要每个人都能使用的规则。</li>\n<li>不同的人的要求都不一样。</li>\n<li>人们不想阅读大量的规则。</li>\n<li>人们也无法记住太多规则。</li>\n</ul>\n<p>因此，我们需要建立规则子集以满足各种不同的需要。</p>\n<ul>\n<li>但任意性地建立子集也会导致混乱。</li>\n</ul>\n<p>我们想要的是可以帮助到许多人的指导方针，使代码更加统一，并有力地促进人们将他们的代码现代化。<br>\n我们想要促进最佳实践，而不是让人们陷入大量选项之中而增加管理压力。<br>\n理想情况是使用全部规则；这会带来极大的好处。</p>\n<p>但这样也带来了一些困难之处。<br>\n我们试图通过使用工具来解决它们。<br>\n每条规则都包括一个<strong>强制实施</strong>小节，列出了进行强制实施的一些建议。<br>\n所谓强制实施，可以是通过代码评审，通过静态分析，通过编译器，或者通过运行时检查来进行的。<br>\n只要可行，我们都倾向于 “机械性的” 检查（人类是缓慢的，不精确的，而且很容易疲倦）和静态检查。<br>\n只有当不存在其他方案时，我们才偶尔建议进行运行时检查；我们并不想带来所谓 “分布式代码爆炸”。<br>\n如果适当的话，我们会（在<strong>强制实施</strong>小节中）将规则标以相关的规则组的名字（所谓 “剖面配置”）。<br>\n一条规则可以属于多个剖面配置，也可以不属于任何剖面配置。<br>\n首先，我们有一些对应于常规需求（期望、理想目标）的剖面配置：</p>\n<ul>\n<li><strong>type</strong>: 消除类型违规（如通过强制转换（cast），联合体（union），或者变参（varargs）把  <code>T</code>  重解释为  <code>U</code> ）</li>\n<li><strong>bounds</strong>: 消除边界违规（如越过数组范围的访问）</li>\n<li><strong>lifetime</strong>: 消除泄漏（如未能  <code>delete</code>  或者进行多次  <code>delete</code> ），以及消除对无效对象的访问（如解引用  <code>nullptr</code> ，或使用悬挂引用）。</li>\n</ul>\n<p>这些剖面配置是为工具的使用而准备的，但对人类读者也能有所帮助。<br>\n我们不打算把<strong>强制实施</strong>小节中的评述限定在我们了解如何强制实施的方面；其中的一些说明仅仅是一些愿望，它们可能会对一些工具构建者们造成影响。</p>\n<p>实现这些规则的工具应当遵循下面的语法以明确抑制一条规则：</p>\n<pre><code>[[gsl::suppress(tag)]]\n</code></pre>\n<p>或可选地带有一条消息（遵循常规的 C++11 标准标注语法）：</p>\n<pre><code>[[gsl::suppress(tag, justification: &quot;message&quot;)]]\n</code></pre>\n<p>其中</p>\n<ul>\n<li>\n<p><code>tag</code>  是包含强制规则的条目的锚定名字（例如，<a href=\"#Rh-public\">C.134</a> 的锚定名字为 “Rh-public”），<br>\n剖面配置的规则组的名字（如 “type”，“bounds”，或 “lifetime”），<br>\n或者剖面配置中的特定规则（<a href=\"#Pro-type-cstylecast\">type.4</a> 或 <a href=\"#Pro-bounds-arrayindex\">bounds.2</a>）</p>\n</li>\n<li>\n<p><code>&quot;message&quot;</code>  是字符串字面量</p>\n</li>\n</ul>\n<h2 id=\"a-namess-structainstruct-本文档的结构\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-structainstruct-本文档的结构\">#</a> <a name=\"SS-struct\"></a>In.struct: 本文档的结构</h2>\n<p>每条规则（指导方针，建议）可以包含几个部分：</p>\n<ul>\n<li>规则本身 —— 例如，<strong>不要使用裸  <code>new</code> </strong></li>\n<li>一个规则参考编号 —— 例如，<strong>C.7</strong>（与类相关的第七条规则）。<br>\n因为大章节之间天然是无序的，所以我们用字母来当作规则参考 “编号” 的第一个部分。<br>\n我们在编号之间保留了一些间隔，以便当添加或删减规则时尽量减少 “断裂”。</li>\n<li><strong>理由</strong>（原理） —— 程序员对于他们不理解的规则是难于遵守的</li>\n<li><strong>示例</strong> —— 抽象地理解规则是很难的；示例有正面的和负面的</li>\n<li><strong>替代方案</strong> —— 针对 “请勿……” 规则</li>\n<li><strong>例外</strong> —— 我们更喜欢简单的一般性规则。但是许多规则都是广泛适用，但并不是普遍适用的，因此必须列出例外情况</li>\n<li><strong>强制实施</strong> —— 关于这条规则如何 “机械性” 地进行检查的建议</li>\n<li><strong>参见</strong> —— 指向相关的规则，以及（本文档中或者别处的）进一步讨论</li>\n<li><strong>注解</strong> —— 需要说明的一些内容，无法被归类到其他部分</li>\n<li><strong>探讨</strong> —— 指向规则主列表之外的更加全面的原理说明和实例</li>\n</ul>\n<p>一些规则难于机械地进行检查，但它们都满足一条最小准则，即专家程序员可以不费太多力气就能找出许多违反情况。<br>\n我们希望 “机械性” 工具能够随着时间获得改进，以接近这种专家程序员所能发觉的程度。<br>\n而且，我们还认为这些规则也会随着时间获得提炼，以变得更明确和易于检查。</p>\n<p>规则应当简明，而不是谨慎地列出每种变化和特殊情况。<br>\n这些信息应当出现在<strong>替代方案</strong>段落和<a href=\"#S-discussion\">探讨</a>章节中。<br>\n如果您不理解或者反对一条规则，请您访问它的<strong>探讨</strong>部分。<br>\n如果您觉得一份探讨有缺漏或不完整，请填写一条 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2lzb2NwcC9DcHBDb3JlR3VpZGVsaW5lcy9pc3N1ZXM=\">Issue</span><br>\n 来解释您的关切，亦或一条相应的问题报告。</p>\n<p>各个示例用于演示规则。</p>\n<ul>\n<li>这些示例并非意图具有产品级的质量，或覆盖所有的教学维度。<br>\n例如，许多的例子都是语言技巧，并使用了诸如  <code>f</code> ， <code>base</code> ，和  <code>x</code>  这样的名字。</li>\n<li>我们尝试保证使下文中 “好” 的示例都遵守《核心指导方针》。</li>\n<li>注释通常用于演示规则，它们可能是不必要的，或者会干扰 “真正的代码”。</li>\n<li>我们假设读者具有标准程序库的知识。例如我们使用普通的  <code>vector</code>  而不是  <code>std::vector</code> 。</li>\n</ul>\n<p>本文档不是语言手册。<br>\n它旨在能够对人有所帮助，而不是变得完整，在技术细节上完全准确，或对现存代码的指南。<br>\n可以在<a href=\"#S-references\">参考资料</a>中找到一些推荐的信息来源。</p>\n<h2 id=\"a-namess-secainsec-主章节\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-secainsec-主章节\">#</a> <a name=\"SS-sec\"></a>In.sec: 主章节</h2>\n<ul>\n<li><a href=\"#S-introduction\">In: 导言</a></li>\n<li><a href=\"#S-philosophy\">P: 理念</a></li>\n<li><a href=\"#S-interfaces\">I: 接口</a></li>\n<li><a href=\"#S-functions\">F: 函数</a></li>\n<li><a href=\"#S-class\">C: 类和类层次</a></li>\n<li><a href=\"#S-enum\">Enum: 枚举</a></li>\n<li><a href=\"#S-resource\">R: 资源管理</a></li>\n<li><a href=\"#S-expr\">ES: 表达式和语句</a></li>\n<li><a href=\"#S-performance\">Per: 性能</a></li>\n<li><a href=\"#S-concurrency\">CP: 并发与并行</a></li>\n<li><a href=\"#S-errors\">E: 错误处理</a></li>\n<li><a href=\"#S-const\">Con: 常量和不可变性</a></li>\n<li><a href=\"#S-templates\">T: 模板和泛型编程</a></li>\n<li><a href=\"#S-cpl\">CPL: C 风格的编程</a></li>\n<li><a href=\"#S-source\">SF: 源文件</a></li>\n<li><a href=\"#sl-the-standard-library\">SL: 标准库</a></li>\n</ul>\n<p>配套章节：</p>\n<ul>\n<li><a href=\"#S-A\">A: 架构相关的理念</a></li>\n<li><a href=\"#S-not\">NR: 伪规则和错误的看法</a></li>\n<li><a href=\"#S-references\">RF: 参考资料</a></li>\n<li><a href=\"#S-profile\">Pro: 剖面配置</a></li>\n<li><a href=\"#gsl-guidelines-support-library\">GSL: 指导方针支持库</a></li>\n<li><a href=\"#S-naming\">NL: 命名和代码布局建议</a></li>\n<li><a href=\"#S-faq\">FAQ: 常见问题的解答</a></li>\n<li><a href=\"#S-libraries\">附录 A: 程序库</a></li>\n<li><a href=\"#S-modernizing\">附录 B: 代码的现代化转换</a></li>\n<li><a href=\"#S-discussion\">附录 C: 相关讨论</a></li>\n<li><a href=\"#S-tools\">附录 D: 支持工具</a></li>\n<li><a href=\"#S-glossary\">词汇表</a></li>\n<li><a href=\"#S-unclassified\">To-do: 未分类的规则原型</a></li>\n</ul>\n<p>章节之间并非是正交的。</p>\n<p>每个章节（比如，“P” 代表 “理念”），以及每个子章节（比如，“C.hier” 代表 “类层次（OOP）”）都有一个用以简化搜索和引用的缩写。<br>\n主章节的缩写也出现在规则编号之中（比如，“C.11” 代表 “使具体类型正规化”）。</p>\n<h1 id=\"a-names-philosophyap-理念\"><a class=\"markdownIt-Anchor\" href=\"#a-names-philosophyap-理念\">#</a> <a name=\"S-philosophy\"></a>P: 理念</h1>\n<p>本章节中的规则都非常具有一般性。</p>\n<p>理念性规则概览：</p>\n<ul>\n<li><a href=\"#Rp-direct\">P.1: 在代码中直接表达你的想法</a></li>\n<li><a href=\"#Rp-Cplusplus\">P.2: 用 ISO 标准 C++ 来编码</a></li>\n<li><a href=\"#Rp-what\">P.3: 表达你的设计意图</a></li>\n<li><a href=\"#Rp-typesafe\">P.4: 理想情况下，程序应当是静态类型安全的</a></li>\n<li><a href=\"#Rp-compile-time\">P.5: 编译期检查优先于运行时检查</a></li>\n<li><a href=\"#Rp-run-time\">P.6: 应当使无法在编译期进行的检查能够在运行时实施</a></li>\n<li><a href=\"#Rp-early\">P.7: 尽早识别运行时错误</a></li>\n<li><a href=\"#Rp-leak\">P.8: 不要泄漏任何资源</a></li>\n<li><a href=\"#Rp-waste\">P.9: 不要浪费时间或空间</a></li>\n<li><a href=\"#Rp-mutable\">P.10: 不可变数据优先于可变数据</a></li>\n<li><a href=\"#Rp-library\">P.11: 把杂乱的构造封装起来，而别让其散布到代码中</a></li>\n<li><a href=\"#Rp-tools\">P.12: 适当采用支持工具</a></li>\n<li><a href=\"#Rp-lib\">P.13: 适当采用支持程序库</a></li>\n</ul>\n<p>通常，理念性的规则都无法机械性地进行检查。<br>\n不过，这些理念主题在各个规则中都有体现。<br>\n如果没有一个理念基础的话，那些更具体、专门和可检查的规则就是缺少理论根据的了。</p>\n<h3 id=\"a-namerp-directap1-在代码中直接表达你的想法\"><a class=\"markdownIt-Anchor\" href=\"#a-namerp-directap1-在代码中直接表达你的想法\">#</a> <a name=\"Rp-direct\"></a>P.1: 在代码中直接表达你的想法</h3>\n<h5 id=\"理由\"><a class=\"markdownIt-Anchor\" href=\"#理由\">#</a> 理由</h5>\n<p>编译器是不会去读注释（或设计文档）的，许多程序员也（固执地）不去读它们。<br>\n而代码中所表达的东西是带有明确的语义的，并且（原则上）是可以由编译器和其他工具进行检验的。</p>\n<h5 id=\"示例\"><a class=\"markdownIt-Anchor\" href=\"#示例\">#</a> 示例</h5>\n<pre><code>class Date &#123;\npublic:\n    Month month() const;  // 好\n    int month();          // 不好\n    // ...\n&#125;;\n</code></pre>\n<p><code>month</code>  的第一个声明式，显然是要返回一个  <code>Month</code> ，而且不会修改  <code>Date</code>  对象的状态。<br>\n而第二个版本则需要读者进行猜测，同时带来了更多的出现难于发现 BUG 的可能性。</p>\n<h5 id=\"示例不好\"><a class=\"markdownIt-Anchor\" href=\"#示例不好\">#</a> 示例，不好</h5>\n<p>这个循环是  <code>std::find</code>  的一种能力有限的形式：</p>\n<pre><code>void f(vector&lt;string&gt;&amp; v)\n&#123;\n    string val;\n    cin &gt;&gt; val;\n    // ...\n    int index = -1;                    // 不好，而且应该使用 gsl::index\n    for (int i = 0; i &lt; v.size(); ++i) &#123;\n        if (v[i] == val) &#123;\n            index = i;\n            break;\n        &#125;\n    &#125;\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"示例好\"><a class=\"markdownIt-Anchor\" href=\"#示例好\">#</a> 示例，好</h5>\n<p>要清晰得多地表达其设计意图，可以这样：</p>\n<pre><code>void f(vector&lt;string&gt;&amp; v)\n&#123;\n    string val;\n    cin &gt;&gt; val;\n    // ...\n    auto p = find(begin(v), end(v), val);  // 好多了\n    // ...\n&#125;\n</code></pre>\n<p>用恰当设计的程序库来表达设计意图（要做什么，而不只是怎么做这些事），要远比直接使用语言功能好得多。</p>\n<p>C++ 程序员应当熟知标准库的基本知识，并在适当的时候加以利用。<br>\n任何程序员都应当熟知其所工作的项目中的基础程序库的基本知识，并适当加以利用。<br>\n使用本文档的指导方针的程序员，应当熟知<a href=\"#gsl-guidelines-support-library\">指导方针支持库</a>，并适当加以利用。</p>\n<h5 id=\"示例-2\"><a class=\"markdownIt-Anchor\" href=\"#示例-2\">#</a> 示例</h5>\n<pre><code>change_speed(double s);   // bad: s 代表什么？\n// ...\nchange_speed(2.3);\n</code></pre>\n<p>更好的方案是明确给出这个 double 的含义（新的速度还是对旧速度的增量？）以及所用单位：</p>\n<pre><code>change_speed(Speed s);    // 好多了：说明了 s 的含义\n// ...\nchange_speed(2.3);        // 错误：没有单位\nchange_speed(23_m / 10s);  // 米每秒\n</code></pre>\n<p>确实可以用普通的（没有单位的） <code>double</code>  作为增量值，但这样是易于出错的。<br>\n如果绝对速度值和增量值都需要的话，我们应当定义一个  <code>Delta</code>  类型。</p>\n<h5 id=\"强制实施\"><a class=\"markdownIt-Anchor\" href=\"#强制实施\">#</a> 强制实施</h5>\n<p>通常非常困难。</p>\n<ul>\n<li>坚持一贯地使用  <code>const</code> （检查成员函数是否会修改对象；检查函数是否会修改以指针或引用形式传递的实参）</li>\n<li>将强制转换标示出来（强制转换阉割了类型系统）</li>\n<li>检测模仿标准库的代码（困难）</li>\n</ul>\n<h3 id=\"a-namerp-cplusplusap2-用-iso-标准-c-来编码\"><a class=\"markdownIt-Anchor\" href=\"#a-namerp-cplusplusap2-用-iso-标准-c-来编码\">#</a> <a name=\"Rp-Cplusplus\"></a>P.2: 用 ISO 标准 C++ 来编码</h3>\n<h5 id=\"理由-2\"><a class=\"markdownIt-Anchor\" href=\"#理由-2\">#</a> 理由</h5>\n<p>本文档正是关于用 ISO 标准 C++ 来编码的一组指导方针。</p>\n<h5 id=\"注解\"><a class=\"markdownIt-Anchor\" href=\"#注解\">#</a> 注解</h5>\n<p>有些环境下是需要使用语言扩展的，例如有关访问系统资源的语言扩展。<br>\n这些情况下，应当将对所需语言扩展的使用局部化，并把它们的使用置于非核心的编码指导方针的控制之下。如果可能的话，应当构建一些接口来封装这些语言扩展，以使其能够被关闭，并当针对不支持这些语言扩展的系统时免除它们的编译。</p>\n<p>语言扩展通常是没有严密定义的语义的。即便语言扩展很常见，<br>\n并且在多种编译器上都有实现，它们也可能有略微不一致的行为<br>\n以及边界情形下的行为，这是<em>缺乏</em>一个严格的标准定义的<br>\n直接后果。大量使用任何这样的语言扩展，都会对代码的可移植性<br>\n造成不良影响。</p>\n<h5 id=\"注解-2\"><a class=\"markdownIt-Anchor\" href=\"#注解-2\">#</a> 注解</h5>\n<p>使用合法的 C++ 并不能保证可移植性（不管其正确性）。<br>\n应当避免依赖于未定义的行为（例如，<a href=\"#Res-order\">未定义的求值顺序</a>）<br>\n并应当关注带有由实现定义的含义的构造（例如， <code>sizeof(int)</code> ）。</p>\n<h5 id=\"注解-3\"><a class=\"markdownIt-Anchor\" href=\"#注解-3\">#</a> 注解</h5>\n<p>有些环境下是需要对标准 C++ 语言或者程序库的功能特性的使用进行限制的，例如，飞行器控制软件标准要求避免动态内存分配。<br>\n这些情况下，应当将对它们的使用（或废弃）置于对本文档针对特定环境所定制的扩充的编码指导方针之下。</p>\n<h5 id=\"强制实施-2\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-2\">#</a> 强制实施</h5>\n<p>使用最新版的 C++ 编译器（目前支持 C<ins>20 或 C</ins>17），并打开禁用语言扩展的选项。</p>\n<h3 id=\"a-namerp-whatap3-表达你的设计意图\"><a class=\"markdownIt-Anchor\" href=\"#a-namerp-whatap3-表达你的设计意图\">#</a> <a name=\"Rp-what\"></a>P.3: 表达你的设计意图</h3>\n<h5 id=\"理由-3\"><a class=\"markdownIt-Anchor\" href=\"#理由-3\">#</a> 理由</h5>\n<p>一些代码如果不（比如通过命名或者代码注释）说明其设计意图的话，是不可能搞清楚代码是否达成其预定目标的。</p>\n<h5 id=\"示例-3\"><a class=\"markdownIt-Anchor\" href=\"#示例-3\">#</a> 示例</h5>\n<pre><code>gsl::index i = 0;\nwhile (i &lt; v.size()) &#123;\n    // ... 在 v[i] 上做一些事 ...\n&#125;\n</code></pre>\n<p>这里并未表明其意图是 “单纯地” 循环访问  <code>v</code>  的元素。使用一个索引的实现细节被暴露了出来（因而可能导致被误用），而且  <code>i</code>  的存在超出了循环的范围，这也许符合也许违背了设计意图。读者仅从这段代码中是无法了解清楚的。</p>\n<p>更好的方式是：</p>\n<pre><code>for (const auto&amp; x : v) &#123; /* 用 x 的值做一些事 */ &#125;\n</code></pre>\n<p>现在，循环机制不明确给出，而且循环的操作针对的是  <code>const</code>  元素，以防止发生意外的修改。如果需要进行修改的话，则可以这样：</p>\n<pre><code>for (auto&amp; x : v) &#123; /* 修改 x */ &#125;\n</code></pre>\n<p><code>for</code>  语句的更多细节，请参见 <a href=\"#Res-for-range\">ES.71</a>。<br>\n有时候，使用具名的算法会更好。 这个示例使用 Ranges TS 中的  <code>for_each</code> ，因为它直接表达了意图：</p>\n<pre><code>for_each(v, [](int x) &#123; /* 用 x 的值做一些事 */ &#125;);\nfor_each(par, v, [](int x) &#123; /* 用 x 的值做一些事 */ &#125;);\n</code></pre>\n<p>最后一种写法让人明白，我们对按照何种顺序来处理  <code>v</code>  的各个元素并不关心。</p>\n<p>程序员应当熟悉：</p>\n<ul>\n<li><a href=\"#gsl-guidelines-support-library\">指导方针支持库</a></li>\n<li><a href=\"#sl-the-standard-library\">ISO C++ 标准库</a></li>\n<li>当前项目所使用的任何基础程序库</li>\n</ul>\n<h5 id=\"注解-4\"><a class=\"markdownIt-Anchor\" href=\"#注解-4\">#</a> 注解</h5>\n<p>其他形式：说明要做什么，而不只是怎么做这些事。</p>\n<h5 id=\"注解-5\"><a class=\"markdownIt-Anchor\" href=\"#注解-5\">#</a> 注解</h5>\n<p>一些语言构造比另一些可以更好地表达设计意图。</p>\n<h5 id=\"示例-4\"><a class=\"markdownIt-Anchor\" href=\"#示例-4\">#</a> 示例</h5>\n<p>如果要用两个  <code>int</code>  来代表二维点的坐标值，应当这样：</p>\n<pre><code>draw_line(int, int, int, int);  // 含混的\ndraw_line(Point, Point);        // 清晰的\n</code></pre>\n<h5 id=\"强制实施-3\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-3\">#</a> 强制实施</h5>\n<p>查找具有更加替代方案的一般模式：</p>\n<ul>\n<li>简单  <code>for</code>  循环 vs. 范围式  <code>for</code>  循环</li>\n<li><code>f(T*, int)</code>  接口 vs.  <code>f(span&lt;T&gt;)</code>  接口</li>\n<li>循环变量出现在过大的范围中</li>\n<li>裸的  <code>new</code>  和  <code>delete</code></li>\n<li>带有大量内建类型的形参的函数</li>\n</ul>\n<p>在聪敏的人工处理和半自动的程序变换之间存在巨大的空间。</p>\n<h3 id=\"a-namerp-typesafeap4-理想情况下程序应当是静态类型安全的\"><a class=\"markdownIt-Anchor\" href=\"#a-namerp-typesafeap4-理想情况下程序应当是静态类型安全的\">#</a> <a name=\"Rp-typesafe\"></a>P.4: 理想情况下，程序应当是静态类型安全的</h3>\n<h5 id=\"理由-4\"><a class=\"markdownIt-Anchor\" href=\"#理由-4\">#</a> 理由</h5>\n<p>理想情况下，程序应当完全是静态（编译期）类型安全的。<br>\n不幸的是，这是不可能的。有问题的领域：</p>\n<ul>\n<li><code>union</code></li>\n<li>强制转换</li>\n<li>数组退化</li>\n<li>范围错误</li>\n<li>窄化转换</li>\n</ul>\n<h5 id=\"注解-6\"><a class=\"markdownIt-Anchor\" href=\"#注解-6\">#</a> 注解</h5>\n<p>这些领域是许多严重问题（如程序崩溃和安全性违规）的来源。<br>\n我们争取为它们给出替代技术。</p>\n<h5 id=\"强制实施-4\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-4\">#</a> 强制实施</h5>\n<p>如果程序各自需要或者条件允许的话，我们可以逐个对这些问题类型分别进行阻止、克制或者检测。<br>\n我们总会给出替代方案。<br>\n例如：</p>\n<ul>\n<li><code>union</code>  - 使用  <code>variant</code> （C++17 提供）</li>\n<li>强制转换 - 尽可能减少其使用；使用模板有助于这点</li>\n<li>数组退化 - 使用  <code>span</code> （来自 GSL）</li>\n<li>范围错误 - 使用  <code>span</code></li>\n<li>窄化转换 - 尽可能减少其使用，必须使用时则使用  <code>narrow</code>  或者  <code>narrow_cast</code> （来自 GSL）</li>\n</ul>\n<h3 id=\"a-namerp-compile-timeap5-编译期检查优先于运行时检查\"><a class=\"markdownIt-Anchor\" href=\"#a-namerp-compile-timeap5-编译期检查优先于运行时检查\">#</a> <a name=\"Rp-compile-time\"></a>P.5: 编译期检查优先于运行时检查</h3>\n<h5 id=\"理由-5\"><a class=\"markdownIt-Anchor\" href=\"#理由-5\">#</a> 理由</h5>\n<p>为了代码清晰性和性能。<br>\n对于编译期识别的错误是不需要编写错误处理的。</p>\n<h5 id=\"示例-5\"><a class=\"markdownIt-Anchor\" href=\"#示例-5\">#</a> 示例</h5>\n<pre><code>// Int 被用作整数的别名\nint bits = 0;         // 请勿如此: 可以避免的代码\nfor (Int i = 1; i; i &lt;&lt;= 1)\n    ++bits;\nif (bits &lt; 32)\n    cerr &lt;&lt; &quot;Int too small\\n&quot;;\n</code></pre>\n<p>这个例子并没有达成其所要达成的目的（因为溢出是未定义行为），应当被替换为简单的  <code>static_assert</code> ：</p>\n<pre><code>// Int 被用作整数的别名\nstatic_assert(sizeof(Int) &gt;= 4);    // do: 编译时检查\n</code></pre>\n<p>或者更好的方式是直接利用类型系统，将  <code>int</code>  替换  <code>int32_t</code> 。</p>\n<h5 id=\"示例-6\"><a class=\"markdownIt-Anchor\" href=\"#示例-6\">#</a> 示例</h5>\n<pre><code>void read(int* p, int n);   // 读取至多 n 个整数到 *p 之中\n\nint a[100];\nread(a, 1000);    // 不好，超过末尾了\n</code></pre>\n<p>更好的做法是</p>\n<pre><code>void read(span&lt;int&gt; r); // 读取到整数区域范围 r 之中\n\nint a[100];\nread(a);        // 好多了: 让编译器确定元素数量\n</code></pre>\n<p><strong>替代形式</strong>：不要把可以在编译期搞定的事推后到运行时进行。</p>\n<h5 id=\"强制实施-5\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-5\">#</a> 强制实施</h5>\n<ul>\n<li>查找指针参数。</li>\n<li>查找运行时进行的范围违反检查。</li>\n</ul>\n<h3 id=\"a-namerp-run-timeap6-应当使无法在编译期进行的检查能够在运行时实施\"><a class=\"markdownIt-Anchor\" href=\"#a-namerp-run-timeap6-应当使无法在编译期进行的检查能够在运行时实施\">#</a> <a name=\"Rp-run-time\"></a>P.6: 应当使无法在编译期进行的检查能够在运行时实施</h3>\n<h5 id=\"理由-6\"><a class=\"markdownIt-Anchor\" href=\"#理由-6\">#</a> 理由</h5>\n<p>把难于检测的错误遗留在程序中，总会带来程序崩溃或得到错误的运行结果。</p>\n<h5 id=\"注解-7\"><a class=\"markdownIt-Anchor\" href=\"#注解-7\">#</a> 注解</h5>\n<p>理想情况下我们可以在编译期或者运行时识别所有的错误（它们并非程序员的逻辑错误）。但是要在编译期识别所有的错误是不可能的，而通常也负担不起在运行时识别剩余的全部错误的代价。不过我们编写程序，应当尽量使其在原则上是可以在充足的（分析程序，运行时检查，机器资源，时间等）资源下进行检查的。</p>\n<h5 id=\"示例不好-2\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-2\">#</a> 示例，不好</h5>\n<pre><code>// 分离编译，可能会被动态加载\nextern void f(int* p);\n\nvoid g(int n)\n&#123;\n    // 不好的：并未把元素数量传递给 f()\n    f(new int[n]);\n&#125;\n</code></pre>\n<p>此处，关键性的信息（元素数量）被完全掩盖起来，使其无法进行静态分析，而如果  <code>f()</code>  属于某个 ABI 的一部分的话，由于无法对这个指针进行 “测量插装”，运行时检查也是不可行的。我们确实可以在自由存储中插入有助于检查的信息，但这需要对系统甚至是编译器做出整体改动。这就是一个能让错误检查变得非常困难的设计。</p>\n<h5 id=\"示例不好-3\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-3\">#</a> 示例，不好</h5>\n<p>当然可以把元素数量和指针一起进行传递：</p>\n<pre><code>// 分离编译，可能会被动态加载\nextern void f2(int* p, int n);\n\nvoid g2(int n)\n&#123;\n    f2(new int[n], m);  // 不好的：可能会把错误的元素数量传递给 f()\n&#125;\n</code></pre>\n<p>把元素数量作为一个参数进行传递，比只传递指针而依靠某种（不明确的）对已知元素个数的约定或者找出元素个数的方式，要好得多，而且是更加常见的做法。但是如上所示，一个简单的错字就可以引入一个严重的错误。 <code>f2()</code>  的两个参数之间的关联是基于约定的，而并不明确。</p>\n<p>而且，这里还隐含假定  <code>f2()</code>  应当  <code>delete</code>  其参数（要不然就是调用者又犯了另一个错误）。</p>\n<h5 id=\"示例不好-4\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-4\">#</a> 示例，不好</h5>\n<p>使用标准库的资源管理指针指向对象时，也不能传递其大小：</p>\n<pre><code>// 分离编译，可能会被动态加载\n// NB: 这里假定调用代码是 ABI 兼容的，使用的是\n// 兼容的 C++ 编译器和同一个 stdlib 实现\nextern void f3(unique_ptr&lt;int[]&gt;, int n);\n\nvoid g3(int n)\n&#123;\n    f3(make_unique&lt;int[]&gt;(n), m);    // 不好的：把所有权和大小分开进行传递\n&#125;\n</code></pre>\n<h5 id=\"示例-7\"><a class=\"markdownIt-Anchor\" href=\"#示例-7\">#</a> 示例</h5>\n<p>我们得把指针和元素数量作为一个对象整体来进行传递：</p>\n<pre><code>extern void f4(vector&lt;int&gt;&amp;);   // 分离编译，可能会被动态加载\nextern void f4(span&lt;int&gt;);      // 分离编译，可能会被动态加载\n                                // NB: 这里假定调用代码是 ABI 兼容的，使用的是\n                                // 兼容的 C++ 编译器和同一个 stdlib 实现\n\nvoid g3(int n)\n&#123;\n    vector&lt;int&gt; v(n);\n    f4(v);                     // 传递引用，保留所有权\n    f4(span&lt;int&gt;&#123;v&#125;);          // 传递视图，保留所有权\n&#125;\n</code></pre>\n<p>这个设计将元素数量作为对象的固有部分，因此不太可能有错误，动态（运行时的）检查即使不总是可承担的，也总是可行的。</p>\n<h5 id=\"示例-8\"><a class=\"markdownIt-Anchor\" href=\"#示例-8\">#</a> 示例</h5>\n<p>如果把所有权和验证所需的全部信息一起传递的话会怎么样呢？</p>\n<pre><code>vector&lt;int&gt; f5(int n)    // OK: 移动\n&#123;\n    vector&lt;int&gt; v(n);\n    // ... 初始化 v ...\n    return v;\n&#125;\n\nunique_ptr&lt;int[]&gt; f6(int n)    // 不好的：缺失了 n\n&#123;\n    auto p = make_unique&lt;int[]&gt;(n);\n    // ... 初始化 *p ...\n    return p;\n&#125;\n\nowner&lt;int*&gt; f7(int n)    // 不好的：缺失了 n 并且我们可能会忘记 delete\n&#123;\n    owner&lt;int*&gt; p = new int[n];\n    // ... 初始化 *p ...\n    return p;\n&#125;\n</code></pre>\n<h5 id=\"示例-9\"><a class=\"markdownIt-Anchor\" href=\"#示例-9\">#</a> 示例</h5>\n<ul>\n<li>???</li>\n<li>展示传递多态基类的接口是如何避开可能进行的检查的，但它们实际上直到它们需要的类型？<br>\n还有用字符串当作 “自由式” 选项的做法</li>\n</ul>\n<h5 id=\"强制实施-6\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-6\">#</a> 强制实施</h5>\n<ul>\n<li>标示出 (pointer, count) 形式的接口（这将标示出大量的因为兼容性原因而无法进行修正的实例）</li>\n<li>???</li>\n</ul>\n<h3 id=\"a-namerp-earlyap7-尽早识别运行时错误\"><a class=\"markdownIt-Anchor\" href=\"#a-namerp-earlyap7-尽早识别运行时错误\">#</a> <a name=\"Rp-early\"></a>P.7: 尽早识别运行时错误</h3>\n<h5 id=\"理由-7\"><a class=\"markdownIt-Anchor\" href=\"#理由-7\">#</a> 理由</h5>\n<p>避免 “神秘的” 程序崩溃。<br>\n避免能够产生（也许无法识别的）错误结果的程序错误。</p>\n<h5 id=\"示例-10\"><a class=\"markdownIt-Anchor\" href=\"#示例-10\">#</a> 示例</h5>\n<pre><code>void increment1(int* p, int n)    // 不好的：易于出错\n&#123;\n    for (int i = 0; i &lt; n; ++i) ++p[i];\n&#125;\n\nvoid use1(int m)\n&#123;\n    const int n = 10;\n    int a[n] = &#123;&#125;;\n    // ...\n    increment1(a, m);   // 可能是打错字，可能假定有 m &lt;= n\n                        // 不过让我们假设 m == 20\n    // ...\n&#125;\n</code></pre>\n<p>我们在  <code>use1</code>  里面犯了一个能够导致数据损坏或程序崩溃的小错误。<br>\n这个 (pointer, count) 形式的接口让  <code>increment1()</code>  没有可以使其防范越界错误的任何现实可行的方式。<br>\n如果我们可以检测到越界访问的下标的话，那么这个错误直到对  <code>p[10]</code>  进行访问之前都不会被发现。<br>\n我们可以提早进行检查来改进这个代码：</p>\n<pre><code>void increment2(span&lt;int&gt; p)\n&#123;\n    for (int&amp; x : p) ++x;\n&#125;\n\nvoid use2(int m)\n&#123;\n    const int n = 10;\n    int a[n] = &#123;&#125;;\n    // ...\n    increment2(&#123;a, m&#125;);    // 可能是打错字，可能假定有 m&lt;=n\n    // ...\n&#125;\n</code></pre>\n<p>现在，就可以在调用点（提早地）检查  <code>m &lt;= n</code> ，而不是更晚进行了。<br>\n如果我们只是打错了字而本想用  <code>n</code>  作为边界值的话，代码还可以进一步简化（来消除一处错误的可能性）：</p>\n<pre><code>void use3(int m)\n&#123;\n    const int n = 10;\n    int a[n] = &#123;&#125;;\n    // ...\n    increment2(a);   // 不需要重复给出 a 的元素数量\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"示例不好-5\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-5\">#</a> 示例，不好</h5>\n<p>不要对同一个值重复进行检查。不要用字符串来传递有结构的数据：</p>\n<pre><code>Date read_date(istream&amp; is);    // 从 istream 读取日期\n\nDate extract_date(const string&amp; s);    // 从 string 中抽取日期\n\nvoid user1(const string&amp; date)    // 操作 date\n&#123;\n    auto d = extract_date(date);\n    // ...\n&#125;\n\nvoid user2()\n&#123;\n    Date d = read_date(cin);\n    // ...\n    user1(d.to_string());\n    // ...\n&#125;\n</code></pre>\n<p>这个日期被（ <code>Date</code>  的构造函数）验证了两次，并以字符串（无结构的数据）的形式来传递。</p>\n<h5 id=\"示例-11\"><a class=\"markdownIt-Anchor\" href=\"#示例-11\">#</a> 示例</h5>\n<p>过量的检查可能是代价昂贵的。<br>\n有些情况下提早检查可能会很低效，因为你可能根本不需要这个值，或者可能仅需要值的一部分，而这要比进行整体的检查容易得多。同样来说，不要添加能够改变接口的渐进式行为的验证性检查（例如，不要在平均复杂度为  <code>O(1)</code>  的接口中添加一个  <code>O(n)</code>  的检查）。</p>\n<pre><code>class Jet &#123;    // 物理规则是: e * e &lt; x * x + y * y + z * z\n    float x;\n    float y;\n    float z;\n    float e;\npublic:\n    Jet(float x, float y, float z, float e)\n        :x(x), y(y), z(z), e(e)\n    &#123;\n        // 应不应该在这里检查这些值是物理上有意义的？\n    &#125;\n\n    float m() const\n    &#123;\n        // 应不应该处理这里的退化情形？\n        return sqrt(x * x + y * y + z * z - e * e);\n    &#125;\n\n    ???\n&#125;;\n</code></pre>\n<p>喷流（Jet）的物理定律（ <code>e * e &lt; x * x + y * y + z * z</code> ），由于可能存在测量误差的缘故并不是不变式。</p>\n<p>???</p>\n<h5 id=\"强制实施-7\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-7\">#</a> 强制实施</h5>\n<ul>\n<li>查找指针和数组：提早且不要重复进行范围检查</li>\n<li>查找类型转换：消除或标示出窄化转换</li>\n<li>查找未经检查的来自输入的值。</li>\n<li>查找被转换成字符串的结构化数据（带有不变式的类的对象）</li>\n<li>???</li>\n</ul>\n<h3 id=\"a-namerp-leakap8-不要泄漏任何资源\"><a class=\"markdownIt-Anchor\" href=\"#a-namerp-leakap8-不要泄漏任何资源\">#</a> <a name=\"Rp-leak\"></a>P.8: 不要泄漏任何资源</h3>\n<h5 id=\"理由-8\"><a class=\"markdownIt-Anchor\" href=\"#理由-8\">#</a> 理由</h5>\n<p>即使是缓慢的资源增长，随着时间推移，也会耗尽这些资源的可用性。<br>\n这对于长时间运行的程序来说尤其重要，而且是负责任的编程行为的基础方面。</p>\n<h5 id=\"示例不好-6\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-6\">#</a> 示例，不好</h5>\n<pre><code>void f(char* name)\n&#123;\n    FILE* input = fopen(name, &quot;r&quot;);\n    // ...\n    if (something) return;   // 不好的：如果 something == true 的话，将会泄漏一个文件句柄\n    // ...\n    fclose(input);\n&#125;\n</code></pre>\n<p>建议采用 <a href=\"#Rr-raii\">RAII</a>：</p>\n<pre><code>void f(char* name)\n&#123;\n    ifstream input &#123;name&#125;;\n    // ...\n    if (something) return;   // OK: 没有泄漏\n    // ...\n&#125;\n</code></pre>\n<p><strong>参见</strong>: <a href=\"#S-resource\">资源管理相关章节</a></p>\n<h5 id=\"注解-8\"><a class=\"markdownIt-Anchor\" href=\"#注解-8\">#</a> 注解</h5>\n<p>通俗地说，泄漏就是 “有东西没清理干净”。<br>\n一种更重要的分类方式是 “有东西无法再被清理干净”。<br>\n例如，在堆上分配一个对象，然后又丢失了最后一个指向这份分配物的指针。<br>\n不应当将这条规则误读为，要求在程序终止时必须把长期存活的对象中的分配物进行回收。<br>\n例如，依赖于系统所保证的进程停止时进行的文件关闭和内存回收行为可以简化代码。<br>\n然而，依赖于进行隐式清理的抽象机制同样简单，而且通常更加安全。</p>\n<h5 id=\"注解-9\"><a class=\"markdownIt-Anchor\" href=\"#注解-9\">#</a> 注解</h5>\n<p>强制实行<a href=\"#SS-lifetime\">生存期安全性剖面配置</a>可以消除泄漏的发生。<br>\n如果和 <a href=\"#Rr-raii\">RAII</a> 所提供的资源安全性组合到一起，也可以（通过不产生任何垃圾而）消除对 “垃圾收集” 的需要。<br>\n如果将之和<a href=\"#SS-force\">类型和边界剖面配置</a> 组合到一起强制实施的话，你将会得到完全的类型和资源安全性，这是通过使用工具来保证的。</p>\n<h5 id=\"强制实施-8\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-8\">#</a> 强制实施</h5>\n<ul>\n<li>查找指针：把它们分成非所有者（默认情形）和所有者。<br>\n如果可行的话，把所有者替换为标准库的资源封装类（如上例所示）。<br>\n或者，也可以把这种所有者用 <a href=\"#gsl-guidelines-support-library\">GSL</a> 中的  <code>owner</code>  进行标记。</li>\n<li>查找裸露的  <code>new</code>  和  <code>delete</code></li>\n<li>查找已知的返回原始指针的资源分配函数（诸如  <code>fopen</code> ， <code>malloc</code> ，和  <code>strdup</code>  等）</li>\n</ul>\n<h3 id=\"a-namerp-wasteap9-不要浪费时间或空间\"><a class=\"markdownIt-Anchor\" href=\"#a-namerp-wasteap9-不要浪费时间或空间\">#</a> <a name=\"Rp-waste\"></a>P.9: 不要浪费时间或空间</h3>\n<h5 id=\"理由-9\"><a class=\"markdownIt-Anchor\" href=\"#理由-9\">#</a> 理由</h5>\n<p>你用的语言是 C++。</p>\n<h5 id=\"注解-10\"><a class=\"markdownIt-Anchor\" href=\"#注解-10\">#</a> 注解</h5>\n<p>为达成某个目标（例如开发速度，资源安全性，或者测试的简化等）而正当花费的时间和空间是不会被浪费的。<br>\n“力求高效的另一种好处是，这一过程将强迫你更深入地理解问题。”—— Alex Stepanov</p>\n<h5 id=\"示例不好-7\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-7\">#</a> 示例，不好</h5>\n<pre><code>struct X &#123;\n    char ch;\n    int i;\n    string s;\n    char ch2;\n\n    X&amp; operator=(const X&amp; a);\n    X(const X&amp;);\n&#125;;\n\nX waste(const char* p)\n&#123;\n    if (!p) throw Nullptr_error&#123;&#125;;\n    int n = strlen(p);\n    auto buf = new char[n];\n    if (!buf) throw Allocation_error&#123;&#125;;\n    for (int i = 0; i &lt; n; ++i) buf[i] = p[i];\n    // ... 对缓冲区进行操作 ...\n    X x;\n    x.ch = 'a';\n    x.s = string(n);    // 在 x.s 上预留 *p 的空间\n    for (gsl::index i = 0; i &lt; x.s.size(); ++i) x.s[i] = buf[i];  // 把 buf 复制给 x.s\n    delete[] buf;\n    return x;\n&#125;\n\nvoid driver()\n&#123;\n    X x = waste(&quot;Typical argument&quot;);\n    // ...\n&#125;\n</code></pre>\n<p>这个确实有些夸张，但我们在产品代码中能够见到这里所犯的每个错误，甚至更糟糕。<br>\n注意， <code>X</code>  的布局保证会浪费至少 6 个字节，而且很可能更多。<br>\n错误的复制操作的定义式废掉了移动语义，使返回操作变得更慢<br>\n（请注意这里并不会保证进行返回值优化（RVO））。<br>\n为  <code>buf</code>  使用的  <code>new</code>  和  <code>delete</code>  是多余的；如果确实想要一个局部的字符串的话，我们应当使用局部的  <code>string</code> 。<br>\n还有几个其他的性能 BUG 和无理由的复杂性。</p>\n<h5 id=\"示例不好-8\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-8\">#</a> 示例，不好</h5>\n<pre><code>void lower(zstring s)\n&#123;\n    for (int i = 0; i &lt; strlen(s); ++i) s[i] = tolower(s[i]);\n&#125;\n</code></pre>\n<p>这个其实是一个来自产品代码的例子。<br>\n可以看到这里有一句  <code>i &lt; strlen(s)</code> 。这个表达式在循环的每次重复中都要求值，这意味着每次循环中  <code>strlen</code>  都必须走完字符串以确定其长度。我们假定在改动字符串内容过程中 <code>tolower</code>  不会影响字符串的长度，因此最好在循环外面缓存长度值，而不是在每次重复中都承担其代价。</p>\n<h5 id=\"注解-11\"><a class=\"markdownIt-Anchor\" href=\"#注解-11\">#</a> 注解</h5>\n<p>单个造成浪费的范例很少是显著的，而一旦它是显著的，通常也可以被高手轻易地清除掉。<br>\n但是，代码库中放任地到处散布的浪费情况，则很容易变得显著，而高手们又不像我们期望那样总是有空的。<br>\n本条规则（以及其他配套的更加具体的规则）的目的是，将与 C++ 语言的使用有关的大多数浪费情况，在其发生之前就将之清除掉。<br>\n在这之后，我们就可以查找与算法和需求有关的浪费情况了，但这超出了我们的指导方针的范畴。</p>\n<h5 id=\"强制实施-9\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-9\">#</a> 强制实施</h5>\n<p>许多更加具体的规则都是针对追求简单性并清除无理由浪费的总体目标的。</p>\n<ul>\n<li>当用户定义的非预置后缀  <code>operator++</code>  或  <code>operator--</code>  函数的返回值未被使用时进行标记。优先代之以采用前缀形式。（注：使用 “用户定义的非预置” 是为了减弱噪声。若实践中噪声还是很显著则需要重新审视这条强制措施。）</li>\n</ul>\n<h3 id=\"a-namerp-mutableap10-不可变数据优先于可变数据\"><a class=\"markdownIt-Anchor\" href=\"#a-namerp-mutableap10-不可变数据优先于可变数据\">#</a> <a name=\"Rp-mutable\"></a>P.10: 不可变数据优先于可变数据</h3>\n<h5 id=\"理由-10\"><a class=\"markdownIt-Anchor\" href=\"#理由-10\">#</a> 理由</h5>\n<p>对常量进行推理要比变量简单得多。<br>\n不可变的事物是不可能被意外改变的。<br>\n不可变性有时候也带来更好地进行优化的机会。<br>\n在常量上不会出现数据竞争。</p>\n<p>另见 <a href=\"#S-const\">Con: 常量和不可变性</a></p>\n<h3 id=\"a-namerp-libraryap11-把杂乱的构造封装起来而别让其散布到代码中\"><a class=\"markdownIt-Anchor\" href=\"#a-namerp-libraryap11-把杂乱的构造封装起来而别让其散布到代码中\">#</a> <a name=\"Rp-library\"></a>P.11: 把杂乱的构造封装起来，而别让其散布到代码中</h3>\n<h5 id=\"理由-11\"><a class=\"markdownIt-Anchor\" href=\"#理由-11\">#</a> 理由</h5>\n<p>杂乱的代码更有可能隐藏有 Bug 而且难于编写。<br>\n而好的接口使用起来更容易和安全。<br>\n杂乱的，底层的代码会混杂出更多这样的代码。</p>\n<h5 id=\"示例-12\"><a class=\"markdownIt-Anchor\" href=\"#示例-12\">#</a> 示例</h5>\n<pre><code>int sz = 100;\nint* p = (int*) malloc(sizeof(int) * sz);\nint count = 0;\n// ...\nfor (;;) &#123;\n    // ... 读取一个 int 到 x 中，如果达到文件尾就退出循环 ...\n    // ... 检查 x 有效 ...\n    if (count == sz)\n        p = (int*) realloc(p, sizeof(int) * sz * 2);\n    p[count++] = x;\n    // ...\n&#125;\n</code></pre>\n<p>这段代码是低层的，啰嗦的，而且易错的。<br>\n比如说，我们就 “忘了” 检查内存耗尽情况。<br>\n我们可以代之以使用  <code>vector</code> ：</p>\n<pre><code>vector&lt;int&gt; v;\nv.reserve(100);\n// ...\nfor (int x; cin &gt;&gt; x; ) &#123;\n    // ... 检查 x is 有效 ...\n    v.push_back(x);\n&#125;\n</code></pre>\n<h5 id=\"注解-12\"><a class=\"markdownIt-Anchor\" href=\"#注解-12\">#</a> 注解</h5>\n<p>标准库和 GSL 都是这种理念的例子。<br>\n例如，我们并不使用混乱的数组，联合体，强制转换，麻烦的生存期问题， <code>gsl::owner</code> ，等等，<br>\n它们用于实现一些关键抽象，诸如  <code>vector</code> ， <code>span</code> ， <code>lock_guard</code> ，以及  <code>future</code> ，我们使用的是<br>\n一般来说比我们有更多时间和专业能力的人所设计和实现的程序库。<br>\n类似地，我们也能够而且应该设计并实现更专门的程序库，而不是将其留给用户（通常是我们自己）<br>\n来面对需要重复把低级代码搞正确的挑战。<br>\n这是作为指导方针基石的<a href=\"#R0\">超集的子集原则</a>的一种变体。</p>\n<h5 id=\"强制实施-10\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-10\">#</a> 强制实施</h5>\n<ul>\n<li>查找如复杂指针操作和在抽象的实现外面进行强制转换这样的 “混乱代码”。</li>\n</ul>\n<h3 id=\"a-namerp-toolsap12-适当采用支持工具\"><a class=\"markdownIt-Anchor\" href=\"#a-namerp-toolsap12-适当采用支持工具\">#</a> <a name=\"Rp-tools\"></a>P.12: 适当采用支持工具</h3>\n<h5 id=\"理由-12\"><a class=\"markdownIt-Anchor\" href=\"#理由-12\">#</a> 理由</h5>\n<p>许多事情机器都比人做得更好。<br>\n对于重复劳动，计算机既不会累也不会厌烦。<br>\n相对于重复性的例行任务，我们通常可以做一些更有意义的事情。</p>\n<h5 id=\"示例-13\"><a class=\"markdownIt-Anchor\" href=\"#示例-13\">#</a> 示例</h5>\n<p>运行静态分析工具来验证你的代码是否遵循了你想要遵循的指导方针。</p>\n<h5 id=\"注解-13\"><a class=\"markdownIt-Anchor\" href=\"#注解-13\">#</a> 注解</h5>\n<p>参见</p>\n<ul>\n<li><a href=\"???\">静态分析工具</a></li>\n<li><a href=\"#Rconc-tools\">并发工具</a></li>\n<li><a href=\"???\">测试工具</a></li>\n</ul>\n<p>还有许多其他种类的工具，诸如源代码仓库和构建工具等等，<br>\n但这些超出了本指导方针的范围。</p>\n<h5 id=\"注解-14\"><a class=\"markdownIt-Anchor\" href=\"#注解-14\">#</a> 注解</h5>\n<p>当心不要变得对过于详细定制的或者过于专门的工具链产生依赖。<br>\n它们会使得你本来可移植的代码变得不可移植。</p>\n<h3 id=\"a-namerp-libap13-适当采用支持程序库\"><a class=\"markdownIt-Anchor\" href=\"#a-namerp-libap13-适当采用支持程序库\">#</a> <a name=\"Rp-lib\"></a>P.13: 适当采用支持程序库</h3>\n<h5 id=\"理由-13\"><a class=\"markdownIt-Anchor\" href=\"#理由-13\">#</a> 理由</h5>\n<p>使用设计良好，文档全面，并且有良好支持的程序库可以节省时间和工作量；<br>\n如果你的大部分工时都必须耗费在实现上的话，<br>\n程序库的质量和文档很可能要比你能做到的要好得多。<br>\n程序库的成本（时间，工作量和资金等等）可以由大量的用户所分担。<br>\n一个被广泛应用的程序库，远比一个独立的应用程序更加能够保持为最新状态，并被移植到新的系统之上。<br>\n对于被广泛应用的程序库的相关知识，也可以节省其他或未来的项目中的时间。<br>\n因此，如果你的应用领域中存在合适的程序库的话，请使用它。</p>\n<h5 id=\"示例-14\"><a class=\"markdownIt-Anchor\" href=\"#示例-14\">#</a> 示例</h5>\n<pre><code>std::sort(begin(v), end(v), std::greater&lt;&gt;());\n</code></pre>\n<p>如果你不是排序算法方面的专家而且有大量时间的话，<br>\n这样的代码比你为特定的应用所编写的任何代码都更可能正确并且运行得更快。<br>\n不使用标准库（或者你的应用所采用的基础程序库）是需要明确理由的，而不是反过来。</p>\n<h5 id=\"注解-15\"><a class=\"markdownIt-Anchor\" href=\"#注解-15\">#</a> 注解</h5>\n<p>默认应当优先使用</p>\n<ul>\n<li><a href=\"#sl-the-standard-library\">ISO C++ 标准库</a></li>\n<li><a href=\"#gsl-guidelines-support-library\">指导方针支持库</a></li>\n</ul>\n<h5 id=\"注解-16\"><a class=\"markdownIt-Anchor\" href=\"#注解-16\">#</a> 注解</h5>\n<p>如果某个重要的领域中不存在设计良好，文档全面，并且有良好支持的程序库的话，<br>\n可能应当由你来设计并实现它，再进行使用了。</p>\n<h1 id=\"a-names-interfacesai-接口\"><a class=\"markdownIt-Anchor\" href=\"#a-names-interfacesai-接口\">#</a> <a name=\"S-interfaces\"></a>I: 接口</h1>\n<p>接口是程序中的两个部分之间的契约。严格地规定服务提供者和该服务使用者的预期是必要的。<br>\n在代码的组织中，良好的接口（易于理解，促进高效的使用方式，不易出错，支持进行测试，等等）可能是最重要的单个方面了。</p>\n<p>接口规则概览：</p>\n<ul>\n<li><a href=\"#Ri-explicit\">I.1: 使接口明确</a></li>\n<li><a href=\"#Ri-global\">I.2: 避免非  <code>const</code>  全局变量</a></li>\n<li><a href=\"#Ri-singleton\">I.3: 避免使用单例</a></li>\n<li><a href=\"#Ri-typed\">I.4: 使接口严格和强类型化</a></li>\n<li><a href=\"#Ri-pre\">I.5: 说明前条件（如果有）</a></li>\n<li><a href=\"#Ri-expects\">I.6: 优先使用  <code>Expects()</code>  来表达前条件</a></li>\n<li><a href=\"#Ri-post\">I.7: 说明后条件</a></li>\n<li><a href=\"#Ri-ensures\">I.8: 优先使用  <code>Ensures()</code>  来表达后条件</a></li>\n<li><a href=\"#Ri-concepts\">I.9: 当接口是模板时，用概念来文档化其参数</a></li>\n<li><a href=\"#Ri-except\">I.10: 使用异常来表明无法实施所要求的任务</a></li>\n<li><a href=\"#Ri-raw\">I.11: 决不以原始指针（ <code>T*</code> ）或引用（ <code>T&amp;</code> ）来传递所有权</a></li>\n<li><a href=\"#Ri-nullptr\">I.12: 把不能为空的指针声明为  <code>not_null</code> </a></li>\n<li><a href=\"#Ri-array\">I.13: 不要只用一个指针来传递数组</a></li>\n<li><a href=\"#Ri-global-init\">I.22: 避免全局对象之间进行复杂的初始化</a></li>\n<li><a href=\"#Ri-nargs\">I.23: 保持较少的函数参数数量</a></li>\n<li><a href=\"#Ri-unrelated\">I.24: 避免可以由同一组实参以不同顺序调用造成不同含义的相邻形参</a></li>\n<li><a href=\"#Ri-abstract\">I.25: 优先以空抽象类作为类层次的接口</a></li>\n<li><a href=\"#Ri-abi\">I.26: 当想要跨编译器的 ABI 时，使用一个 C 风格的语言子集</a></li>\n<li><a href=\"#Ri-pimpl\">I.27: 对于稳定的程序库 ABI，考虑使用 Pimpl 手法</a></li>\n<li><a href=\"#Ri-encapsulate\">I.30: 将有违规则的部分封装</a></li>\n</ul>\n<p><strong>参见</strong></p>\n<ul>\n<li><a href=\"#S-functions\">F: 函数</a></li>\n<li><a href=\"#SS-concrete\">C.concrete: 具体类型</a></li>\n<li><a href=\"#SS-hier\">C.hier: 类层次</a></li>\n<li><a href=\"#SS-overload\">C.over: 函数重载和重载运算符</a></li>\n<li><a href=\"#SS-containers\">C.con: 容器和其他资源封装类</a></li>\n<li><a href=\"#S-errors\">E: 错误处理</a></li>\n<li><a href=\"#S-templates\">T: 模板和泛型编程</a></li>\n</ul>\n<h3 id=\"a-nameri-explicitai1-使接口明确\"><a class=\"markdownIt-Anchor\" href=\"#a-nameri-explicitai1-使接口明确\">#</a> <a name=\"Ri-explicit\"></a>I.1: 使接口明确</h3>\n<h5 id=\"理由-14\"><a class=\"markdownIt-Anchor\" href=\"#理由-14\">#</a> 理由</h5>\n<p>正确性。未在接口中规定的假设很容易被忽视而且难于测试。</p>\n<h5 id=\"示例不好-9\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-9\">#</a> 示例，不好</h5>\n<p>通过全局（命名空间作用域）变量（调用模式）来控制函数的行为，是隐含的，而且潜在会造成困惑。例如：</p>\n<pre><code>int round(double d)\n&#123;\n    return (round_up) ? ceil(d) : d;    // 请勿：“不可见的”依赖\n&#125;\n</code></pre>\n<p>两次调用  <code>round(7.2)</code>  的含义可能给出不同的结果，这对于调用者来说是不明显的。</p>\n<h5 id=\"例外\"><a class=\"markdownIt-Anchor\" href=\"#例外\">#</a> 例外</h5>\n<p>我们有时候会通过环境变量来控制一组操作的细节，比如常规 / 详细的输出，或者调试 / 优化版本。<br>\n使用非局部的控制方式可能带来困惑，但可以只用来控制实现的细节，否则就只有固定的语义了。</p>\n<h5 id=\"示例不好-10\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-10\">#</a> 示例，不好</h5>\n<p>通过非局部变量（比如  <code>errno</code> ）进行的报告经常被忽略。例如：</p>\n<pre><code>// 请勿如此：fprintf 的返回值未进行检查\nfprintf(connection, &quot;logging: %d %d %d\\n&quot;, x, y, s);\n</code></pre>\n<p>要是连接已经关闭而导致没有产生日志输出的话会怎么样？参见 I.???。</p>\n<p><strong>替代方案</strong>：抛出异常。异常是无法被忽略的。</p>\n<p><strong>其他形式</strong>：避免通过非局部或者隐含的状态来跨越接口传递信息。<br>\n注意，非  <code>const</code>  的成员函数会通过对象的状态来向其他成员函数传递信息。</p>\n<p><strong>其他形式</strong>：接口应当是函数或者一组函数集合。<br>\n函数可以是函数模板，而函数集合可以是类或者类模板。</p>\n<h5 id=\"强制实施-11\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-11\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】 函数不能基于声明于命名空间作用域的变量来作出影响控制流的决定。</li>\n<li>【简单】 函数不能对声明于命名空间作用域的变量进行写入操作。</li>\n</ul>\n<h3 id=\"a-nameri-globalai2-避免非-const-全局变量\"><a class=\"markdownIt-Anchor\" href=\"#a-nameri-globalai2-避免非-const-全局变量\">#</a> <a name=\"Ri-global\"></a>I.2: 避免非  <code>const</code>  全局变量</h3>\n<h5 id=\"理由-15\"><a class=\"markdownIt-Anchor\" href=\"#理由-15\">#</a> 理由</h5>\n<p>非  <code>const</code>  全局变量能够隐藏依赖关系，并使这些依赖项可能出现无法预测的变动。</p>\n<h5 id=\"示例-15\"><a class=\"markdownIt-Anchor\" href=\"#示例-15\">#</a> 示例</h5>\n<pre><code>struct Data &#123;\n    // ... 大量成员 ...\n&#125; data;            //  非 const 数据\n\nvoid compute()     // 请勿这样做\n&#123;\n    // ... 使用 data ...\n&#125;\n\nvoid output()     // 请勿这样做\n&#123;\n    // ... 使用 data ...\n&#125;\n</code></pre>\n<p>哪个可能会修改  <code>data</code>  呢？</p>\n<p><strong>警告</strong>：全局对象的初始化并不是完全有序的。<br>\n当使用全局对象时，应当用常量为之初始化。<br>\n还要注意，即便对于  <code>const</code>  对象，也可能发生未定义的初始化顺序。</p>\n<h5 id=\"例外-2\"><a class=\"markdownIt-Anchor\" href=\"#例外-2\">#</a> 例外</h5>\n<p>全局对象通常优于单例。</p>\n<h5 id=\"注解-17\"><a class=\"markdownIt-Anchor\" href=\"#注解-17\">#</a> 注解</h5>\n<p>全局常量是有益的。</p>\n<h5 id=\"注解-18\"><a class=\"markdownIt-Anchor\" href=\"#注解-18\">#</a> 注解</h5>\n<p>针对全局变量的规则同样适用于命名空间作用域的变量。</p>\n<p><strong>替代方案</strong>：如果你用全局（或者更一般地说命名空间作用域）数据来避免复制操作的话，请考虑把数据以  <code>const</code>  引用的形式进行传递的方案。<br>\n另一种方案是把数据定义为某个对象的状态，而把操作定义为其成员函数。</p>\n<p><strong>警告</strong>：请关注数据竞争：当一个线程能够访问非局部数据（或以引用传递的数据），而另一个线程执行被调用的函数时，就可能带来数据竞争。<br>\n指向可变数据的每个指针或引用都是潜在的数据竞争。</p>\n<p>使用全局指针或引用来访问和修改非 const 且非局部的数据，并非是比非 const 全局变量更好的替代方案，<br>\n这是因为它并不能解决隐藏依赖性或潜在竞争条件的问题。</p>\n<h5 id=\"注解-19\"><a class=\"markdownIt-Anchor\" href=\"#注解-19\">#</a> 注解</h5>\n<p>不可变数据是不会带来数据竞争条件的。</p>\n<p><strong>参见</strong>：另见<a href=\"#SS-call\">关于调用函数的规则</a>。</p>\n<h4 id=\"注解-20\"><a class=\"markdownIt-Anchor\" href=\"#注解-20\">#</a> 注解</h4>\n<p>这条规则是 “避免”，而不是 “不要用”。当然是有（罕见）例外的，比如  <code>cin</code> 、 <code>cout</code>  和  <code>cerr</code> 。</p>\n<h5 id=\"强制实施-12\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-12\">#</a> 强制实施</h5>\n<p>【简单】 报告所有在命名空间作用域中声明的非  <code>const</code>  变量和全局的指向非 const 数据的指针 / 引用。</p>\n<h3 id=\"a-nameri-singletonai3-避免使用单例\"><a class=\"markdownIt-Anchor\" href=\"#a-nameri-singletonai3-避免使用单例\">#</a> <a name=\"Ri-singleton\"></a>I.3: 避免使用单例</h3>\n<h5 id=\"理由-16\"><a class=\"markdownIt-Anchor\" href=\"#理由-16\">#</a> 理由</h5>\n<p>单例基本上就是经过伪装的更复杂的全局对象。</p>\n<h5 id=\"示例-16\"><a class=\"markdownIt-Anchor\" href=\"#示例-16\">#</a> 示例</h5>\n<pre><code>class Singleton &#123;\n    // ... 大量代码，用于确保只创建一个 Singleton，\n    // 进行正确地初始化，等等\n&#125;;\n</code></pre>\n<p>单例的想法有许多变种。<br>\n这也是问题的一方面。</p>\n<h5 id=\"注解-21\"><a class=\"markdownIt-Anchor\" href=\"#注解-21\">#</a> 注解</h5>\n<p>如果不想让全局对象被改变，请将其声明为  <code>const</code>  或  <code>constexpr</code> 。</p>\n<h5 id=\"例外-3\"><a class=\"markdownIt-Anchor\" href=\"#例外-3\">#</a> 例外</h5>\n<p>你可以使用最简单的 “单例” 形式（简单到通常不被当作单例）来获得首次使用时进行初始化的效果：</p>\n<pre><code>X&amp; myX()\n&#123;\n    static X my_x &#123;3&#125;;\n    return my_x;\n&#125;\n</code></pre>\n<p>这是解决初始化顺序相关问题的最有效方案之一。<br>\n在多线程环境中，静态对象的初始化并不会引入数据竞争条件<br>\n（除非你不小心在其构造函数中访问了某个共享对象）。</p>\n<p>注意局部的  <code>static</code>  对象初始化并不会蕴含竞争条件。<br>\n不过，如果  <code>X</code>  的销毁中涉及了需要进行同步的操作的话，我们就得用一个不那么简单的方案。<br>\n例如：</p>\n<pre><code>X&amp; myX()\n&#123;\n    static auto p = new X &#123;3&#125;;\n    return *p;  // 有可能泄漏\n&#125;\n</code></pre>\n<p>这样就必须有人以某种适当的线程安全方式来  <code>delete</code>  这个对象了。<br>\n这是容易出错的，因此除了以下情况外我们并不使用这种技巧：</p>\n<ul>\n<li><code>myX</code>  是在多线程代码中，</li>\n<li>这个  <code>X</code>  对象需要销毁（比如由于它要释放某个资源），而且</li>\n<li><code>X</code>  的析构函数的代码需要进行同步。</li>\n</ul>\n<p>如果你和许多人一样把单例定义为只能创建一个对象的类的话，像  <code>myX</code>  这样的函数并非单例，而且这种好用的技巧并不算无单例规则的例外。</p>\n<h5 id=\"强制实施-13\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-13\">#</a> 强制实施</h5>\n<p>通常非常困难。</p>\n<ul>\n<li>查找名字中包含  <code>singleton</code>  的类。</li>\n<li>查找只创建一个对象的类（通过对对象计数或者检查其构造函数）。</li>\n<li>如果某个类 X 具有公开的静态函数，并且它包含具有该类 X 类型的函数级局部静态变量并返回指向它的指针或者引用，就禁止它。</li>\n</ul>\n<h3 id=\"a-nameri-typedai4-使接口严格和强类型化\"><a class=\"markdownIt-Anchor\" href=\"#a-nameri-typedai4-使接口严格和强类型化\">#</a> <a name=\"Ri-typed\"></a>I.4: 使接口严格和强类型化</h3>\n<h5 id=\"理由-17\"><a class=\"markdownIt-Anchor\" href=\"#理由-17\">#</a> 理由</h5>\n<p>类型是最简单和最好的文档，它们有定义明确的含义并因而提高了易读性，并且是在编译期进行检查的。<br>\n而且，严格类型化的代码通常也能更好地进行优化。</p>\n<h5 id=\"示例请勿这样做\"><a class=\"markdownIt-Anchor\" href=\"#示例请勿这样做\">#</a> 示例，请勿这样做</h5>\n<p>考虑：</p>\n<pre><code>void pass(void* data);    // 使用弱的并且缺乏明确性的类型 void* 是有问题的\n</code></pre>\n<p>调用者无法确定它允许使用哪些类型，而且因为它并没有指定  <code>const</code> ，<br>\n也不确定其数据是否会被改动。注意，任何指针类型都可以隐式转换为  <code>void*</code> ，<br>\n因此调用者很容易提供这样的值给它。</p>\n<p>被调用方必须以  <code>static_cast</code>  将数据强制转换为某个无验证的类型以使用它。<br>\n这样做易于犯错，而且啰嗦。</p>\n<p>应当仅在设计中无法以 C++ 来予以描述的数据的传递时才使用  <code>const void*</code> 。请考虑使用  <code>variant</code>  或指向基类的指针来代替它。</p>\n<p><strong>替代方案</strong>：通常，利用模板形参可以把  <code>void*</code>  排除而改为  <code>T*</code>  或者  <code>T&amp;</code> 。<br>\n对于泛型代码，这些个  <code>T</code>  可以是一般模板参数或者是概念约束的模板参数。</p>\n<h5 id=\"示例不好-11\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-11\">#</a> 示例，不好</h5>\n<p>考虑：</p>\n<pre><code>draw_rect(100, 200, 100, 500); // 这些数值什么意思？\n\ndraw_rect(p.x, p.y, 10, 20); // 10 和 20 的单位是什么？\n</code></pre>\n<p>很明显调用者在描述一个矩形，不明确的是它们都和其哪些部分相关。而且  <code>int</code>  可以表示任何形式的信息，包括各种不同单位的值，因此我们必须得猜测这四个  <code>int</code>  的含义。前两个很可能代表坐标对偶  <code>x</code>  和  <code>y</code> ，但后两个是什么呢？</p>\n<p>注释和参数的名字可以有所帮助，但我们可以直截了当：</p>\n<pre><code>void draw_rectangle(Point top_left, Point bottom_right);\nvoid draw_rectangle(Point top_left, Size height_width);\n\ndraw_rectangle(p, Point&#123;10, 20&#125;);  // 两个角点\ndraw_rectangle(p, Size&#123;10, 20&#125;);   // 一个角和一对 (height, width)\n</code></pre>\n<p>显然，我们是无法利用静态类型系统识别所有的错误的，<br>\n例如，假定第一个参数是左上角这一点就依赖于约定（命名或者注释）。</p>\n<h5 id=\"示例不好-12\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-12\">#</a> 示例，不好</h5>\n<p>考虑：</p>\n<pre><code>set_settings(true, false, 42); // 这些数值什么意思？\n</code></pre>\n<p>各参数类型及其值并不能表明其所指定的设置项是什么以及它们的值所代表的含义。</p>\n<p>下面的设计则更加明确，安全且易读：</p>\n<pre><code>alarm_settings s&#123;&#125;;\ns.enabled = true;\ns.displayMode = alarm_settings::mode::spinning_light;\ns.frequency = alarm_settings::every_10_seconds;\nset_settings(s);\n</code></pre>\n<p>对于一组布尔值的情况，可以考虑使用某种标记  <code>enum</code> ；这是一种用于表示一组布尔值的模式。</p>\n<pre><code>enable_lamp_options(lamp_option::on | lamp_option::animate_state_transitions);\n</code></pre>\n<h5 id=\"示例不好-13\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-13\">#</a> 示例，不好</h5>\n<p>下例中，接口中并未明确给出  <code>time_to_blink</code>  的含义：按秒还是按毫秒算？</p>\n<pre><code>void blink_led(int time_to_blink) // 不好 -- 在单位上含糊\n&#123;\n    // ...\n    // 对 time_to_blink 做一些事\n    // ...\n&#125;\n\nvoid use()\n&#123;\n    blink_led(2);\n&#125;\n</code></pre>\n<h5 id=\"示例好-2\"><a class=\"markdownIt-Anchor\" href=\"#示例好-2\">#</a> 示例，好</h5>\n<p><code>std::chrono::duration</code>  类型可以让时间段的单位明确下来。</p>\n<pre><code>void blink_led(milliseconds time_to_blink) // 好 -- 单位明确\n&#123;\n    // ...\n    // 对 time_to_blink 做一些事\n    // ...\n&#125;\n\nvoid use()\n&#123;\n    blink_led(1500ms);\n&#125;\n</code></pre>\n<p>这个函数还可以写成使其接受任何时间段单位的形式。</p>\n<pre><code>template&lt;class rep, class period&gt;\nvoid blink_led(duration&lt;rep, period&gt; time_to_blink) // 好 -- 接受任何单位\n&#123;\n    // 假设最小的有意义单位是毫秒\n    auto milliseconds_to_blink = duration_cast&lt;milliseconds&gt;(time_to_blink);\n    // ...\n    // 对 milliseconds_to_blink 做一些事\n    // ...\n&#125;\n\nvoid use()\n&#123;\n    blink_led(2s);\n    blink_led(1500ms);\n&#125;\n</code></pre>\n<h5 id=\"强制实施-14\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-14\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】 报告将  <code>void*</code>  用作参数或返回类型的情况</li>\n<li>【简单】 报告使用了多个  <code>bool</code>  参数的情况</li>\n<li>【难于做好】 查找使用了过多基础类型的参数的函数。</li>\n</ul>\n<h3 id=\"a-nameri-preai5-说明前条件如果有\"><a class=\"markdownIt-Anchor\" href=\"#a-nameri-preai5-说明前条件如果有\">#</a> <a name=\"Ri-pre\"></a>I.5: 说明前条件（如果有）</h3>\n<h5 id=\"理由-18\"><a class=\"markdownIt-Anchor\" href=\"#理由-18\">#</a> 理由</h5>\n<p>在参数上蕴含着使它们在被调用方中能够恰当使用的约束关系。</p>\n<h5 id=\"示例-17\"><a class=\"markdownIt-Anchor\" href=\"#示例-17\">#</a> 示例</h5>\n<p>考虑：</p>\n<pre><code>double sqrt(double x);\n</code></pre>\n<p>这里  <code>x</code>  必须是非负数。类型系统是无法（简洁并自然地）表达这点的，因而我们得用别的方法。例如：</p>\n<pre><code>double sqrt(double x); // x 必须是非负数\n</code></pre>\n<p>一些前条件可以表示为断言。例如：</p>\n<pre><code>double sqrt(double x) &#123; Expects(x &gt;= 0); /* ... */ &#125;\n</code></pre>\n<p>理想情况下，这个  <code>Expects(x &gt;= 0)</code>  应当是  <code>sqrt()</code>  的接口的一部分，但我们无法轻易做到这点。当前，我们将之放入定义式（函数体）之中。</p>\n<p><strong>参考</strong>:  <code>Expects()</code>  在 <a href=\"#gsl-guidelines-support-library\">GSL</a> 中有说明。</p>\n<h5 id=\"注解-22\"><a class=\"markdownIt-Anchor\" href=\"#注解-22\">#</a> 注解</h5>\n<p>优先使用正式的必要条件说明，比如  <code>Expects(!p);</code> 。<br>\n如果这样不可行，就在注释中使用文字来说明，比如  <code>// 序列 [p:q) 根据 &lt; 排序</code> 。</p>\n<h5 id=\"注解-23\"><a class=\"markdownIt-Anchor\" href=\"#注解-23\">#</a> 注解</h5>\n<p>许多成员函数都以某个类所保持的不变式作为一项前条件。<br>\n这个不变式是由构造函数所建立的，且必须在被从类之外所调用的每个成员函数的退出时重新建立。<br>\n我们并不需要对每个成员函数都说明这个不变式。</p>\n<h5 id=\"强制实施-15\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-15\">#</a> 强制实施</h5>\n<p>【无法强制实施】</p>\n<p><strong>参见</strong>：有关传递指针的规则。???</p>\n<h3 id=\"a-nameri-expectsai6-优先使用-expects-来表达前条件\"><a class=\"markdownIt-Anchor\" href=\"#a-nameri-expectsai6-优先使用-expects-来表达前条件\">#</a> <a name=\"Ri-expects\"></a>I.6: 优先使用  <code>Expects()</code>  来表达前条件</h3>\n<h5 id=\"理由-19\"><a class=\"markdownIt-Anchor\" href=\"#理由-19\">#</a> 理由</h5>\n<p>清晰地表明这个条件是一个前条件，并便于工具的利用。</p>\n<h5 id=\"示例-18\"><a class=\"markdownIt-Anchor\" href=\"#示例-18\">#</a> 示例</h5>\n<pre><code>int area(int height, int width)\n&#123;\n    Expects(height &gt; 0 &amp;&amp; width &gt; 0);            // 好\n    if (height &lt;= 0 || width &lt;= 0) my_error();   // 隐晦的\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"注解-24\"><a class=\"markdownIt-Anchor\" href=\"#注解-24\">#</a> 注解</h5>\n<p>前条件是可以用许多方式来说明的，包括代码注释， <code>if</code>  语句，以及  <code>assert()</code> 。<br>\n这些方式使其难于与普通代码之间进行区分，难于进行更新，难于利用工具来操作，而且可能具有错误的语义（你真的总是想要在调试模式中止程序而在生产运行中不做任何检查吗？）</p>\n<h5 id=\"注解-25\"><a class=\"markdownIt-Anchor\" href=\"#注解-25\">#</a> 注解</h5>\n<p>前条件应当是接口的一部分，而不是实现的一部分，<br>\n但我们至今还没有能够做到这点的语言设施。<br>\n一旦语言支持变为可用（例如，参见<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcGVuLXN0ZC5vcmcvanRjMS9zYzIyL3dnMjEvZG9jcy9wYXBlcnMvMjAxNi9wMDM4MHIxLnBkZg==\">契约提案</span>），我们就将会采用前条件，后条件和断言的标准版本。</p>\n<h5 id=\"注解-26\"><a class=\"markdownIt-Anchor\" href=\"#注解-26\">#</a> 注解</h5>\n<p><code>Expects()</code>  还可以用于在算法的中部来检查某个条件。</p>\n<h5 id=\"注解-27\"><a class=\"markdownIt-Anchor\" href=\"#注解-27\">#</a> 注解</h5>\n<p>使用  <code>unsigned</code>  并不是回避<a href=\"#Res-nonnegative\">确保非负数值</a>问题的好方法。</p>\n<h5 id=\"强制实施-16\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-16\">#</a> 强制实施</h5>\n<p>【无法强制实施】 要把各种对前条件进行断言的方式都找出来是不可行的。对那些易于识别的（如  <code>assert()</code> ）实例给出警告的做法，其意义在缺少语言设施的前提下是有问题的。</p>\n<h3 id=\"a-nameri-postai7-说明后条件\"><a class=\"markdownIt-Anchor\" href=\"#a-nameri-postai7-说明后条件\">#</a> <a name=\"Ri-post\"></a>I.7: 说明后条件</h3>\n<h5 id=\"理由-20\"><a class=\"markdownIt-Anchor\" href=\"#理由-20\">#</a> 理由</h5>\n<p>以检测到对返回结果的误解，还可能发现实现中存在错误。</p>\n<h5 id=\"示例不好-14\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-14\">#</a> 示例，不好</h5>\n<p>考虑：</p>\n<pre><code>int area(int height, int width) &#123; return height * width; &#125;  // 不好\n</code></pre>\n<p>这里，我们（粗心大意地）遗漏了前条件的说明，因此高度和宽度必须是正数这点是不明确的。<br>\n我们也遗漏了后条件的说明，因此算法（ <code>height * width</code> ）对于大于最大整数的面积来说是错误的这点是不明显的。<br>\n可能会有溢出。<br>\n应该考虑使用：</p>\n<pre><code>int area(int height, int width)\n&#123;\n    auto res = height * width;\n    Ensures(res &gt; 0);\n    return res;\n&#125;\n</code></pre>\n<h5 id=\"示例不好-15\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-15\">#</a> 示例，不好</h5>\n<p>考虑一个著名的安全性 BUG：</p>\n<pre><code>void f()    // 有问题的\n&#123;\n    char buffer[MAX];\n    // ...\n    memset(buffer, 0, sizeof(buffer));\n&#125;\n</code></pre>\n<p>由于没有后条件来说明缓冲区应当被清零，优化器可能会将这个看似多余的  <code>memset()</code>  调用给清除掉：</p>\n<pre><code>void f()    // 有改进\n&#123;\n    char buffer[MAX];\n    // ...\n    memset(buffer, 0, sizeof(buffer));\n    Ensures(buffer[0] == 0);\n&#125;\n</code></pre>\n<h5 id=\"注解-28\"><a class=\"markdownIt-Anchor\" href=\"#注解-28\">#</a> 注解</h5>\n<p>后条件通常是在说明函数目的的代码注释中非正式地进行说明的；用  <code>Ensures()</code>  可以使之更加系统化，更加明显，并且更容易检查。</p>\n<h5 id=\"注解-29\"><a class=\"markdownIt-Anchor\" href=\"#注解-29\">#</a> 注解</h5>\n<p>后条件对于那些无法在所返回的结果中直接体现的东西来说尤其重要，比如要说明所用的数据结构。</p>\n<h5 id=\"示例-19\"><a class=\"markdownIt-Anchor\" href=\"#示例-19\">#</a> 示例</h5>\n<p>考虑一个操作  <code>Record</code>  的函数，它使用  <code>mutex</code>  来避免数据竞争条件：</p>\n<pre><code>mutex m;\n\nvoid manipulate(Record&amp; r)    // 请勿这样做\n&#123;\n    m.lock();\n    // ... 没有 m.unlock() ...\n&#125;\n</code></pre>\n<p>这里，我们 “忘记” 说明应当释放  <code>mutex</code> ，因此我们搞不清楚这里  <code>mutex</code>  释放的缺失是一个 BUG 还是一种功能特性。<br>\n把后条件说明将使其更加明确：</p>\n<pre><code>void manipulate(Record&amp; r)    // 后条件: m 在退出后是未锁定的\n&#123;\n    m.lock();\n    // ... 没有 m.unlock() ...\n&#125;\n</code></pre>\n<p>现在这个 BUG 就明显了（但仅对阅读了代码注释的人类来说）。</p>\n<p>更好的做法是使用 <a href=\"#Rr-raii\">RAII</a> 来在代码中保证后条件（“锁必须进行释放”）的实施：</p>\n<pre><code>void manipulate(Record&amp; r)    // 最好这样\n&#123;\n    lock_guard&lt;mutex&gt; _ &#123;m&#125;;\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"注解-30\"><a class=\"markdownIt-Anchor\" href=\"#注解-30\">#</a> 注解</h5>\n<p>理想情况下，后条件应当在接口或声明式中说明，让使用者易于见到它们。<br>\n只有那些与使用者有关的后条件才应当在接口中说明。<br>\n仅与内部状态相关的后条件应当属于定义式或实现。</p>\n<h5 id=\"强制实施-17\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-17\">#</a> 强制实施</h5>\n<p>【无法强制实施】 这是一条理念性的指导方针，一般情况下进行直接的<br>\n检查是不可行的。不过许多工具链中都有适用于特定领域的检查器，<br>\n比如针对锁定持有情况的检查器。</p>\n<h3 id=\"a-nameri-ensuresai8-优先使用-ensures-来表达后条件\"><a class=\"markdownIt-Anchor\" href=\"#a-nameri-ensuresai8-优先使用-ensures-来表达后条件\">#</a> <a name=\"Ri-ensures\"></a>I.8: 优先使用  <code>Ensures()</code>  来表达后条件</h3>\n<h5 id=\"理由-21\"><a class=\"markdownIt-Anchor\" href=\"#理由-21\">#</a> 理由</h5>\n<p>清晰地表明这个条件是一个后条件，并便于工具的利用。</p>\n<h5 id=\"示例-20\"><a class=\"markdownIt-Anchor\" href=\"#示例-20\">#</a> 示例</h5>\n<pre><code>void f()\n&#123;\n    char buffer[MAX];\n    // ...\n    memset(buffer, 0, MAX);\n    Ensures(buffer[0] == 0);\n&#125;\n</code></pre>\n<h5 id=\"注解-31\"><a class=\"markdownIt-Anchor\" href=\"#注解-31\">#</a> 注解</h5>\n<p>后条件是可以用许多方式来说明的，包括代码注释， <code>if</code>  语句，以及  <code>assert()</code> 。<br>\n这些方式使其难于与普通代码之间进行区分，难于进行更新，难于利用工具来操作，而且可能具有错误的语义。</p>\n<p><strong>替代方案</strong>：如 “这个资源必须被释放” 这样形式的后条件最好以 <a href=\"#Rr-raii\">RAII</a> 的方式来表达。</p>\n<h5 id=\"注释\"><a class=\"markdownIt-Anchor\" href=\"#注释\">#</a> 注释</h5>\n<p>理想情况下， <code>Ensures</code>  应当是接口的一部分，但我们无法轻易做到这点。<br>\n当前，我们将之放入定义式（函数体）之中。<br>\n一旦语言支持变为可用（例如，参见<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcGVuLXN0ZC5vcmcvanRjMS9zYzIyL3dnMjEvZG9jcy9wYXBlcnMvMjAxNi9wMDM4MHIxLnBkZg==\">契约提案</span>），我们就将会采用前条件，后条件和断言的标准版本。</p>\n<h5 id=\"强制实施-18\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-18\">#</a> 强制实施</h5>\n<p>【无法强制实施】 要把各种对后条件进行断言的方式都找出来是不可行的。对那些易于识别的（如  <code>assert()</code> ）实例给出警告的做法，其意义在缺少语言设施的前提下是有问题的。</p>\n<h3 id=\"a-nameri-conceptsai9-当接口是模板时用概念来文档化其参数\"><a class=\"markdownIt-Anchor\" href=\"#a-nameri-conceptsai9-当接口是模板时用概念来文档化其参数\">#</a> <a name=\"Ri-concepts\"></a>I.9: 当接口是模板时，用概念来文档化其参数</h3>\n<h5 id=\"理由-22\"><a class=\"markdownIt-Anchor\" href=\"#理由-22\">#</a> 理由</h5>\n<p>更严谨地说明接口，并使其在（不远的）将来可以在编译时进行检查。</p>\n<h5 id=\"示例-21\"><a class=\"markdownIt-Anchor\" href=\"#示例-21\">#</a> 示例</h5>\n<p>使用 C++20 风格的必要条件说明。例如：</p>\n<pre><code>template&lt;typename Iter, typename Val&gt;\n  requires input_iterator&lt;Iter&gt; &amp;&amp; equality_comparable_with&lt;iter_value_t&lt;Iter&gt;, Val&gt;\nIter find(Iter first, Iter last, Val v)\n&#123;\n    // ...\n&#125;\n</code></pre>\n<p><strong>参见</strong>: <a href=\"#SS-GP\">泛型编程</a>和<a href=\"#SS-concepts\">概念</a>。</p>\n<h5 id=\"强制实施-19\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-19\">#</a> 强制实施</h5>\n<p>对未被概念所约束（在其声明式之中或者在一个  <code>requires</code>  子句中所给出）的并非可变数量的模板形参作出警告。</p>\n<h3 id=\"a-nameri-exceptai10-使用异常来表明无法实施所要求的任务\"><a class=\"markdownIt-Anchor\" href=\"#a-nameri-exceptai10-使用异常来表明无法实施所要求的任务\">#</a> <a name=\"Ri-except\"></a>I.10: 使用异常来表明无法实施所要求的任务</h3>\n<h5 id=\"理由-23\"><a class=\"markdownIt-Anchor\" href=\"#理由-23\">#</a> 理由</h5>\n<p>不应该让错误可以被忽略，因为这将导致系统或者一次运算进入未定义的（或者预料之外的）状态。<br>\n这是错误的一个主要来源。</p>\n<h5 id=\"示例-22\"><a class=\"markdownIt-Anchor\" href=\"#示例-22\">#</a> 示例</h5>\n<pre><code>int printf(const char* ...);    // 不好: 当输出失败时返回负值\n\ntemplate&lt;class F, class ...Args&gt;\n// 好: 当无法启动一个新的线程时抛出 system_error\nexplicit thread(F&amp;&amp; f, Args&amp;&amp;... args);\n</code></pre>\n<h5 id=\"注解-32\"><a class=\"markdownIt-Anchor\" href=\"#注解-32\">#</a> 注解</h5>\n<p>错误是什么？</p>\n<p>错误的含义是函数无法达成其所宣称的目标（这包括后条件的建立）。<br>\n把错误忽略掉的调用方代码将导致错误的结果，或者未定义的系统状态。<br>\n例如，无法连接一个远程服务器本身并不是错误：<br>\n这个服务器可以因为各种原因而拒绝连接，因此合乎常理的方式是让其返回一个其调用者必然要检查的结果。<br>\n不过，如果无法连接本身就是被当作一种错误的话，这个失败时应当抛出一个异常。</p>\n<h5 id=\"例外-4\"><a class=\"markdownIt-Anchor\" href=\"#例外-4\">#</a> 例外</h5>\n<p>许多传统的接口函数（比如 UNIX 的信号处理器）都使用错误代码（就是  <code>errno</code> ）来报告其实是状态代码而不是错误的东西。你没有更好的选择只能用它，因此对其调用并不违反本条规则。</p>\n<h5 id=\"替代方案\"><a class=\"markdownIt-Anchor\" href=\"#替代方案\">#</a> 替代方案</h5>\n<p>如果你不能使用异常（比如说由于你的代码全都是老式的原始指针用法，或者由于你有硬实时性的约束），请考虑使用返回一对值的代码风格：</p>\n<pre><code>int val;\nint error_code;\ntie(val, error_code) = do_something();\nif (error_code) &#123;\n    // ... 处理错误或者退出 ...\n&#125;\n// ... 使用 val ...\n</code></pre>\n<p>这种风格不幸地会导致未初始化的变量。<br>\n从 C++17 开始，可以使用 “结构化绑定” 功能特性来从返回值直接对多个变量初始化。</p>\n<pre><code>auto [val, error_code] = do_something();\nif (error_code) &#123;\n    // ... 处理错误或者退出 ...\n&#125;\n// ... 使用 val ...\n</code></pre>\n<h5 id=\"注解-33\"><a class=\"markdownIt-Anchor\" href=\"#注解-33\">#</a> 注解</h5>\n<p>我们并不认为 “性能” 是一种不使用异常的合理理由。</p>\n<ul>\n<li>通常，显式的错误检查和处理会消耗掉和异常处理一样多的时间和空间。</li>\n<li>通常，使用异常的更清晰的代码会带来更好的性能（简化了对程序执行路径的追踪和其优化）。</li>\n<li>一条对性能关键代码的好规则是，把检查从代码的<a href=\"#Rper-critical\">关键</a>部分中移出去。</li>\n<li>长期来看，更规整的代码会得到更好的优化。</li>\n<li>在做出性能相关的声明前一定要小心地<a href=\"#Rper-measure\">进行测量</a>。</li>\n</ul>\n<p><strong>参见</strong>: <a href=\"#Ri-pre\">I.5</a> 和 <a href=\"#Ri-post\">I.7</a> 有关报告前条件和后条件的违反。</p>\n<h5 id=\"强制实施-20\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-20\">#</a> 强制实施</h5>\n<ul>\n<li>【无法强制实施】 这是一条理念性的指导方针，进行直接的检查是不可行的。</li>\n<li>查找  <code>errno</code> 。</li>\n</ul>\n<h3 id=\"a-nameri-rawai11-决不以原始指针t或引用t来传递所有权\"><a class=\"markdownIt-Anchor\" href=\"#a-nameri-rawai11-决不以原始指针t或引用t来传递所有权\">#</a> <a name=\"Ri-raw\"></a>I.11: 决不以原始指针（ <code>T*</code> ）或引用（ <code>T&amp;</code> ）来传递所有权</h3>\n<h5 id=\"理由-24\"><a class=\"markdownIt-Anchor\" href=\"#理由-24\">#</a> 理由</h5>\n<p>如果对调用者和被调用方哪一个拥有对象有疑问，那就会造成泄漏或者发生提早的析构。</p>\n<h5 id=\"示例-23\"><a class=\"markdownIt-Anchor\" href=\"#示例-23\">#</a> 示例</h5>\n<p>考虑：</p>\n<pre><code>X* compute(args)    // 请勿这样做\n&#123;\n    X* res = new X&#123;&#125;;\n    // ...\n    return res;\n&#125;\n</code></pre>\n<p>应当由谁来删除返回的这个  <code>X</code>  呢？如果  <code>compute</code>  返回引用的话这个问题将更难发现。<br>\n应该考虑按值来返回结果（如果结果比较大的话就用移动语义）：</p>\n<pre><code>vector&lt;double&gt; compute(args)  // 好的\n&#123;\n    vector&lt;double&gt; res(10000);\n    // ...\n    return res;\n&#125;\n</code></pre>\n<p><strong>替代方案</strong>：用 “智能指针” 来<a href=\"#Rr-smartptrparam\">传递所有权</a>，比如  <code>unique_ptr</code> （专有所有权）和  <code>shared_ptr</code> （共享所有权）。<br>\n这样做比返回对象自身来说并没有那么简炼，而且通常也不那么高效，<br>\n因此，仅当需要引用语义时再使用智能指针。</p>\n<p><strong>替代方案</strong>：有时候因为 ABI 兼容性的要求或者缺少资源，是无法对老代码进行修改的。<br>\n这种情况下，请用<a href=\"#gsl-guidelines-support-library\">指导方针支持库</a>的  <code>owner</code>  来标记拥有对象的指针：</p>\n<pre><code>owner&lt;X*&gt; compute(args)    // 现在就明确传递了所有权这一点\n&#123;\n    owner&lt;X*&gt; res = new X&#123;&#125;;\n    // ...\n    return res;\n&#125;\n</code></pre>\n<p>这告诉了分析工具  <code>res</code>  是一个所有者。<br>\n就是说，它的值必须被  <code>delete</code> ，或者被传递给另一个所有者，正如这里的  <code>return</code>  所做。</p>\n<p>在资源包装类的实现中也同样使用了  <code>owner</code> 。</p>\n<h5 id=\"注解-34\"><a class=\"markdownIt-Anchor\" href=\"#注解-34\">#</a> 注解</h5>\n<p>以原始指针（或迭代器）的形式传递的对象，都假定是由调用方<br>\n所有的，因此其生存期也由调用方来处理。换种方式来看：<br>\n传递所有权的 API 相对于传递指针的 API 来说比较少见，<br>\n因此缺省情况就是 “不传递所有权”。</p>\n<p><strong>参见</strong>: <a href=\"#Rf-conventional\">实参传递</a>，<a href=\"#Rr-smartptrparam\">使用智能指针参数</a>，以及<a href=\"#Rf-value-return\">返回值</a>。</p>\n<h5 id=\"强制实施-21\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-21\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】 当对并非  <code>owner&lt;T&gt;</code>  的原始指针进行  <code>delete</code>  就发出警告。建议使用标准库的资源包装或者使用  <code>owner&lt;T&gt;</code> 。</li>\n<li>【简单】 当任何代码路径上遗漏了对  <code>owner</code>  指针的  <code>reset</code>  或者显式的  <code>delete</code>  时就发出警告。</li>\n<li>【简单】 当把  <code>new</code>  或者返回值为  <code>owner</code>  的函数的返回值赋值给原始指针或非  <code>ower</code>  的引用时就发出警告。</li>\n</ul>\n<h3 id=\"a-nameri-nullptrai12-把不能为空的指针声明为-not_null\"><a class=\"markdownIt-Anchor\" href=\"#a-nameri-nullptrai12-把不能为空的指针声明为-not_null\">#</a> <a name=\"Ri-nullptr\"></a>I.12: 把不能为空的指针声明为  <code>not_null</code></h3>\n<h5 id=\"理由-25\"><a class=\"markdownIt-Anchor\" href=\"#理由-25\">#</a> 理由</h5>\n<p>帮助避免对  <code>nullptr</code>  解引用的错误。<br>\n通过避免多余的  <code>nullptr</code>  检查来提高性能。</p>\n<h5 id=\"示例-24\"><a class=\"markdownIt-Anchor\" href=\"#示例-24\">#</a> 示例</h5>\n<pre><code>int length(const char* p);            // 不清楚 length(nullptr) 是否有效\n\nlength(nullptr);                      // OK?\n\nint length(not_null&lt;const char*&gt; p);  // 有改善：可以假定 p 不可能为 nullptr\n\nint length(const char* p);            // 只好假定 p 可以为 nullptr\n</code></pre>\n<p>通过在源代码中说明意图，实现者和工具就可以提供更好的诊断能力，比如通过静态分析来找出某些种类的错误，还可以实施优化，比如移除分支和空值测试。</p>\n<h5 id=\"注解-35\"><a class=\"markdownIt-Anchor\" href=\"#注解-35\">#</a> 注解</h5>\n<p><code>not_null</code>  在<a href=\"#gsl-guidelines-support-library\">指导方针支持库</a>中定义。</p>\n<h5 id=\"注解-36\"><a class=\"markdownIt-Anchor\" href=\"#注解-36\">#</a> 注解</h5>\n<p>指向  <code>char</code>  的指针将指向 C 风格的字符串（以零终结的字符的连续串）这一点仍然是潜规则，并且也是混乱和错误的潜在来源。请使用  <code>czstring</code>  来代替  <code>const char*</code> 。</p>\n<pre><code>// 可以假定 p 不能为 nullptr\n// 可以假定 p 指向以零终结的字符数组\nint length(not_null&lt;zstring&gt; p);\n</code></pre>\n<p>注意：  <code>length()</code>  显然是经过伪装的  <code>std::strlen()</code> 。</p>\n<h5 id=\"强制实施-22\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-22\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】〔基础〕 如果有函数在所有控制流路径上访问指针参数之前检查它是否是  <code>nullptr</code> ，则给出警告称其应当被声明为  <code>not_null</code> 。</li>\n<li>【复杂】 如果有指针返回值的函数在所有返回路径上都保证其不是  <code>nullptr</code> ，则给出警告称返回类型应当被声明为  <code>not_null</code> 。</li>\n</ul>\n<h3 id=\"a-nameri-arrayai13-不要只用一个指针来传递数组\"><a class=\"markdownIt-Anchor\" href=\"#a-nameri-arrayai13-不要只用一个指针来传递数组\">#</a> <a name=\"Ri-array\"></a>I.13: 不要只用一个指针来传递数组</h3>\n<h5 id=\"理由-26\"><a class=\"markdownIt-Anchor\" href=\"#理由-26\">#</a> 理由</h5>\n<p>(pointer, size) 式的接口是易于出错的。同样，（指向数组的）普通指针还必须依赖某种约定以使被调用方来确定其大小。</p>\n<h5 id=\"示例-25\"><a class=\"markdownIt-Anchor\" href=\"#示例-25\">#</a> 示例</h5>\n<p>考虑：</p>\n<pre><code>void copy_n(const T* p, T* q, int n); // 从 [p:p+n) 复制到 [q:q+n)\n</code></pre>\n<p>当由  <code>q</code>  所指向的数组少于  <code>n</code>  个元素会怎么样？此时我们将覆写一些可能无关的内存。<br>\n当由  <code>p</code>  所指向的数组少于  <code>n</code>  个元素会怎么样？此时我们将读取一些可能无关的内存。<br>\n此二者都是未定义的行为，而且可能是非常恶劣的 BUG。</p>\n<h5 id=\"替代方案-2\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-2\">#</a> 替代方案</h5>\n<p>考虑使用明确的  <code>span</code> ：</p>\n<pre><code>void copy(span&lt;const T&gt; r, span&lt;T&gt; r2); // 将 r 复制给 r2\n</code></pre>\n<h5 id=\"示例不好-16\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-16\">#</a> 示例，不好</h5>\n<p>考虑：</p>\n<pre><code>void draw(Shape* p, int n);  // 糟糕的接口；糟糕的代码\nCircle arr[10];\n// ...\ndraw(arr, 10);\n</code></pre>\n<p>把  <code>10</code>  作为参数  <code>n</code>  传递可能是错误的：虽然最常见的约定是假定有  <code>[0:n)</code> ，但这点并未不是明确的。更糟糕的是， <code>draw()</code>  的调用通过编译了：这里有一次从数组到指针的隐式转换（数组退化），然后又进行了从  <code>Circle</code>  到  <code>Shape</code>  的另一次隐式转换。 <code>draw()</code>  是不可能安全地迭代这个数组的：它无法知道元素的大小。</p>\n<p><strong>替代方案</strong>：使用一个辅助类来确保元素的数量正确，并避免进行危险的隐式转换。例如：</p>\n<pre><code>void draw2(span&lt;Circle&gt;);\nCircle arr[10];\n// ...\ndraw2(span&lt;Circle&gt;(arr));  // 推断出元素的数量\ndraw2(arr);    // 推断出元素的类型和数组大小\n\nvoid draw3(span&lt;Shape&gt;);\ndraw3(arr);    // 错误: 无法将 Circle[10] 转换为 span&lt;Shape&gt;\n</code></pre>\n<p>这个  <code>draw2()</code>  传递了与  <code>draw()</code>  同样数量的信息，但明确指定了它接受的是  <code>Circle</code>  的范围。参见？？？.</p>\n<h5 id=\"例外-5\"><a class=\"markdownIt-Anchor\" href=\"#例外-5\">#</a> 例外</h5>\n<p>使用  <code>zstring</code>  和  <code>czstring</code>  来表示 C 风格的以零终结字符串。<br>\n但这样做时，应当使用  <code>std::string_view</code>  或 <a href=\"#gsl-guidelines-support-library\">GSL</a> 中的  <code>span&lt;char&gt;</code>  以避免范围错误。</p>\n<h5 id=\"强制实施-23\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-23\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】〔边界〕 对任何依赖于从数组类型向指针类型的隐式转换的表达式给出警告。允许 zstring/czstring 指针类型的例外。</li>\n<li>【简单】〔边界〕 对任何指针类型表达式进行且结果为指针类型的值的运算操作给出警告。允许 zstring/czstring 指针类型的例外。</li>\n</ul>\n<h3 id=\"a-nameri-global-initai22-避免全局对象之间进行复杂的初始化\"><a class=\"markdownIt-Anchor\" href=\"#a-nameri-global-initai22-避免全局对象之间进行复杂的初始化\">#</a> <a name=\"Ri-global-init\"></a>I.22: 避免全局对象之间进行复杂的初始化</h3>\n<h5 id=\"理由-27\"><a class=\"markdownIt-Anchor\" href=\"#理由-27\">#</a> 理由</h5>\n<p>复杂的初始化可能导致未定义的执行顺序。</p>\n<h5 id=\"示例-26\"><a class=\"markdownIt-Anchor\" href=\"#示例-26\">#</a> 示例</h5>\n<pre><code>// file1.c\n\nextern const X x;\n\nconst Y y = f(x);   // 读取 x; 写入 y\n\n// file2.c\n\nextern const Y y;\n\nconst X x = g(y);   // 读取 y; 写入 x\n</code></pre>\n<p>由于  <code>x</code>  和  <code>y</code>  是处于不同翻译单元之内的，调用  <code>f()</code>  和  <code>g()</code>  的顺序就是未定义的；<br>\n我们可能会访问到还未初始化的  <code>const</code>  对象。<br>\n这里展示的是，全局（命名空间作用域）对象的初始化顺序难题并不仅限于全局<em>变量</em>而已。</p>\n<h5 id=\"注解-37\"><a class=\"markdownIt-Anchor\" href=\"#注解-37\">#</a> 注解</h5>\n<p>并发代码中的初始化顺序问题是更加难于处理的。<br>\n所以通常最好完全避免使用全局（命名空间作用域）的对象。</p>\n<h5 id=\"强制实施-24\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-24\">#</a> 强制实施</h5>\n<ul>\n<li>标记调用了非  <code>constexpr</code>  函数的全局初始化式</li>\n<li>标记访问了  <code>extern</code>  对象的全局初始化式</li>\n</ul>\n<h3 id=\"a-nameri-nargsai23-保持较少的函数参数数量\"><a class=\"markdownIt-Anchor\" href=\"#a-nameri-nargsai23-保持较少的函数参数数量\">#</a> <a name=\"Ri-nargs\"></a>I.23: 保持较少的函数参数数量</h3>\n<h5 id=\"理由-28\"><a class=\"markdownIt-Anchor\" href=\"#理由-28\">#</a> 理由</h5>\n<p>大量参数会带来更大的出现混乱的机会。大量传递参数与其他替代方案相比也通常是代价比较大的。</p>\n<h5 id=\"讨论\"><a class=\"markdownIt-Anchor\" href=\"#讨论\">#</a> 讨论</h5>\n<p>两个最常见的使得函数具有过多参数的原因是：</p>\n<ol>\n<li>\n<p><em>缺乏抽象</em><br>\n缺少一种抽象，使得一个组合值被以<br>\n一组独立的元素的方式进行传递，而不是以一个单独的保证了不变式的对象来传递。<br>\n这不仅使其参数列表变长，而且会导致错误，<br>\n因为各个成分值无法再被某种获得保证的不变式进行保护。</p>\n</li>\n<li>\n<p><em>违反了 “函数单一职责” 原则</em><br>\n这个函数试图完成多项任务，它可能应当被重构。</p>\n</li>\n</ol>\n<h5 id=\"示例-27\"><a class=\"markdownIt-Anchor\" href=\"#示例-27\">#</a> 示例</h5>\n<p>标准库的  <code>merge()</code>  函数达到了我们可以自如处理的界限：</p>\n<pre><code>template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;\nOutputIterator merge(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2,\n                     OutputIterator result, Compare comp);\n</code></pre>\n<p>注意，这属于上面的第一种问题：缺乏抽象。STL 传递的不是范围（抽象），而是一对迭代器（未封装的成分值）。</p>\n<p>其中有四个模板参数和六个函数参数。<br>\n为简化最常用和最简单的用法，比较器参数可以缺省使用  <code>&lt;</code> ：</p>\n<pre><code>template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;\nOutputIterator merge(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2,\n                     OutputIterator result);\n</code></pre>\n<p>这实际上不会减低其整体复杂性，但它减少了对于许多使用者的表面复杂性。<br>\n为了真正地减少参数的数量，我们得把参数归拢到更高层的抽象之中：</p>\n<pre><code>template&lt;class InputRange1, class InputRange2, class OutputIterator&gt;\nOutputIterator merge(InputRange1 r1, InputRange2 r2, OutputIterator result);\n</code></pre>\n<p>把参数成 “批” 进行组合是减少参数数量和增加进行检查的机会的一般性技巧。</p>\n<p>或者，我们也可以用标准库概念来定义 “三个类型必须可以用于归并”：</p>\n<pre><code>template&lt;class In1, class In2, class Out&gt;\n  requires mergeable&lt;In1, In2, Out&gt;\nOut merge(In1 r1, In2 r2, Out result);\n</code></pre>\n<h5 id=\"示例-28\"><a class=\"markdownIt-Anchor\" href=\"#示例-28\">#</a> 示例</h5>\n<p>安全性剖面配置中建议将以下代码</p>\n<pre><code>void f(int* some_ints, int some_ints_length);  // 不好：C 风格，不安全\n</code></pre>\n<p>替换为</p>\n<pre><code>void f(gsl::span&lt;int&gt; some_ints);              // 好：安全，有边界检查\n</code></pre>\n<p>这样，使用一种抽象可以获得安全性和健壮性的好处，而且自然地减少了参数的数量。</p>\n<h5 id=\"注解-38\"><a class=\"markdownIt-Anchor\" href=\"#注解-38\">#</a> 注解</h5>\n<p>多少参数算很多？请使用少于四个参数。<br>\n有些函数确实最好表现为四个独立的参数，但这样的函数并不多。</p>\n<p><strong>替代方案</strong>：使用更好的抽象：把参数归集为由意义的对象，然后（按值或按引用）传递这些对象。</p>\n<p><strong>替代方案</strong>：利用默认实参或者重载来让最常见的调用方式可以用比较少的实参来进行。</p>\n<h5 id=\"强制实施-25\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-25\">#</a> 强制实施</h5>\n<ul>\n<li>当函数声明了两个类型相同的迭代器（也包括指针）而不是一个范围或视图，就给出警告。</li>\n<li>【无法强制实施】 这是一条理念性的指导方针，进行直接的检查是不可行的。</li>\n</ul>\n<h3 id=\"a-nameri-unrelatedai24-避免可以由同一组实参以不同顺序调用造成不同含义的相邻形参\"><a class=\"markdownIt-Anchor\" href=\"#a-nameri-unrelatedai24-避免可以由同一组实参以不同顺序调用造成不同含义的相邻形参\">#</a> <a name=\"Ri-unrelated\"></a>I.24: 避免可以由同一组实参以不同顺序调用造成不同含义的相邻形参</h3>\n<h5 id=\"理由-29\"><a class=\"markdownIt-Anchor\" href=\"#理由-29\">#</a> 理由</h5>\n<p>相同类型的相邻参数很容易被不小心互换掉。</p>\n<h5 id=\"示例不好-17\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-17\">#</a> 示例，不好</h5>\n<p>考虑：</p>\n<pre><code>void copy_n(T* p, T* q, int n);  // 从 [p:p + n) 复制到 [q:q + n)\n</code></pre>\n<p>这是个 K&amp;R C 风格接口的一种恶劣的变种。它导致很容易把 “目标” 和 “来源” 参数搞反。</p>\n<p>可以在 “来源” 参数上使用  <code>const</code> ：</p>\n<pre><code>void copy_n(const T* p, T* q, int n);  // 从 [p:p + n) 复制到 [q:q + n)\n</code></pre>\n<h5 id=\"例外-6\"><a class=\"markdownIt-Anchor\" href=\"#例外-6\">#</a> 例外</h5>\n<p>当参数的顺序不重要时，不会造成问题：</p>\n<pre><code>int max(int a, int b);\n</code></pre>\n<h5 id=\"替代方案-3\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-3\">#</a> 替代方案</h5>\n<p>不要以指针来传递数组，而要传递用来表示一个范围的对象（比如一个  <code>span</code> ）：</p>\n<pre><code>void copy_n(span&lt;const T&gt; p, span&lt;T&gt; q);  // 从 p 复制到 q\n</code></pre>\n<h5 id=\"替代方案-4\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-4\">#</a> 替代方案</h5>\n<p>定义一个  <code>struct</code>  来作为参数类型，并依照各个参数来命名它的各字段：</p>\n<pre><code>struct SystemParams &#123;\n    string config_file;\n    string output_path;\n    seconds timeout;\n&#125;;\nvoid initialize(SystemParams p);\n</code></pre>\n<p>这样做带来一种使其调用代码对于以后的读者变得明晰的倾向，因为这种参数<br>\n在调用点通常都要按名字来进行填充。</p>\n<h5 id=\"注解-39\"><a class=\"markdownIt-Anchor\" href=\"#注解-39\">#</a> 注解</h5>\n<p>只有接口设计者才能胜任处理违反本条指导方针的源头问题。</p>\n<h5 id=\"强制实施策略\"><a class=\"markdownIt-Anchor\" href=\"#强制实施策略\">#</a> 强制实施策略</h5>\n<p>【简单】 当两个连续的参数具有相同的类型时就给出警告。</p>\n<p>我们仍在寻找不这么简单的强制实施方式。</p>\n<h3 id=\"a-nameri-abstractai25-优先以空抽象类作为类层次的接口\"><a class=\"markdownIt-Anchor\" href=\"#a-nameri-abstractai25-优先以空抽象类作为类层次的接口\">#</a> <a name=\"Ri-abstract\"></a>I.25: 优先以空抽象类作为类层次的接口</h3>\n<h5 id=\"理由-30\"><a class=\"markdownIt-Anchor\" href=\"#理由-30\">#</a> 理由</h5>\n<p>空的（没有非静态成员数据）抽象类要比带有状态的基类更倾向于保持稳定。</p>\n<h5 id=\"示例不好-18\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-18\">#</a> 示例，不好</h5>\n<p>你知道  <code>Shape</code>  总会冒出来的 😃</p>\n<pre><code>class Shape &#123;  // 不好: 接口类中加载了数据\npublic:\n    Point center() const &#123; return c; &#125;\n    virtual void draw() const;\n    virtual void rotate(int);\n    // ...\nprivate:\n    Point c;\n    vector&lt;Point&gt; outline;\n    Color col;\n&#125;;\n</code></pre>\n<p>这将强制性要求每个派生类都要计算出一个中心点 —— 即使这并不容易，而且这个中心点从不会被用到。相似地说，不是每个  <code>Shape</code>  都有一个  <code>Color</code> ，而许多  <code>Shape</code>  也最好别用一个定义成一系列  <code>Point</code>  的轮廓来进行表示。使用抽象类要更好：</p>\n<pre><code>class Shape &#123;    // 有改进: Shape 是一个纯接口\npublic:\n    virtual Point center() const = 0;   // 纯虚函数\n    virtual void draw() const = 0;\n    virtual void rotate(int) = 0;\n    // ...\n    // ... 没有数据成员 ...\n    // ...\n    virtual ~Shape() = default;        \n&#125;;\n</code></pre>\n<h5 id=\"强制实施-26\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-26\">#</a> 强制实施</h5>\n<p>【简单】 当把类  <code>C</code>  的指针 / 引用赋值给  <code>C</code>  的某个基类的指针 / 引用，而这个基类包含数据成员时，就给出警告。</p>\n<h3 id=\"a-nameri-abiai26-当想要跨编译器的-abi-时使用一个-c-风格的语言子集\"><a class=\"markdownIt-Anchor\" href=\"#a-nameri-abiai26-当想要跨编译器的-abi-时使用一个-c-风格的语言子集\">#</a> <a name=\"Ri-abi\"></a>I.26: 当想要跨编译器的 ABI 时，使用一个 C 风格的语言子集</h3>\n<h5 id=\"理由-31\"><a class=\"markdownIt-Anchor\" href=\"#理由-31\">#</a> 理由</h5>\n<p>不同的编译器会实现不同的类的二进制布局，异常处理，函数名字，以及其他的实现细节。</p>\n<h5 id=\"例外-7\"><a class=\"markdownIt-Anchor\" href=\"#例外-7\">#</a> 例外</h5>\n<p>在一些平台上正有公共的 ABI 兴起，这可以使你从更加苛刻的限制中摆脱出来。</p>\n<h5 id=\"注解-40\"><a class=\"markdownIt-Anchor\" href=\"#注解-40\">#</a> 注解</h5>\n<p>如果你只用一种编译器，你也可以在接口上使用完全的 C++。但当升级到新的编译器版本之后，可能需要进行重新编译。</p>\n<h5 id=\"强制实施-27\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-27\">#</a> 强制实施</h5>\n<p>【无法强制实施】 要可靠地识别某个接口是否是构成 ABI 的一部分是很困难的。</p>\n<h3 id=\"a-nameri-pimplai27-对于稳定的程序库-abi考虑使用-pimpl-手法\"><a class=\"markdownIt-Anchor\" href=\"#a-nameri-pimplai27-对于稳定的程序库-abi考虑使用-pimpl-手法\">#</a> <a name=\"Ri-pimpl\"></a>I.27: 对于稳定的程序库 ABI，考虑使用 Pimpl 手法</h3>\n<h5 id=\"理由-32\"><a class=\"markdownIt-Anchor\" href=\"#理由-32\">#</a> 理由</h5>\n<p>由于私有数据成员参与类的内存布局，而私有成员函数参与重载决议，<br>\n对这些实现细节的改动都要求使用了这类的所有用户全部重新编译。而持有指向实现的指针（Pimpl）的<br>\n非多态的接口类，则可以将类的用户从其实现的改变隔离开来，其代价是一层间接。</p>\n<h5 id=\"示例-29\"><a class=\"markdownIt-Anchor\" href=\"#示例-29\">#</a> 示例</h5>\n<p>接口（widget.h）</p>\n<pre><code>class widget &#123;\n    class impl;\n    std::unique_ptr&lt;impl&gt; pimpl;\npublic:\n    void draw(); // 公开 API 转发给实现\n    widget(int); // 定义于实现文件中\n    ~widget();   // 定义于实现文件中，其中 impl 将为完整类型\n    widget(widget&amp;&amp;); // 定义于实现文件中\n    widget(const widget&amp;) = delete;\n    widget&amp; operator=(widget&amp;&amp;); // 定义于实现文件中\n    widget&amp; operator=(const widget&amp;) = delete;\n&#125;;\n</code></pre>\n<p>实现（widget.cpp）</p>\n<pre><code>class widget::impl &#123;\n    int n; // private data\npublic:\n    void draw(const widget&amp; w) &#123; /* ... */ &#125;\n    impl(int n) : n(n) &#123;&#125;\n&#125;;\nvoid widget::draw() &#123; pimpl-&gt;draw(*this); &#125;\nwidget::widget(int n) : pimpl&#123;std::make_unique&lt;impl&gt;(n)&#125; &#123;&#125;\nwidget::widget(widget&amp;&amp;) = default;\nwidget::~widget() = default;\nwidget&amp; widget::operator=(widget&amp;&amp;) = default;\n</code></pre>\n<h5 id=\"注解-41\"><a class=\"markdownIt-Anchor\" href=\"#注解-41\">#</a> 注解</h5>\n<p>参见 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXJic3V0dGVyLmNvbS9nb3R3L18xMDAv\">GOTW #100</span> 和 <span class=\"exturl\" data-url=\"aHR0cDovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jcHAvbGFuZ3VhZ2UvcGltcGw=\">cppreference</span> 有关这个手法相关的权衡和其他实现细节。</p>\n<h5 id=\"强制实施-28\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-28\">#</a> 强制实施</h5>\n<p>【无法强制】 很难可靠地识别出哪个接口属于 ABI 的一部分。</p>\n<h3 id=\"a-nameri-encapsulateai30-将有违规则的部分封装\"><a class=\"markdownIt-Anchor\" href=\"#a-nameri-encapsulateai30-将有违规则的部分封装\">#</a> <a name=\"Ri-encapsulate\"></a>I.30: 将有违规则的部分封装</h3>\n<h5 id=\"理由-33\"><a class=\"markdownIt-Anchor\" href=\"#理由-33\">#</a> 理由</h5>\n<p>维持代码简单且安全。<br>\n有时候因为逻辑的或者性能的原因，需要使用难看的，不安全的或者易错的技术。<br>\n此时，将它们局部化，而不是使其 “感染” 接口，可以避免更多的程序员团队必须当心其<br>\n细节和微妙之处。<br>\n如果可能的话，实现复杂度不能通过接口渗透到用户代码之中。</p>\n<h5 id=\"示例-30\"><a class=\"markdownIt-Anchor\" href=\"#示例-30\">#</a> 示例</h5>\n<p>考虑一个程序，其基于某种形式的输入（比如  <code>main</code>  的实参）来决定<br>\n从文件，从命令行，还是从标准输入来获得输入数据。<br>\n我们可能会将其写成</p>\n<pre><code>bool owned;\nowner&lt;istream*&gt; inp;\nswitch (source) &#123;\ncase std_in:        owned = false; inp = &amp;cin;                       break;\ncase command_line:  owned = true;  inp = new istringstream&#123;argv[2]&#125;; break;\ncase file:          owned = true;  inp = new ifstream&#123;argv[2]&#125;;      break;\n&#125;\nistream&amp; in = *inp;\n</code></pre>\n<p>这违反了<a href=\"#Res-always\">避免未初始化变量</a>，<br>\n<a href=\"#Ri-raw\">避免忽略所有权</a>，<br>\n和<a href=\"#Res-magic\">避免魔法常量</a>等规则。<br>\n尤其是，人们必须记得找地方写</p>\n<pre><code>if (owned) delete inp;\n</code></pre>\n<p>我们可以通过使用带有一个特殊的删除器（对  <code>cin</code>  不做任何事）的  <code>unique_ptr</code>  来处理这个特定的例子，<br>\n但这对于新手来说较复杂（他们很容易遇到这种问题），并且这个例子其实是一个更一般的问题的特例：<br>\n我们希望将其当做静态的某种属性（此处为所有权），需要在运行时进行<br>\n偶尔的处理。<br>\n一般的，更常见的，且更安全的例子可以被静态处理，因而我们并不希望为它们添加开销和复杂性。<br>\n然而我们还是不得不处理那些不常见的，较不安全的，而且更为昂贵的情况。<br>\n<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9yZXNvdXJjZS1tb2RlbC5wZGY=\">[Str15]</span> 中对这种例子有所探讨。</p>\n<p>由此，我们编写这样的类</p>\n<pre><code>class Istream &#123; [[gsl::suppress(lifetime)]]\npublic:\n    enum Opt &#123; from_line = 1 &#125;;\n    Istream() &#123; &#125;\n    Istream(zstring p) : owned&#123;true&#125;, inp&#123;new ifstream&#123;p&#125;&#125; &#123;&#125;            // 从文件读取\n    Istream(zstring p, Opt) : owned&#123;true&#125;, inp&#123;new istringstream&#123;p&#125;&#125; &#123;&#125;  // 从命令行读取\n    ~Istream() &#123; if (owned) delete inp; &#125;\n    operator istream&amp; () &#123; return *inp; &#125;\nprivate:\n    bool owned = false;\n    istream* inp = &amp;cin;\n&#125;;\n</code></pre>\n<p>这样， <code>istream</code>  的所有权的动态本质就被封装起来。<br>\n大体上，在现实的代码中还是需要针对潜在的错误添加一些检查。</p>\n<h5 id=\"强制实施-29\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-29\">#</a> 强制实施</h5>\n<ul>\n<li>很难，判断那种违背规则的代码是基本的是很难做到的</li>\n<li>对允许规则违背的部分跨越接口的规则抑制进行标记</li>\n</ul>\n<h1 id=\"a-names-functionsaf-函数\"><a class=\"markdownIt-Anchor\" href=\"#a-names-functionsaf-函数\">#</a> <a name=\"S-functions\"></a>F: 函数</h1>\n<p>函数指定了一个活动或者一次计算，以将系统从一种一致的状态转移到另一种一致的状态。函数是程序的基础构造块。</p>\n<p>应当使函数的名字有意义，说明对其参数的必要条件，并清晰地规定参数和其结果之间的关系。函数的实现本身并不是规格说明。请尝试同时对函数应当做什么和函数应当怎样做来进行思考。<br>\n函数在大多数接口中都是最关键的部分，请参考接口的规则。</p>\n<p>函数规则概览：</p>\n<p>函数定义式的规则：</p>\n<ul>\n<li><a href=\"#Rf-package\">F.1: 把有意义的操作 “打包” 成为精心命名的函数</a></li>\n<li><a href=\"#Rf-logical\">F.2: 一个函数应当实施单一一项逻辑操作</a></li>\n<li><a href=\"#Rf-single\">F.3: 保持函数短小简洁</a></li>\n<li><a href=\"#Rf-constexpr\">F.4: 如果函数可能必须在编译期进行求值，就将其声明为  <code>constexpr</code> </a></li>\n<li><a href=\"#Rf-inline\">F.5: 如果函数非常小，并且是时间敏感的，就将其声明为  <code>inline</code> </a></li>\n<li><a href=\"#Rf-noexcept\">F.6: 如果函数必然不会抛出异常，就将其声明为  <code>noexcept</code> </a></li>\n<li><a href=\"#Rf-smart\">F.7: 对于常规用法，应当接受  <code>T*</code>  或  <code>T&amp;</code>  参数而不是智能指针</a></li>\n<li><a href=\"#Rf-pure\">F.8: 优先采用纯函数</a></li>\n<li><a href=\"#Rf-unused\">F.9: 未使用的形参应当没有名字</a></li>\n<li><a href=\"#Rf-name\">F.10: 若操作可被重用，则应为其命名</a></li>\n<li><a href=\"%5B#Rf-lambda\">F.11: 当需要仅在一处使用的简单函数对象时使用无名 lambda</a></li>\n</ul>\n<p>参数传递表达式的规则：</p>\n<ul>\n<li><a href=\"#Rf-conventional\">F.15: 优先采用简单的和传统的信息传递方式</a></li>\n<li><a href=\"#Rf-in\">F.16: 对于 “输入（in）” 参数，把复制操作廉价的类型按值进行传递，把其他类型按  <code>const</code>  引用进行传递</a></li>\n<li><a href=\"#Rf-inout\">F.17: 对于 “输入 / 输出（in-out）” 参数，按非  <code>const</code>  引用进行传递</a></li>\n<li><a href=\"#Rf-consume\">F.18: 对于 “将被移动（will-move-from）” 参数，按  <code>X&amp;&amp;</code>  进行传递并对参数  <code>std::move</code> </a></li>\n<li><a href=\"#Rf-forward\">F.19: 对于 “转发（forward）” 参数，按  <code>TP&amp;&amp;</code>  进行传递并只对参数  <code>std::forward</code> </a></li>\n<li><a href=\"#Rf-out\">F.20: 对于 “输出（out）” 值，采用返回值优先于输出参数</a></li>\n<li><a href=\"#Rf-out-multi\">F.21: 要返回多个 “输出” 值，优先返回结构体或元组（tuple）</a></li>\n<li><a href=\"#Rf-ptr-ref\">F.60: 当 “没有参数” 是有效的选项时，采用  <code>T*</code>  优先于  <code>T&amp;</code> </a></li>\n</ul>\n<p>参数传递语义的规则：</p>\n<ul>\n<li><a href=\"#Rf-ptr\">F.22: 用  <code>T*</code>  或  <code>owner&lt;T*&gt;</code>  来代表单个对象</a></li>\n<li><a href=\"#Rf-nullptr\">F.23: 用  <code>not_null&lt;T&gt;</code>  来表明 “空值（null）” 不是有效的值</a></li>\n<li><a href=\"#Rf-range\">F.24: 用  <code>span&lt;T&gt;</code>  或者  <code>span_p&lt;T&gt;</code>  来代表一个半开序列</a></li>\n<li><a href=\"#Rf-zstring\">F.25: 用  <code>zstring</code>  或者  <code>not_null&lt;zstring&gt;</code>  来代表 C 风格的字符串</a></li>\n<li><a href=\"#Rf-unique_ptr\">F.26: 当需要指针时，用  <code>unique_ptr&lt;T&gt;</code>  来传递所有权</a></li>\n<li><a href=\"#Rf-shared_ptr\">F.27: 用  <code>shared_ptr&lt;T&gt;</code>  来共享所有权</a></li>\n</ul>\n<p><a name=\"Rf-value-return\"></a>值返回语义的规则：</p>\n<ul>\n<li><a href=\"#Rf-return-ptr\">F.42: 返回  <code>T*</code>  来（仅仅）给出一个位置</a></li>\n<li><a href=\"#Rf-dangle\">F.43: 不要（直接或间接）返回指向局部对象的指针或引用</a></li>\n<li><a href=\"#Rf-return-ref\">F.44: 当不想进行复制，且不需要 “没有对象被返回” 时，返回  <code>T&amp;</code> </a></li>\n<li><a href=\"#Rf-return-ref-ref\">F.45: 不要返回  <code>T&amp;&amp;</code> </a></li>\n<li><a href=\"#Rf-main\">F.46:  <code>int</code>  是  <code>main()</code>  的返回类型</a></li>\n<li><a href=\"#Rf-assignment-op\">F.47: 赋值运算符返回  <code>T&amp;</code> </a></li>\n<li><a href=\"#Rf-return-move-local\">F.48: 不要用  <code>std::move(local)</code> </a></li>\n<li><a href=\"#Rf-return-const\">F.49: 不要返回  <code>const T</code> </a></li>\n</ul>\n<p>其他函数规则：</p>\n<ul>\n<li><a href=\"#Rf-capture-vs-overload\">F.50: 当函数不适用时（不能俘获局部变量，或者不能编写局部函数），就使用 Lambda</a></li>\n<li><a href=\"#Rf-default-args\">F.51: 如果需要作出选择，采用默认实参应当优先于进行重载</a></li>\n<li><a href=\"#Rf-reference-capture\">F.52: 对于局部使用的（也包括传递给算法的）lambda，优先采用按引用俘获</a></li>\n<li><a href=\"#Rf-value-capture\">F.53: 对于非局部使用的（包括被返回的，在堆上存储的，或者传递给别的线程的）lambda，避免采用按引用俘获</a></li>\n<li><a href=\"#Rf-this-capture\">F.54: 当俘获了  <code>this</code>  时，显式俘获所有的变量（不使用默认俘获）</a></li>\n<li><a href=\"#F-varargs\">F.55: 不要使用  <code>va_arg</code>  参数</a></li>\n<li><a href=\"#F-nesting\">F.56: 避免不必要的条件嵌套</a></li>\n</ul>\n<p>函数和 Lambda 表达式以及函数对象有很强的相似性。</p>\n<p><strong>参见</strong>：<a href=\"#SS-lambdas\">C.lambdas: 函数对象和 lambda</a></p>\n<h2 id=\"a-namess-fct-defafdef-函数的定义式\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-fct-defafdef-函数的定义式\">#</a> <a name=\"SS-fct-def\"></a>F.def: 函数的定义式</h2>\n<p>函数的定义式就是一并指定了函数的实现（函数体）的函数声明式。</p>\n<h3 id=\"a-namerf-packageaf1-把有意义的操作打包成为精心命名的函数\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-packageaf1-把有意义的操作打包成为精心命名的函数\">#</a> <a name=\"Rf-package\"></a>F.1: 把有意义的操作 “打包” 成为精心命名的函数</h3>\n<h5 id=\"理由-34\"><a class=\"markdownIt-Anchor\" href=\"#理由-34\">#</a> 理由</h5>\n<p>把公共的代码分解出去，将使代码更易于阅读，更可能被重用，并能够对源于复杂代码的错误有所限制。<br>\n如果某部分是一个明确指定的活动，就将之从其包围代码中分离出来，并为其进行命名。</p>\n<h5 id=\"示例请勿这样做-2\"><a class=\"markdownIt-Anchor\" href=\"#示例请勿这样做-2\">#</a> 示例，请勿这样做</h5>\n<pre><code>void read_and_print(istream&amp; is)    // 读取并打印一个 int\n&#123;\n    int x;\n    if (is &gt;&gt; x)\n        cout &lt;&lt; &quot;the int is &quot; &lt;&lt; x &lt;&lt; '\\n';\n    else\n        cerr &lt;&lt; &quot;no int on input\\n&quot;;\n&#125;\n</code></pre>\n<p><code>read_and_print</code>  的几乎每件事都有问题。<br>\n它进行了读取，它（向一个固定  <code>ostream</code> ）进行了写入，它（向一个固定的  <code>ostream</code> ）写入了错误消息，它只能处理  <code>int</code> 。<br>\n这里没有可以重用的东西，逻辑上分开的操作被搅拌到了一起，而局部变量在其逻辑上使用完毕之后仍处于作用域中。<br>\n作为一个小例子的话还好，但如果输入操作、输出操作和错误处理更加复杂的话，<br>\n这个纠缠混乱的代码就会变得难于理解了。</p>\n<h5 id=\"注解-42\"><a class=\"markdownIt-Anchor\" href=\"#注解-42\">#</a> 注解</h5>\n<p>如果你编写的一个有些价值的 lambda 可能潜在地被用于多处，那就为它进行命名并将其赋值给一个（通常非局部的）变量。</p>\n<h5 id=\"示例-31\"><a class=\"markdownIt-Anchor\" href=\"#示例-31\">#</a> 示例</h5>\n<pre><code>sort(a, b, [](T x, T y) &#123; return x.rank() &lt; y.rank() &amp;&amp; x.value() &lt; y.value(); &#125;);\n</code></pre>\n<p>对 lambda 进行命名，将会把这个表达式进行逻辑上的分解，还会为 lambda 的含义给出有力的提示。</p>\n<pre><code>auto lessT = [](T x, T y) &#123; return x.rank() &lt; y.rank() &amp;&amp; x.value() &lt; y.value(); &#125;;\n\nsort(a, b, lessT);\n</code></pre>\n<p>对于性能和可维护性来说，最简短的代码并不总是最好的选择。</p>\n<h5 id=\"例外-8\"><a class=\"markdownIt-Anchor\" href=\"#例外-8\">#</a> 例外</h5>\n<p>循环体，包括用作循环体的 lambda，很少需要进行命名。<br>\n然而，大型的循环体（比如好多行或者好多页）也是个问题。<br>\n规则 “<a href=\"#Rf-single\">保持函数短小简洁</a>” 暗含有 “保持循环体短小”。<br>\n与此相似，用作回调参数的 lambda 有事后也是有意义的，虽然它们不大可能被重用。</p>\n<h5 id=\"强制实施-30\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-30\">#</a> 强制实施</h5>\n<ul>\n<li>参见 “<a href=\"#Rf-single\">保持函数短小简洁</a>”</li>\n<li>把不同地方所用的同样和非常相似的 lambda 标记出来。</li>\n</ul>\n<h3 id=\"a-namerf-logicalaf2-一个函数应当实施单一一项逻辑操作\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-logicalaf2-一个函数应当实施单一一项逻辑操作\">#</a> <a name=\"Rf-logical\"></a>F.2: 一个函数应当实施单一一项逻辑操作</h3>\n<h5 id=\"理由-35\"><a class=\"markdownIt-Anchor\" href=\"#理由-35\">#</a> 理由</h5>\n<p>仅实施单一操作的函数易于理解，测试和重用。</p>\n<h5 id=\"示例-32\"><a class=\"markdownIt-Anchor\" href=\"#示例-32\">#</a> 示例</h5>\n<p>考虑：</p>\n<pre><code>void read_and_print()    // 不好\n&#123;\n    int x;\n    cin &gt;&gt; x;\n    // 检查错误\n    cout &lt;&lt; x &lt;&lt; &quot;\\n&quot;;\n&#125;\n</code></pre>\n<p>这是一整块被绑定到一个特定的输入的代码，而且无法为其找到另一种（不同的）用途。作为代替，我们把函数分解为合适的逻辑部分并进行参数化：</p>\n<pre><code>int read(istream&amp; is)    // 有改进\n&#123;\n    int x;\n    is &gt;&gt; x;\n    // 检查错误\n    return x;\n&#125;\n\nvoid print(ostream&amp; os, int x)\n&#123;\n    os &lt;&lt; x &lt;&lt; &quot;\\n&quot;;\n&#125;\n</code></pre>\n<p>这样的话，就可以在需要时进行组合：</p>\n<pre><code>void read_and_print()\n&#123;\n    auto x = read(cin);\n    print(cout, x);\n&#125;\n</code></pre>\n<p>如果有需要，我们还可以进一步把  <code>read()</code>  和  <code>print()</code>  针对数据类型，I/O 机制，以及对错误的反应等等方面进行模板化。例如：</p>\n<pre><code>auto read = [](auto&amp; input, auto&amp; value)    // 有改善\n&#123;\n    input &gt;&gt; value;\n    // 检查错误\n&#125;;\n\nauto print(auto&amp; output, const auto&amp; value)\n&#123;\n    output &lt;&lt; value &lt;&lt; &quot;\\n&quot;;\n&#125;\n</code></pre>\n<h5 id=\"强制实施-31\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-31\">#</a> 强制实施</h5>\n<ul>\n<li>把具有多个 “输出” 参数的函数当作有问题的。使用返回值来代替，包括以  <code>tuple</code>  用作多个返回值。</li>\n<li>把无法装入编辑器的一屏之内的 “大型” 函数当作有问题的。考虑把这种函数分解为较小的恰当命名的子操作。</li>\n<li>把有七个或更多参数的函数当作有问题的。</li>\n</ul>\n<h3 id=\"a-namerf-singleaf3-保持函数短小简洁\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-singleaf3-保持函数短小简洁\">#</a> <a name=\"Rf-single\"></a>F.3: 保持函数短小简洁</h3>\n<h5 id=\"理由-36\"><a class=\"markdownIt-Anchor\" href=\"#理由-36\">#</a> 理由</h5>\n<p>大型函数难于阅读，更有可能包含复杂的代码，而且更有可能含有其作用域超过最低限度的变量。<br>\n带有复杂的控制结构的函数更有可能变长，也更有可能隐藏逻辑错误于其中。</p>\n<h5 id=\"示例-33\"><a class=\"markdownIt-Anchor\" href=\"#示例-33\">#</a> 示例</h5>\n<p>考虑：</p>\n<pre><code>double simple_func(double val, int flag1, int flag2)\n    // simple_func: 接受一个值并计算所需的 ASIC 值，\n    // 依赖于两个模式标记。\n&#123;\n    double intermediate;\n    if (flag1 &gt; 0) &#123;\n        intermediate = func1(val);\n        if (flag2 % 2)\n             intermediate = sqrt(intermediate);\n    &#125;\n    else if (flag1 == -1) &#123;\n        intermediate = func1(-val);\n        if (flag2 % 2)\n             intermediate = sqrt(-intermediate);\n        flag1 = -flag1;\n    &#125;\n    if (abs(flag2) &gt; 10) &#123;\n        intermediate = func2(intermediate);\n    &#125;\n    switch (flag2 / 10) &#123;\n    case 1: if (flag1 == -1) return finalize(intermediate, 1.171);\n            break;\n    case 2: return finalize(intermediate, 13.1);\n    default: break;\n    &#125;\n    return finalize(intermediate, 0.);\n&#125;\n</code></pre>\n<p>这个函数过于复杂了。<br>\n要如何判断是否所有的可能性都被正确处理了呢？<br>\n当然，它也同样违反了别的规则。</p>\n<p>我们可以进行重构：</p>\n<pre><code>double func1_muon(double val, int flag)\n&#123;\n    // ???\n&#125;\n\ndouble func1_tau(double val, int flag1, int flag2)\n&#123;\n    // ???\n&#125;\n\ndouble simple_func(double val, int flag1, int flag2)\n    // simple_func: 接受一个值并计算所需的 ASIC 值，\n    // 依赖于两个模式标记。\n&#123;\n    if (flag1 &gt; 0)\n        return func1_muon(val, flag2);\n    if (flag1 == -1)\n        // 由 func1_tau 来处理: flag1 = -flag1;\n        return func1_tau(-val, flag1, flag2);\n    return 0.;\n&#125;\n</code></pre>\n<h5 id=\"注解-43\"><a class=\"markdownIt-Anchor\" href=\"#注解-43\">#</a> 注解</h5>\n<p>“无法放入一屏显示” 通常是对 “太长了” 的一种不错的实际定义方式。<br>\n一行到五行大小的函数应当被当作是常态。</p>\n<h5 id=\"注解-44\"><a class=\"markdownIt-Anchor\" href=\"#注解-44\">#</a> 注解</h5>\n<p>把大型函数分解成较小的紧致的有名字的函数。<br>\n小型的简单函数在函数调用的代价比较明显时很容易被内联。</p>\n<h5 id=\"强制实施-32\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-32\">#</a> 强制实施</h5>\n<ul>\n<li>标记无法 “放入一屏” 的函数。<br>\n一屏有多大？可以试试 60 行，每行 140 个字符；这大致上就是书本页面能够适于阅读的最大值了。</li>\n<li>标记过于复杂的函数。多复杂算是过于复杂呢？<br>\n应当用圈复杂度来度量。可以试试 “多于 10 个逻辑路径”。一个简单的开关算作一条路径。</li>\n</ul>\n<h3 id=\"a-namerf-constexpraf4-如果函数可能必须在编译期进行求值就将其声明为-constexpr\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-constexpraf4-如果函数可能必须在编译期进行求值就将其声明为-constexpr\">#</a> <a name=\"Rf-constexpr\"></a>F.4: 如果函数可能必须在编译期进行求值，就将其声明为  <code>constexpr</code></h3>\n<h5 id=\"理由-37\"><a class=\"markdownIt-Anchor\" href=\"#理由-37\">#</a> 理由</h5>\n<p>需要用  <code>constexpr</code>  来告诉编译器允许对其进行编译期求值。</p>\n<h5 id=\"示例-34\"><a class=\"markdownIt-Anchor\" href=\"#示例-34\">#</a> 示例</h5>\n<p>（不）著名的阶乘例子：</p>\n<pre><code>constexpr int fac(int n)\n&#123;\n    constexpr int max_exp = 17;      // constexpr 使得可以在 Expects 中使用 max_exp\n    Expects(0 &lt;= n &amp;&amp; n &lt; max_exp);  // 防止犯糊涂和发生溢出\n    int x = 1;\n    for (int i = 2; i &lt;= n; ++i) x *= i;\n    return x;\n&#125;\n</code></pre>\n<p>这个是 C<ins>14。<br>\n对于 C</ins>11，请使用递归形式的  <code>fac()</code> 。</p>\n<h5 id=\"注解-45\"><a class=\"markdownIt-Anchor\" href=\"#注解-45\">#</a> 注解</h5>\n<p><code>constexpr</code>  并不会保证发生编译期求值；<br>\n它只能保证函数可以在当程序员需要或者编译器为优化而决定时，对常量表达式实参进行编译期求值。</p>\n<pre><code>constexpr int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\n\nvoid test(int v)\n&#123;\n    int m1 = min(-1, 2);            // 可能进行编译期求值\n    constexpr int m2 = min(-1, 2);  // 编译期求值\n    int m3 = min(-1, v);            // 运行期求值\n    constexpr int m4 = min(-1, v);  // 错误: 无法在编译期求值\n&#125;\n</code></pre>\n<h5 id=\"注解-46\"><a class=\"markdownIt-Anchor\" href=\"#注解-46\">#</a> 注解</h5>\n<p>不要试图让所有函数都变成  <code>constexpr</code> 。<br>\n大多数计算都最好在运行时进行。</p>\n<h5 id=\"注解-47\"><a class=\"markdownIt-Anchor\" href=\"#注解-47\">#</a> 注解</h5>\n<p>任何可能最终将依赖于高层次的运行时配置或者<br>\n业务逻辑的 API，都不应当是  <code>constexpr</code>  的。这种定制化是无法<br>\n由编译期来求值的，并且依赖于这种 API 的任何  <code>constexpr</code>  函数<br>\n也都应当进行重构，或者抛弃掉  <code>constexpr</code> 。</p>\n<h5 id=\"强制实施-33\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-33\">#</a> 强制实施</h5>\n<p>不可能也不必要。<br>\n当在要求常量的地方调用了非  <code>constexpr</code>  函数时，编译器会报告错误。</p>\n<h3 id=\"a-namerf-inlineaf5-如果函数非常小并且是时间敏感的就将其声明为-inline\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-inlineaf5-如果函数非常小并且是时间敏感的就将其声明为-inline\">#</a> <a name=\"Rf-inline\"></a>F.5: 如果函数非常小，并且是时间敏感的，就将其声明为  <code>inline</code></h3>\n<h5 id=\"理由-38\"><a class=\"markdownIt-Anchor\" href=\"#理由-38\">#</a> 理由</h5>\n<p>有些优化器可以不依赖于程序员的提示就能很好地进行内联，但请不要依赖这点。<br>\n请测量！至少超过 40 年，我们一直在允诺编译器可以不依赖于人类的提示而做到比人类更好地内联。<br>\n可是我们还在等。<br>\n（显式地，或于类定义体中编写成员函数而隐式地）将其指定为内联能够促进编译器工作得更好。</p>\n<h5 id=\"示例-35\"><a class=\"markdownIt-Anchor\" href=\"#示例-35\">#</a> 示例</h5>\n<pre><code>inline string cat(const string&amp; s, const string&amp; s2) &#123; return s + s2; &#125;\n</code></pre>\n<h5 id=\"例外-9\"><a class=\"markdownIt-Anchor\" href=\"#例外-9\">#</a> 例外</h5>\n<p>不要把  <code>inline</code>  函数加入需要变得稳定的接口中，除非你十分确定它不会再发生变化。<br>\n内联函数是 ABI 的一部分。</p>\n<h5 id=\"注解-48\"><a class=\"markdownIt-Anchor\" href=\"#注解-48\">#</a> 注解</h5>\n<p><code>constexpr</code>  蕴含  <code>inline</code> 。</p>\n<h5 id=\"注解-49\"><a class=\"markdownIt-Anchor\" href=\"#注解-49\">#</a> 注解</h5>\n<p>在类之中所定义的成员函数默认是  <code>inline</code>  的。</p>\n<h5 id=\"例外-10\"><a class=\"markdownIt-Anchor\" href=\"#例外-10\">#</a> 例外</h5>\n<p>函数模板（包括类模板的成员函数  <code>A&lt;T&gt;::function()</code>  和成员函数模板  <code>A::function&lt;T&gt;()</code> ）一般都定义于头文件中，因此是内联的。</p>\n<h5 id=\"强制实施-34\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-34\">#</a> 强制实施</h5>\n<p>对超过三条语句，并且本可以声明为非内联的  <code>inline</code>  函数（比如类成员函数）标记为  <code>inline</code> 。</p>\n<h3 id=\"a-namerf-noexceptaf6-如果函数必然不会抛出异常就将其声明为-noexcept\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-noexceptaf6-如果函数必然不会抛出异常就将其声明为-noexcept\">#</a> <a name=\"Rf-noexcept\"></a>F.6: 如果函数必然不会抛出异常，就将其声明为  <code>noexcept</code></h3>\n<h5 id=\"理由-39\"><a class=\"markdownIt-Anchor\" href=\"#理由-39\">#</a> 理由</h5>\n<p>如果不打算抛出异常的话，程序就会认为无法处理这种错误，并且应当尽早终止。把函数声明为  <code>noexcept</code>  对优化器有好处，因为其减少了可能的执行路径的数量。它也能使发生故障之后的退出动作有所加速。</p>\n<h5 id=\"示例-36\"><a class=\"markdownIt-Anchor\" href=\"#示例-36\">#</a> 示例</h5>\n<p>给完全以 C 或者其他任何没有异常的语言编写的每个函数都标上  <code>noexcept</code> 。<br>\nC++ 标准库隐含地对 C 标准库中的所有函数做了这件事。</p>\n<h5 id=\"注解-50\"><a class=\"markdownIt-Anchor\" href=\"#注解-50\">#</a> 注解</h5>\n<p><code>constexpr</code>  函数在运行时执行时可能抛出异常，因此可能需要对其中的一些使用有条件  <code>noexcept</code> 。</p>\n<h5 id=\"示例-37\"><a class=\"markdownIt-Anchor\" href=\"#示例-37\">#</a> 示例</h5>\n<p>对能够抛出异常的函数也可以使用  <code>noexcept</code> ：</p>\n<pre><code>vector&lt;string&gt; collect(istream&amp; is) noexcept\n&#123;\n    vector&lt;string&gt; res;\n    for (string s; is &gt;&gt; s;)\n        res.push_back(s);\n    return res;\n&#125;\n</code></pre>\n<p>如果  <code>collect()</code>  耗光了内存，程序就会崩溃。<br>\n除非这个程序特别精心编写成不会耗尽内存，否则这也许正是正确的方式；<br>\n <code>terminate()</code>  能够产生合适的错误日志信息（但当内存耗尽时是很难做出任何巧妙的事情的）。</p>\n<h5 id=\"注解-51\"><a class=\"markdownIt-Anchor\" href=\"#注解-51\">#</a> 注解</h5>\n<p>当你想决定是否要给函数标上  <code>noexcept</code>  时，一定要特别<br>\n注意你的代码的执行环境，尤其是与抛出异常和内存分配<br>\n相关的情形。打算成为完全通用的代码（比如像<br>\n标准库和其他类似的工具代码），应当支持那些<br>\n可以有意义地处理  <code>bad_alloc</code>  异常的执行环境。<br>\n不过，大多数程序和执行环境都不能有意义地<br>\n处理内存分配失败，而中止程序则是在这些情况中<br>\n应对分类失败的最干净和最简单的方式。如果已知<br>\n应用程序代码无法应对分配失败的话，对于即使<br>\n确实会进行分配的函数，添加  <code>noexcept</code>  也是适当的。</p>\n<p>换一种方式来说：在大多数程序中，大多数函数都会抛出异常（比如说，<br>\n它们可能使用  <code>new</code> ，调用会抛出异常的函数，或者使用通过抛出异常<br>\n来报告失败的库函数），因此请勿随意到处散布  <code>noexcept</code>  而不<br>\n考虑清楚是否有异常是可以被处理的。</p>\n<p><code>noexcept</code>  对于常用的，底层的函数是最有用处的（并且几乎<br>\n显然是正确的）。</p>\n<h5 id=\"注解-52\"><a class=\"markdownIt-Anchor\" href=\"#注解-52\">#</a> 注解</h5>\n<p>析构函数， <code>swap</code>  函数，移动操作，以及默认构造函数不应当抛出异常。<br>\n另请参见 <a href=\"#Rc-default00\">C.44</a>。</p>\n<h5 id=\"强制实施-35\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-35\">#</a> 强制实施</h5>\n<ul>\n<li>标记不是  <code>noexcept</code> ，而又不能抛出异常的函数。</li>\n<li>标记抛出异常的  <code>swap</code> ， <code>move</code> ，析构函数，以及默认构造函数。</li>\n</ul>\n<h3 id=\"a-namerf-smartaf7-对于常规用法应当接受-t-或-t-参数而不是智能指针\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-smartaf7-对于常规用法应当接受-t-或-t-参数而不是智能指针\">#</a> <a name=\"Rf-smart\"></a>F.7: 对于常规用法，应当接受  <code>T*</code>  或  <code>T&amp;</code>  参数而不是智能指针</h3>\n<h5 id=\"理由-40\"><a class=\"markdownIt-Anchor\" href=\"#理由-40\">#</a> 理由</h5>\n<p>智能指针的传递会转移或者共享所有权，因此应当仅在有意要实现所有权语义时才能使用。<br>\n不操作生存期的函数应当接受原始指针或引用。</p>\n<p>使用按智能指针传递方式把函数限制为只能服务于使用智能指针的调用方。<br>\n需要一个  <code>widget</code>  的函数应当能够接受任何  <code>widget</code>  对象，而不只是由某种特定种类的智能指针管理其生存期的那些。</p>\n<p>智能指针的传递（比如  <code>std::shared_ptr</code> ）暗含了一些运行时成本。</p>\n<h5 id=\"示例-38\"><a class=\"markdownIt-Anchor\" href=\"#示例-38\">#</a> 示例</h5>\n<pre><code>// 接受任何的 int*\nvoid f(int*);\n\n// 只能接受你想转移所有权的 int\nvoid g(unique_ptr&lt;int&gt;);\n\n// 只能接受你想共享所有权的 int\nvoid g(shared_ptr&lt;int&gt;);\n\n// 不会改变所有权，但要求调用方对其具有特定的所有权。\nvoid h(const unique_ptr&lt;int&gt;&amp;);\n\n// 接受任何的 int\nvoid h(int&amp;);\n</code></pre>\n<h5 id=\"示例不好-19\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-19\">#</a> 示例，不好</h5>\n<pre><code>// 被调用方\nvoid f(shared_ptr&lt;widget&gt;&amp; w)\n&#123;\n    // ...\n    use(*w); // w 的唯一使用点 -- 其生存期是完全未被涉及到的\n    // ...\n&#125;;\n\n// 调用方\nshared_ptr&lt;widget&gt; my_widget = /* ... */;\nf(my_widget);\n\nwidget stack_widget;\nf(stack_widget); // 错误\n</code></pre>\n<h5 id=\"示例好-3\"><a class=\"markdownIt-Anchor\" href=\"#示例好-3\">#</a> 示例，好</h5>\n<pre><code>// 被调用方\nvoid f(widget&amp; w)\n&#123;\n    // ...\n    use(w);\n    // ...\n&#125;;\n\n// 调用方\nshared_ptr&lt;widget&gt; my_widget = /* ... */;\nf(*my_widget);\n\nwidget stack_widget;\nf(stack_widget); // ok -- 这样就有效了\n</code></pre>\n<h5 id=\"注解-53\"><a class=\"markdownIt-Anchor\" href=\"#注解-53\">#</a> 注解</h5>\n<p>我们可以静态地找出悬挂指针的许多常见情况（参见<a href=\"#SS-lifetime\">生存期安全性剖面配置</a>）。函数实参天然存活于函数调用的生存期，因而具有更少的生存期问题。</p>\n<h5 id=\"强制实施-36\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-36\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】若函数接受可复制的智能指针类型（即重载了  <code>operator-&gt;</code>  或  <code>operator*</code> ），但该函数仅调用了： <code>operator*</code> 、 <code>operator-&gt;</code>  或  <code>get()</code> ，则给出警告。<br>\n建议代之以  <code>T*</code>  或  <code>T&amp;</code> 。</li>\n<li>对于智能指针类型（重载了  <code>operator-&gt;</code>  或  <code>operator*</code>  的类型）的参数，若它是可复制 / 可移动的，但从没有从函数体中被复制 / 移动出来，且从未对其进行修改，且未将其传递给会修改它其他函数，对之进行标记。这意味着并未使用其所有权语义。<br>\n建议代之以  <code>T*</code>  或  <code>T&amp;</code> 。</li>\n</ul>\n<p><strong>参见</strong></p>\n<ul>\n<li><a href=\"#Rf-ptr-ref\">当 “无实参” 是有效情形时，优先采用  <code>T*</code>  而不是  <code>T&amp;</code> </a></li>\n<li><a href=\"#Rr-summary-smartptrs\">智能指针规则概述</a></li>\n</ul>\n<h3 id=\"a-namerf-pureaf8-优先采用纯函数\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-pureaf8-优先采用纯函数\">#</a> <a name=\"Rf-pure\"></a>F.8: 优先采用纯函数</h3>\n<h5 id=\"理由-41\"><a class=\"markdownIt-Anchor\" href=\"#理由-41\">#</a> 理由</h5>\n<p>纯函数更容易进行推导，有时候也更易于优化（甚至并行化），有时候还可以进行存储。</p>\n<h5 id=\"示例-39\"><a class=\"markdownIt-Anchor\" href=\"#示例-39\">#</a> 示例</h5>\n<pre><code>template&lt;class T&gt;\nauto square(T t) &#123; return t * t; &#125;\n</code></pre>\n<h5 id=\"强制实施-37\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-37\">#</a> 强制实施</h5>\n<p>不可能进行强制实施。</p>\n<h3 id=\"a-namerf-unusedaf9-未使用的形参应当没有名字\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-unusedaf9-未使用的形参应当没有名字\">#</a> <a name=\"Rf-unused\"></a>F.9: 未使用的形参应当没有名字</h3>\n<h5 id=\"理由-42\"><a class=\"markdownIt-Anchor\" href=\"#理由-42\">#</a> 理由</h5>\n<p>可读性。<br>\n抑制未使用形参的警告消息。</p>\n<h5 id=\"示例-40\"><a class=\"markdownIt-Anchor\" href=\"#示例-40\">#</a> 示例</h5>\n<pre><code>widget* find(const set&lt;widget&gt;&amp; s, const widget&amp; w, Hint);   // 这里曾经使用过一个提示\n</code></pre>\n<h5 id=\"注解-54\"><a class=\"markdownIt-Anchor\" href=\"#注解-54\">#</a> 注解</h5>\n<p>为解决这个问题，在 1980 年代早期就引入了允许形参无名的规则。</p>\n<p>如果形参是根据条件不被使用的，可以用  <code>[[maybe_unused]]</code>  特性来声明它们。<br>\n例如：</p>\n<pre><code>template &lt;typename Value&gt;\nValue* find(const set&lt;Value&gt;&amp; s, const Value&amp; v, [[maybe_unused]] Hint h)\n&#123;\n    if constexpr (sizeof(Value) &gt; CacheSize)\n    &#123;\n        // 仅当 Value 具有特定大小时才使用提示参数\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"强制实施-38\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-38\">#</a> 强制实施</h5>\n<p>对有名字的未使用形参进行标记。</p>\n<h3 id=\"a-namerf-nameaf10-若操作可被重用则应为其命名\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-nameaf10-若操作可被重用则应为其命名\">#</a> <a name=\"Rf-name\"></a>F.10: 若操作可被重用，则应为其命名</h3>\n<h5 id=\"理由-43\"><a class=\"markdownIt-Anchor\" href=\"#理由-43\">#</a> 理由</h5>\n<p>文档，可读性，重用机会。</p>\n<h5 id=\"示例-41\"><a class=\"markdownIt-Anchor\" href=\"#示例-41\">#</a> 示例</h5>\n<pre><code>struct Rec &#123;\n    string name;\n    string addr;\n    int id;         // 唯一标识符\n&#125;;\n\nbool same(const Rec&amp; a, const Rec&amp; b)\n&#123;\n    return a.id == b.id;\n&#125;\n\nvector&lt;Rec*&gt; find_id(const string&amp; name);    // 寻找“name”的所有记录\n\nauto x = find_if(vr.begin(), vr.end(),\n    [&amp;](Rec&amp; r) &#123;\n        if (r.name.size() != n.size()) return false; // 要比较的名字在 n 里\n        for (int i = 0; i &lt; r.name.size(); ++i)\n            if (tolower(r.name[i]) != tolower(n[i])) return false;\n        return true;\n    &#125;\n);\n</code></pre>\n<p>这里蕴含着一个有用的函数（大小写不敏感的字符串比较），lambda 的参数变大时总会这样。</p>\n<pre><code>bool compare_insensitive(const string&amp; a, const string&amp; b)\n&#123;\n    if (a.size() != b.size()) return false;\n    for (int i = 0; i &lt; a.size(); ++i) if (tolower(a[i]) != tolower(b[i])) return false;\n    return true;\n&#125;\n\nauto x = find_if(vr.begin(), vr.end(),\n    [&amp;](Rec&amp; r) &#123; return compare_insensitive(r.name, n); &#125;\n);\n</code></pre>\n<p>或者可以这样（如果你倾向于避免隐含绑定到  <code>n</code>  的名字）：</p>\n<pre><code>auto cmp_to_n = [&amp;n](const string&amp; a) &#123; return compare_insensitive(a, n); &#125;;\n\nauto x = find_if(vr.begin(), vr.end(),\n    [](const Rec&amp; r) &#123; return cmp_to_n(r.name); &#125;\n);\n</code></pre>\n<h5 id=\"注解-55\"><a class=\"markdownIt-Anchor\" href=\"#注解-55\">#</a> 注解</h5>\n<p>函数、lambda 或运算符均如此。</p>\n<h5 id=\"例外-11\"><a class=\"markdownIt-Anchor\" href=\"#例外-11\">#</a> 例外</h5>\n<ul>\n<li>逻辑上仅在局部使用的 lambda，比如作为  <code>for_each</code>  或类似控制流算法的实参。</li>\n<li>作为<a href=\"#???\">初始化</a>的 lambda。</li>\n</ul>\n<h5 id=\"强制实施-39\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-39\">#</a> 强制实施</h5>\n<ul>\n<li>【困难】 标记相似的 lambda</li>\n<li>???</li>\n</ul>\n<h3 id=\"a-namerf-lambdaaf11-当需要仅在一处使用的简单函数对象时使用无名-lambda\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-lambdaaf11-当需要仅在一处使用的简单函数对象时使用无名-lambda\">#</a> <a name=\"Rf-lambda\"></a>F.11: 当需要仅在一处使用的简单函数对象时使用无名 lambda</h3>\n<h5 id=\"理由-44\"><a class=\"markdownIt-Anchor\" href=\"#理由-44\">#</a> 理由</h5>\n<p>使代码精简，提供比其他方式更好的局部性。</p>\n<h5 id=\"示例-42\"><a class=\"markdownIt-Anchor\" href=\"#示例-42\">#</a> 示例</h5>\n<pre><code>auto earlyUsersEnd = std::remove_if(users.begin(), users.end(),\n                                    [](const User &amp;a) &#123; return a.id &gt; 100; &#125;);\n</code></pre>\n<h5 id=\"例外-12\"><a class=\"markdownIt-Anchor\" href=\"#例外-12\">#</a> 例外</h5>\n<p>为 lambda 命名有助于明晰代码，即便它仅用一次。</p>\n<h5 id=\"强制实施-40\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-40\">#</a> 强制实施</h5>\n<ul>\n<li>寻找相同或几乎相同的 lambda（以将它们替换为具名的函数或者具名的 lambda）。</li>\n</ul>\n<h2 id=\"a-namess-callafcall-参数传递\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-callafcall-参数传递\">#</a> <a name=\"SS-call\"></a>F.call: 参数传递</h2>\n<p>存在各种不同的向函数传递参数和返回值的方式。</p>\n<h3 id=\"a-namerf-conventionalaf15-优先采用简单的和传统的信息传递方式\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-conventionalaf15-优先采用简单的和传统的信息传递方式\">#</a> <a name=\"Rf-conventional\"></a>F.15: 优先采用简单的和传统的信息传递方式</h3>\n<h5 id=\"理由-45\"><a class=\"markdownIt-Anchor\" href=\"#理由-45\">#</a> 理由</h5>\n<p>使用 “与众不同和精巧” 的技巧会带来意外，其他程序员的理解减慢，并促进 BUG 的发生。<br>\n如果你确实想要比常规技巧更好的优化，请进行测量以确保它真的有所提升，并为其写下文档 / 注释，因为这种提升可能无法移植。</p>\n<p>下面的表格总结了以下 F.16-21 的各个指导方针中的建议。</p>\n<p>一般性参数传递：</p>\n<p><img data-src=\"D:/desk/git/images/param-passing-normal.png\" alt=\"一般性参数传递表\" title=\"一般性参数传递\"></p>\n<p>高级参数传递：</p>\n<p><img data-src=\"D:/desk/git/images/param-passing-advanced.png\" alt=\"高级参数传递表\" title=\"高级参数传递\"></p>\n<p>只有在进行论证必要之后再使用高级技巧，并将其必要性注明在代码注释中。</p>\n<p>对于字符序列的传递，参见 <a href=\"#SS-string\">字符串</a>。</p>\n<h5 id=\"例外-13\"><a class=\"markdownIt-Anchor\" href=\"#例外-13\">#</a> 例外</h5>\n<p>使用  <code>shared_ptr</code>  等类型来表达共享所有权时，不应遵循指导方针 F.16-21，<br>\n而应遵循 <a href=\"#Rr-sharedptrparam-owner\">R.34</a>，<a href=\"#Rr-sharedptrparam\">R.35</a>，以及 <a href=\"#Rr-sharedptrparam-const\">R.36</a>。</p>\n<h3 id=\"a-namerf-inaf16-对于输入in参数把复制操作廉价的类型按值进行传递把其他类型按-const-引用进行传递\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-inaf16-对于输入in参数把复制操作廉价的类型按值进行传递把其他类型按-const-引用进行传递\">#</a> <a name=\"Rf-in\"></a>F.16: 对于 “输入（in）” 参数，把复制操作廉价的类型按值进行传递，把其他类型按  <code>const</code>  引用进行传递</h3>\n<h5 id=\"理由-46\"><a class=\"markdownIt-Anchor\" href=\"#理由-46\">#</a> 理由</h5>\n<p>既能让调用者了解函数不会修改其参数，也使得参数能够以右值初始化。</p>\n<p>何谓 “复制操作廉价” 依赖于机器的架构，不过只有两三个机器字（Word）的类型（double，指针，引用等）一般最好按值传递。<br>\n当可以廉价复制时，没什么比得过进行复制的简单性和安全性，而且对于小型对象（最多两三个机器字）来说，也比按引用传递更快，因为它不需要在函数中进行一次额外的间接访问。</p>\n<h5 id=\"示例-43\"><a class=\"markdownIt-Anchor\" href=\"#示例-43\">#</a> 示例</h5>\n<pre><code>void f1(const string&amp; s);  // OK: 按 const 引用传递; 总是廉价的\n\nvoid f2(string s);         // bad: 可能是昂贵的\n\nvoid f3(int x);            // OK: 无可比拟\n\nvoid f4(const int&amp; x);     // bad: f4() 中的访问带来开销\n</code></pre>\n<p>（仅）对于高级的运用，如果你确实需要为 “只当作输入” 的参数的按右值传递进行优化的话：</p>\n<ul>\n<li>如果函数需要无条件地从参数进行移动，那就按  <code>&amp;&amp;</code>  来接受参数。参见 <a href=\"#Rf-consume\">F.18</a>。</li>\n<li>如果函数需要保留参数的一个副本，那就在按  <code>const&amp;</code>  接受参数（对于左值）之外，<br>\n添加一个按  <code>&amp;&amp;</code>  传递参数（对于右值）的重载，并在函数体中将之  <code>std::move</code>  到其目标之中。基本上，这个重载是 “将被移动（will-move-from）”；参见 <a href=\"#Rf-consume\">F.18</a>。</li>\n<li>在特殊情况中，比如有多个 “输入 + 复制” 的参数时，考虑采用完美转发。参见 <a href=\"#Rf-forward\">F.19</a>。</li>\n</ul>\n<h5 id=\"示例-44\"><a class=\"markdownIt-Anchor\" href=\"#示例-44\">#</a> 示例</h5>\n<pre><code>int multiply(int, int); // 仅输入了 int，按值传递\n\n// suffix 仅作输入，但并不如 int 那样廉价，因此按 const&amp; 传递\nstring&amp; concatenate(string&amp;, const string&amp; suffix);\n\nvoid sink(unique_ptr&lt;widget&gt;);  // 仅作输入，但移动了这个 widget 的所有权\n</code></pre>\n<p>避免 “为了效率” 而按  <code>T&amp;&amp;</code>  来传递参数这类的 “玄奥技巧”。<br>\n关于按  <code>&amp;&amp;</code>  传递带来性能好处的大多数传言都是假的或者是脆弱的（不过也请参考 <a href=\"#Rf-consume\">F.18</a> 和 <a href=\"#Rf-forward\">F.19</a>）。</p>\n<h5 id=\"注解-56\"><a class=\"markdownIt-Anchor\" href=\"#注解-56\">#</a> 注解</h5>\n<p>可以假定引用都指代了某个有效对象（语言规则）。<br>\n“空引用”（正规地说）是不存在的。<br>\n如果要表示一个非强制的值，请使用指针， <code>std::optional</code> ，或者一个用以代表 “没有值” 的特殊值。</p>\n<h5 id=\"强制实施-41\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-41\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】〔基础〕 当按值传递的参数的大小大于  <code>2 * sizeof(void*)</code>  时给出警告。<br>\n建议代之以  <code>const</code>  的引用。</li>\n<li>【简单】〔基础〕 当按  <code>const</code>  引用传递的参数的大小小于或等于  <code>2 * sizeof(void*)</code>  时给出警告。建议代之以按值传递。</li>\n<li>【简单】〔基础〕 当按  <code>const</code>  引用传递的参数被  <code>move</code>  时给出警告。</li>\n</ul>\n<h5 id=\"例外-14\"><a class=\"markdownIt-Anchor\" href=\"#例外-14\">#</a> 例外</h5>\n<p>使用  <code>shared_ptr</code>  等类型来表达共享所有权时，应遵循 <a href=\"#Rr-sharedptrparam-owner\">R.34</a> 或 <a href=\"#Rr-sharedptrparam-const\">R.36</a>，<br>\n取决于函数是否无条件地获取实参的引用。</p>\n<h3 id=\"a-namerf-inoutaf17-对于输入输出in-out参数按非-const-引用进行传递\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-inoutaf17-对于输入输出in-out参数按非-const-引用进行传递\">#</a> <a name=\"Rf-inout\"></a>F.17: 对于 “输入 / 输出（in-out）” 参数，按非  <code>const</code>  引用进行传递</h3>\n<h5 id=\"理由-47\"><a class=\"markdownIt-Anchor\" href=\"#理由-47\">#</a> 理由</h5>\n<p>让调用者明了这个对象假定将会被改动。</p>\n<h5 id=\"示例-45\"><a class=\"markdownIt-Anchor\" href=\"#示例-45\">#</a> 示例</h5>\n<pre><code>void update(Record&amp; r);  // 假定 update 将会写入 r\n</code></pre>\n<h5 id=\"注解-57\"><a class=\"markdownIt-Anchor\" href=\"#注解-57\">#</a> 注解</h5>\n<p>一些用户定义和标准程序库的类型，如  <code>span&lt;T&gt;</code>  或迭代器等，<br>\n是<a href=\"#Rf-in\">可廉价复制</a>的，并可按值传递，<br>\n这样做时具有可改动（in-out）引用语义：</p>\n<pre><code>void increment_all(span&lt;int&gt; a)\n&#123;\n  for (auto&amp;&amp; e : a)\n    ++e;\n&#125;\n</code></pre>\n<h5 id=\"注解-58\"><a class=\"markdownIt-Anchor\" href=\"#注解-58\">#</a> 注解</h5>\n<p><code>T&amp;</code>  参数既可以向函数中传递信息，也可以传递出来。<br>\n因此  <code>T&amp;</code>  能够作为 “输入 / 输出” 参数。这点本身就可能是一种错误的来源：</p>\n<pre><code>void f(string&amp; s)\n&#123;\n    s = &quot;New York&quot;;  // 不明显的错误\n&#125;\n\nvoid g()\n&#123;\n    string buffer = &quot;.................................&quot;;\n    f(buffer);\n    // ...\n&#125;\n</code></pre>\n<p>这里， <code>g()</code>  的作者提供了一个缓冲区让  <code>f()</code>  来填充，但  <code>f()</code>  仅仅替换掉了它（以多少比简单的字符复制高一些的成本）。<br>\n如果  <code>g()</code>  的作者对  <code>buffer</code>  的大小作出了错误的假设的话，就会发生糟糕的逻辑错误。</p>\n<h5 id=\"强制实施-42\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-42\">#</a> 强制实施</h5>\n<ul>\n<li>【中等】〔基础〕 对带有指向非  <code>const</code>  的引用参数但又<em>不</em>向其进行写入的函数给出警告。</li>\n<li>【简单】〔基础〕 当按引用传递的非  <code>const</code>  参数被进行  <code>move</code>  时给出警告。</li>\n</ul>\n<h3 id=\"a-namerf-consumeaf18-对于将被移动will-move-from参数按-x-进行传递并对参数-stdmove\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-consumeaf18-对于将被移动will-move-from参数按-x-进行传递并对参数-stdmove\">#</a> <a name=\"Rf-consume\"></a>F.18: 对于 “将被移动（will-move-from）” 参数，按  <code>X&amp;&amp;</code>  进行传递并对参数  <code>std::move</code></h3>\n<h5 id=\"理由-48\"><a class=\"markdownIt-Anchor\" href=\"#理由-48\">#</a> 理由</h5>\n<p>这样做很高效，并且消除了调用点的 BUG： <code>X&amp;&amp;</code>  绑定到右值，而要传递左值的话则要求在调用点明确进行  <code>std::move</code> 。</p>\n<h5 id=\"示例-46\"><a class=\"markdownIt-Anchor\" href=\"#示例-46\">#</a> 示例</h5>\n<pre><code>void sink(vector&lt;int&gt;&amp;&amp; v)  // 无论参数所拥有的是什么，sink 都获得了其所有权\n&#123;\n    // 通常这里可能有对 v 的 const 访问\n    store_somewhere(std::move(v));\n    // 通常这里不再会使用 v 了；它已经被移走\n&#125;\n</code></pre>\n<p>注意， <code>std::move(v)</code>  使得  <code>store_somewhere()</code>  可以把  <code>v</code>  遗留为被移走的状态。<br>\n<a href=\"#Rc-move-semantic\">这可能很危险</a>。</p>\n<h5 id=\"例外-15\"><a class=\"markdownIt-Anchor\" href=\"#例外-15\">#</a> 例外</h5>\n<p>只能移动并且移动廉价的唯一拥有者类型，比如  <code>unique_ptr</code> ，也可以按值传递，这样写起来更简单而且效果相同。按值传递确实产生了一次额外的（廉价）移动操作，但我们更加优先于简单性和清晰性。</p>\n<p>例如：</p>\n<pre><code>template&lt;class T&gt;\nvoid sink(std::unique_ptr&lt;T&gt; p)\n&#123;\n    // 使用 p ... 可能在之后的什么地方 std::move(p)\n&#125;   // p 被销毁\n</code></pre>\n<h5 id=\"例外-16\"><a class=\"markdownIt-Anchor\" href=\"#例外-16\">#</a> 例外</h5>\n<p>当 “将被移动” 的形参是  <code>shared_ptr</code>  时，应遵循 <a href=\"#Rr-sharedptrparam-owner\">R.34</a>，并按值传递  <code>shared_ptr</code> 。</p>\n<h5 id=\"强制实施-43\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-43\">#</a> 强制实施</h5>\n<ul>\n<li>对于所有  <code>X&amp;&amp;</code>  参数（其中的  <code>X</code>  不是模板类型参数的名字），如果函数体中使用它时没有用  <code>std::move</code> ，就将其标明。</li>\n<li>标明对已经被移动过的对象的访问。</li>\n<li>不要有条件地从对象进行移动。</li>\n</ul>\n<h3 id=\"a-namerf-forwardaf19-对于转发forward参数按-tp-进行传递并只对参数-stdforward\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-forwardaf19-对于转发forward参数按-tp-进行传递并只对参数-stdforward\">#</a> <a name=\"Rf-forward\"></a>F.19: 对于 “转发（forward）” 参数，按  <code>TP&amp;&amp;</code>  进行传递并只对参数  <code>std::forward</code></h3>\n<h5 id=\"理由-49\"><a class=\"markdownIt-Anchor\" href=\"#理由-49\">#</a> 理由</h5>\n<p>如果一个对象要被传递给其他代码而并不在本函数中直接使用，我们就想让这个函数对于该参数的  <code>const</code>  性质和右值性质来说是中立的。</p>\n<p>这种情况下，而且只有这种情况下，才应当让参数为  <code>TP&amp;&amp;</code> ，其中  <code>TP</code>  为模板类型参数 —— 它既<em>忽略</em>了也<em>保持</em>了  <code>const</code>  性质和右值性质。因而使用  <code>TP&amp;&amp;</code>  的任何代码都隐含地声称它自己并不关心变量的  <code>const</code>  性质和右值性质（因为这被忽略了），但它有意把值继续传递给其他确实关心  <code>const</code>  性质和右值性质的代码（因为这也是被保持的）。把  <code>TP&amp;&amp;</code>  用于参数类型上是安全的，因为从调用方传递来的任何临时对象都会在函数调用期间一直存活。基本上  <code>TP&amp;&amp;</code>  类型的参数应当总是在函数体中通过  <code>std::forward</code>  来继续传递。</p>\n<h5 id=\"示例-47\"><a class=\"markdownIt-Anchor\" href=\"#示例-47\">#</a> 示例</h5>\n<p>你通常在每个静态控制流路径中恰好进行一次完整的形参（或形参包组，通过  <code>...</code> ）的转发：</p>\n<pre><code>template&lt;class F, class... Args&gt;\ninline auto invoke(F f, Args&amp;&amp;... args)\n&#123;\n    return f(forward&lt;Args&gt;(args)...);\n&#125;\n</code></pre>\n<h5 id=\"示例-48\"><a class=\"markdownIt-Anchor\" href=\"#示例-48\">#</a> 示例</h5>\n<p>有时候，你可能会在每个静态控制流路径中按每个子对象一次的方式分段转发一个组合形参：</p>\n<pre><code>template&lt;class PairLike&gt;\ninline auto test(PairLike&amp;&amp;... pairlike)\n&#123;\n    // ...\n    f1(some, args, and, forward&lt;PairLike&gt;(pairlike).first);           // 转发 .first\n    f2(and, forward&lt;PairLike&gt;(pairlike).second, in, another, call);   // 转发 .second\n&#125;\n</code></pre>\n<h5 id=\"强制实施-44\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-44\">#</a> 强制实施</h5>\n<ul>\n<li>对于接受  <code>TP&amp;&amp;</code>  参数的函数（其中的  <code>TP</code>  不是模板类型参数的名字），如果函数对它做了任何别的事，而不是在每个静态路径中都正好进行一次  <code>std::forward</code> ，或者在每个静态路径中对其进行多次  <code>std::forward</code>  但限定为不同的数据成员均正好进行一次，就将函数进行标明。</li>\n</ul>\n<h3 id=\"a-namerf-outaf20-对于输出out值采用返回值优先于输出参数\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-outaf20-对于输出out值采用返回值优先于输出参数\">#</a> <a name=\"Rf-out\"></a>F.20: 对于 “输出（out）” 值，采用返回值优先于输出参数</h3>\n<h5 id=\"理由-50\"><a class=\"markdownIt-Anchor\" href=\"#理由-50\">#</a> 理由</h5>\n<p>返回值是自我说明的，而  <code>&amp;</code>  参数则既可能是输入 / 输出的也可能是仅输出的，并且倾向于被误用。</p>\n<p>适用的情况也包括如标准容器这样的大型对象，它们为性能因素使用了隐式的移动操作，并且避免进行显式的内存管理。</p>\n<p>当有多个值要返回时，<a href=\"#Rf-out-multi\">使用元组</a>或者类似的多成员类型。</p>\n<h5 id=\"示例-49\"><a class=\"markdownIt-Anchor\" href=\"#示例-49\">#</a> 示例</h5>\n<pre><code>// OK: 返回指向具有 x 值的元素的指针\nvector&lt;const int*&gt; find_all(const vector&lt;int&gt;&amp;, int x);\n\n// 不好: 把指向具有 x 值的元素的指针放入 out\nvoid find_all(const vector&lt;int&gt;&amp;, vector&lt;const int*&gt;&amp; out, int x);\n</code></pre>\n<h5 id=\"注解-59\"><a class=\"markdownIt-Anchor\" href=\"#注解-59\">#</a> 注解</h5>\n<p>含有许多（每个都廉价移动的）元素的  <code>struct</code> ，聚合起来则可能是移动操作昂贵的。</p>\n<h5 id=\"例外-17\"><a class=\"markdownIt-Anchor\" href=\"#例外-17\">#</a> 例外</h5>\n<ul>\n<li>对于非具体类型，比如继承层次中的类型来说，可以用  <code>unique_ptr</code>  或  <code>shared_ptr</code>  来返回对象。</li>\n<li>如果类型的移动操作昂贵（比如  <code>array&lt;BigPOD&gt;</code> ），就考虑将其分配在自由存储中并返回一个句柄（比如  <code>unique_ptr</code> ），或者传递一个指代用以填充的非  <code>const</code>  目标对象的引用（将其用作输出参数）。</li>\n<li>对于内部循环中的多次函数调用之间重用自带容量的对象（比如  <code>std::string</code>  和  <code>std::vector</code> ）：<a href=\"#Rf-out-multi\">将其按照输入 / 输出参数处理，并按引用传递</a>。</li>\n</ul>\n<h5 id=\"示例-50\"><a class=\"markdownIt-Anchor\" href=\"#示例-50\">#</a> 示例</h5>\n<p>假设  <code>Matrix</code>  带有移动操作（可能它将其元素都保存在一个  <code>std::vector</code>  中）：</p>\n<pre><code>Matrix operator+(const Matrix&amp; a, const Matrix&amp; b)\n&#123;\n    Matrix res;\n    // ... 用二者的和填充 res ...\n    return res;\n&#125;\n\nMatrix x = m1 + m2;  // 移动构造函数\n\ny = m3 + m3;         // 移动赋值\n</code></pre>\n<h5 id=\"注解-60\"><a class=\"markdownIt-Anchor\" href=\"#注解-60\">#</a> 注解</h5>\n<p>返回值优化无法处理赋值的情况，不过移动赋值却可以。</p>\n<h5 id=\"示例-51\"><a class=\"markdownIt-Anchor\" href=\"#示例-51\">#</a> 示例</h5>\n<pre><code>struct Package &#123;      // 特殊情况: 移动操作昂贵的对象\n    char header[16];\n    char load[2024 - 16];\n&#125;;\n\nPackage fill();       // 不好: 大型的返回值\nvoid fill(Package&amp;);  // OK\n\nint val();            // OK\nvoid val(int&amp;);       // 不好: val 会不会读取参数？\n</code></pre>\n<h5 id=\"强制实施-45\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-45\">#</a> 强制实施</h5>\n<ul>\n<li>对于指代非  <code>const</code>  的引用参数，如果其被写入之前未进行过读取，而且其类型能够廉价地返回，则标记它们；它们应当是 “输入” 的返回值。</li>\n</ul>\n<h3 id=\"a-namerf-out-multiaf21-要返回多个输出值优先返回结构体或元组tuple\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-out-multiaf21-要返回多个输出值优先返回结构体或元组tuple\">#</a> <a name=\"Rf-out-multi\"></a>F.21: 要返回多个 “输出” 值，优先返回结构体或元组（tuple）</h3>\n<h5 id=\"理由-51\"><a class=\"markdownIt-Anchor\" href=\"#理由-51\">#</a> 理由</h5>\n<p>返回值是自我说明为 “仅输出” 值的。<br>\n注意，C++ 是支持多返回值的，按约定使用的是  <code>tuple</code> （包括  <code>pair</code> ），并可以在调用点使用  <code>tie</code>  或结构化绑定（C++17）以带来更多的便利。<br>\n优先使用具名的结构体，使其返回值具有语义。不过，没有名字的  <code>tuple</code>  在泛型代码中则很有用。</p>\n<h5 id=\"示例-52\"><a class=\"markdownIt-Anchor\" href=\"#示例-52\">#</a> 示例</h5>\n<pre><code>// 不好: 在代码注释作用说明仅作输出的参数\nint f(const string&amp; input, /*output only*/ string&amp; output_data)\n&#123;\n    // ...\n    output_data = something();\n    return status;\n&#125;\n\n// 好: 自我说明的\ntuple&lt;int, string&gt; f(const string&amp; input)\n&#123;\n    // ...\n    return &#123;status, something()&#125;;\n&#125;\n</code></pre>\n<p>C++98 的标准库已经使用这种风格了，因为  <code>pair</code>  就像一种两个元素的  <code>tuple</code>  一样。<br>\n例如，给定一个  <code>set&lt;string&gt; my_set</code> ，请考虑：</p>\n<pre><code>// C++98\nresult = my_set.insert(&quot;Hello&quot;);\nif (result.second) do_something_with(result.first);    // 变通方案\n</code></pre>\n<p>在 C++11 中我们可以这样写，将结果直接放入现存的局部变量中：</p>\n<pre><code>Sometype iter;                                // 如果我们还未因为别的目的而使用\nSomeothertype success;                        // 这些变量，则进行默认初始化\n\ntie(iter, success) = my_set.insert(&quot;Hello&quot;);   // 普通的返回值\nif (success) do_something_with(iter);\n</code></pre>\n<p>而在 C++17 中，我们可以使用 “结构化绑定” 对多个变量进行声明和初始化：</p>\n<pre><code>if (auto [ iter, success ] = my_set.insert(&quot;Hello&quot;); success) do_something_with(iter);\n</code></pre>\n<h5 id=\"例外-18\"><a class=\"markdownIt-Anchor\" href=\"#例外-18\">#</a> 例外</h5>\n<p>有时候需要把对象传递给函数让其操纵它的状态。<br>\n这种情况下，按引用传递对象 <a href=\"#Rf-inout\"> <code>T&amp;</code> </a> 通常是恰当的技巧。<br>\n显式传递一个输入 / 输出参数再让其作为返回值返回出来通常是没必要的。<br>\n例如：</p>\n<pre><code>istream&amp; operator&gt;&gt;(istream&amp; in, string&amp; s);    // 与 std::operator&gt;&gt;() 很相似\n\nfor (string s; in &gt;&gt; s; ) &#123;\n    // 对文本行做些事\n&#125;\n</code></pre>\n<p>这里， <code>s</code>  和  <code>in</code>  都用作了输入 / 输出参数。<br>\n <code>in</code>  按（非  <code>const</code> ）引用来传递，以便可以操作其状态。<br>\n <code>s</code>  的传递是为避免重复进行分配。<br>\n通过重用  <code>s</code> （按引用传递），我们只需要在为扩展  <code>s</code>  的容量时才会分配新的内存。<br>\n这种技巧有时候被称为 “调用方分配的输出参数” 模式，它特别适合于<br>\n诸如  <code>string</code>  和  <code>vector</code>  这样需要进行自由存储分配的类型。</p>\n<p>比较一下，如果所有的值都按返回值传递出来的话，得像如下这样做：</p>\n<pre><code>pair&lt;istream&amp;, string&gt; get_string(istream&amp; in)  // 不建议这样做\n&#123;\n    string s;\n    in &gt;&gt; s;\n    return &#123;in, move(s)&#125;;\n&#125;\n\nfor (auto p = get_string(cin); p.first; ) &#123;\n    // 对 p.second 做些事\n&#125;\n</code></pre>\n<p>我们觉得这样明显不够简洁，而且性能明显更差。</p>\n<p>当严格理解这条规则（F.21）时，这些例外并不真的算是例外，因为它依赖于输入 / 输出参数，<br>\n而不是规则中提到的单纯的输出参数。<br>\n不过我们倾向于进行明确而不是精巧的说明。</p>\n<h5 id=\"注解-61\"><a class=\"markdownIt-Anchor\" href=\"#注解-61\">#</a> 注解</h5>\n<p>许多情况下，返回某种用户定义的某个专门的类型是有好处的。<br>\n例如：</p>\n<pre><code>struct Distance &#123;\n    int value;\n    int unit = 1;   // 1 表示一米\n&#125;;\n\nDistance d1 = measure(obj1);        // 访问 d1.value 和 d1.unit\nauto d2 = measure(obj2);            // 访问 d2.value 和 d2.unit\nauto [value, unit] = measure(obj3); // 访问 value 和 unit；\n                                    // 对于了解 measure() 的人来说有点多余\nauto [x, y] = measure(obj4);        // 请勿如此；这很可能造成混乱\n</code></pre>\n<p>只有当返回的值表现的是几个无关实体而不是某个抽象的时候，才应使用过于通用的  <code>pair</code>  和  <code>tuple</code> 。</p>\n<p>作为另一个例子，应当使用像  <code>variant&lt;T, error_code&gt;</code>  这样的专门的类型，而不使用通用的  <code>tuple</code> 。</p>\n<h5 id=\"注解-62\"><a class=\"markdownIt-Anchor\" href=\"#注解-62\">#</a> 注解</h5>\n<p>当所要返回的元组是从复制操作昂贵的局部变量进行初始化时，<br>\n可以用显式  <code>move</code>  有效避免复制：</p>\n<pre><code>pair&lt;LargeObject, LargeObject&gt; f(const string&amp; input)\n&#123;\n    LargeObject large1 = g(input);\n    LargeObject large2 = h(input);\n    // ...\n    return &#123; move(large1), move(large2) &#125;; // 没有复制\n&#125;\n</code></pre>\n<p>还可以：</p>\n<pre><code>pair&lt;LargeObject, LargeObject&gt; f(const string&amp; input)\n&#123;\n    // ...\n    return &#123; g(input), h(input) &#125;; // 没有复制，没有移动\n&#125;\n</code></pre>\n<p>请注意这与 <a href=\"#Res-move\">ES.56</a> 的  <code>return move(...)</code>  反模式是不同的。</p>\n<h5 id=\"强制实施-46\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-46\">#</a> 强制实施</h5>\n<ul>\n<li>输出参数应当被替换为返回值。<br>\n输出参数时由函数写入的，调用了非  <code>const</code>  成员函数的，或者将它作为非  <code>const</code>  参数继续传递的参数。</li>\n</ul>\n<h3 id=\"a-namerf-ptr-refaf60-当没有参数是有效的选项时采用-t-优先于-t\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-ptr-refaf60-当没有参数是有效的选项时采用-t-优先于-t\">#</a> <a name=\"Rf-ptr-ref\"></a>F.60: 当 “没有参数” 是有效的选项时，采用  <code>T*</code>  优先于  <code>T&amp;</code></h3>\n<h5 id=\"理由-52\"><a class=\"markdownIt-Anchor\" href=\"#理由-52\">#</a> 理由</h5>\n<p>指针（ <code>T*</code> ）可能为  <code>nullptr</code> ，而引用（ <code>T&amp;</code> ）则不能，不存在合法的 “空引用”。<br>\n有时候用  <code>nullptr</code>  作为一种代表 “没有对象” 的方式是有用处的，但若是没有这种情况的话，使用引用的写法更简单，而且可能会产生更好的代码。</p>\n<h5 id=\"示例-53\"><a class=\"markdownIt-Anchor\" href=\"#示例-53\">#</a> 示例</h5>\n<pre><code>string zstring_to_string(zstring p) // zstring 就是 char*; 这是一个 C 风格的字符串\n&#123;\n    if (!p) return string&#123;&#125;;    // p 可能为 nullptr; 别忘了要检查\n    return string&#123;p&#125;;\n&#125;\n\nvoid print(const vector&lt;int&gt;&amp; r)\n&#123;\n    // r 指代一个 vector&lt;int&gt;; 不需要检查\n&#125;\n</code></pre>\n<h5 id=\"注解-63\"><a class=\"markdownIt-Anchor\" href=\"#注解-63\">#</a> 注解</h5>\n<p>构造出一个本质上是  <code>nullptr</code>  的引用是可能的，但不是合法的 C++ 代码（比如， <code>T* p = nullptr; T&amp; r = *p;</code> ）。<br>\n这种错误非常罕见。</p>\n<h5 id=\"注解-64\"><a class=\"markdownIt-Anchor\" href=\"#注解-64\">#</a> 注解</h5>\n<p>如果你更喜欢指针写法（ <code>-&gt;</code>  以及  <code>*</code>  vs.  <code>.</code> ）的话， <code>not_null&lt;T*&gt;</code>  可以提供和  <code>T&amp;</code>  相同的保证。</p>\n<h5 id=\"强制实施-47\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-47\">#</a> 强制实施</h5>\n<ul>\n<li>Flag ???</li>\n</ul>\n<h3 id=\"a-namerf-ptraf22-用-townert-或者智能指针来代表一个对象\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-ptraf22-用-townert-或者智能指针来代表一个对象\">#</a> <a name=\"Rf-ptr\"></a>F.22: 用  <code>T*</code> ， <code>owner&lt;T*&gt;</code>  或者智能指针来代表一个对象</h3>\n<h5 id=\"理由-53\"><a class=\"markdownIt-Anchor\" href=\"#理由-53\">#</a> 理由</h5>\n<p>可读性：这样能够明确普通指针的含义。<br>\n带来了显著的工具支持。</p>\n<h5 id=\"注解-65\"><a class=\"markdownIt-Anchor\" href=\"#注解-65\">#</a> 注解</h5>\n<p>在传统的 C 和 C++ 代码中，普通的  <code>T*</code>  有各种互相没什么关联的用法，比如：</p>\n<ul>\n<li>标识单个对象（本函数内不会进行 delete）</li>\n<li>指向分配于自由存储之中的一个对象（随后将会 delete）</li>\n<li>持有  <code>nullptr</code>  值</li>\n<li>标识一个 C 风格字符串（以零结尾的字符数组）</li>\n<li>标识一个数组，其长度被分开指明</li>\n<li>标识数组中的一个位置</li>\n</ul>\n<p>这样就难于了解代码真正做了什么和打算做什么。<br>\n它也会使检查工作和工具支持复杂化。</p>\n<h5 id=\"示例-54\"><a class=\"markdownIt-Anchor\" href=\"#示例-54\">#</a> 示例</h5>\n<pre><code>void use(int* p, int n, char* s, int* q)\n&#123;\n    p[n - 1] = 666; // 不好: 不知道 p 是不是指向了 n 个元素；\n                    // 应当假定它并非如此，否则应当使用 span&lt;int&gt;\n    cout &lt;&lt; s;      // 不好: 不知道 s 指向的是不是以零结尾的字符数组；\n                    // 应当假定它并非如此，否则应当使用 zstring\n    delete q;       // 不好: 不知道 *q 是不是在自由存储中分配的；\n                    // 否则应当使用 owner\n&#125;\n</code></pre>\n<p>更好的做法</p>\n<pre><code>void use2(span&lt;int&gt; p, zstring s, owner&lt;int*&gt; q)\n&#123;\n    p[p.size() - 1] = 666; // OK, 会造成范围错误\n    cout &lt;&lt; s; // OK\n    delete q;  // OK\n&#125;\n</code></pre>\n<h5 id=\"注解-66\"><a class=\"markdownIt-Anchor\" href=\"#注解-66\">#</a> 注解</h5>\n<p><code>owner&lt;T*&gt;</code>  表示所有权， <code>zstring</code>  表示 C 风格的字符串。</p>\n<p><strong>再者</strong>：应当假定从指向  <code>T</code>  的智能指针（比如  <code>unique_ptr&lt;T&gt;</code> ）中获得的  <code>T*</code>  是指向单个元素的。</p>\n<p><strong>参见</strong>: <a href=\"#gsl-guidelines-support-library\">支持程序库</a></p>\n<p><strong>参见</strong>: <a href=\"#Ri-array\">请勿将数组作为单个指针来传递</a></p>\n<h5 id=\"强制实施-48\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-48\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】〔边界〕 对指针类型的表达式的算术操作，若其结果为指针类型的值，就给出警告。</li>\n</ul>\n<h3 id=\"a-namerf-nullptraf23-用-not_nullt-来表明空值null不是有效的值\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-nullptraf23-用-not_nullt-来表明空值null不是有效的值\">#</a> <a name=\"Rf-nullptr\"></a>F.23: 用  <code>not_null&lt;T&gt;</code>  来表明 “空值（null）” 不是有效的值</h3>\n<h5 id=\"理由-54\"><a class=\"markdownIt-Anchor\" href=\"#理由-54\">#</a> 理由</h5>\n<p>清晰性。以  <code>not_null&lt;T&gt;</code>  为参数的函数很明确地说明，应当由该函数的调用者来负责进行任何必要的  <code>nullptr</code>  检查。<br>\n相似地，以  <code>not_null&lt;T&gt;</code>  为返回值的函数很明确地说明，该函数的调用者无须检查  <code>nullptr</code> 。</p>\n<h5 id=\"示例-55\"><a class=\"markdownIt-Anchor\" href=\"#示例-55\">#</a> 示例</h5>\n<p><code>not_null&lt;T*&gt;</code>  让读者（人类或机器）明了，在进行解引用前不需要检查  <code>nullptr</code> 。<br>\n而且当进行调试时，可以对  <code>owner&lt;T*&gt;</code>  和  <code>not_null&lt;T&gt;</code>  进行植入来进行正确性检查。</p>\n<p>考虑：</p>\n<pre><code>int length(Record* p);\n</code></pre>\n<p>当调用  <code>length(p)</code>  时，我应该先检查  <code>p</code>  是否为  <code>nullptr</code>  吗？是不是应当由  <code>length()</code>  的实现来检查  <code>p</code>  是否为  <code>nullptr</code> ？</p>\n<pre><code>// 确保 p != nullptr 是调用者的任务\nint length(not_null&lt;Record*&gt; p);\n\n// length() 的实现者必须假定可能出现 p == nullptr\nint length(Record* p);\n</code></pre>\n<h5 id=\"注解-67\"><a class=\"markdownIt-Anchor\" href=\"#注解-67\">#</a> 注解</h5>\n<p>假定  <code>not_null&lt;T*&gt;</code>  不可能是  <code>nullptr</code> ；而  <code>T*</code>  则可能为  <code>nullptr</code> ；二者都可以在内存中表示为  <code>T*</code> （因此不会带来运行时开销）。</p>\n<h5 id=\"注解-68\"><a class=\"markdownIt-Anchor\" href=\"#注解-68\">#</a> 注解</h5>\n<p><code>not_null</code>  不仅对内建指针有效。它也能在  <code>unique_ptr</code> ， <code>shared_ptr</code> ，以及其他指针式的类型上使用。</p>\n<h5 id=\"强制实施-49\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-49\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】 当函数中的一个原始指针在未测试  <code>nullptr</code> （或等价形式）之前就被解引用时，就给出警告。</li>\n<li>【简单】 当函数中的一个原始指针有时候会在测试  <code>nullptr</code> （或等价形式）后进行解引用，而有时候不会时，就报错。</li>\n<li>【简单】 当函数中的一个  <code>not_null</code>  指针进行了  <code>nullptr</code>  测试时，就给出警告。</li>\n</ul>\n<h3 id=\"a-namerf-rangeaf24-用-spant-或者-span_pt-来代表一个半开序列\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-rangeaf24-用-spant-或者-span_pt-来代表一个半开序列\">#</a> <a name=\"Rf-range\"></a>F.24: 用  <code>span&lt;T&gt;</code>  或者  <code>span_p&lt;T&gt;</code>  来代表一个半开序列</h3>\n<h5 id=\"理由-55\"><a class=\"markdownIt-Anchor\" href=\"#理由-55\">#</a> 理由</h5>\n<p>非正式和不明确的范围（range）是一种错误来源。</p>\n<h5 id=\"示例-56\"><a class=\"markdownIt-Anchor\" href=\"#示例-56\">#</a> 示例</h5>\n<pre><code>X* find(span&lt;X&gt; r, const X&amp; v);    // 在 r 中寻找 v\n\nvector&lt;X&gt; vec;\n// ...\nauto p = find(&#123;vec.begin(), vec.end()&#125;, X&#123;&#125;);  // 在 vec 中寻找 X&#123;&#125;\n</code></pre>\n<h5 id=\"注解-69\"><a class=\"markdownIt-Anchor\" href=\"#注解-69\">#</a> 注解</h5>\n<p>范围（Range）在 C++ 代码中十分常见。典型情况下，它们都是隐含的，且非常难于保证它们能够被正确使用。<br>\n特别地，给定一对儿参数  <code>(p, n)</code>  来代表数组  <code>[p:p+n)</code> ，<br>\n通常来说不可能确定  <code>*p</code>  后面是不是真的存在  <code>n</code>  个元素。<br>\n <code>span&lt;T&gt;</code>  和  <code>span_p&lt;T&gt;</code>  两个简单的辅助类，分别用于代表范围  <code>[p:q)</code> ，以及一个以  <code>p</code>  开头并以使谓词为真的第一个元素结尾的范围。</p>\n<h5 id=\"示例-57\"><a class=\"markdownIt-Anchor\" href=\"#示例-57\">#</a> 示例</h5>\n<p><code>span</code>  代表元素的范围，我们应当如何操作范围的各个元素呢？</p>\n<pre><code>void f(span&lt;int&gt; s)\n&#123;\n    // 范围的遍历（保证正确进行）\n    for (int x : s) cout &lt;&lt; x &lt;&lt; '\\n';\n\n    // C 风格的遍历（可能带有检查）\n    for (gsl::index i = 0; i &lt; s.size(); ++i) cout &lt;&lt; s[i] &lt;&lt; '\\n';\n\n    // 随机访问（可能带有检查）\n    s[7] = 9;\n\n    // 截取指针（可能带有检查）\n    std::sort(&amp;s[0], &amp;s[s.size() / 2]);\n&#125;\n</code></pre>\n<h5 id=\"注解-70\"><a class=\"markdownIt-Anchor\" href=\"#注解-70\">#</a> 注解</h5>\n<p><code>span&lt;T&gt;</code>  对象并不拥有其元素，而且很小，可以按值传递。</p>\n<p>把一个  <code>span</code>  对象作为参数传递的效率完全等同于传递一对儿指针参数或者传递一个指针和一个整数计数值。</p>\n<p><strong>参见</strong>: <a href=\"#gsl-guidelines-support-library\">支持程序库</a></p>\n<h5 id=\"强制实施-50\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-50\">#</a> 强制实施</h5>\n<p>【复杂】 当对指针参数的访问是以其他整型类型的参数为边界限定时，就给出警告并建议改用  <code>span</code> 。</p>\n<h3 id=\"a-namerf-zstringaf25-用-zstring-或者-not_nullzstring-来代表-c-风格的字符串\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-zstringaf25-用-zstring-或者-not_nullzstring-来代表-c-风格的字符串\">#</a> <a name=\"Rf-zstring\"></a>F.25: 用  <code>zstring</code>  或者  <code>not_null&lt;zstring&gt;</code>  来代表 C 风格的字符串</h3>\n<h5 id=\"理由-56\"><a class=\"markdownIt-Anchor\" href=\"#理由-56\">#</a> 理由</h5>\n<p>C 风格的字符串非常普遍。它们是按一种约定方式定义的：就是以零结尾的字符数组。<br>\n我们必须把 C 风格的字符串从指向单个字符的指针或者指向字符数组的老式的指针当中区分出来。</p>\n<p>当不需要零结尾时，请使用 ‘string_view’。</p>\n<h5 id=\"示例-58\"><a class=\"markdownIt-Anchor\" href=\"#示例-58\">#</a> 示例</h5>\n<p>考虑：</p>\n<pre><code>int length(const char* p);\n</code></pre>\n<p>当调用  <code>length(p)</code>  时，我应该先检查  <code>p</code>  是否为  <code>nullptr</code>  吗？是不是应当由  <code>length()</code>  的实现来检查  <code>p</code>  是否为  <code>nullptr</code> ？</p>\n<pre><code>// length() 的实现者必须假定可能出现 p == nullptr\nint length(zstring p);\n\n// it is the caller's job to make sure p != nullptr\nint length(not_null&lt;zstring&gt; p);\n</code></pre>\n<h5 id=\"注解-71\"><a class=\"markdownIt-Anchor\" href=\"#注解-71\">#</a> 注解</h5>\n<p><code>zstring</code>  不含有所有权。</p>\n<p><strong>参见</strong>: <a href=\"#gsl-guidelines-support-library\">支持程序库</a></p>\n<h3 id=\"a-namerf-unique_ptraf26-当需要指针时用-unique_ptrt-来传递所有权\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-unique_ptraf26-当需要指针时用-unique_ptrt-来传递所有权\">#</a> <a name=\"Rf-unique_ptr\"></a>F.26: 当需要指针时，用  <code>unique_ptr&lt;T&gt;</code>  来传递所有权</h3>\n<h5 id=\"理由-57\"><a class=\"markdownIt-Anchor\" href=\"#理由-57\">#</a> 理由</h5>\n<p>使用  <code>unique_ptr</code>  是安全地传递指针的最廉价的方式。</p>\n<p><strong>参见</strong>：<a href=\"#Rc-factory\">C.50</a> 关于何时从一个工厂中返回  <code>shared_ptr</code> 。</p>\n<h5 id=\"示例-59\"><a class=\"markdownIt-Anchor\" href=\"#示例-59\">#</a> 示例</h5>\n<pre><code>unique_ptr&lt;Shape&gt; get_shape(istream&amp; is)  // 从输入流中装配一个形状\n&#123;\n    auto kind = read_header(is); // 从输入中读取头部并识别下一个形状\n    switch (kind) &#123;\n    case kCircle:\n        return make_unique&lt;Circle&gt;(is);\n    case kTriangle:\n        return make_unique&lt;Triangle&gt;(is);\n    // ...\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"注解-72\"><a class=\"markdownIt-Anchor\" href=\"#注解-72\">#</a> 注解</h5>\n<p>当要传递的对象属于某个类层次，且将要通过接口（基类）来使用它时，你需要传递一个指针而不是对象。</p>\n<h5 id=\"强制实施-51\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-51\">#</a> 强制实施</h5>\n<p>【简单】 当函数返回了局部分配了的原始指针时就给出警告。建议改为使用  <code>unique_ptr</code>  或  <code>shared_ptr</code> 。</p>\n<h3 id=\"a-namerf-shared_ptraf27-用-shared_ptrt-来共享所有权\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-shared_ptraf27-用-shared_ptrt-来共享所有权\">#</a> <a name=\"Rf-shared_ptr\"></a>F.27: 用  <code>shared_ptr&lt;T&gt;</code>  来共享所有权</h3>\n<h5 id=\"理由-58\"><a class=\"markdownIt-Anchor\" href=\"#理由-58\">#</a> 理由</h5>\n<p>使用  <code>std::shared_ptr</code>  是表示共享所有权的标准方式。其含义是，最后一个拥有者负责删除对象。</p>\n<h5 id=\"示例-60\"><a class=\"markdownIt-Anchor\" href=\"#示例-60\">#</a> 示例</h5>\n<pre><code>shared_ptr&lt;const Image&gt; im &#123; read_image(somewhere) &#125;;\n\nstd::thread t0 &#123;shade, args0, top_left, im&#125;;\nstd::thread t1 &#123;shade, args1, top_right, im&#125;;\nstd::thread t2 &#123;shade, args2, bottom_left, im&#125;;\nstd::thread t3 &#123;shade, args3, bottom_right, im&#125;;\n\n// 脱离各线程\n// 最后执行完的线程会删除这个图像\n</code></pre>\n<h5 id=\"注解-73\"><a class=\"markdownIt-Anchor\" href=\"#注解-73\">#</a> 注解</h5>\n<p>如果同时不可能超过一个所有者的话，优先采用  <code>unique_ptr</code>  而不是  <code>shared_ptr</code> 。<br>\n <code>shared_ptr</code>  的作用是共享所有权。</p>\n<p>注意，过于普遍的使用  <code>shared_ptr</code>  是有成本的（ <code>shared_ptr</code>  的引用计数上的原子性操作会产生可测量的总体花费）。</p>\n<h5 id=\"替代方案-5\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-5\">#</a> 替代方案</h5>\n<p>让单个对象来拥有这个共享对象（比如一个有作用域的对象），并当其所有使用方都完成工作后（最好隐含地）销毁它。</p>\n<h5 id=\"强制实施-52\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-52\">#</a> 强制实施</h5>\n<p>【无法强制实施】 这种模式过于复杂，无法可靠地进行检测。</p>\n<h3 id=\"a-namerf-return-ptraf42-返回-t-来仅仅给出一个位置\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-return-ptraf42-返回-t-来仅仅给出一个位置\">#</a> <a name=\"Rf-return-ptr\"></a>F.42: 返回  <code>T*</code>  来（仅仅）给出一个位置</h3>\n<h5 id=\"理由-59\"><a class=\"markdownIt-Anchor\" href=\"#理由-59\">#</a> 理由</h5>\n<p>指针就是用来干这个的。<br>\n使用  <code>T*</code>  来传递所有权其实是一种误用。</p>\n<h5 id=\"示例-61\"><a class=\"markdownIt-Anchor\" href=\"#示例-61\">#</a> 示例</h5>\n<pre><code>Node* find(Node* t, const string&amp; s)  // 在 Node 组成的二叉树中寻找 s\n&#123;\n    if (!t || t-&gt;name == s) return t;\n    if ((auto p = find(t-&gt;left, s))) return p;\n    if ((auto p = find(t-&gt;right, s))) return p;\n    return nullptr;\n&#125;\n</code></pre>\n<p><code>find</code>  所返回的指针如果不是  <code>nullptr</code>  的话，就指定了一个含有  <code>s</code>  的  <code>Node</code> 。<br>\n重要的是，这里面并没有暗含着把所指向的对象的所有权传递给调用者。</p>\n<h5 id=\"注解-74\"><a class=\"markdownIt-Anchor\" href=\"#注解-74\">#</a> 注解</h5>\n<p>迭代器、索引值和引用也可以用来传递位置。<br>\n<a href=\"#Rf-ptr-ref\">当不需要使用  <code>nullptr</code> </a>，或者<a href=\"???\">当不会改变被指代的对象</a>时，用引用通常比用指针更好。</p>\n<h5 id=\"注解-75\"><a class=\"markdownIt-Anchor\" href=\"#注解-75\">#</a> 注解</h5>\n<p>不要返回指向某个不在调用方的作用域中的东西的指针；参见 <a href=\"#Rf-dangle\">F.43</a>。</p>\n<p><strong>参见</strong>: <a href=\"#???\">有关如何避免悬挂指针的讨论</a></p>\n<h5 id=\"强制实施-53\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-53\">#</a> 强制实施</h5>\n<ul>\n<li>标记出施加在普通  <code>T*</code>  上的  <code>delete</code> ， <code>std::free()</code>  等等。<br>\n只有所有者才能被删除。</li>\n<li>标记出赋值给普通  <code>T*</code>  的  <code>new</code> ， <code>malloc()</code>  等等。<br>\n只有所有者才应当负责进行删除。</li>\n</ul>\n<h3 id=\"a-namerf-dangleaf43-不要直接或间接返回指向局部对象的指针或引用\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-dangleaf43-不要直接或间接返回指向局部对象的指针或引用\">#</a> <a name=\"Rf-dangle\"></a>F.43: 不要（直接或间接）返回指向局部对象的指针或引用</h3>\n<h5 id=\"理由-60\"><a class=\"markdownIt-Anchor\" href=\"#理由-60\">#</a> 理由</h5>\n<p>避免由于使用了这种悬挂指针而造成的程序崩溃和数据损坏。</p>\n<h5 id=\"示例-不好\"><a class=\"markdownIt-Anchor\" href=\"#示例-不好\">#</a> 示例，不好</h5>\n<p>从函数返回后，其中的局部对象就不再存在了：</p>\n<pre><code>int* f()\n&#123;\n    int fx = 9;\n    return &amp;fx;  // 不好\n&#125;\n\nvoid g(int* p)   // 貌似确实是无辜的\n&#123;\n    int gx;\n    cout &lt;&lt; &quot;*p == &quot; &lt;&lt; *p &lt;&lt; '\\n';\n    *p = 999;\n    cout &lt;&lt; &quot;gx == &quot; &lt;&lt; gx &lt;&lt; '\\n';\n&#125;\n\nvoid h()\n&#123;\n    int* p = f();\n    int z = *p;  // 从已经丢弃的栈帧中读取（不好）\n    g(p);        // 把指向已丢弃栈帧的指针传递给函数（不好）\n&#125;\n</code></pre>\n<p>我在一种流行的实现上得到了以下输出：</p>\n<pre><code>*p == 999\ngx == 999\n</code></pre>\n<p>我预期这样的结果是因为，对  <code>g()</code>  的调用重用了被  <code>f()</code>  的调用所丢弃的栈空间，因此  <code>*p</code>  所指代的空间应当会被  <code>gx</code>  所占据。</p>\n<ul>\n<li>请想象一下当  <code>fx</code>  和  <code>gx</code>  类型不同时会发生什么。</li>\n<li>请想象一下当  <code>fx</code>  或  <code>gx</code>  的类型带有不变式时会发生什么。</li>\n<li>请想象一下当在更大的一组函数之间传递的不止是悬挂指针时会发生什么。</li>\n<li>请想象一下一个攻击者能够利用悬挂指针干些什么。</li>\n</ul>\n<p>幸运的是，大多数（全部？）的当代编译器都可以识别这种简单的情况并给出警告。</p>\n<h5 id=\"注解-76\"><a class=\"markdownIt-Anchor\" href=\"#注解-76\">#</a> 注解</h5>\n<p>这同样适用于引用：</p>\n<pre><code>int&amp; f()\n&#123;\n    int x = 7;\n    // ...\n    return x;  // 不好: 返回指代即将被销毁的对象的引用\n&#125;\n</code></pre>\n<h5 id=\"注解-77\"><a class=\"markdownIt-Anchor\" href=\"#注解-77\">#</a> 注解</h5>\n<p>这条仅适用于非  <code>static</code>  的局部变量。<br>\n所有的  <code>static</code>  变量都是（顾名思义）静态分配的，因此指向它们的指针不可能变为悬挂的。</p>\n<h5 id=\"示例-不好-2\"><a class=\"markdownIt-Anchor\" href=\"#示例-不好-2\">#</a> 示例，不好</h5>\n<p>并非所有的局部变量指针的泄漏都是那么明显的：</p>\n<pre><code>int* glob;       // 全局变量的不好的方面太多了\n\ntemplate&lt;class T&gt;\nvoid steal(T x)\n&#123;\n    glob = x();  // 不好\n&#125;\n\nvoid f()\n&#123;\n    int i = 99;\n    steal([&amp;] &#123; return &amp;i; &#125;);\n&#125;\n\nint main()\n&#123;\n    f();\n    cout &lt;&lt; *glob &lt;&lt; '\\n';\n&#125;\n</code></pre>\n<p>我这次成功从  <code>f</code>  的调用所丢弃的位置上读到了数据。<br>\n存于  <code>glob</code>  中的指针可能在很晚才被使用，并可能以无法预测的方式造成各种麻烦。</p>\n<h5 id=\"注解-78\"><a class=\"markdownIt-Anchor\" href=\"#注解-78\">#</a> 注解</h5>\n<p>局部变量的地址的 “返回” 或者泄漏方式，可能是返回语句，以  <code>T&amp;</code>  输出参数，以所返回对象的成员，以所返回数组的元素，还有更多其他方式。</p>\n<h5 id=\"注解-79\"><a class=\"markdownIt-Anchor\" href=\"#注解-79\">#</a> 注解</h5>\n<p>还可以构造出相似的从内部作用域 “泄漏” 到外部作用域的例子；<br>\n对这样的例子应当按照与从函数中泄漏指针的相同方式来处理。</p>\n<p>这个问题的一个略有不同的变体是，把指针放入容器使其生存期超过其所指向的对象。</p>\n<p><strong>参见</strong>：另一种获得悬挂指针的方式是<a href=\"#???\">指针失效</a>。<br>\n这种情况也可以用相似的技术来检测和避免。</p>\n<h5 id=\"强制实施-54\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-54\">#</a> 强制实施</h5>\n<ul>\n<li>编译器通常可以发现返回局部对象 引用，许多情况下也可以发现返回指向局部对象的指针。</li>\n<li>静态分析可以发现许多常见的确定指针位置的使用模式（因而可以消除掉悬挂指针）</li>\n</ul>\n<h3 id=\"a-namerf-return-refaf44-当不想进行复制而没有对象被返回不是有效的选项时返回-t\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-return-refaf44-当不想进行复制而没有对象被返回不是有效的选项时返回-t\">#</a> <a name=\"Rf-return-ref\"></a>F.44: 当不想进行复制，而 “没有对象被返回” 不是有效的选项时，返回  <code>T&amp;</code></h3>\n<h5 id=\"理由-61\"><a class=\"markdownIt-Anchor\" href=\"#理由-61\">#</a> 理由</h5>\n<p>语言规则保证  <code>T&amp;</code>  会指代对象，因此不需要对其测试  <code>nullptr</code> 。</p>\n<p><strong>参见</strong>：所返回的引用诀不能蕴含所有权的传递：<br>\n<a href=\"#???\">有关如何避免悬挂指针的讨论</a>以及<a href=\"#???\">有关所有权的讨论</a>。</p>\n<h5 id=\"示例-62\"><a class=\"markdownIt-Anchor\" href=\"#示例-62\">#</a> 示例</h5>\n<pre><code>class Car\n&#123;\n    array&lt;wheel, 4&gt; w;\n    // ...\npublic:\n    wheel&amp; get_wheel(int i) &#123; Expects(i &lt; w.size()); return w[i]; &#125;\n    // ...\n&#125;;\n\nvoid use()\n&#123;\n    Car c;\n    wheel&amp; w0 = c.get_wheel(0); // w0 与 c 的生存期相同\n&#125;\n</code></pre>\n<h5 id=\"强制实施-55\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-55\">#</a> 强制实施</h5>\n<p>对不存在可能产生  <code>nullptr</code>  的  <code>return</code>  表达式的函数进行标记。</p>\n<h3 id=\"a-namerf-return-ref-refaf45-不要返回-t\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-return-ref-refaf45-不要返回-t\">#</a> <a name=\"Rf-return-ref-ref\"></a>F.45: 不要返回  <code>T&amp;&amp;</code></h3>\n<h5 id=\"理由-62\"><a class=\"markdownIt-Anchor\" href=\"#理由-62\">#</a> 理由</h5>\n<p>它要求返回对已销毁的临时对象的引用。<br>\n <code>&amp;&amp;</code>  是吸引临时对象的符号。</p>\n<h5 id=\"示例-63\"><a class=\"markdownIt-Anchor\" href=\"#示例-63\">#</a> 示例</h5>\n<p>返回的右值引用超出了返回的完整表达式结束的范围：</p>\n<pre><code>auto&amp;&amp; x = max(0, 1);   // 到目前为止，没问题\nfoo(x);                 // 未定义的行为\n</code></pre>\n<p>这种用法是频繁产生 bug 的根源，经常错误地报告为编译器错误。<br>\n函数的实现者应避免为用户设置此类陷阱。</p>\n<p><a href=\"#SS-lifetime\">生存期安全性</a>完全执行时，会捕捉到这个问题。</p>\n<h5 id=\"示例-64\"><a class=\"markdownIt-Anchor\" href=\"#示例-64\">#</a> 示例</h5>\n<p>当临时的引用” 向下” 传递给被调用对象时，返回右值引用是正常的；<br>\n然后，临时对象保证比函数调用生命期更长（参见 <a href=\"#Rf-consume\">F.18</a> 和 <a href=\"#Rf-forward\">F.19</a>）。<br>\n但是，将这样的引用 “向上” 传递给更大的调用范围时，不好。<br>\n对于通过普通引用或完美传递方式传递参数，并希望返回值的通过函数，使用简单的  <code>auto</code>  而不是  <code>auto &amp;&amp;</code>  返回推导的类型。</p>\n<p>假定 “F” 按值返回：</p>\n<pre><code>template&lt;class F&gt;\nauto&amp;&amp; wrapper(F f)\n&#123;\n    log_call(typeid(f)); // 或者别的什么测量手段\n    return f();          // 不好：返回一个临时对象的引用\n&#125;\n</code></pre>\n<p>更好的方式：</p>\n<pre><code>template&lt;class F&gt;\nauto wrapper(F f)\n&#123;\n    log_call(typeid(f)); // 或者别的什么测量手段\n    return f();          // 好\n&#125;\n</code></pre>\n<h5 id=\"例外-19\"><a class=\"markdownIt-Anchor\" href=\"#例外-19\">#</a> 例外</h5>\n<p><code>std::move</code>  和  <code>std::forward</code>  确实会返回  <code>&amp;&amp;</code> ，但它们只不过是强制转换 —— 只会按惯例在某些表达式上下文中使用，其中指代临时对象的引用只会在该临时对象被销毁之前在同一个表达式中被传递。我们不知道还存在任何别的返回  <code>&amp;&amp;</code>  的好例子。</p>\n<h5 id=\"强制实施-56\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-56\">#</a> 强制实施</h5>\n<p>对除了  <code>std::move</code>  和  <code>std::forward</code>  之外的任何把  <code>&amp;&amp;</code>  作为返回类型的情况都进行标记。</p>\n<h3 id=\"a-namerf-mainaf46-int-是-main-的返回类型\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-mainaf46-int-是-main-的返回类型\">#</a> <a name=\"Rf-main\"></a>F.46:  <code>int</code>  是  <code>main()</code>  的返回类型</h3>\n<h5 id=\"reason\"><a class=\"markdownIt-Anchor\" href=\"#reason\">#</a> Reason</h5>\n<p>这是一条语言规则，但通常被 “语言扩展” 所违反，因此值得一提。<br>\n把  <code>main</code> （即程序中的那个全局的  <code>main</code> ）声明为  <code>void</code>  会限制其可移植性。</p>\n<h5 id=\"示例-65\"><a class=\"markdownIt-Anchor\" href=\"#示例-65\">#</a> 示例</h5>\n<pre><code>    void main() &#123; /* ... */ &#125;;  // 不好，不符合 C++\n\n    int main()\n    &#123;\n        std::cout &lt;&lt; &quot;This is the way to do it\\n&quot;;\n    &#125;\n</code></pre>\n<h5 id=\"注解-80\"><a class=\"markdownIt-Anchor\" href=\"#注解-80\">#</a> 注解</h5>\n<p>我们提出这条规则，只是因为这种错误持续存在于大众之间。<br>\n注意，虽然其返回类型不是  <code>void</code> ，但主函数并不需要明确的返回语句。</p>\n<h5 id=\"强制实施-57\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-57\">#</a> 强制实施</h5>\n<ul>\n<li>编译器应当做到。</li>\n<li>如果编译器做不到，就让工具把它标记出来。</li>\n</ul>\n<h3 id=\"a-namerf-assignment-opaf47-赋值运算符返回-t\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-assignment-opaf47-赋值运算符返回-t\">#</a> <a name=\"Rf-assignment-op\"></a>F.47: 赋值运算符返回  <code>T&amp;</code></h3>\n<h5 id=\"理由-63\"><a class=\"markdownIt-Anchor\" href=\"#理由-63\">#</a> 理由</h5>\n<p>运算符重载的惯例（尤其是对于具体类型来说），是让<br>\n <code>operator=(const T&amp;)</code>  实施赋值之后返回（非  <code>const</code> ）的<br>\n <code>*this</code> 。这就确保了与标准库类型之间的一致性，并遵从了<br>\n “像  <code>int</code>  一样工作” 的原则。</p>\n<h5 id=\"注解-81\"><a class=\"markdownIt-Anchor\" href=\"#注解-81\">#</a> 注解</h5>\n<p>历史上层有过一些建议让赋值运算符返回  <code>const T&amp;</code> 。<br>\n这主要是为了避免  <code>(a = b) = c</code>  形式的代码 —— 这种代码其实并不常见到足以成为违反与标准类型之间一致性的理由。</p>\n<h5 id=\"示例-66\"><a class=\"markdownIt-Anchor\" href=\"#示例-66\">#</a> 示例</h5>\n<pre><code>class Foo\n&#123;\n public:\n    ...\n    Foo&amp; operator=(const Foo&amp; rhs)\n    &#123;\n      // 复制各个成员。\n      ...\n      return *this;\n    &#125;\n&#125;;\n</code></pre>\n<h5 id=\"强制实施-58\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-58\">#</a> 强制实施</h5>\n<p>应当通过工具对所有赋值运算符的返回类型（和返回值）进行检查<br>\n来强制实施。</p>\n<h3 id=\"a-namerf-return-move-localaf48-不要用-return-stdmovelocal\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-return-move-localaf48-不要用-return-stdmovelocal\">#</a> <a name=\"Rf-return-move-local\"></a>F.48: 不要用  <code>return std::move(local)</code></h3>\n<h5 id=\"理由-64\"><a class=\"markdownIt-Anchor\" href=\"#理由-64\">#</a> 理由</h5>\n<p>有了确保进行的副本消除之后，现在在返回语句中明确使用  <code>std::move</code>  几乎总是不良的实践。</p>\n<h5 id=\"示例不好-20\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-20\">#</a> 示例，不好</h5>\n<pre><code>S f()\n&#123;\n  S result;\n  return std::move(result);\n&#125;\n</code></pre>\n<h5 id=\"示例好-4\"><a class=\"markdownIt-Anchor\" href=\"#示例好-4\">#</a> 示例，好</h5>\n<pre><code>S f()\n&#123;\n  S result;\n  return result;\n&#125;\n</code></pre>\n<h5 id=\"强制实施-59\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-59\">#</a> 强制实施</h5>\n<p>应当通过工具对返回语句进行检查来强制实施。</p>\n<h3 id=\"a-namerf-return-constaf49-不要返回-const-t\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-return-constaf49-不要返回-const-t\">#</a> <a name=\"Rf-return-const\"></a>F.49: 不要返回  <code>const T</code></h3>\n<h5 id=\"理由-65\"><a class=\"markdownIt-Anchor\" href=\"#理由-65\">#</a> 理由</h5>\n<p>不建议返回  <code>const</code>  值。<br>\n这种老旧的建议已经过时了；它并不会带来什么价值，而且还会对移动语义造成影响。</p>\n<h5 id=\"示例-67\"><a class=\"markdownIt-Anchor\" href=\"#示例-67\">#</a> 示例</h5>\n<pre><code>const vector&lt;int&gt; fct();    // 不好: 这个 &quot;const&quot; 带来的麻烦超过其价值\n\nvoid g(vector&lt;int&gt;&amp; vx)\n&#123;\n    // ...\n    fct() = vx;   // 被 &quot;const&quot; 所禁止\n    // ...\n    vx = fct(); // 昂贵的复制：&quot;const&quot; 抑制掉了移动语义\n    // ...\n&#125;\n</code></pre>\n<p>要求对返回值添加  <code>const</code>  的理由是可以防止（非常少见的）对临时对象的意外访问。<br>\n而反对的理由则是它妨碍了（非常常见的）对移动语义的利用。</p>\n<p><strong>另见</strong>: <a href=\"#Rf-out\">F.20，有关 “out” 输出值的一般条款</a></p>\n<h5 id=\"强制实施-60\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-60\">#</a> 强制实施</h5>\n<ul>\n<li>标记  <code>const</code>  返回值。修正方法：移除  <code>const</code>  使其变为返回非  <code>const</code>  值。</li>\n</ul>\n<h3 id=\"a-namerf-capture-vs-overloadaf50-当函数不适用时不能俘获局部变量或者不能编写局部函数就使用-lambda\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-capture-vs-overloadaf50-当函数不适用时不能俘获局部变量或者不能编写局部函数就使用-lambda\">#</a> <a name=\"Rf-capture-vs-overload\"></a>F.50: 当函数不适用时（不能俘获局部变量，或者不能编写局部函数），就使用 Lambda</h3>\n<h5 id=\"理由-66\"><a class=\"markdownIt-Anchor\" href=\"#理由-66\">#</a> 理由</h5>\n<p>函数不能俘获局部变量且不能在局部作用域中进行定义；当想要这些能力时，如果可能就应当使用 lambda，不行的就用手写的函数对象。另一方面，lambda 和函数对象是不能重载的；如果想要重载，就优先使用函数（让 lambda 重载的变通方案相当繁复）。如果两种方式都不行的话，就优先写一个函数；应当只使用所需的最简工具。</p>\n<h5 id=\"示例-68\"><a class=\"markdownIt-Anchor\" href=\"#示例-68\">#</a> 示例</h5>\n<pre><code>// 编写只会接受 int 或 string 的函数\n// -- 重载是很自然的\nvoid f(int);\nvoid f(const string&amp;);\n\n// 编写需要俘获局部状态的函数对象，可以出现于\n// 语句或者表达式作用域中 -- lambda 更自然\nvector&lt;work&gt; v = lots_of_work();\nfor (int tasknum = 0; tasknum &lt; max; ++tasknum) &#123;\n    pool.run([=, &amp;v] &#123;\n        /*\n        ...\n        ... 处理 v 的 1 / max, 即第 tasknum 个部分\n        ...\n        */\n    &#125;);\n&#125;\npool.join();\n</code></pre>\n<h5 id=\"例外-20\"><a class=\"markdownIt-Anchor\" href=\"#例外-20\">#</a> 例外</h5>\n<p>泛型的 lambda 可以提供一种更精简的编写函数模板的方式，因此会比较有用，虽然普通的函数模板用稍多一点儿的语法可以做到同样的事情。这种优势在未来一旦所有的函数都获得了 Concept 参数的能力之后就可能会消失。</p>\n<h5 id=\"强制实施-61\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-61\">#</a> 强制实施</h5>\n<ul>\n<li>有名字的非泛型 lambda（比如  <code>auto x = [](int i) &#123; /*...*/; &#125;;</code> ），而其并未发生俘获并且出现于全局作用域，对它们给出警告。代之以编写常规的函数。</li>\n</ul>\n<h3 id=\"a-namerf-default-argsaf51-如果需要作出选择采用默认实参应当优先于进行重载\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-default-argsaf51-如果需要作出选择采用默认实参应当优先于进行重载\">#</a> <a name=\"Rf-default-args\"></a>F.51: 如果需要作出选择，采用默认实参应当优先于进行重载</h3>\n<h5 id=\"理由-67\"><a class=\"markdownIt-Anchor\" href=\"#理由-67\">#</a> 理由</h5>\n<p>默认实参本就是为一个单一实现提供替代的接口的。<br>\n无法保证一组重载函数全部都实现相同的语义。<br>\n使用默认实参可以避免出现代码重复。</p>\n<h5 id=\"注解-82\"><a class=\"markdownIt-Anchor\" href=\"#注解-82\">#</a> 注解</h5>\n<p>当变化来自相同类型的一组参数时，需要在默认实参和重载两种方案之间进行选择。<br>\n例如：</p>\n<pre><code>void print(const string&amp; s, format f = &#123;&#125;);\n</code></pre>\n<p>相对的则是</p>\n<pre><code>void print(const string&amp; s);  // 使用默认的 format\nvoid print(const string&amp; s, format f);\n</code></pre>\n<p>如果要为一组不同类型来实现语义上等价的操作，就不需要进行选择了。例如：</p>\n<pre><code>void print(const char&amp;);\nvoid print(int);\nvoid print(zstring);\n</code></pre>\n<h5 id=\"参见\"><a class=\"markdownIt-Anchor\" href=\"#参见\">#</a> 参见</h5>\n<p>[虚函数的默认实参](#Rf-virtual-default-arg}</p>\n<h5 id=\"强制实施-62\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-62\">#</a> 强制实施</h5>\n<ul>\n<li>如果某个重载集合中的各个重载具有一个共同的形参前缀（例如  <code>f(int)</code> ， <code>f(int, const string&amp;)</code> ， <code>f(int, const string&amp;, double)</code> ），则为其给出警告。（注意：如果这条强制措施实践中产生太多消息，请对此进行复查。）</li>\n</ul>\n<h3 id=\"a-namerf-reference-captureaf52-对于局部使用的也包括传递给算法的lambda优先采用按引用俘获\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-reference-captureaf52-对于局部使用的也包括传递给算法的lambda优先采用按引用俘获\">#</a> <a name=\"Rf-reference-capture\"></a>F.52: 对于局部使用的（也包括传递给算法的）lambda，优先采用按引用俘获</h3>\n<h5 id=\"理由-68\"><a class=\"markdownIt-Anchor\" href=\"#理由-68\">#</a> 理由</h5>\n<p>为了效率和正确性，当使用局部的 lambda 时，你基本上总是需要进行按引用俘获。这也包括编写或者调用并行算法的情形，因为它们在返回前会进行联结。</p>\n<h5 id=\"讨论-2\"><a class=\"markdownIt-Anchor\" href=\"#讨论-2\">#</a> 讨论</h5>\n<p>效率方面的考虑是，大多数的类型都是按引用传递比按值传递更便宜。</p>\n<p>正确性方面的考虑是，许多的调用都希望在调用点对原本的对象实施副作用（参见下面的示例）。而按值传递妨碍了这点。</p>\n<h5 id=\"注解-83\"><a class=\"markdownIt-Anchor\" href=\"#注解-83\">#</a> 注解</h5>\n<p>不幸的是，并没有一种简单的方法，能够按  <code>const</code>  引用来捕获以获得其局部调用的效率，同时又妨碍其副作用。</p>\n<h5 id=\"示例-69\"><a class=\"markdownIt-Anchor\" href=\"#示例-69\">#</a> 示例</h5>\n<p>此处，一个大型对象（网络消息）被传递给一个迭代算法，而它也许不够高效，或者能够正确复制这个消息（它可能是无法复制的）：</p>\n<pre><code>std::for_each(begin(sockets), end(sockets), [&amp;message](auto&amp; socket)\n&#123;\n    socket.send(message);\n&#125;);\n</code></pre>\n<h5 id=\"示例-70\"><a class=\"markdownIt-Anchor\" href=\"#示例-70\">#</a> 示例</h5>\n<p>下面是一个简单的三阶段并行管线。每个  <code>stage</code>  对象封装了一个工作线程和一个队列，有一个用来把任务入队的  <code>process</code>  函数，且其析构函数会自动进行阻塞以在线程结束前等待队列变空。</p>\n<pre><code>void send_packets(buffers&amp; bufs)\n&#123;\n    stage encryptor([](buffer&amp; b) &#123; encrypt(b); &#125;);\n    stage compressor([&amp;](buffer&amp; b) &#123; compress(b); encryptor.process(b); &#125;);\n    stage decorator([&amp;](buffer&amp; b) &#123; decorate(b); compressor.process(b); &#125;);\n    for (auto&amp; b : bufs) &#123; decorator.process(b); &#125;\n&#125;  // 自动阻塞以等待管线完成\n</code></pre>\n<h5 id=\"强制实施-63\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-63\">#</a> 强制实施</h5>\n<p>对于按引用捕获的 lambda，若其并非局部地用在函数作用域中，或者若其被按引用传递给某个函数，则对其进行标记。（注意：这条规则是一种近似，但确实对按指针传递进行标记，它们更可能被受调方所保存，通过某个参数来向某个堆位置进行写入，返回 lambda，等等。生存期方面的规则也会提供一般性的规则，以针对包括通过 lambda 脱离的指针和引用进行标记。）</p>\n<h3 id=\"a-namerf-value-captureaf53-对于非局部使用的包括被返回的在堆上存储的或者传递给别的线程的lambda避免采用按引用俘获\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-value-captureaf53-对于非局部使用的包括被返回的在堆上存储的或者传递给别的线程的lambda避免采用按引用俘获\">#</a> <a name=\"Rf-value-capture\"></a>F.53: 对于非局部使用的（包括被返回的，在堆上存储的，或者传递给别的线程的）lambda，避免采用按引用俘获</h3>\n<h5 id=\"理由-69\"><a class=\"markdownIt-Anchor\" href=\"#理由-69\">#</a> 理由</h5>\n<p>指向局部对象的指针和引用不能超出它们的作用域而存活。按引用捕获的 lambda 恰是另外一种保存指向局部对象的引用的地方，因而当它们（或其副本）存活超出作用域的话，也不应该这样做。</p>\n<h5 id=\"示例不好-21\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-21\">#</a> 示例，不好</h5>\n<pre><code>int local = 42;\n\n// 需要局部对象的引用。\n// 注意，当程序离开作用域时，\n// 局部对象不再存在，因此\n// process() 的调用将带有未定义行为！\nthread_pool.queue_work([&amp;] &#123; process(local); &#125;);\n</code></pre>\n<h5 id=\"示例好-5\"><a class=\"markdownIt-Anchor\" href=\"#示例好-5\">#</a> 示例，好</h5>\n<pre><code>int local = 42;\n// 需要局部对象的副本。\n// 由于为局部变量建立了副本，它将在\n// 函数调用的全部时间内可用。\nthread_pool.queue_work([=] &#123; process(local); &#125;);\n</code></pre>\n<h5 id=\"注解-84\"><a class=\"markdownIt-Anchor\" href=\"#注解-84\">#</a> 注解</h5>\n<p>如果必须捕获非局部指针，则应考虑使用  <code>unique_ptr</code> ；它会处理生存期和同步问题。</p>\n<p>如果必须捕获  <code>this</code>  指针，则应考虑使用  <code>[*this]</code>  捕获，它会创建整个对象的一个副本。</p>\n<h5 id=\"强制实施-64\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-64\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】 当捕获列表中包含指代局部声明的变量的引用时给出警告。</li>\n<li>【复杂】 当捕获列表中包含指代局部声明的变量的引用，而 lambda 被传递给非  <code>const</code>  且非局部的上下文时，进行标记。</li>\n</ul>\n<h3 id=\"a-namerf-this-captureaf54-当俘获了-this-时显式俘获所有的变量不使用默认俘获\"><a class=\"markdownIt-Anchor\" href=\"#a-namerf-this-captureaf54-当俘获了-this-时显式俘获所有的变量不使用默认俘获\">#</a> <a name=\"Rf-this-capture\"></a>F.54: 当俘获了  <code>this</code>  时，显式俘获所有的变量（不使用默认俘获）</h3>\n<h5 id=\"理由-70\"><a class=\"markdownIt-Anchor\" href=\"#理由-70\">#</a> 理由</h5>\n<p>这是容易混淆的。在成员函数里边写  <code>[=]</code>  貌似会按值来俘获，但其实会按引用俘获数据成员，因为它实际上按值俘获了不可见的  <code>this</code>  指针。如果你确实要这样做的话，请把  <code>this</code>  写明。</p>\n<h5 id=\"示例-71\"><a class=\"markdownIt-Anchor\" href=\"#示例-71\">#</a> 示例</h5>\n<pre><code>class My_class &#123;\n    int x = 0;\n    // ...\n\n    void f()\n    &#123;\n        int i = 0;\n        // ...\n\n        auto lambda = [=] &#123; use(i, x); &#125;;   // 不好: “貌似”按复制/按值俘获\n        // [&amp;] 在当前的语言规则下的语义是一样的，也会复制 this 指针\n        // [=,this] 和 [&amp;,this] 也没好多少，并且也会导致混淆\n\n        x = 42;\n        lambda(); // 调用 use(0, 42);\n        x = 43;\n        lambda(); // 调用 use(0, 43);\n\n        // ...\n\n        auto lambda2 = [i, this] &#123; use(i, x); &#125;; // ok, 最明确并且最不混淆\n\n        // ...\n    &#125;\n&#125;;\n</code></pre>\n<h5 id=\"注解-85\"><a class=\"markdownIt-Anchor\" href=\"#注解-85\">#</a> 注解</h5>\n<p>这在标准化之中正在进行积极的讨论，而且很可能在未来版本的标准中通过增加一种新的俘获模式或者调整  <code>[=]</code>  的含义而得到结局。当前的话，还是应当明确为好。</p>\n<h5 id=\"强制实施-65\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-65\">#</a> 强制实施</h5>\n<ul>\n<li>若指定了默认俘获（如  <code>=</code>  或  <code>&amp;</code> ）的 lambda 俘获列表并且还俘获了  <code>this</code>  的情况 —— 无论是如  <code>[&amp;, this]</code>  这样显式，还是通过  <code>[=]</code>  这样的默认俘获而又在函数体中使用了  <code>this</code> —— 对此进行标识。</li>\n</ul>\n<h3 id=\"a-namef-varargsaf55-不要使用-va_arg-参数\"><a class=\"markdownIt-Anchor\" href=\"#a-namef-varargsaf55-不要使用-va_arg-参数\">#</a> <a name=\"F-varargs\"></a>F.55: 不要使用  <code>va_arg</code>  参数</h3>\n<h5 id=\"理由-71\"><a class=\"markdownIt-Anchor\" href=\"#理由-71\">#</a> 理由</h5>\n<p>从  <code>va_arg</code>  中读取时需要假定确实传递了正确类型的参数。<br>\n而向变参传递时则需要假定将会读取正确的类型。<br>\n这样是很脆弱的，因为其在语言中无法一般性地强制其安全，因而需要靠程序员的纪律来保证其正确。</p>\n<h5 id=\"示例-72\"><a class=\"markdownIt-Anchor\" href=\"#示例-72\">#</a> 示例</h5>\n<pre><code>int sum(...)\n&#123;\n    // ...\n    while (/*...*/)\n        result += va_arg(list, int); // 不好，假定所传递的是 int\n    // ...\n&#125;\n\nsum(3, 2); // ok\nsum(3.14159, 2.71828); // 不好，未定义的行为\n\ntemplate&lt;class ...Args&gt;\nauto sum(Args... args) // 好，而且更灵活\n&#123;\n    return (... + args); // 注意：C++17 的“折叠表达式”\n&#125;\n\nsum(3, 2); // ok: 5\nsum(3.14159, 2.71828); // ok: ~5.85987\n</code></pre>\n<h5 id=\"替代方案-6\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-6\">#</a> 替代方案</h5>\n<ul>\n<li>重载</li>\n<li>变参模板</li>\n<li><code>variant</code>  参数</li>\n<li><code>initializer_list</code> （同质的）</li>\n</ul>\n<h5 id=\"注解-86\"><a class=\"markdownIt-Anchor\" href=\"#注解-86\">#</a> 注解</h5>\n<p>有时候，对于并不涉及实际的参数传递的技巧来说，声明  <code>...</code>  形参有其作用，比如当声明 “接受任何东西” 的函数，以在重载集合中禁止 “其他所有东西”，或在模板元程序中表达一种 “全覆盖（catchall）” 情况时。</p>\n<h5 id=\"强制实施-66\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-66\">#</a> 强制实施</h5>\n<ul>\n<li>为  <code>va_list</code> ， <code>va_start</code> ，或  <code>va_arg</code>  的使用给出诊断。</li>\n<li>如果 vararg 参数的函数并未提供重载以为该参数位置指定更加特定的类型，则当其传递参数时给出诊断。修正：使用别的函数，或标明  <code>[[suppress(types)]]</code> 。</li>\n</ul>\n<h3 id=\"a-namef-nestingaf56-避免不必要的条件嵌套\"><a class=\"markdownIt-Anchor\" href=\"#a-namef-nestingaf56-避免不必要的条件嵌套\">#</a> <a name=\"F-nesting\"></a>F.56: 避免不必要的条件嵌套</h3>\n<h5 id=\"理由-72\"><a class=\"markdownIt-Anchor\" href=\"#理由-72\">#</a> 理由</h5>\n<p>浅层嵌套的条件语句使代码容易理解。也会使缩进结构清除明了。<br>\n力求将基础代码放在最外层作用域，除非这样做会搞乱缩进。</p>\n<h5 id=\"示例-73\"><a class=\"markdownIt-Anchor\" href=\"#示例-73\">#</a> 示例</h5>\n<p>使用防卫代码块来处理异常情况，并提早返回。</p>\n<pre><code>// 不好：深层嵌套\nvoid foo() &#123;\n    ...\n    if (x) &#123;\n        computeImportantThings(x);\n    &#125;\n&#125;\n\n// 不好：还有多余的 else。\nvoid foo() &#123;\n    ...\n    if (!x) &#123;\n        return;\n    &#125;\n    else &#123;\n        computeImportantThings(x);\n    &#125;\n&#125;\n\n// 好：提早返回，无多余 else\nvoid foo() &#123;\n    ...\n    if (!x)\n        return;\n\n    computeImportantThings(x);\n&#125;\n</code></pre>\n<h5 id=\"示例-74\"><a class=\"markdownIt-Anchor\" href=\"#示例-74\">#</a> 示例</h5>\n<pre><code>// 不好：不必要的条件嵌套\nvoid foo() &#123;\n    ...\n    if (x) &#123;\n        if (y) &#123;\n            computeImportantThings(x);\n        &#125;\n    &#125;\n&#125;\n\n// 好：合并条件 + 提早返回\nvoid foo() &#123;\n    ...\n    if (!(x &amp;&amp; y))\n        return;\n\n    computeImportantThings(x);\n&#125;\n</code></pre>\n<h5 id=\"强制实施-67\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-67\">#</a> 强制实施</h5>\n<p>标记多余的  <code>else</code> 。<br>\n对函数体仅为包含一个代码块的条件语句的函数进行标记。</p>\n<h1 id=\"a-names-classac-类和类层次\"><a class=\"markdownIt-Anchor\" href=\"#a-names-classac-类和类层次\">#</a> <a name=\"S-class\"></a>C: 类和类层次</h1>\n<p>类是一种自定义类型，程序员可以定义它的表示，操作和接口。<br>\n类层次用于把相关的类组织到层次化的结构当中。</p>\n<p>类的规则概览：</p>\n<ul>\n<li><a href=\"#Rc-org\">C.1: 把相关的数据组织到结构中（ <code>struct</code>  或  <code>class</code> ）</a></li>\n<li><a href=\"#Rc-struct\">C.2: 当类具有不变式时使用  <code>class</code> ；当数据成员可以独立进行变动时使用  <code>struct</code> </a></li>\n<li><a href=\"#Rc-interface\">C.3: 用类来表示接口和实现之间的区别</a></li>\n<li><a href=\"#Rc-member\">C.4: 仅当函数直接访问类的内部表示时才让函数作为其成员</a></li>\n<li><a href=\"#Rc-helper\">C.5: 把辅助函数放在其所支持的类相同的命名空间之中</a></li>\n<li><a href=\"#Rc-standalone\">C.7: 不要在同一个语句中同时定义类或枚举并声明该类型的变量</a></li>\n<li><a href=\"#Rc-class\">C.8: 当有任何非公开成员时使用  <code>class</code>  而不是  <code>struct</code> </a></li>\n<li><a href=\"#Rc-private\">C.9: 让成员的暴露最小化</a></li>\n</ul>\n<p>子章节：</p>\n<ul>\n<li><a href=\"#SS-concrete\">C.concrete: 具体类型</a></li>\n<li><a href=\"#S-ctor\">C.ctor: 构造函数，赋值和析构函数</a></li>\n<li><a href=\"#SS-containers\">C.con: 容器和其他资源包装</a></li>\n<li><a href=\"#SS-lambdas\">C.lambdas: 函数对象和 lambda</a></li>\n<li><a href=\"#SS-hier\">C.hier: 类层次（OOP）</a></li>\n<li><a href=\"#SS-overload\">C.over: 重载和运算符重载</a></li>\n<li><a href=\"#SS-union\">C.union: 联合体</a></li>\n</ul>\n<h3 id=\"a-namerc-orgac1-把相关的数据组织到结构中struct-或-class\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-orgac1-把相关的数据组织到结构中struct-或-class\">#</a> <a name=\"Rc-org\"></a>C.1: 把相关的数据组织到结构中（ <code>struct</code>  或  <code>class</code> ）</h3>\n<h5 id=\"理由-73\"><a class=\"markdownIt-Anchor\" href=\"#理由-73\">#</a> 理由</h5>\n<p>易理解性。<br>\n如果数据之间（以基本的原因而）相关，应当在代码中体现这点。</p>\n<h5 id=\"示例-75\"><a class=\"markdownIt-Anchor\" href=\"#示例-75\">#</a> 示例</h5>\n<pre><code>void draw(int x, int y, int x2, int y2);  // 不好: 不必要的隐含式的关系\nvoid draw(Point from, Point to);          // 好多了\n</code></pre>\n<h5 id=\"注解-87\"><a class=\"markdownIt-Anchor\" href=\"#注解-87\">#</a> 注解</h5>\n<p>没有虚函数的简单的类是不会带来空间或时间开销的。</p>\n<h5 id=\"注解-88\"><a class=\"markdownIt-Anchor\" href=\"#注解-88\">#</a> 注解</h5>\n<p>从语言的角度看， <code>class</code>  和  <code>struct</code>  的差别只有其成员的默认可见性不同。</p>\n<h5 id=\"强制实施-68\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-68\">#</a> 强制实施</h5>\n<p>也许不可能做到。也许对总是一起使用的数据项目进行启发式查找是一种可能方式。</p>\n<h3 id=\"a-namerc-structac2-当类具有不变式时使用-class当数据成员可以独立进行变动时使用-struct\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-structac2-当类具有不变式时使用-class当数据成员可以独立进行变动时使用-struct\">#</a> <a name=\"Rc-struct\"></a>C.2: 当类具有不变式时使用  <code>class</code> ；当数据成员可以独立进行变动时使用  <code>struct</code></h3>\n<h5 id=\"理由-74\"><a class=\"markdownIt-Anchor\" href=\"#理由-74\">#</a> 理由</h5>\n<p>可读性。<br>\n易理解性。<br>\n <code>class</code>  的使用会提醒程序员需要考虑不变式。<br>\n这是一种很有用的惯例。</p>\n<h5 id=\"注解-89\"><a class=\"markdownIt-Anchor\" href=\"#注解-89\">#</a> 注解</h5>\n<p>不变式是对象的成员之间的一种逻辑条件，必须由构造函数建立，并由公开成员函数假定成员。<br>\n不变式一旦建立（通常是由构造函数），就可以对对象的各个成员函数进行调用了。<br>\n不变式既可以非正式地说明（比如在代码注释中），也可以正式地用  <code>Expects</code>  说明。</p>\n<p>如果数据成员都可以互相独立地进行改变，则不可能存在不变式。</p>\n<h5 id=\"示例-76\"><a class=\"markdownIt-Anchor\" href=\"#示例-76\">#</a> 示例</h5>\n<pre><code>struct Pair &#123;  // 成员可以独立地变动\n    string name;\n    int volume;\n&#125;;\n</code></pre>\n<p>但是：</p>\n<pre><code>class Date &#123;\npublic:\n    // 验证 &#123;yy, mm, dd&#125; 是有效的日期并进行初始化\n    Date(int yy, Month mm, char dd);\n    // ...\nprivate:\n    int y;\n    Month m;\n    char d;    // day\n&#125;;\n</code></pre>\n<h5 id=\"注解-90\"><a class=\"markdownIt-Anchor\" href=\"#注解-90\">#</a> 注解</h5>\n<p>如果一个类中有任何的  <code>private</code>  数据的话，其使用者就不可能不通过构造函数而完全初始化一个对象。<br>\n因此，类的定义者必然提供构造函数且必须明确其含义。<br>\n这就相当于表示该定义者需要定义一种不变式。</p>\n<p><strong>参见</strong>：</p>\n<ul>\n<li><a href=\"#Rc-class\">把带有私有数据的类定义为  <code>class</code> </a></li>\n<li><a href=\"#Rl-order\">优先将接口部分放在类的开头</a></li>\n<li><a href=\"#Rc-private\">使成员的暴露最小化</a></li>\n<li><a href=\"#Rh-protected\">避免  <code>protected</code>  数据</a></li>\n</ul>\n<h5 id=\"强制实施-69\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-69\">#</a> 强制实施</h5>\n<p>查找所有数据都私有的  <code>struct</code>  和带有公开成员的  <code>class</code> 。</p>\n<h3 id=\"a-namerc-interfaceac3-用类来表示接口和实现之间的区别\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-interfaceac3-用类来表示接口和实现之间的区别\">#</a> <a name=\"Rc-interface\"></a>C.3: 用类来表示接口和实现之间的区别</h3>\n<h5 id=\"理由-75\"><a class=\"markdownIt-Anchor\" href=\"#理由-75\">#</a> 理由</h5>\n<p>接口和实现之间的明确区别能够提升可读性并简化维护工作。</p>\n<h5 id=\"示例-77\"><a class=\"markdownIt-Anchor\" href=\"#示例-77\">#</a> 示例</h5>\n<pre><code>class Date &#123;\npublic:\n    Date();\n    // 验证 &#123;yy, mm, dd&#125; 是有效的日期并进行初始化\n    Date(int yy, Month mm, char dd);\n\n    int day() const;\n    Month month() const;\n    // ...\nprivate:\n    // ... 一些内部表示 ...\n&#125;;\n</code></pre>\n<p>比如说，我们现在可以改变  <code>Date</code>  的表示而不对其使用者造成影响（虽然很可能需要重新编译）。</p>\n<h5 id=\"注解-91\"><a class=\"markdownIt-Anchor\" href=\"#注解-91\">#</a> 注解</h5>\n<p>使用这样的类来表示接口和实现之间的区别当然不是唯一可能的方式。<br>\n比如说，我们也可以使用命名空间中的一组自由函数，一个抽象基类，或者一个带有概念的函数模板来表示一个接口。<br>\n最重要的一点，在于明确地把接口和其实现 “细节” 区分开来。<br>\n理想地，并且典型地，接口要比其实现稳定得多。</p>\n<h5 id=\"强制实施-70\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-70\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerc-memberac4-仅当函数直接访问类的内部表示时才让函数作为其成员\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-memberac4-仅当函数直接访问类的内部表示时才让函数作为其成员\">#</a> <a name=\"Rc-member\"></a>C.4: 仅当函数直接访问类的内部表示时才让函数作为其成员</h3>\n<h5 id=\"理由-76\"><a class=\"markdownIt-Anchor\" href=\"#理由-76\">#</a> 理由</h5>\n<p>比成员函数更少的耦合，减少可能由于改动对象状态而造成问题的函数，减少每当改变内部表示时需要进行修改的函数数量。</p>\n<h5 id=\"示例-78\"><a class=\"markdownIt-Anchor\" href=\"#示例-78\">#</a> 示例</h5>\n<pre><code>class Date &#123;\n    // ... 相对较小的接口 ...\n&#125;;\n\n// 辅助函数:\nDate next_weekday(Date);\nbool operator==(Date, Date);\n</code></pre>\n<p>这些 “辅助函数” 并不需要直接访问  <code>Date</code>  的内部表示。</p>\n<h5 id=\"注解-92\"><a class=\"markdownIt-Anchor\" href=\"#注解-92\">#</a> 注解</h5>\n<p>当 C++ 带来<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcGVuLXN0ZC5vcmcvanRjMS9zYzIyL3dnMjEvZG9jcy9wYXBlcnMvMjAxNi9wMDI1MXIwLnBkZg==\">统一函数调用</span>之后，这条规则会更有效。</p>\n<h5 id=\"例外-21\"><a class=\"markdownIt-Anchor\" href=\"#例外-21\">#</a> 例外</h5>\n<p>语言规定  <code>virtual</code>  函数为成员函数，而并非所有的  <code>virtual</code>  函数都会直接访问数据。<br>\n特别是，抽象类的成员很少这样做。</p>\n<p>注意 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMjAwNjA1MDIxNzU5L2h0dHBzOi8vcGFyYXNvbC50YW11LmVkdS9+eXVyaXlzL3BhcGVycy9PTU0xMC5wZGY=\">multi methods</span>。</p>\n<h5 id=\"例外-22\"><a class=\"markdownIt-Anchor\" href=\"#例外-22\">#</a> 例外</h5>\n<p>语言规定运算符  <code>=</code> ， <code>()</code> ， <code>[]</code>  和  <code>-&gt;</code>  是成员函数。</p>\n<h5 id=\"示例-79\"><a class=\"markdownIt-Anchor\" href=\"#示例-79\">#</a> 示例</h5>\n<p>一个重载集合中的一些成员可以不直接访问  <code>private</code>  数据：</p>\n<pre><code>class Foobar &#123;\npublic:\n    void foo(long x) &#123; /* 操作 private 数据 */ &#125;\n    void foo(double x) &#123; foo(std::lround(x)); &#125;\n    // ...\nprivate:\n    // ...\n&#125;;\n</code></pre>\n<h5 id=\"例外-23\"><a class=\"markdownIt-Anchor\" href=\"#例外-23\">#</a> 例外</h5>\n<p>类似地，一组函数可以被设计为进行链式调用：</p>\n<pre><code>x.scale(0.5).rotate(45).set_color(Color::red);\n</code></pre>\n<p>典型情况下，这些函数中的一些而并非全部会访问  <code>private</code>  数据。</p>\n<h5 id=\"强制实施-71\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-71\">#</a> 强制实施</h5>\n<ul>\n<li>寻找并不直接访问数据成员的非  <code>virtual</code>  成员函数。<br>\n麻烦的是由许多并不需要直接访问数据成员的函数也会这么做。</li>\n<li>忽略  <code>virtual</code>  函数。</li>\n<li>忽略至少包含一个访问了  <code>private</code>  成员的函数的重载集合中的函数。</li>\n<li>忽略返回  <code>this</code>  的函数。</li>\n</ul>\n<h3 id=\"a-namerc-helperac5-把辅助函数放在其所支持的类相同的命名空间之中\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-helperac5-把辅助函数放在其所支持的类相同的命名空间之中\">#</a> <a name=\"Rc-helper\"></a>C.5: 把辅助函数放在其所支持的类相同的命名空间之中</h3>\n<h5 id=\"理由-77\"><a class=\"markdownIt-Anchor\" href=\"#理由-77\">#</a> 理由</h5>\n<p>辅助函数是（由类的作者提供的）并不需要直接访问类的内部表示的函数，它们也被当作是类的可用接口的一部分。<br>\n把它们和类放在相同的命名空间中，使它们与类的关系更明显，并允许通过基于参数的查找机制找到它们。</p>\n<h5 id=\"示例-80\"><a class=\"markdownIt-Anchor\" href=\"#示例-80\">#</a> 示例</h5>\n<pre><code>namespace Chrono &#123; // 我们在这里放置与时间有关的服务\n\n    class Time &#123; /* ... */ &#125;;\n    class Date &#123; /* ... */ &#125;;\n\n    // 辅助函数:\n    bool operator==(Date, Date);\n    Date next_weekday(Date);\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"注解-93\"><a class=\"markdownIt-Anchor\" href=\"#注解-93\">#</a> 注解</h5>\n<p>这点对于<a href=\"#Ro-namespace\">重载运算符</a>来说尤其重要。</p>\n<h5 id=\"强制实施-72\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-72\">#</a> 强制实施</h5>\n<ul>\n<li>对接受某一个命名空间中的参数类型的全局函数进行标记。</li>\n</ul>\n<h3 id=\"a-namerc-standaloneac7-不要在同一个语句中同时定义类或枚举并声明该类型的变量\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-standaloneac7-不要在同一个语句中同时定义类或枚举并声明该类型的变量\">#</a> <a name=\"Rc-standalone\"></a>C.7: 不要在同一个语句中同时定义类或枚举并声明该类型的变量</h3>\n<h5 id=\"理由-78\"><a class=\"markdownIt-Anchor\" href=\"#理由-78\">#</a> 理由</h5>\n<p>在同一个声明式中混合类型的定义和另一个实体的定义会导致混淆，而且不是必要的。</p>\n<h5 id=\"示例不好-22\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-22\">#</a> 示例，不好</h5>\n<pre><code>struct Data &#123; /*...*/ &#125; data&#123; /*...*/ &#125;;\n</code></pre>\n<h5 id=\"示例好-6\"><a class=\"markdownIt-Anchor\" href=\"#示例好-6\">#</a> 示例，好</h5>\n<pre><code>struct Data &#123; /*...*/ &#125;;\nData data&#123; /*...*/ &#125;;\n</code></pre>\n<h5 id=\"强制实施-73\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-73\">#</a> 强制实施</h5>\n<ul>\n<li>如果类或者枚举的定义式的  <code>&#125;</code>  后面没有跟着  <code>;</code>  就标记出来。它缺少了  <code>;</code> 。</li>\n</ul>\n<h3 id=\"a-namerc-classac8-当有任何非公开成员时使用-class-而不是-struct\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-classac8-当有任何非公开成员时使用-class-而不是-struct\">#</a> <a name=\"Rc-class\"></a>C.8: 当有任何非公开成员时使用  <code>class</code>  而不是  <code>struct</code></h3>\n<h5 id=\"理由-79\"><a class=\"markdownIt-Anchor\" href=\"#理由-79\">#</a> 理由</h5>\n<p>可读性。<br>\n表明有些东西被隐藏或者进行了抽象。<br>\n这是一种有用的惯例。</p>\n<h5 id=\"示例不好-23\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-23\">#</a> 示例，不好</h5>\n<pre><code>struct Date &#123;\n    int d, m;\n\n    Date(int i, Month m);\n    // ... 许多函数 ...\nprivate:\n    int y;  // year\n&#125;;\n</code></pre>\n<p>这段代码在 C++ 语言规则方面没有任何问题，<br>\n但从设计角度看则几乎全是错误。<br>\n私有数据和公开数据相比藏得太远了。<br>\n数据在类的声明式中被分到了不同的部分中。<br>\n不同部分的数据具有不同的访问性。<br>\n所有这些都减弱了可读性，并使维护变得更复杂。</p>\n<h5 id=\"注解-94\"><a class=\"markdownIt-Anchor\" href=\"#注解-94\">#</a> 注解</h5>\n<p>优先将接口部分放在类的开头，<a href=\"#Rl-order\">参见 NL.16</a>。</p>\n<h5 id=\"强制实施-74\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-74\">#</a> 强制实施</h5>\n<p>对于声明为  <code>struct</code>  的类，当其带有  <code>private</code>  或  <code>protected</code>  成员时就进行标记。</p>\n<h3 id=\"a-namerc-privateac9-让成员的暴露最小化\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-privateac9-让成员的暴露最小化\">#</a> <a name=\"Rc-private\"></a>C.9: 让成员的暴露最小化</h3>\n<h5 id=\"理由-80\"><a class=\"markdownIt-Anchor\" href=\"#理由-80\">#</a> 理由</h5>\n<p>封装。<br>\n信息隐藏。<br>\n使发生意外访问的机会最小化。<br>\n这会简化维护工作。</p>\n<h5 id=\"示例-81\"><a class=\"markdownIt-Anchor\" href=\"#示例-81\">#</a> 示例</h5>\n<pre><code>template&lt;typename T, typename U&gt;\nstruct pair &#123;\n    T a;\n    U b;\n    // ...\n&#125;;\n</code></pre>\n<p>无论我们在  <code>//</code>  部分中干什么， <code>pair</code>  的任意用户都可以任意地并且不相关地改动其  <code>a</code>  和  <code>b</code> 。<br>\n在大型代码库中，我们无法轻易找出哪段代码对  <code>pair</code>  的成员都做了什么。<br>\n这也许正是我们想要的，但如果想要在成员之间强加某种关系，就需要使它们为  <code>private</code> ，<br>\n并通过构造函数和成员函数来强加这种关系（不变式）。<br>\n例如：</p>\n<pre><code>class Distance &#123;\npublic:\n    // ...\n    double meters() const &#123; return magnitude*unit; &#125;\n    void set_unit(double u)\n    &#123;\n            // ... 检查 u 是 10 的倍数 ...\n            // ... 适当地改变幅度 ...\n            unit = u;\n    &#125;\n    // ...\nprivate:\n    double magnitude;\n    double unit;    // 1 为米，1000 为千米，0.001 为毫米，等等\n&#125;;\n</code></pre>\n<h5 id=\"注解-95\"><a class=\"markdownIt-Anchor\" href=\"#注解-95\">#</a> 注解</h5>\n<p>如果无法轻易确定一组变量的直接用户的集合，那么这个集合的类型或用法也无法被（轻易）改变或改进。<br>\n对于  <code>public</code>  和  <code>protected</code>  数据来说这是常见的情况。</p>\n<h5 id=\"示例-82\"><a class=\"markdownIt-Anchor\" href=\"#示例-82\">#</a> 示例</h5>\n<p>一个类可以向其用户提供两个接口。<br>\n一个针对其派生类（ <code>protected</code> ），而另一个针对一般用户（ <code>public</code> ）。<br>\n例如，可能允许派生类跳过某种运行时检查，因为其已经确保了正确性：</p>\n<pre><code>class Foo &#123;\npublic:\n    int bar(int x) &#123; check(x); return do_bar(x); &#125;\n    // ...\nprotected:\n    int do_bar(int x); // 在数据上做些操作\n    // ...\nprivate:\n    // ... 数据 ...\n&#125;;\n\nclass Dir : public Foo &#123;\n    //...\n    int mem(int x, int y)\n    &#123;\n        /* ... 做一些事 ... */\n        return do_bar(x + y); // OK：派生类可以略过检查\n    &#125;\n&#125;;\n\nvoid user(Foo&amp; x)\n&#123;\n    int r1 = x.bar(1);      // OK，有检查\n    int r2 = x.do_bar(2);   // 错误：可能略过检查\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"注解-96\"><a class=\"markdownIt-Anchor\" href=\"#注解-96\">#</a> 注解</h5>\n<p><a href=\"#Rh-protected\"> <code>protected</code>  数据不是好主意</a>。</p>\n<h5 id=\"注解-97\"><a class=\"markdownIt-Anchor\" href=\"#注解-97\">#</a> 注解</h5>\n<p>优先让  <code>public</code>  成员在前， <code>protected</code>  成员其次， <code>private</code>  成员在后；参见 <a href=\"#Rl-order\">NL.16</a>。</p>\n<h5 id=\"强制实施-75\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-75\">#</a> 强制实施</h5>\n<ul>\n<li><a href=\"#Rh-protected\">标记  <code>protected</code>  数据</a>。</li>\n<li>标记混合的  <code>public</code>  和  <code>private</code>  数据。</li>\n</ul>\n<h2 id=\"a-namess-concreteacconcrete-具体类型\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-concreteacconcrete-具体类型\">#</a> <a name=\"SS-concrete\"></a>C.concrete: 具体类型</h2>\n<p>具体类型的规则概览：</p>\n<ul>\n<li><a href=\"#Rc-concrete\">C.10: 优先使用具体类型而不是类继承层次</a></li>\n<li><a href=\"#Rc-regular\">C.11: 使具体类型正规化</a></li>\n<li><a href=\"#Rc-constref\">C.12: 不要令可复制或移动类型的数据成员为  <code>const</code>  或引用</a></li>\n</ul>\n<h3 id=\"a-namerc-concreteac10-优先使用具体类型而不是类继承层次\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-concreteac10-优先使用具体类型而不是类继承层次\">#</a> <a name=\"Rc-concrete\"></a>C.10: 优先使用具体类型而不是类继承层次</h3>\n<h5 id=\"理由-81\"><a class=\"markdownIt-Anchor\" href=\"#理由-81\">#</a> 理由</h5>\n<p>具体类型在本质上就比类继承层次中的类型更简单：<br>\n它们更易于设计，更易于实现，更易于使用，更易于进行推理，更小，也更快。<br>\n使用继承层次是需要一些理由（用例）来支持的。</p>\n<h5 id=\"示例-83\"><a class=\"markdownIt-Anchor\" href=\"#示例-83\">#</a> 示例</h5>\n<pre><code>class Point1 &#123;\n    int x, y;\n    // ... 一些操作 ...\n    // ... 没有虚函数 ...\n&#125;;\n\nclass Point2 &#123;\n    int x, y;\n    // ... 一些操作，其中有些是虚的 ...\n    virtual ~Point2();\n&#125;;\n\nvoid use()\n&#123;\n    Point1 p11 &#123;1, 2&#125;;   // 在栈上创建一个对象\n    Point1 p12 &#123;p11&#125;;    // 一个副本\n\n    auto p21 = make_unique&lt;Point2&gt;(1, 2);   // 在自由存储中创建一个对象\n    auto p22 = p21-&gt;clone();                // 创建一个副本\n    // ...\n&#125;\n</code></pre>\n<p>当一个类属于某个继承层次时，我们（即使在小例子中不需要，在真实代码中也）必然要通过指针或者引用来操作它的对象。<br>\n这意味着更多的内存开销，更多的分配和回收操作，以及更多的用于实施间接操作所带来的运行时开销。</p>\n<h5 id=\"注解-98\"><a class=\"markdownIt-Anchor\" href=\"#注解-98\">#</a> 注解</h5>\n<p>具体类型可以在栈上分配，也可以成为其他类的成员。</p>\n<h5 id=\"注解-99\"><a class=\"markdownIt-Anchor\" href=\"#注解-99\">#</a> 注解</h5>\n<p>对于运行时多态接口来说，使用间接是一项基本要求。<br>\n而分配 / 回收操作的开销则不是（它们只是最常见的情况而已）。<br>\n我们可以使用基类来作为有作用域的派生类对象的接口。<br>\n当禁止使用动态分配时（比如硬实时）就可以这样做，为某些种类的插件提供一种稳定的接口。</p>\n<h5 id=\"强制实施-76\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-76\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerc-regularac11-使具体类型正规化\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-regularac11-使具体类型正规化\">#</a> <a name=\"Rc-regular\"></a>C.11: 使具体类型正规化</h3>\n<h5 id=\"理由-82\"><a class=\"markdownIt-Anchor\" href=\"#理由-82\">#</a> 理由</h5>\n<p>正规类型比不正规的类型更易于理解和进行推导（不正规性会导致理解和使用上花费更多的精力）。</p>\n<p>C++ 内建类型都是正规的，标准程序库的一些类型，如  <code>string</code> ， <code>vector</code> ，和  <code>map</code>  也是如此。可以定义没有赋值和相等比较的具体类，但它们很罕见（理当如此）。</p>\n<h5 id=\"示例-84\"><a class=\"markdownIt-Anchor\" href=\"#示例-84\">#</a> 示例</h5>\n<pre><code>struct Bundle &#123;\n    string name;\n    vector&lt;Record&gt; vr;\n&#125;;\n\nbool operator==(const Bundle&amp; a, const Bundle&amp; b)\n&#123;\n    return a.name == b.name &amp;&amp; a.vr == b.vr;\n&#125;\n\nBundle b1 &#123; &quot;my bundle&quot;, &#123;r1, r2, r3&#125;&#125;;\nBundle b2 = b1;\nif (!(b1 == b2)) error(&quot;impossible!&quot;);\nb2.name = &quot;the other bundle&quot;;\nif (b1 == b2) error(&quot;No!&quot;);\n</code></pre>\n<p>特别是，当具体类型可以复制时，也应当为之提供相等比较运算符，并确保  <code>a = b</code>  蕴含  <code>a == b</code> 。</p>\n<h5 id=\"注解-100\"><a class=\"markdownIt-Anchor\" href=\"#注解-100\">#</a> 注解</h5>\n<p>对于用来与 C 代码共用的结构体，为其定义  <code>operator==</code>  是不可行的。</p>\n<h5 id=\"注解-101\"><a class=\"markdownIt-Anchor\" href=\"#注解-101\">#</a> 注解</h5>\n<p>无法进行克隆的资源包装类（例如，包含一个  <code>mutex</code>  的  <code>scoped_lock</code> ）是具体类型，不过通常都无法进行复制（但它们一般都可以被移动），<br>\n因此它们不是正规类型；但它们倾向于成为 “仅可移动类型”。</p>\n<h5 id=\"强制实施-77\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-77\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerc-constrefac12-不要令可复制或移动类型的数据成员为-const-或引用\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-constrefac12-不要令可复制或移动类型的数据成员为-const-或引用\">#</a> <a name=\"Rc-constref\"></a>C.12: 不要令可复制或移动类型的数据成员为  <code>const</code>  或引用</h3>\n<h5 id=\"理由-83\"><a class=\"markdownIt-Anchor\" href=\"#理由-83\">#</a> 理由</h5>\n<p><code>const</code>  和引用数据成员在可复制或移动类型中没什么用处，还会由于微妙的原因使这种类型变得至少部分地无法复制 / 无法移动而很难使用。</p>\n<h5 id=\"示例不好-24\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-24\">#</a> 示例；不好</h5>\n<pre><code>class bad &#123;\n    const int i;    // 不好\n    string&amp; s;      // 不好\n    // ...\n&#125;;\n</code></pre>\n<p><code>const</code>  和  <code>&amp;</code>  数据成员会导致类变成 “仅可进行某些复制”—— 可复制构造但不可复制赋值。</p>\n<h5 id=\"注解-102\"><a class=\"markdownIt-Anchor\" href=\"#注解-102\">#</a> 注解</h5>\n<p>如果需要一个指向某物的成员，就请使用指针（原始的或智能的，而当它不能为 null 时使用  <code>gsl::not_null</code> ）而不是引用。</p>\n<h5 id=\"强制实施-78\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-78\">#</a> 强制实施</h5>\n<p>标记具有任意复制或移动操作的类型中的  <code>const</code> ， <code>&amp;</code> ，或者  <code>&amp;&amp;</code>  的数据成员。</p>\n<h2 id=\"a-names-ctoracctor-构造函数赋值和析构函数\"><a class=\"markdownIt-Anchor\" href=\"#a-names-ctoracctor-构造函数赋值和析构函数\">#</a> <a name=\"S-ctor\"></a>C.ctor: 构造函数，赋值，和析构函数</h2>\n<p>这些函数控制对象的生存期：创建，复制，移动，以及销毁。<br>\n定义构造函数是为了确保以及简化类的初始化过程。</p>\n<p>以下被称为<em>默认操作</em>：</p>\n<ul>\n<li>默认构造函数:  <code>X()</code></li>\n<li>复制构造函数:  <code>X(const X&amp;)</code></li>\n<li>复制赋值:  <code>operator=(const X&amp;)</code></li>\n<li>移动构造函数:  <code>X(X&amp;&amp;)</code></li>\n<li>移动赋值:  <code>operator=(X&amp;&amp;)</code></li>\n<li>析构函数:  <code>~X()</code></li>\n</ul>\n<p>缺省情况下，编译器会为这些操作中被使用的进行定义，但这些默认定义可以被抑制掉。</p>\n<p>默认操作是一组互相关联的操作，它们共同实现了对象的生存期语义。<br>\n缺省情况下，C++ 按照值类型的方式来对待各个类，但并非所有的类型都与值类型相符。</p>\n<p>默认操作的规则集合：</p>\n<ul>\n<li><a href=\"#Rc-zero\">C.20: 只要可能，请避免定义任何的默认操作</a></li>\n<li><a href=\"#Rc-five\">C.21: 如果定义或者  <code>=delete</code>  了任何复制、移动或析构函数，请定义或者  <code>=delete</code>  它们全部</a></li>\n<li><a href=\"#Rc-matched\">C.22: 使默认操作之间保持一致</a></li>\n</ul>\n<p>析构函数的规则：</p>\n<ul>\n<li><a href=\"#Rc-dtor\">C.30: 如果一个类需要在对象销毁时执行明确的操作，请为其定义析构函数</a></li>\n<li><a href=\"#Rc-dtor-release\">C.31: 类所获取的所有资源，必须都在类的析构函数中进行释放</a></li>\n<li><a href=\"#Rc-dtor-ptr\">C.32: 如果类中带有原始指针（ <code>T*</code> ）或者引用（ <code>T&amp;</code> ），请考虑它是否是所有者</a></li>\n<li><a href=\"#Rc-dtor-ptr2\">C.33: 如果类中带有所有权的指针成员，请定义析构函数</a></li>\n<li><a href=\"#Rc-dtor-virtual\">C.35: 基类的析构函数应当要么是 public 和 virtual，要么是 protected 且非 virtual</a></li>\n<li><a href=\"#Rc-dtor-fail\">C.36: 析构函数不能失败</a></li>\n<li><a href=\"#Rc-dtor-noexcept\">C.37: 使析构函数  <code>noexcept</code> </a></li>\n</ul>\n<p>构造函数的规则：</p>\n<ul>\n<li><a href=\"#Rc-ctor\">C.40: 如果类具有不变式，请为其定义构造函数</a></li>\n<li><a href=\"#Rc-complete\">C.41: 构造函数应当创建经过完整初始化的对象</a></li>\n<li><a href=\"#Rc-throw\">C.42: 当构造函数无法构造有效对象时，应当抛出异常</a></li>\n<li><a href=\"#Rc-default0\">C.43: 保证可复制类带有默认构造函数</a></li>\n<li><a href=\"#Rc-default00\">C.44: 尽量让默认构造函数简单且不抛出异常</a></li>\n<li><a href=\"#Rc-default\">C.45: 不要定义仅对数据成员进行初始化的默认构造函数；应当使用成员初始化式</a></li>\n<li><a href=\"#Rc-explicit\">C.46: 默认情况下，把单参数的构造函数声明为  <code>explicit</code> </a></li>\n<li><a href=\"#Rc-order\">C.47: 按成员声明的顺序对成员变量进行定义和初始化</a></li>\n<li><a href=\"#Rc-in-class-initializer\">C.48: 对于常量初始化式来说，优先采用类中的初始化式而不是构造函数中的成员初始化式</a></li>\n<li><a href=\"#Rc-initialize\">C.49: 优先进行初始化而不是在构造函数中赋值</a></li>\n<li><a href=\"#Rc-factory\">C.50: 当初始化过程中需要体现 “虚函数行为” 时，请使用工厂函数</a></li>\n<li><a href=\"#Rc-delegating\">C.51: 用委派构造函数来表示类中所有构造函数的共同行为</a></li>\n<li><a href=\"#Rc-inheriting\">C.52: 使用继承构造函数来把构造函数引入到无须进行其他的明确初始化操作的派生类之中</a></li>\n</ul>\n<p>复制和移动的规则：</p>\n<ul>\n<li><a href=\"#Rc-copy-assignment\">C.60: 使复制赋值非  <code>virtual</code> ，接受  <code>const&amp;</code>  的参数，并返回非  <code>const</code>  的引用</a></li>\n<li><a href=\"#Rc-copy-semantic\">C.61: 复制操作应当进行复制</a></li>\n<li><a href=\"#Rc-copy-self\">C.62: 使复制赋值可以安全进行自赋值</a></li>\n<li><a href=\"#Rc-move-assignment\">C.63: 使移动赋值非  <code>virtual</code> ，接受  <code>&amp;&amp;</code>  的参数，并返回非  <code>const&amp;</code> </a></li>\n<li><a href=\"#Rc-move-semantic\">C.64: 移动操作应当进行移动，并使原对象处于有效状态</a></li>\n<li><a href=\"#Rc-move-self\">C.65: 使移动赋值可以安全进行自赋值</a></li>\n<li><a href=\"#Rc-move-noexcept\">C.66: 使移动操作  <code>noexcept</code> </a></li>\n<li><a href=\"#Rc-copy-virtual\">C.67: 多态类应当抑制公开的移动 / 复制操作</a></li>\n</ul>\n<p>其他的默认操作规则：</p>\n<ul>\n<li><a href=\"#Rc-eqdefault\">C.80: 当需要明确使用缺省语义时，使用  <code>=default</code> </a></li>\n<li><a href=\"#Rc-delete\">C.81: 当需要关闭缺省行为（且不需要替代的行为）时，使用  <code>=delete</code> </a></li>\n<li><a href=\"#Rc-ctor-virtual\">C.82: 不要在构造函数和析构函数中调用虚函数</a></li>\n<li><a href=\"#Rc-swap\">C.83: 考虑为值类型提供  <code>noexcept</code>  的  <code>swap</code>  函数</a></li>\n<li><a href=\"#Rc-swap-fail\">C.84:  <code>swap</code>  不能失败</a></li>\n<li><a href=\"#Rc-swap-noexcept\">C.85: 使  <code>swap</code>  函数  <code>noexcept</code> </a></li>\n<li><a href=\"#Rc-eq\">C.86: 使  <code>==</code>  对操作数的类型对称，并使之  <code>noexcept</code> </a></li>\n<li><a href=\"#Rc-eq-base\">C.87: 请当心基类的  <code>==</code> </a></li>\n<li><a href=\"#Rc-hash\">C.89: 使  <code>hash</code>  函数  <code>noexcept</code> </a></li>\n<li><a href=\"#Rc-memset\">C.90: 依靠构造函数和赋值运算符，不要依靠  <code>memset</code>  和  <code>memcpy</code> </a></li>\n</ul>\n<h2 id=\"a-namess-defopacdefop-默认操作\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-defopacdefop-默认操作\">#</a> <a name=\"SS-defop\"></a>C.defop: 默认操作</h2>\n<p>缺省情况下，语言会提供具有预置语义的默认操作。<br>\n不过，程序员可以关闭或者替换掉这些缺省实现。</p>\n<h3 id=\"a-namerc-zeroac20-只要可能请避免定义任何的默认操作\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-zeroac20-只要可能请避免定义任何的默认操作\">#</a> <a name=\"Rc-zero\"></a>C.20: 只要可能，请避免定义任何的默认操作</h3>\n<h5 id=\"理由-84\"><a class=\"markdownIt-Anchor\" href=\"#理由-84\">#</a> 理由</h5>\n<p>这样最简单，而且能提供最清晰的语义。</p>\n<h5 id=\"示例-85\"><a class=\"markdownIt-Anchor\" href=\"#示例-85\">#</a> 示例</h5>\n<pre><code>struct Named_map &#123;\npublic:\n    // ... 并未声明任何默认操作 ...\nprivate:\n    string name;\n    map&lt;int, int&gt; rep;\n&#125;;\n\nNamed_map nm;        // 默认构造\nNamed_map nm2 &#123;nm&#125;;  // 复制构造\n</code></pre>\n<p>由于  <code>std::map</code>  和  <code>string</code>  都带有全部的特殊函数，这里并不需要做别的事情。</p>\n<h5 id=\"注解-103\"><a class=\"markdownIt-Anchor\" href=\"#注解-103\">#</a> 注解</h5>\n<p>这被称为 “零之准则（The rule of zero）”。</p>\n<h5 id=\"强制实施-79\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-79\">#</a> 强制实施</h5>\n<p>【无法强制实施】 虽然无法强制实施，但一个优秀的静态分析器可以检查出一些模式，指出可使之符合本条规则的改进可能性。<br>\n例如，一个带有（指针，大小）成员对，同时在析构函数中  <code>delete</code>  这个指针的类也许可以被转换为使用一个  <code>vector</code> 。</p>\n<h3 id=\"a-namerc-fiveac21-如果定义或者-delete-了任何复制-移动或析构函数请定义或者-delete-它们全部\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-fiveac21-如果定义或者-delete-了任何复制-移动或析构函数请定义或者-delete-它们全部\">#</a> <a name=\"Rc-five\"></a>C.21: 如果定义或者  <code>=delete</code>  了任何复制、移动或析构函数，请定义或者  <code>=delete</code>  它们全部</h3>\n<h5 id=\"理由-85\"><a class=\"markdownIt-Anchor\" href=\"#理由-85\">#</a> 理由</h5>\n<p>复制、移动和析构的语义互相之间是紧密相关的，一旦需要声明其中一个，麻烦的是其他的也需要予以考虑。</p>\n<p>只要声明了复制、移动或析构函数，<br>\n即便是声明为  <code>=default</code>  或  <code>=delete</code> ，也将会抑制掉<br>\n移动构造函数和移动赋值运算符的隐式声明。<br>\n而声明移动构造函数或移动赋值运算符，<br>\n即便是声明为  <code>=default</code>  或  <code>=delete</code> ，也将会导致隐式生成的复制构造函数<br>\n或隐式生成的复制赋值运算符被定义为弃置的。<br>\n因此，只要声明了它们中的任何一个，就应当将<br>\n其他全部都予以声明，以避免出现预期外的效果，比如将所有潜在的移动<br>\n都变成了更昂贵的复制操作，或者使类变为只能移动的。</p>\n<h5 id=\"示例不好-25\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-25\">#</a> 示例，不好</h5>\n<pre><code>struct M2 &#123;   // 不好: 不完整的复制/移动/析构操作集合\npublic:\n    // ...\n    // ... 没有复制和移动操作 ...\n    ~M2() &#123; delete[] rep; &#125;\nprivate:\n    pair&lt;int, int&gt;* rep;  // pair 的以零终止的集合\n&#125;;\n\nvoid use()\n&#123;\n    M2 x;\n    M2 y;\n    // ...\n    x = y;   // 缺省的赋值\n    // ...\n&#125;\n</code></pre>\n<p>既然对于析构函数需要 “特殊关照”（这里是要进行回收操作），隐式定义的复制和移动赋值运算符仍保持正确性的可能是很低的（此处会导致双重删除问题）。</p>\n<h5 id=\"注解-104\"><a class=\"markdownIt-Anchor\" href=\"#注解-104\">#</a> 注解</h5>\n<p>这被称为 “五之准则（The rule of five）”。</p>\n<h5 id=\"注解-105\"><a class=\"markdownIt-Anchor\" href=\"#注解-105\">#</a> 注解</h5>\n<p>如果想（于定义了别的函数时）保持缺省实现，请写下  <code>=default</code>  以表明对这个函数是特意这样做的。<br>\n如果不想要一个生成的缺省函数，可以用  <code>=delete</code>  来抑制它。</p>\n<h5 id=\"示例好-7\"><a class=\"markdownIt-Anchor\" href=\"#示例好-7\">#</a> 示例，好</h5>\n<p>如果要声明析构函数仅是为了使其为  <code>virtual</code>  的话，<br>\n可将其定义为预置的。</p>\n<pre><code>class AbstractBase &#123;\npublic:\n    virtual ~AbstractBase() = default;\n    // ...\n&#125;;\n</code></pre>\n<p>为避免发生如 <a href=\"#Rc-copy-virtual\">C.67</a> 所说的切片，<br>\n使复制和移动操作为受保护的或  <code>=delete</code> ，并添加  <code>clone</code> ：</p>\n<pre><code>class CloneableBase &#123;\npublic:\n    virtual unique_ptr&lt;CloneableBase&gt; clone() const;\n    virtual ~CloneableBase() = default;\n    CloneableBase() = default;\n    CloneableBase(const CloneableBase&amp;) = delete;\n    CloneableBase&amp; operator=(const CloneableBase&amp;) = delete;\n    CloneableBase(CloneableBase&amp;&amp;) = delete;\n    CloneableBase&amp; operator=(CloneableBase&amp;&amp;) = delete;\n    // ... 其他构造函数和函数 ...\n&#125;;\n</code></pre>\n<p>这里仅定义移动操作或者进定义复制操作也可以具有<br>\n相同效果，但明确说明每个特殊成员的意图，<br>\n可使其对读者更加易于理解。</p>\n<h5 id=\"注解-106\"><a class=\"markdownIt-Anchor\" href=\"#注解-106\">#</a> 注解</h5>\n<p>编译器会很大程度上强制实施这条规则，并在理想情况下会对任何违反都给出警告。</p>\n<h5 id=\"注解-107\"><a class=\"markdownIt-Anchor\" href=\"#注解-107\">#</a> 注解</h5>\n<p>在带有析构函数的类中，依靠隐式生成的复制操作的做法已经被摒弃。</p>\n<h5 id=\"注解-108\"><a class=\"markdownIt-Anchor\" href=\"#注解-108\">#</a> 注解</h5>\n<p>编写这些函数很容易出错。<br>\n注意它们的参数类型：</p>\n<pre><code>class X &#123;\npublic:\n    // ...\n    virtual ~X() = default;            // 析构函数 (如果 X 是基类，用 virtual)\n    X(const X&amp;) = default;             // 复制构造函数\n    X&amp; operator=(const X&amp;) = default;  // 复制赋值\n    X(X&amp;&amp;) = default;                  // 移动构造函数\n    X&amp; operator=(X&amp;&amp;) = default;       // 移动赋值\n&#125;;\n</code></pre>\n<p>一个小错误（例如拼写错误，遗漏  <code>const</code> ，使用  <code>&amp;</code>  而不是 '&amp;&amp;`，或遗漏一个特殊功能）可能导致错误或警告。<br>\n为避免单调乏味和出错的可能性，请尝试遵循<a href=\"%EF%BC%83Rc-zero\">零规则</a>。</p>\n<h5 id=\"强制实施-80\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-80\">#</a> 强制实施</h5>\n<p>【简单】 类中应当要么为每个复制 / 移动 / 析构函数都提供一个声明（即便是  <code>=delete</code> ），要么都不这样做。</p>\n<h3 id=\"a-namerc-matchedac22-使默认操作之间保持一致\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-matchedac22-使默认操作之间保持一致\">#</a> <a name=\"Rc-matched\"></a>C.22: 使默认操作之间保持一致</h3>\n<h5 id=\"理由-86\"><a class=\"markdownIt-Anchor\" href=\"#理由-86\">#</a> 理由</h5>\n<p>默认操作是一个概念上相配合的集合。它们的语义是相互关联的。<br>\n如果复制 / 移动构造和复制 / 移动赋值所做的是逻辑上不同的事情的话，这会让使用者感觉诡异。如果构造函数和析构函数并不提供一种对资源管理的统一视角的话，也会让使用者感觉诡异。如果复制和移动操作并不体现出构造函数和析构函数的工作方式的话，同样会让使用者感觉诡异。</p>\n<h5 id=\"示例不好-26\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-26\">#</a> 示例，不好</h5>\n<pre><code>class Silly &#123;   // 不好: 复制操作不一致\n    class Impl &#123;\n        // ...\n    &#125;;\n    shared_ptr&lt;Impl&gt; p;\npublic:\n    Silly(const Silly&amp; a) : p&#123;make_shared&lt;Impl&gt;()&#125; &#123; *p = *a.p; &#125;   // 深复制\n    Silly&amp; operator=(const Silly&amp; a) &#123; p = a.p; &#125;   // 浅复制\n    // ...\n&#125;;\n</code></pre>\n<p>这些操作在复制语义上并不统一。这将会导致混乱和出现 BUG。</p>\n<h5 id=\"强制实施-81\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-81\">#</a> 强制实施</h5>\n<ul>\n<li>【复杂】 复制 / 移动构造函数和对应的复制 / 移动赋值运算符，应当在相同的解引用层次上向相同的成员变量进行写入。</li>\n<li>【复杂】 在复制 / 移动构造函数中被写入的任何成员变量，在其他构造函数中也都应当进行初始化。</li>\n<li>【复杂】 如果复制 / 移动构造函数对某个成员变量进行了深复制，就应当在析构函数中对这个成员变量进行修改。</li>\n<li>【复杂】 如果析构函数修改了某个成员变量，在任何复制 / 移动构造函数或赋值运算符中就都应当对该成员变量进行写入。</li>\n</ul>\n<h2 id=\"a-namess-dtoracdtor-析构函数\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-dtoracdtor-析构函数\">#</a> <a name=\"SS-dtor\"></a>C.dtor: 析构函数</h2>\n<p>“这个类需要析构函数吗？” 是一个出人意料有洞察力的设计问题。<br>\n对于大多数类来说，答案是 “不需要”，要么是因为类中并没有保持任何资源，要么是因为销毁过程已经被<a href=\"#Rc-zero\">零之准则</a>处理掉了；<br>\n就是说，它的成员在销毁之中可以自己照顾自己。<br>\n当答案为 “需要” 时，类的大部分设计应当遵循下列规则（参见<a href=\"#Rc-five\">五之准则</a>）。</p>\n<h3 id=\"a-namerc-dtorac30-如果一个类需要在对象销毁时执行明确的操作请为其定义析构函数\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-dtorac30-如果一个类需要在对象销毁时执行明确的操作请为其定义析构函数\">#</a> <a name=\"Rc-dtor\"></a>C.30: 如果一个类需要在对象销毁时执行明确的操作，请为其定义析构函数</h3>\n<h5 id=\"理由-87\"><a class=\"markdownIt-Anchor\" href=\"#理由-87\">#</a> 理由</h5>\n<p>析构函数是在对象的生存期结束时被隐式执行的。<br>\n如果预置的析构函数足堪使用的话，就应当用它。<br>\n只有当类需要执行的代码不在其成员的析构函数中时，才需要定义非预置的析构函数。</p>\n<h5 id=\"示例-86\"><a class=\"markdownIt-Anchor\" href=\"#示例-86\">#</a> 示例</h5>\n<pre><code>template&lt;typename A&gt;\nstruct final_action &#123;   // 略有简化\n    A act;\n    final_action(A a) : act&#123;a&#125; &#123;&#125;\n    ~final_action() &#123; act(); &#125;\n&#125;;\n\ntemplate&lt;typename A&gt;\nfinal_action&lt;A&gt; finally(A act)   // 推断出动作的类型\n&#123;\n    return final_action&lt;A&gt;&#123;act&#125;;\n&#125;\n\nvoid test()\n&#123;\n    auto act = finally([] &#123; cout &lt;&lt; &quot;Exit test\\n&quot;; &#125;);  // 设置退出动作\n    // ...\n    if (something) return;   // 动作在这里得到执行\n    // ...\n&#125; // 动作在这里得到执行\n</code></pre>\n<p><code>final_action</code>  的全部目的就是为了在其销毁时执行一段代码（通常是一个 lambda）。</p>\n<h5 id=\"注解-109\"><a class=\"markdownIt-Anchor\" href=\"#注解-109\">#</a> 注解</h5>\n<p>需要自定义析构函数的类大致上有两种：</p>\n<ul>\n<li>类中具有某个资源，而它并未表示成一个具有析构函数的类，比如  <code>vector</code>  或事物类。</li>\n<li>类的目的主要用于在销毁时执行某个动作，比如一个追踪器，或者  <code>final_action</code> 。</li>\n</ul>\n<h5 id=\"示例不好-27\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-27\">#</a> 示例，不好</h5>\n<pre><code>class Foo &#123;   // 不好; 使用预置的析构函数\npublic:\n    // ...\n    ~Foo() &#123; s = &quot;&quot;; i = 0; vi.clear(); &#125;  // 清理\nprivate:\n    string s;\n    int i;\n    vector&lt;int&gt; vi;\n&#125;;\n</code></pre>\n<p>预置的析构函数会做得更好，更高效，而且不会出错。</p>\n<h5 id=\"注解-110\"><a class=\"markdownIt-Anchor\" href=\"#注解-110\">#</a> 注解</h5>\n<p>当需要预置的析构函数，但其生成被抑制（比如由于定义了移动构造函数）时，可以使用  <code>=default</code> 。</p>\n<h5 id=\"强制实施-82\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-82\">#</a> 强制实施</h5>\n<p>查找疑似 “隐式的资源”，比如指针和引用等。查找带有析构函数的类，即便其所有数据成员都带有自己的析构函数。</p>\n<h3 id=\"a-namerc-dtor-releaseac31-类所获取的所有资源必须都在类的析构函数中进行释放\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-dtor-releaseac31-类所获取的所有资源必须都在类的析构函数中进行释放\">#</a> <a name=\"Rc-dtor-release\"></a>C.31: 类所获取的所有资源，必须都在类的析构函数中进行释放</h3>\n<h5 id=\"理由-88\"><a class=\"markdownIt-Anchor\" href=\"#理由-88\">#</a> 理由</h5>\n<p>避免资源泄漏，尤其是错误情形中。</p>\n<h5 id=\"注解-111\"><a class=\"markdownIt-Anchor\" href=\"#注解-111\">#</a> 注解</h5>\n<p>对于以具有完整的默认操作集合的类来表示的资源来说，这些都是会自动发生的。</p>\n<h5 id=\"示例-87\"><a class=\"markdownIt-Anchor\" href=\"#示例-87\">#</a> 示例</h5>\n<pre><code>class X &#123;\n    ifstream f;   // 可能会拥有某个文件\n    // ... 没有任何定义或者声明为 =deleted 的默认操作 ...\n&#125;;\n</code></pre>\n<p><code>X</code>  的  <code>ifstream</code>  会在其所在  <code>X</code>  的销毁时，隐含地关闭任何可能已经被它所打开的文件。</p>\n<h5 id=\"示例不好-28\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-28\">#</a> 示例，不好</h5>\n<pre><code>class X2 &#123;     // 不好\n    FILE* f;   // 可能会拥有某个文件\n    // ... 没有任何定义或者声明为 =deleted 的默认操作 ...\n&#125;;\n</code></pre>\n<p><code>X2</code>  可能会泄漏文件的句柄。</p>\n<h5 id=\"注解-112\"><a class=\"markdownIt-Anchor\" href=\"#注解-112\">#</a> 注解</h5>\n<p>不过关不掉的 socket 怎么办呢？析构函数、close 以及清理操作<a href=\"#Rc-dtor-fail\">不应当失败</a>。<br>\n如果它确实这样的话，就出现了一个不存在真正的好解决方案的问题。<br>\n对于新手来说，作为析构函数的编写者，无法了解析构函数是因为什么被调用的，而且不能通过抛出异常来 “拒绝执行”。<br>\n参见<a href=\"#Sd-never-fail\">相关讨论</a>。<br>\n让这个问题更加糟糕的，还包括许多的 close/release 操作都是无法重试的。<br>\n许多人都曾试图解决这个问题，但仍不存在已知的一般性解决方案。<br>\n如果可能的话，可以考虑吧 close/cleanup 的失败看成是基本的设计错误，然后终止程序（terminate）。</p>\n<h5 id=\"注解-113\"><a class=\"markdownIt-Anchor\" href=\"#注解-113\">#</a> 注解</h5>\n<p>类之中也可以持有指向它并不拥有的对象的指针和引用。<br>\n显然这样的对象是不应当在类的析构函数中被  <code>delete</code>  的。<br>\n例如：</p>\n<pre><code>Preprocessor pp &#123; /* ... */ &#125;;\nParser p &#123; pp, /* ... */ &#125;;\nType_checker tc &#123; p, /* ... */ &#125;;\n</code></pre>\n<p>这里的  <code>p</code>  指向  <code>pp</code>  但并不拥有它。</p>\n<h5 id=\"强制实施-83\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-83\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】 当类中所有的指针或引用成员变量是所有者<br>\n（比如通过使用  <code>gsl::owner</code>  所断定）时，它们就应当在析构函数中有所引用。</li>\n<li>【困难】 当在所有权上没有明确的说法时，为指针或引用成员变量确定其是否是所有者<br>\n（比如，检查构造函数的代码）。</li>\n</ul>\n<h3 id=\"a-namerc-dtor-ptrac32-如果类中带有原始指针t或者引用t请考虑它是否是所有者\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-dtor-ptrac32-如果类中带有原始指针t或者引用t请考虑它是否是所有者\">#</a> <a name=\"Rc-dtor-ptr\"></a>C.32: 如果类中带有原始指针（ <code>T*</code> ）或者引用（ <code>T&amp;</code> ），请考虑它是否是所有者</h3>\n<h5 id=\"理由-89\"><a class=\"markdownIt-Anchor\" href=\"#理由-89\">#</a> 理由</h5>\n<p>大量的代码都是和所有权无关的。</p>\n<h5 id=\"示例-88\"><a class=\"markdownIt-Anchor\" href=\"#示例-88\">#</a> 示例</h5>\n<pre><code>class legacy_class\n&#123;\n    foo* m_owning;   // 不好：改为 unique_ptr&lt;T&gt; 或 owner&lt;T*&gt;\n    bar* m_observer; // OK：不用改\n&#125;\n</code></pre>\n<p>唯一确定所有权的方式可能就是深入代码中去寻找内存分配了。</p>\n<h5 id=\"注解-114\"><a class=\"markdownIt-Anchor\" href=\"#注解-114\">#</a> 注解</h5>\n<p>所有权在新代码（以及重构的遗留代码）中应当是清晰的：<a href=\"#Rr-owner\">R.20</a> 对于有所有权指针，<br>\n<a href=\"#Rr-ptr\">R.3</a> 对于无所有权指针。引用从来不能有所有权，<a href=\"#Rr-ref\">R.4</a>。</p>\n<h5 id=\"强制实施-84\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-84\">#</a> 强制实施</h5>\n<p>查看原始指针成员和引用成员的初始化，看看是否进行了分配操作。</p>\n<h3 id=\"a-namerc-dtor-ptr2ac33-如果类中带有所有权的指针成员请定义析构函数\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-dtor-ptr2ac33-如果类中带有所有权的指针成员请定义析构函数\">#</a> <a name=\"Rc-dtor-ptr2\"></a>C.33: 如果类中带有所有权的指针成员，请定义析构函数</h3>\n<h5 id=\"理由-90\"><a class=\"markdownIt-Anchor\" href=\"#理由-90\">#</a> 理由</h5>\n<p>被拥有的对象，必须在拥有它的对象销毁时进行  <code>delete</code> 。</p>\n<h5 id=\"示例-89\"><a class=\"markdownIt-Anchor\" href=\"#示例-89\">#</a> 示例</h5>\n<p>指针成员可以表示某种资源。<br>\n<a href=\"#Rr-ptr\">不应该这样使用  <code>T*</code> </a>，但老代码中这是很常见的。<br>\n请把  <code>T*</code>  当作一种可能的所有者的嫌疑。</p>\n<pre><code>template&lt;typename T&gt;\nclass Smart_ptr &#123;\n    T* p;   // 不好: *p 的所有权含糊不清\n    // ...\npublic:\n    // ... 没有自定义的默认操作 ...\n&#125;;\n\nvoid use(Smart_ptr&lt;int&gt; p1)\n&#123;\n    // 错误: p2.p 泄漏了（当其不为 nullptr 且未被其他代码所拥有时）\n    auto p2 = p1;\n&#125;\n</code></pre>\n<p>注意，当你定义析构函数时，你必须定义或者弃置（delete）<a href=\"#Rc-five\">所有的默认操作</a>：</p>\n<pre><code>template&lt;typename T&gt;\nclass Smart_ptr2 &#123;\n    T* p;   // 不好: *p 的所有权含糊不清\n    // ...\npublic:\n    // ... 没有自定义的复制操作 ...\n    ~Smart_ptr2() &#123; delete p; &#125;  // p 是所有者！\n&#125;;\n\nvoid use(Smart_ptr2&lt;int&gt; p1)\n&#123;\n    auto p2 = p1;   // 错误: 双重删除\n&#125;\n</code></pre>\n<p>预置的复制操作仅仅把  <code>p1.p</code>  复制给了  <code>p2.p</code> ，这导致对  <code>p1.p</code>  进行双重销毁。请明确所有权的处理：</p>\n<pre><code>template&lt;typename T&gt;\nclass Smart_ptr3 &#123;\n    owner&lt;T*&gt; p;   // OK: 明确了 *p 的所有权\n    // ...\npublic:\n    // ...\n    // ... 复制和移动操作 ...\n    ~Smart_ptr3() &#123; delete p; &#125;\n&#125;;\n\nvoid use(Smart_ptr3&lt;int&gt; p1)\n&#123;\n    auto p2 = p1;   // OK: 未发生双重删除\n&#125;\n</code></pre>\n<h5 id=\"注解-115\"><a class=\"markdownIt-Anchor\" href=\"#注解-115\">#</a> 注解</h5>\n<p>通常最简单的处理析构函数的方式，就是把指针换成一个智能指针（比如  <code>std::unique_ptr</code> ），并让编译器来安排进行恰当的隐式销毁过程。</p>\n<h5 id=\"注解-116\"><a class=\"markdownIt-Anchor\" href=\"#注解-116\">#</a> 注解</h5>\n<p>为什么不直接要求全部带有所有权的指针都是 “智能指针” 呢？<br>\n这样做有时候需要进行不平凡的代码改动，并且可能会对 ABI 造成影响。</p>\n<h5 id=\"强制实施-85\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-85\">#</a> 强制实施</h5>\n<ul>\n<li>怀疑带有指针数据成员的类。</li>\n<li>带有  <code>owner&lt;T&gt;</code>  的类应当定义其默认操作。</li>\n</ul>\n<h3 id=\"a-namerc-dtor-virtualac35-基类的析构函数应当要么是-public-和-virtual要么是-protected-且非-virtual\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-dtor-virtualac35-基类的析构函数应当要么是-public-和-virtual要么是-protected-且非-virtual\">#</a> <a name=\"Rc-dtor-virtual\"></a>C.35: 基类的析构函数应当要么是 public 和 virtual，要么是 protected 且非 virtual</h3>\n<h5 id=\"理由-91\"><a class=\"markdownIt-Anchor\" href=\"#理由-91\">#</a> 理由</h5>\n<p>以防止未定义行为。<br>\n若析构函数是 public，调用方代码就可以尝试通过基类指针来销毁一个派生类的对象，而如果基类的析构函数是非 virtual，则其结果是未定义的。<br>\n若析构函数是 protected，调用方代码就无法通过基类指针进行销毁，而且这个析构函数不需要是 virtual；它应当是 protected 而不是 private，以便它能够在派生类析构函数中执行。<br>\n总之，基类的编写者并不知道什么是当进行销毁时要做的适当操作。</p>\n<h5 id=\"探讨\"><a class=\"markdownIt-Anchor\" href=\"#探讨\">#</a> 探讨</h5>\n<p>请参见<a href=\"#Sd-dtor\">这条规则</a>中的探讨段落.</p>\n<h5 id=\"示例不好-29\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-29\">#</a> 示例，不好</h5>\n<pre><code>struct Base &#123;  // 不好: 隐含带有 public 的非 virtual 析构函数\n    virtual void f();\n&#125;;\n\nstruct D : Base &#123;\n    string s &#123;&quot;a resource needing cleanup&quot;&#125;;\n    ~D() &#123; /* ... do some cleanup ... */ &#125;\n    // ...\n&#125;;\n\nvoid use()\n&#123;\n    unique_ptr&lt;Base&gt; p = make_unique&lt;D&gt;();\n    // ...\n&#125; // p 的销毁调用了 ~Base() 而不是 ~D()，这导致 D::s 的泄漏，也许不止\n</code></pre>\n<h5 id=\"注解-117\"><a class=\"markdownIt-Anchor\" href=\"#注解-117\">#</a> 注解</h5>\n<p>虚函数针对派生类定义了一个接口，使用它并不需要对派生类有所了解。<br>\n如果这个接口允许进行销毁，那么它应当安全地做到这点。</p>\n<h5 id=\"注解-118\"><a class=\"markdownIt-Anchor\" href=\"#注解-118\">#</a> 注解</h5>\n<p>析构函数必须是非私有的，否则它会妨碍使用这个类型：</p>\n<pre><code>class X &#123;\n    ~X();   // 私有析构函数\n    // ...\n&#125;;\n\nvoid use()\n&#123;\n    X a;                        // 错误: 无法销毁\n    auto p = make_unique&lt;X&gt;();  // 错误: 无法销毁\n&#125;\n</code></pre>\n<h5 id=\"例外-24\"><a class=\"markdownIt-Anchor\" href=\"#例外-24\">#</a> 例外</h5>\n<p>可以构想出一种可能需要受保护虚析构函数的情形：派生类型（且仅限于这种类型）的对象允许通过基类指针来销毁<em>另一个</em>对象（而不是其自身）。不过我们在实际中从未见到过这种情况。</p>\n<h5 id=\"强制实施-86\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-86\">#</a> 强制实施</h5>\n<ul>\n<li>带有任何虚函数的类的析构函数，应当要么是 public virtual，要么是 protected 且非 virtual。</li>\n<li>如果某个类公开继承于某个基类，则该基类应当具有要么是 public virtual，要么是 protected 且非 virtual 的析构函数。</li>\n</ul>\n<h3 id=\"a-namerc-dtor-failac36-析构函数不能失败\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-dtor-failac36-析构函数不能失败\">#</a> <a name=\"Rc-dtor-fail\"></a>C.36: 析构函数不能失败</h3>\n<h5 id=\"理由-92\"><a class=\"markdownIt-Anchor\" href=\"#理由-92\">#</a> 理由</h5>\n<p>一般来说当析构函数可能失败时我们不知道怎样写出没有错误的代码。<br>\n标准库要求它所处理的所有的类所带有的析构函数都应当不会因抛出异常而退出。</p>\n<h5 id=\"示例-90\"><a class=\"markdownIt-Anchor\" href=\"#示例-90\">#</a> 示例</h5>\n<pre><code>class X &#123;\npublic:\n    ~X() noexcept;\n    // ...\n&#125;;\n\nX::~X() noexcept\n&#123;\n    // ...\n    if (cannot_release_a_resource) terminate();\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"注解-119\"><a class=\"markdownIt-Anchor\" href=\"#注解-119\">#</a> 注解</h5>\n<p>许多人都曾试图针对析构函数中的故障处理设计一种傻瓜式的方案。<br>\n但没有人得到过任何一种通用方案。<br>\n这确实是真正的实际问题：比如说，怎么处理无法关闭的 socket？<br>\n析构函数的编写者无法了解析构函数为什么会被调用，并且不能通过抛出异常来 “拒绝执行”。<br>\n参见<a href=\"#Sd-never-fail\">探讨</a>段落。<br>\n让问题更麻烦的是，许多的 “关闭 / 释放” 操作还都是不能重试的。<br>\n如果确实可行的话，请把 “关闭 / 清理” 的失败作为一项基本设计错误并终止（terminate）程序。</p>\n<h5 id=\"注解-120\"><a class=\"markdownIt-Anchor\" href=\"#注解-120\">#</a> 注解</h5>\n<p>把析构函数声明为  <code>noexcept</code> 。这将确保它要么正常完成执行，要么就终止程序。</p>\n<h5 id=\"注解-121\"><a class=\"markdownIt-Anchor\" href=\"#注解-121\">#</a> 注解</h5>\n<p>如果一个资源无法释放而程序不能失败，请尝试把这个故障用某种方式通知给系统中的其他部分<br>\n（也许甚或修改某个全局状态，并希望有人能注意到它并有能力处理这个问题）。<br>\n请充分警惕，这种技巧是有专门用途的，并且容易出错。<br>\n请考虑 “连接关闭不了” 的那个例子。<br>\n这也许是因为连接的另一端出现了问题，但只有对连接的两端同时负责的代码才能恰当地处理这个问题。<br>\n析构函数可以向系统中负责管控的部分发送一个消息（或别的什么），然后认为已经关闭了连接并正常返回。</p>\n<h5 id=\"注解-122\"><a class=\"markdownIt-Anchor\" href=\"#注解-122\">#</a> 注解</h5>\n<p>如果析构函数所用的操作可能会失败的话，它可以捕获这些异常，某些时候仍然可以成功完成执行<br>\n（例如，换用与抛出异常的清理机制不同的另一种机制）。</p>\n<h5 id=\"强制实施-87\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-87\">#</a> 强制实施</h5>\n<p>【简单】 如果析构函数可能抛出异常，就应当将其声明为  <code>noexcept</code> 。</p>\n<h3 id=\"a-namerc-dtor-noexceptac37-使析构函数-noexcept\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-dtor-noexceptac37-使析构函数-noexcept\">#</a> <a name=\"Rc-dtor-noexcept\"></a>C.37: 使析构函数  <code>noexcept</code></h3>\n<h5 id=\"理由-93\"><a class=\"markdownIt-Anchor\" href=\"#理由-93\">#</a> 理由</h5>\n<p><a href=\"#Rc-dtor-fail\">析构函数不能失败</a>。如果析构函数试图抛出异常来退出，这就是一种设计错误，程序最好终止执行。</p>\n<h5 id=\"注解-123\"><a class=\"markdownIt-Anchor\" href=\"#注解-123\">#</a> 注解</h5>\n<p>当类中的所有成员都带有  <code>noexcept</code>  析构函数时，析构函数（无论是自定义的还是编译器生成的）将被隐含地声明为  <code>noexcept</code> （这与其函数体中的代码无关）。通过将析构函数明确标记为  <code>noexcept</code> ，程序员可以防止由于添加或修改类的成员而导致析构函数变为隐含的  <code>noexcept(false)</code> 。</p>\n<h5 id=\"示例-91\"><a class=\"markdownIt-Anchor\" href=\"#示例-91\">#</a> 示例</h5>\n<p>并非所有析构函数都默认为 noexcept; 一个抛出异常的成员会影响整个类的层级：</p>\n<pre><code>struct X &#123;\n    Details x;  // 碰巧有一个抛出析构函数\n    // ...\n    ~X() &#123; &#125;    // 隐含地 noexcept（false）; 也可以抛出异常\n&#125;;\n</code></pre>\n<p>所以，不确定的话，声明一个析构函数 noexcept.</p>\n<h5 id=\"注解-124\"><a class=\"markdownIt-Anchor\" href=\"#注解-124\">#</a> 注解</h5>\n<p>为什么对所有析构函数声明 noexcept？<br>\n因为在许多情况下，特别是简单的情况，会分散混乱。</p>\n<h5 id=\"强制实施-88\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-88\">#</a> 强制实施</h5>\n<p>【简单】 如果析构函数可能抛出异常，就应当将其声明为  <code>noexcept</code> 。</p>\n<h2 id=\"a-namess-ctoracctor-构造函数\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-ctoracctor-构造函数\">#</a> <a name=\"SS-ctor\"></a>C.ctor: 构造函数</h2>\n<p>构造函数定义对象如何进行初始化（构造）。</p>\n<h3 id=\"a-namerc-ctorac40-如果类具有不变式请为其定义构造函数\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-ctorac40-如果类具有不变式请为其定义构造函数\">#</a> <a name=\"Rc-ctor\"></a>C.40: 如果类具有不变式，请为其定义构造函数</h3>\n<h5 id=\"理由-94\"><a class=\"markdownIt-Anchor\" href=\"#理由-94\">#</a> 理由</h5>\n<p>这正是构造函数的用途。</p>\n<h5 id=\"示例-92\"><a class=\"markdownIt-Anchor\" href=\"#示例-92\">#</a> 示例</h5>\n<pre><code>class Date &#123;  // Date 表示从 1900/1/1 到 2100/12/31 范围中\n              // 的一个有效日期\n    Date(int dd, int mm, int yy)\n        :d&#123;dd&#125;, m&#123;mm&#125;, y&#123;yy&#125;\n    &#123;\n        if (!is_valid(d, m, y)) throw Bad_date&#123;&#125;;  // 不变式的实施\n    &#125;\n    // ...\nprivate:\n    int d, m, y;\n&#125;;\n</code></pre>\n<p>把不变式表达为构造函数上的一个  <code>Ensures</code>  通常是一种好做法。</p>\n<h5 id=\"注解-125\"><a class=\"markdownIt-Anchor\" href=\"#注解-125\">#</a> 注解</h5>\n<p>即便类并没有不变式，也可以用构造函数来简化代码。例如：</p>\n<pre><code>struct Rec &#123;\n    string s;\n    int i &#123;0&#125;;\n    Rec(const string&amp; ss) : s&#123;ss&#125; &#123;&#125;\n    Rec(int ii) :i&#123;ii&#125; &#123;&#125;\n&#125;;\n\nRec r1 &#123;7&#125;;\nRec r2 &#123;&quot;Foo bar&quot;&#125;;\n</code></pre>\n<h5 id=\"注解-126\"><a class=\"markdownIt-Anchor\" href=\"#注解-126\">#</a> 注解</h5>\n<p>C++11 的初始化式列表规则免除了对许多构造函数的需求。例如：</p>\n<pre><code>struct Rec2&#123;\n    string s;\n    int i;\n    Rec2(const string&amp; ss, int ii = 0) :s&#123;ss&#125;, i&#123;ii&#125; &#123;&#125;   // 多余的\n&#125;;\n\nRec2 r1 &#123;&quot;Foo&quot;, 7&#125;;\nRec2 r2 &#123;&quot;Bar&quot;&#125;;\n</code></pre>\n<p><code>Rec2</code>  的构造函数是多余的。<br>\n同样的， <code>int</code>  的默认值最好用<a href=\"#Rc-in-class-initializer\">成员初始化式</a>来给出。</p>\n<p><strong>参见</strong>: <a href=\"#Rc-complete\">构造有效对象</a>和<a href=\"#Rc-throw\">构造函数抛出异常</a>。</p>\n<h5 id=\"强制实施-89\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-89\">#</a> 强制实施</h5>\n<ul>\n<li>对带有自定义的复制操作但没有构造函数的类进行标记（自定义的复制操作是类是否带有不变式的良好指示器）</li>\n</ul>\n<h3 id=\"a-namerc-completeac41-构造函数应当创建经过完整初始化的对象\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-completeac41-构造函数应当创建经过完整初始化的对象\">#</a> <a name=\"Rc-complete\"></a>C.41: 构造函数应当创建经过完整初始化的对象</h3>\n<h5 id=\"理由-95\"><a class=\"markdownIt-Anchor\" href=\"#理由-95\">#</a> 理由</h5>\n<p>构造函数为类设立不变式。类的使用者应当能够假定构造完成的对象是可以使用的。</p>\n<h5 id=\"示例不好-30\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-30\">#</a> 示例，不好</h5>\n<pre><code>class X1 &#123;\n    FILE* f;   // 在任何其他函数之前应当调用 init()\n    // ...\npublic:\n    X1() &#123;&#125;\n    void init();   // 初始化 f\n    void read();   // 从 f 中读取数据\n    // ...\n&#125;;\n\nvoid f()\n&#123;\n    X1 file;\n    file.read();   // 程序崩溃或者错误的数据读取！\n    // ...\n    file.init();   // 太晚了\n    // ...\n&#125;\n</code></pre>\n<p>编译器读不懂代码注释。</p>\n<h5 id=\"例外-25\"><a class=\"markdownIt-Anchor\" href=\"#例外-25\">#</a> 例外</h5>\n<p>如果无法方便地通过构造函数来构造有效的对象的话，请<a href=\"#Rc-factory\">使用工厂函数</a>。</p>\n<h5 id=\"强制实施-90\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-90\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】 每个构造函数都应当对每个成员变量进行初始化（明确地，通过委派构造函数调用，或者通过默认构造）。</li>\n<li>【未知】 如果构造函数带有  <code>Ensures</code>  契约的话，尝试确定它给出的是否是一项后条件。</li>\n</ul>\n<h5 id=\"注解-127\"><a class=\"markdownIt-Anchor\" href=\"#注解-127\">#</a> 注解</h5>\n<p>如果构造函数（为创建有效的对象）获取了某个资源，则这个资源应当<a href=\"#Rc-dtor-release\">由析构函数释放</a>。<br>\n这种以构造函数获取资源并以析构函数来释放的惯用法被称为 <a href=\"#Rr-raii\">RAII</a>（“资源获取即初始化 / Resource Acquisition Is Initialization”）。</p>\n<h3 id=\"a-namerc-throwac42-当构造函数无法构造有效对象时应当抛出异常\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-throwac42-当构造函数无法构造有效对象时应当抛出异常\">#</a> <a name=\"Rc-throw\"></a>C.42: 当构造函数无法构造有效对象时，应当抛出异常</h3>\n<h5 id=\"理由-96\"><a class=\"markdownIt-Anchor\" href=\"#理由-96\">#</a> 理由</h5>\n<p>留下无效对象不管就是会造成麻烦的做法。</p>\n<h5 id=\"示例-93\"><a class=\"markdownIt-Anchor\" href=\"#示例-93\">#</a> 示例</h5>\n<pre><code>class X2 &#123;\n    FILE* f;\n    // ...\npublic:\n    X2(const string&amp; name)\n        :f&#123;fopen(name.c_str(), &quot;r&quot;)&#125;\n    &#123;\n        if (!f) throw runtime_error&#123;&quot;could not open&quot; + name&#125;;\n        // ...\n    &#125;\n\n    void read();      // 从 f 中读取数据\n    // ...\n&#125;;\n\nvoid f()\n&#123;\n    X2 file &#123;&quot;Zeno&quot;&#125;; // 当文件打不开时会抛出异常\n    file.read();      // 好的\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"示例不好-31\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-31\">#</a> 示例，不好</h5>\n<pre><code>class X3 &#123;     // 不好: 构造函数留下了无效的对象\n    FILE* f;   // 在任何其他函数之前应当调用 is_valid()\n    bool valid;\n    // ...\npublic:\n    X3(const string&amp; name)\n        :f&#123;fopen(name.c_str(), &quot;r&quot;)&#125;, valid&#123;false&#125;\n    &#123;\n        if (f) valid = true;\n        // ...\n    &#125;\n\n    bool is_valid() &#123; return valid; &#125;\n    void read();   // 从 f 中读取数据\n    // ...\n&#125;;\n\nvoid f()\n&#123;\n    X3 file &#123;&quot;Heraclides&quot;&#125;;\n    file.read();   // 程序崩溃或错误的数据读取！\n    // ...\n    if (file.is_valid()) &#123;\n        file.read();\n        // ...\n    &#125;\n    else &#123;\n        // ... 处理错误 ...\n    &#125;\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"注解-128\"><a class=\"markdownIt-Anchor\" href=\"#注解-128\">#</a> 注解</h5>\n<p>对于变量的定义式（比如在栈上，或者作为其他对象的成员），不存在可以返回错误代码的明确函数调用。<br>\n留下无效的对象并依赖使用者能够一贯地在使用之前检查  <code>is_valid()</code>  函数是啰嗦的，易错的，并且是低效的做法。</p>\n<h5 id=\"例外-26\"><a class=\"markdownIt-Anchor\" href=\"#例外-26\">#</a> 例外</h5>\n<p>有些领域，比如像飞行器控制这样的硬实时系统中，（在没有其他工具支持下）异常处理在计时方面不具有足够的可预测性。<br>\n这样的话就必须使用  <code>is_valid()</code>  技巧。这种情况下，可以一贯并即刻地检查  <code>is_valid()</code>  来模拟 <a href=\"#Rr-raii\">RAII</a>。</p>\n<h5 id=\"替代方案-7\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-7\">#</a> 替代方案</h5>\n<p>如果你觉得想要使用某种 “构造函数之后初始化” 或者 “两阶段初始化” 手法，请试着避免这样做。<br>\n如果你确实要如此的话，请参考<a href=\"#Rc-factory\">工厂函数</a>。</p>\n<h5 id=\"注解-129\"><a class=\"markdownIt-Anchor\" href=\"#注解-129\">#</a> 注解</h5>\n<p>人们使用  <code>init()</code>  函数而不是在构造函数中进行初始化的一种原因是为了避免代码重复。<br>\n<a href=\"#Rc-delegating\">委派构造函数</a>和<a href=\"#Rc-in-class-initializer\">默认成员初始化式</a>可以更好地做到这点。<br>\n另一种原因是为了把初始化推迟到需要对象的位置；它的解决方法通常为 “<a href=\"#Res-init\">直到变量可以正确进行初始化的位置再声明变量</a>”。</p>\n<h5 id=\"强制实施-91\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-91\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerc-default0ac43-保证可复制类带有默认构造函数\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-default0ac43-保证可复制类带有默认构造函数\">#</a> <a name=\"Rc-default0\"></a>C.43: 保证可复制类带有默认构造函数</h3>\n<h5 id=\"理由-97\"><a class=\"markdownIt-Anchor\" href=\"#理由-97\">#</a> 理由</h5>\n<p>就是说，确保当具体类可复制时它也满足 “半正规” 类型的其他规定。</p>\n<p>许多的语言和程序库设施都依赖于默认构造函数来初始化其各个元素，比如  <code>T a[10]</code>  和  <code>std::vector&lt;T&gt; v(10)</code> 。<br>\n对于同时是可复制的类型来说，默认构造函数通常会简化定义一个适当的<a href=\"#???\">移动遗留状态</a>的任务。</p>\n<h5 id=\"示例-94\"><a class=\"markdownIt-Anchor\" href=\"#示例-94\">#</a> 示例</h5>\n<pre><code>class Date &#123; // 不好: 缺少默认构造函数\npublic:\n    Date(int dd, int mm, int yyyy);\n    // ...\n&#125;;\n\nvector&lt;Date&gt; vd1(1000);   // 需要默认的 Date\nvector&lt;Date&gt; vd2(1000, Date&#123;7, Month::October, 1885&#125;);   // 替代方式\n</code></pre>\n<p>仅当没有用户声明的构造函数时，默认构造函数才会自动生成，因此上面的例子中的 vector  <code>vdl</code>  是无法进行初始化的。<br>\n缺乏默认值会导致用户感觉奇怪，并且使其使用变复杂，因此如果可以合理定义的话就应当定义默认值。</p>\n<p><code>Date</code>  可以推动我们考虑：<br>\n“天然的” 默认日期是不存在的（大爆炸对大多数人来说在时间上太过久远了），因此这并非是毫无意义的例子。<br>\n <code>&#123;0, 0, 0&#125;</code>  在大多数历法系统中都不是有效的日期，因此选用它可能会引入某种如同浮点的  <code>NaN</code>  这样的东西。<br>\n不过，大多数现实的  <code>Date</code>  类都有某个 “首日”（比如很常见的 1970/1/1），因此以它为默认日期通常很容易做到。</p>\n<pre><code>class Date &#123;\npublic:\n    Date(int dd, int mm, int yyyy);\n    Date() = default; // [参见](#Rc-default)\n    // ...\nprivate:\n    int dd &#123;1&#125;;\n    int mm &#123;1&#125;;\n    int yyyy &#123;1970&#125;;\n    // ...\n&#125;;\n\nvector&lt;Date&gt; vd1(1000);\n</code></pre>\n<h5 id=\"注解-130\"><a class=\"markdownIt-Anchor\" href=\"#注解-130\">#</a> 注解</h5>\n<p>所有成员都带有默认构造函数的类，隐含得到一个默认构造函数：</p>\n<pre><code>struct X &#123;\n    string s;\n    vector&lt;int&gt; v;\n&#125;;\n\nX x; // 意为 X&#123;&#123; \"&#123;&#123;\" &#125;&#125;&#125;, &#123;&#125;&#125;; 即空字符串和空 vector\n</code></pre>\n<p>需要注意的是，内建类型并不会进行正确的默认构造：</p>\n<pre><code>struct X &#123;\n    string s;\n    int i;\n&#125;;\n\nvoid f()\n&#123;\n    X x;    // x.s 被初始化为空字符串; x.i 未初始化\n\n    cout &lt;&lt; x.s &lt;&lt; ' ' &lt;&lt; x.i &lt;&lt; '\\n';\n    ++x.i;\n&#125;\n</code></pre>\n<p>静态分配的内建类型对象被默认初始化为  <code>0</code> ，但局部的内建变量并非如此。<br>\n请注意你的编译期也许默认初始化了局部内建变量，而它在优化构建中并不会这样做。<br>\n因此，上例这样的代码也许恰好可以工作，但这其实依赖于未定义的行为。<br>\n假定你确实需要初始化的话，可以使用明确的默认初始化：</p>\n<pre><code>struct X &#123;\n    string s;\n    int i &#123;&#125;;   // 默认初始化（为 0）\n&#125;;\n</code></pre>\n<h5 id=\"注解-131\"><a class=\"markdownIt-Anchor\" href=\"#注解-131\">#</a> 注解</h5>\n<p>缺乏合理的默认构造的类，通常也都不是可以复制的，因此它们并不受本条指导方针所限。</p>\n<p>例如，基类不能进行复制，且因而并不需要一个默认构造函数：</p>\n<pre><code>// Shape 是个抽象基类，而不是可复制类型\n// 它可以有也可以没有默认构造函数。\nstruct Shape &#123;\n    virtual void draw() = 0;\n    virtual void rotate(int) = 0;\n    // =delete 复制/移动函数\n    // ...\n&#125;;\n</code></pre>\n<p>必须在构造过程中获取由调用方提供的资源的类，通常无法提供默认构造函数，但它们并不受本条指导方针所限，因为这样的类通常也不是可复制的：</p>\n<pre><code>// std::lock_guard 不是可复制类型。\n// 它没有默认构造函数。\nlock_guard g &#123;mx&#125;;  // 护卫 mutex mx\nlock_guard g2;      // 错误：不护卫任何东西\n</code></pre>\n<p>带有必须由其成员函数或者其用户进行特殊处理的 “特殊状态” 的类，会带来额外的工作量，<br>\n（而且很可能有更多的错误）。这样的类型不管其是否可以复制，都可以以这个特殊状态作为其默认构造的值：</p>\n<pre><code>// std::ofstream 不是可复制类型。\n// 它刚好有一个默认构造函数，\n// 并带来一种特殊的“未打开”状态。\nofstream out &#123;&quot;Foobar&quot;&#125;;\n// ...\nout &lt;&lt; log(time, transaction);\n</code></pre>\n<p>一些类似的可复制的具有特殊状态的类型，比如具有特殊状态 “==nullptr” 的可复制的智能指针，也应该以该特殊状态作为其默认构造的值。</p>\n<p>不过，为有意义的状态提供默认构造函数（比如  <code>std::string</code>  的  <code>&quot;&quot;</code>  和  <code>std::vector</code>  的  <code>&#123;&#125;</code> ），也是推荐的做法。</p>\n<h5 id=\"强制实施-92\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-92\">#</a> 强制实施</h5>\n<ul>\n<li>对于可用  <code>=</code>  进行复制的类，若没有默认构造函数则对其进行标记。</li>\n<li>对于可用  <code>==</code>  进行比较但不可复制的类进行标记。</li>\n</ul>\n<h3 id=\"a-namerc-default00ac44-尽量让默认构造函数简单且不抛出异常\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-default00ac44-尽量让默认构造函数简单且不抛出异常\">#</a> <a name=\"Rc-default00\"></a>C.44: 尽量让默认构造函数简单且不抛出异常</h3>\n<h5 id=\"理由-98\"><a class=\"markdownIt-Anchor\" href=\"#理由-98\">#</a> 理由</h5>\n<p>如果可以设置一个 “默认” 值同时又不会涉及可能失败的操作的话，就可以简化错误处理以及对移动操作的推理。</p>\n<h5 id=\"示例有问题的\"><a class=\"markdownIt-Anchor\" href=\"#示例有问题的\">#</a> 示例，有问题的</h5>\n<pre><code>template&lt;typename T&gt;\n// elem 指向以 new 分配的 space-elem 个元素\nclass Vector0 &#123;\npublic:\n    Vector0() :Vector0&#123;0&#125; &#123;&#125;\n    Vector0(int n) :elem&#123;new T[n]&#125;, space&#123;elem + n&#125;, last&#123;elem&#125; &#123;&#125;\n    // ...\nprivate:\n    own&lt;T*&gt; elem;\n    T* space;\n    T* last;\n&#125;;\n</code></pre>\n<p>这段代码很不错而且通用，不过在发生错误之后把一个  <code>Vector0</code>  进行置空会涉及一次分配，而它是可能失败的。<br>\n而且把默认的  <code>Vector</code>  表示为  <code>&#123;new T[0], 0, 0&#125;</code>  也比较浪费。<br>\n比如说， <code>Vector0&lt;int&gt; v[100]</code>  会耗费 100 次分配操作。</p>\n<h5 id=\"示例-95\"><a class=\"markdownIt-Anchor\" href=\"#示例-95\">#</a> 示例</h5>\n<pre><code>template&lt;typename T&gt;\n// elem 为 nullptr，否则 elem 指向以 new 分配的 space-elem 个元素\nclass Vector1 &#123;\npublic:\n    // 设置表示为 &#123;nullptr, nullptr, nullptr&#125;; 不会抛出异常\n    Vector1() noexcept &#123;&#125;\n    Vector1(int n) :elem&#123;new T[n]&#125;, space&#123;elem + n&#125;, last&#123;elem&#125; &#123;&#125;\n    // ...\nprivate:\n    own&lt;T*&gt; elem &#123;&#125;;\n    T* space &#123;&#125;;\n    T* last &#123;&#125;;\n&#125;;\n</code></pre>\n<p>表示为  <code>&#123;nullptr, nullptr, nullptr&#125;</code>  的  <code>Vector1&#123;&#125;</code>  很廉价，但这是一种特殊情况并且隐含了运行时检查。<br>\n在检测到错误后可以很容易地把  <code>Vector1</code>  置空。</p>\n<h5 id=\"强制实施-93\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-93\">#</a> 强制实施</h5>\n<ul>\n<li>标记会抛出的默认构造函数</li>\n</ul>\n<h3 id=\"a-namerc-defaultac45-不要定义仅对数据成员进行初始化的默认构造函数应当使用成员初始化式\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-defaultac45-不要定义仅对数据成员进行初始化的默认构造函数应当使用成员初始化式\">#</a> <a name=\"Rc-default\"></a>C.45: 不要定义仅对数据成员进行初始化的默认构造函数；应当使用成员初始化式</h3>\n<h5 id=\"理由-99\"><a class=\"markdownIt-Anchor\" href=\"#理由-99\">#</a> 理由</h5>\n<p>使用类内部的成员初始化式，编译器可以据此生成函数。由编译器生成的函数可能更高效。</p>\n<h5 id=\"示例不好-32\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-32\">#</a> 示例，不好</h5>\n<pre><code>class X1 &#123; // 不好: 未使用成员初始化式\n    string s;\n    int i;\npublic:\n    X1() :s&#123;&quot;default&quot;&#125;, i&#123;1&#125; &#123; &#125;\n    // ...\n&#125;;\n</code></pre>\n<h5 id=\"示例-96\"><a class=\"markdownIt-Anchor\" href=\"#示例-96\">#</a> 示例</h5>\n<pre><code>class X2 &#123;\n    string s &#123;&quot;default&quot;&#125;;\n    int i &#123;1&#125;;\npublic:\n    // 使用编译期生成的默认构造函数\n    // ...\n&#125;;\n</code></pre>\n<h5 id=\"强制实施-94\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-94\">#</a> 强制实施</h5>\n<p>【简单】 默认构造函数应当不只是用常量初始化成员变量。</p>\n<h3 id=\"a-namerc-explicitac46-默认情况下把单参数的构造函数声明为-explicit\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-explicitac46-默认情况下把单参数的构造函数声明为-explicit\">#</a> <a name=\"Rc-explicit\"></a>C.46: 默认情况下，把单参数的构造函数声明为  <code>explicit</code></h3>\n<h5 id=\"理由-100\"><a class=\"markdownIt-Anchor\" href=\"#理由-100\">#</a> 理由</h5>\n<p>用以避免意外的类型转换。</p>\n<h5 id=\"示例不好-33\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-33\">#</a> 示例，不好</h5>\n<pre><code>class String &#123;\npublic:\n    String(int);   // 不好\n    // ...\n&#125;;\n\nString s = 10;   // 意外: 大小为 10 的字符串\n</code></pre>\n<h5 id=\"例外-27\"><a class=\"markdownIt-Anchor\" href=\"#例外-27\">#</a> 例外</h5>\n<p>如果确实想要从构造函数参数类型隐式转换为类类型的话，就不使用  <code>explicit</code> ：</p>\n<pre><code>class Complex &#123;\npublic:\n    Complex(double d);   // OK: 希望进行从 d 向 &#123;d, 0&#125; 的转换\n    // ...\n&#125;;\n\nComplex z = 10.7;   // 无意外的转换\n</code></pre>\n<p><strong>参见</strong>: <a href=\"#Ro-conversion\">有关隐式转换的讨论</a></p>\n<h5 id=\"注解-132\"><a class=\"markdownIt-Anchor\" href=\"#注解-132\">#</a> 注解</h5>\n<p>不应当将复制和移动构造函数作为  <code>explicit</code>  的，因为它们并不进行转换。显式的复制 / 移动构造函数会把按值传递和返回变麻烦。</p>\n<h5 id=\"强制实施-95\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-95\">#</a> 强制实施</h5>\n<p>【简单】 单参数的构造函数应当声明为  <code>explicit</code> 。有益的单参数非  <code>explicit</code>  构造函数在大多数代码库中都是很少见的。对没在 “已确认列表” 中列出的每个违规都要给出警告。</p>\n<h3 id=\"a-namerc-orderac47-按成员声明的顺序对成员变量进行定义和初始化\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-orderac47-按成员声明的顺序对成员变量进行定义和初始化\">#</a> <a name=\"Rc-order\"></a>C.47: 按成员声明的顺序对成员变量进行定义和初始化</h3>\n<h5 id=\"理由-101\"><a class=\"markdownIt-Anchor\" href=\"#理由-101\">#</a> 理由</h5>\n<p>以尽量避免混淆和错误。该顺序正是初始化的发生顺序（而这与成员初始化式的顺序无关）。</p>\n<h5 id=\"示例不好-34\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-34\">#</a> 示例，不好</h5>\n<pre><code>class Foo &#123;\n    int m1;\n    int m2;\npublic:\n    Foo(int x) :m2&#123;x&#125;, m1&#123;++x&#125; &#123; &#125;   // 不好: 有误导性的初始化式顺序\n    // ...\n&#125;;\n\nFoo x(1); // 意外: x.m1 == x.m2 == 2\n</code></pre>\n<h5 id=\"强制实施-96\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-96\">#</a> 强制实施</h5>\n<p>【简单】 成员初始化式的列表中应当以成员声明的相同顺序列出各个成员。</p>\n<p><strong>参见</strong>: <a href=\"#Sd-order\">讨论</a></p>\n<h3 id=\"a-namerc-in-class-initializerac48-对于常量初始化式来说优先采用类中的初始化式而不是构造函数中的成员初始化式\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-in-class-initializerac48-对于常量初始化式来说优先采用类中的初始化式而不是构造函数中的成员初始化式\">#</a> <a name=\"Rc-in-class-initializer\"></a>C.48: 对于常量初始化式来说，优先采用类中的初始化式而不是构造函数中的成员初始化式</h3>\n<h5 id=\"理由-102\"><a class=\"markdownIt-Anchor\" href=\"#理由-102\">#</a> 理由</h5>\n<p>明确所有构造函数都将使用相同的值。避免重复。避免可维护性问题。这样做会产生最简短最高效的代码。</p>\n<h5 id=\"示例不好-35\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-35\">#</a> 示例，不好</h5>\n<pre><code>class X &#123;   // 不好\n    int i;\n    string s;\n    int j;\npublic:\n    X() :i&#123;666&#125;, s&#123;&quot;qqq&quot;&#125; &#123; &#125;   // j 未初始化\n    X(int ii) :i&#123;ii&#125; &#123;&#125;         // s 为 &quot;&quot; 而 j 未初始化\n    // ...\n&#125;;\n</code></pre>\n<p>维护者如何能看出  <code>j</code>  是否是故意未初始化的（尽管这可能是个糟糕的想法），而且是不是故意要使  <code>s</code>  的默认值在一种情况下为  <code>&quot;&quot;</code>  而另一种情况下为  <code>qqq</code>  呢（几乎可以肯定是个 Bug）？这里  <code>j</code>  的问题（忘记对成员初始化）通常会出现在向现存类中添加新成员的时候。</p>\n<h5 id=\"示例-97\"><a class=\"markdownIt-Anchor\" href=\"#示例-97\">#</a> 示例</h5>\n<pre><code>class X2 &#123;\n    int i &#123;666&#125;;\n    string s &#123;&quot;qqq&quot;&#125;;\n    int j &#123;0&#125;;\npublic:\n    X2() = default;        // 所有成员都初始化为默认值\n    X2(int ii) :i&#123;ii&#125; &#123;&#125;   // s 和 j 被初始化为默认值\n    // ...\n&#125;;\n</code></pre>\n<p><strong>替代方案</strong>：也可以用构造函数的默认实参来获得一部分的好处，而且这在比较老的代码中也并不少见。不过这种方式不够直白，会导致需要传递较多的参数，并且当有多个构造函数时也会造成重复：</p>\n<pre><code>class X3 &#123;   // 不好: 不明确，参数传递开销\n    int i;\n    string s;\n    int j;\npublic:\n    X3(int ii = 666, const string&amp; ss = &quot;qqq&quot;, int jj = 0)\n        :i&#123;ii&#125;, s&#123;ss&#125;, j&#123;jj&#125; &#123; &#125;   // 所有成员都初始化为默认值\n    // ...\n&#125;;\n</code></pre>\n<h5 id=\"强制实施-97\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-97\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】 每个构造函数都应该对所有成员变量进行初始化（明确进行，通过委派构造函数调用，或者通过默认构造）。</li>\n<li>【简单】 构造函数的默认实参的出现表明类内部的初始化式可能更合适。</li>\n</ul>\n<h3 id=\"a-namerc-initializeac49-优先进行初始化而不是在构造函数中赋值\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-initializeac49-优先进行初始化而不是在构造函数中赋值\">#</a> <a name=\"Rc-initialize\"></a>C.49: 优先进行初始化而不是在构造函数中赋值</h3>\n<h5 id=\"理由-103\"><a class=\"markdownIt-Anchor\" href=\"#理由-103\">#</a> 理由</h5>\n<p>初始化语法明确指出所进行的是初始化而不是赋值，它更加精炼和高效。这样也避免了 “未设值前就使用” 的错误。</p>\n<h5 id=\"示例好-8\"><a class=\"markdownIt-Anchor\" href=\"#示例好-8\">#</a> 示例，好</h5>\n<pre><code>class A &#123;   // 好\n    string s1;\npublic:\n    A(czstring p) : s1&#123;p&#125; &#123; &#125;    // 好: 直接构造（这里明确指名了 C 风格字符串）\n    // ...\n&#125;;\n</code></pre>\n<h5 id=\"示例不好-36\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-36\">#</a> 示例，不好</h5>\n<pre><code>class B &#123;   // 不好\n    string s1;\npublic:\n    B(const char* p) &#123; s1 = p; &#125;   // 不好: 执行默认构造函数之后进行赋值\n    // ...\n&#125;;\n\nclass C &#123;   // 恶劣，非常不好\n    int* p;\npublic:\n    C() &#123; cout &lt;&lt; *p; p = new int&#123;10&#125;; &#125;   // 意外，初始化前就被使用了\n    // ...\n&#125;;\n</code></pre>\n<h5 id=\"示例更好的做法\"><a class=\"markdownIt-Anchor\" href=\"#示例更好的做法\">#</a> 示例，更好的做法</h5>\n<p>可以使用 C++17 的  <code>std::string_view</code>  或  <code>gsl::span&lt;char&gt;</code>  代替这些  <code>const char*</code> <br>\n 来作为<a href=\"#Rstr-view\">一种表示函数实参的更通用的方式</a>：</p>\n<pre><code>class D &#123;   // 好\n    string s1;\npublic:\n    D(string_view v) : s1&#123;v&#125; &#123; &#125;    // 好: 直接构造\n    // ...\n&#125;;\n</code></pre>\n<h3 id=\"a-namerc-factoryac50-当初始化过程中需要体现虚函数行为时请使用工厂函数\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-factoryac50-当初始化过程中需要体现虚函数行为时请使用工厂函数\">#</a> <a name=\"Rc-factory\"></a>C.50: 当初始化过程中需要体现 “虚函数行为” 时，请使用工厂函数</h3>\n<h5 id=\"理由-104\"><a class=\"markdownIt-Anchor\" href=\"#理由-104\">#</a> 理由</h5>\n<p>当基类对象的状态必须依赖于对象的派生部分的状态时，需要使用虚函数（或等价手段），并最小化造成误用和不完全构造的对象的机会窗口。</p>\n<h5 id=\"注解-133\"><a class=\"markdownIt-Anchor\" href=\"#注解-133\">#</a> 注解</h5>\n<p>工厂的返回类型默认情况下通常应当为  <code>unique_ptr</code> ；如果某些用法需要共享，则调用方可以将这个  <code>unique_ptr</code>   <code>move</code>  到一个  <code>shared_ptr</code>  中。但是，如果工厂的作者已知其所返回的对象的所有用法都是共享使用的话，就可返回  <code>shared_ptr</code> ，并在函数体中使用  <code>make_shared</code>  以节省一次分配。</p>\n<h5 id=\"示例不好-37\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-37\">#</a> 示例，不好</h5>\n<pre><code>class B &#123;\npublic:\n    B()\n    &#123;\n        /* ... */\n        f(); // 不好: C.82：不要在构造函数和析构函数中调用虚函数\n        /* ... */\n    &#125;\n\n    virtual void f() = 0;\n&#125;;\n</code></pre>\n<h5 id=\"示例-98\"><a class=\"markdownIt-Anchor\" href=\"#示例-98\">#</a> 示例</h5>\n<pre><code>class B &#123;\nprotected:\n    class Token &#123;&#125;;\n\npublic:\n    explicit B(Token) &#123; /* ... */ &#125;  // 创建不完全初始化的对象\n    virtual void f() = 0;\n\n    template&lt;class T&gt;\n    static shared_ptr&lt;T&gt; create()    // 创建共享对象的接口\n    &#123;\n        auto p = make_shared&lt;T&gt;(typename T::Token&#123;&#125;);\n        p-&gt;post_initialize();\n        return p;\n    &#125;\n\nprotected:\n    virtual void post_initialize()   // 构造之后立即调用\n        &#123; /* ... */ f(); /* ... */ &#125; // 好: 虚函数分派是安全的\n&#125;;\n\nclass D : public B &#123;                 // 某个派生类\nprotected:\n    class Token &#123;&#125;;\n\npublic:\n    explicit D(Token) : B( B::Token&#123;&#125; ) &#123;&#125;\n    void f() override &#123; /* ... */ &#125;;\n\nprotected:\n    template&lt;class T&gt;\n    friend shared_ptr&lt;T&gt; B::create();\n&#125;;\n\nshared_ptr&lt;D&gt; p = D::create&lt;D&gt;();  // 创建一个 D 的对象\n</code></pre>\n<p><code>make_shared</code>  要求公开的构造函数。构造函数通过要求一个受保护的  <code>Token</code>  而无法再被公开调用，从而避免不完全构造的对象泄漏出去。<br>\n通过提供工厂函数  <code>create()</code> ，（在自由存储上）构造对象变得简便。</p>\n<h5 id=\"注解-134\"><a class=\"markdownIt-Anchor\" href=\"#注解-134\">#</a> 注解</h5>\n<p>根据惯例，工厂方法在自由存储上进行分配，而不是在运行栈或者某个外围对象之内进行。</p>\n<p><strong>参见</strong>: <a href=\"#Sd-factory\">讨论</a></p>\n<h3 id=\"a-namerc-delegatingac51-用委派构造函数来表示类中所有构造函数的共同行为\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-delegatingac51-用委派构造函数来表示类中所有构造函数的共同行为\">#</a> <a name=\"Rc-delegating\"></a>C.51: 用委派构造函数来表示类中所有构造函数的共同行为</h3>\n<h5 id=\"理由-105\"><a class=\"markdownIt-Anchor\" href=\"#理由-105\">#</a> 理由</h5>\n<p>以避免代码重复和意外出现的差异。</p>\n<h5 id=\"示例不好-38\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-38\">#</a> 示例，不好</h5>\n<pre><code>class Date &#123;   // 不好: 有重复\n    int d;\n    Month m;\n    int y;\npublic:\n    Date(int dd, Month mm, year yy)\n        :d&#123;dd&#125;, m&#123;mm&#125;, y&#123;yy&#125;\n        &#123; if (!valid(d, m, y)) throw Bad_date&#123;&#125;; &#125;\n\n    Date(int dd, Month mm)\n        :d&#123;dd&#125;, m&#123;mm&#125; y&#123;current_year()&#125;\n        &#123; if (!valid(d, m, y)) throw Bad_date&#123;&#125;; &#125;\n    // ...\n&#125;;\n</code></pre>\n<p>写这些共同行为很啰嗦，而且可能意外出现不一致。</p>\n<h5 id=\"示例-99\"><a class=\"markdownIt-Anchor\" href=\"#示例-99\">#</a> 示例</h5>\n<pre><code>class Date2 &#123;\n    int d;\n    Month m;\n    int y;\npublic:\n    Date2(int dd, Month mm, year yy)\n        :d&#123;dd&#125;, m&#123;mm&#125; y&#123;yy&#125;\n        &#123; if (!valid(d, m, y)) throw Bad_date&#123;&#125;; &#125;\n\n    Date2(int dd, Month mm)\n        :Date2&#123;dd, mm, current_year()&#125; &#123;&#125;\n    // ...\n&#125;;\n</code></pre>\n<p><strong>参见</strong>：当 “重复行为” 是简单的初始化时，考虑使用<a href=\"#Rc-in-class-initializer\">类内部的成员初始化式</a>。</p>\n<h5 id=\"强制实施-98\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-98\">#</a> 强制实施</h5>\n<p>【中等】 查找相似的构造函数体。</p>\n<h3 id=\"a-namerc-inheritingac52-使用继承构造函数来把构造函数引入到无须进行其他的明确初始化操作的派生类之中\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-inheritingac52-使用继承构造函数来把构造函数引入到无须进行其他的明确初始化操作的派生类之中\">#</a> <a name=\"Rc-inheriting\"></a>C.52: 使用继承构造函数来把构造函数引入到无须进行其他的明确初始化操作的派生类之中</h3>\n<h5 id=\"理由-106\"><a class=\"markdownIt-Anchor\" href=\"#理由-106\">#</a> 理由</h5>\n<p>当派生类需要这些构造函数时，重新实现它们既啰嗦又容易出错。</p>\n<h5 id=\"示例-100\"><a class=\"markdownIt-Anchor\" href=\"#示例-100\">#</a> 示例</h5>\n<p><code>std::vector</code>  有许多棘手的构造函数，如果我想要创建自己的  <code>vector</code>  的话，我并不想重新实现它们：</p>\n<pre><code>class Rec &#123;\n    // ... 数据，以及许多不错的构造函数 ...\n&#125;;\n\nclass Oper : public Rec &#123;\n    using Rec::Rec;\n    // ... 没有数据成员 ...\n    // ... 许多不错的工具函数 ...\n&#125;;\n</code></pre>\n<h5 id=\"示例不好-39\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-39\">#</a> 示例，不好</h5>\n<pre><code>struct Rec2 : public Rec &#123;\n    int x;\n    using Rec::Rec;\n&#125;;\n\nRec2 r &#123;&quot;foo&quot;, 7&#125;;\nint val = r.x;   // 未初始化\n</code></pre>\n<h5 id=\"强制实施-99\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-99\">#</a> 强制实施</h5>\n<p>确保派生类的每个成员都被初始化。</p>\n<h2 id=\"a-namess-copyaccopy-复制和移动\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-copyaccopy-复制和移动\">#</a> <a name=\"SS-copy\"></a>C.copy: 复制和移动</h2>\n<p>具体类型一般都应当是可以复制的，而类层次中的接口则不应如此。<br>\n资源包装可以复制也可以不能复制。<br>\n我们可以基于逻辑因素，也可以为性能原因而将类型定义为可移动的。</p>\n<h3 id=\"a-namerc-copy-assignmentac60-使复制赋值非-virtual接受-const-的参数并返回非-const-的引用\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-copy-assignmentac60-使复制赋值非-virtual接受-const-的参数并返回非-const-的引用\">#</a> <a name=\"Rc-copy-assignment\"></a>C.60: 使复制赋值非  <code>virtual</code> ，接受  <code>const&amp;</code>  的参数，并返回非  <code>const</code>  的引用</h3>\n<h5 id=\"理由-107\"><a class=\"markdownIt-Anchor\" href=\"#理由-107\">#</a> 理由</h5>\n<p>这样做简单且高效。如果想对右值进行优化，则可以提供一个接受  <code>&amp;&amp;</code>  的重载（参见 <a href=\"#Rf-consume\">F.18</a>）。</p>\n<h5 id=\"示例-101\"><a class=\"markdownIt-Anchor\" href=\"#示例-101\">#</a> 示例</h5>\n<pre><code>class Foo &#123;\npublic:\n    Foo&amp; operator=(const Foo&amp; x)\n    &#123;\n        // 好: 不需要检查自赋值的情况（除非为性能考虑）\n        auto tmp = x;\n        swap(tmp); // 参见 C.83\n        return *this;\n    &#125;\n    // ...\n&#125;;\n\nFoo a;\nFoo b;\nFoo f();\n\na = b;    // 用左值赋值：复制\na = f();  // 用右值赋值：可能进行移动\n</code></pre>\n<h5 id=\"注解-135\"><a class=\"markdownIt-Anchor\" href=\"#注解-135\">#</a> 注解</h5>\n<p><code>swap</code>  实现技巧可以提供<a href=\"#Abrahams01\">强保证</a>。</p>\n<h5 id=\"示例-102\"><a class=\"markdownIt-Anchor\" href=\"#示例-102\">#</a> 示例</h5>\n<p>如果不产生临时副本能够得到明显好得多的性能的话应当怎么办呢？考虑一个简单的  <code>Vector</code>  类，其所使用的领域中常常要对大型的、大小相同的  <code>Vector</code>  进行赋值。这种情况下， <code>swap</code>  实现技巧中所蕴含的元素复制操作将导致运行成本按数量级增长。</p>\n<pre><code>template&lt;typename T&gt;\nclass Vector &#123;\npublic:\n    Vector&amp; operator=(const Vector&amp;);\n    // ...\nprivate:\n    T* elem;\n    int sz;\n&#125;;\n\nVector&amp; Vector::operator=(const Vector&amp; a)\n&#123;\n    if (a.sz &gt; sz) &#123;\n        // ... 使用 swap 技巧，没有更好的方式了 ...\n        return *this;\n    &#125;\n    // ... 从 *a.elem 复制 sz 个元素给 elem ...\n    if (a.sz &lt; sz) &#123;\n        // ... 销毁 *this 中过剩的元素并调整大小 ...\n    &#125;\n    return *this;\n&#125;\n</code></pre>\n<p>直接向目标元素中进行写入的话，我们得到的是<a href=\"#Abrahams01\">基本保证</a>而不是  <code>swap</code>  技巧所提供的强保证。还要当心<a href=\"#Rc-copy-self\">自赋值</a>。</p>\n<p><strong>替代方案</strong>：如果你想要  <code>virtual</code>  的赋值运算符，并了解为何这样做很有问题的话，请不要使其为  <code>operator=</code> 。请使用一个命名函数，如  <code>virtual void assign(const Foo&amp;)</code> 。<br>\n参见<a href=\"#Rc-copy-virtual\">复制构造函数 vs.  <code>clone()</code> </a>。</p>\n<h5 id=\"强制实施-100\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-100\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】 赋值运算符不能为  <code>virtual</code> 。有怪兽出没！</li>\n<li>【简单】 赋值运算符应当返回  <code>T&amp;</code>  以支持调用链，不要改为如  <code>const T&amp;</code>  等类型，这样会影响可组合性以及把对象放入容器的能力。</li>\n<li>【中等】 赋值运算符应当（隐式或者显式）调用所有的基类和成员的赋值运算符。<br>\n检查析构函数以分辨类型具有指针语义还是值语义。</li>\n</ul>\n<h3 id=\"a-namerc-copy-semanticac61-复制操作应当进行复制\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-copy-semanticac61-复制操作应当进行复制\">#</a> <a name=\"Rc-copy-semantic\"></a>C.61: 复制操作应当进行复制</h3>\n<h5 id=\"理由-108\"><a class=\"markdownIt-Anchor\" href=\"#理由-108\">#</a> 理由</h5>\n<p>这正是一般假定所具有的语义。执行  <code>x = y</code>  之后，应当有  <code>x == y</code> 。<br>\n进行复制之后， <code>x</code>  和  <code>y</code>  可以是各自独立的对象（值语义，非指针的内建类型和标准库类型的工作方式），也可以代表某个共享的对象（指针语义，就是指针的工作方式）。</p>\n<h5 id=\"示例-103\"><a class=\"markdownIt-Anchor\" href=\"#示例-103\">#</a> 示例</h5>\n<pre><code>class X &#123;   // OK: 值语义\npublic:\n    X();\n    X(const X&amp;);     // 复制 X\n    void modify();   // 改变 X 的值\n    // ...\n    ~X() &#123; delete[] p; &#125;\nprivate:\n    T* p;\n    int sz;\n&#125;;\n\nbool operator==(const X&amp; a, const X&amp; b)\n&#123;\n    return a.sz == b.sz &amp;&amp; equal(a.p, a.p + a.sz, b.p, b.p + b.sz);\n&#125;\n\nX::X(const X&amp; a)\n    :p&#123;new T[a.sz]&#125;, sz&#123;a.sz&#125;\n&#123;\n    copy(a.p, a.p + sz, p);\n&#125;\n\nX x;\nX y = x;\nif (x != y) throw Bad&#123;&#125;;\nx.modify();\nif (x == y) throw Bad&#123;&#125;;   // 假定具有值语义\n</code></pre>\n<h5 id=\"示例-104\"><a class=\"markdownIt-Anchor\" href=\"#示例-104\">#</a> 示例</h5>\n<pre><code>class X2 &#123;  // OK: 指针语义\npublic:\n    X2();\n    X2(const X2&amp;) = default; // 浅拷贝\n    ~X2() = default;\n    void modify();          // 改变所指向的值\n    // ...\nprivate:\n    T* p;\n    int sz;\n&#125;;\n\nbool operator==(const X2&amp; a, const X2&amp; b)\n&#123;\n    return a.sz == b.sz &amp;&amp; a.p == b.p;\n&#125;\n\nX2 x;\nX2 y = x;\nif (x != y) throw Bad&#123;&#125;;\nx.modify();\nif (x != y) throw Bad&#123;&#125;;  // 假定具有指针语义\n</code></pre>\n<h5 id=\"注解-136\"><a class=\"markdownIt-Anchor\" href=\"#注解-136\">#</a> 注解</h5>\n<p>应当优先采用值语义，除非你要构建某种 “智能指针”。值语义是最容易进行推理的，而且也是被标准库设施所期望的。</p>\n<h5 id=\"强制实施-101\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-101\">#</a> 强制实施</h5>\n<p>【无法强制实施】</p>\n<h3 id=\"a-namerc-copy-selfac62-使复制赋值可以安全进行自赋值\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-copy-selfac62-使复制赋值可以安全进行自赋值\">#</a> <a name=\"Rc-copy-self\"></a>C.62: 使复制赋值可以安全进行自赋值</h3>\n<h5 id=\"理由-109\"><a class=\"markdownIt-Anchor\" href=\"#理由-109\">#</a> 理由</h5>\n<p>如果  <code>x=x</code>  会改变  <code>x</code>  的值的话，会让人惊异，并导致发生严重的错误（通常会含有资源泄漏）。</p>\n<h5 id=\"示例-105\"><a class=\"markdownIt-Anchor\" href=\"#示例-105\">#</a> 示例</h5>\n<p>标准库的容器类都能优雅且高效地处理自赋值：</p>\n<pre><code>std::vector&lt;int&gt; v = &#123;3, 1, 4, 1, 5, 9&#125;;\nv = v;\n// v 的值仍然是 &#123;3, 1, 4, 1, 5, 9&#125;\n</code></pre>\n<h5 id=\"注解-137\"><a class=\"markdownIt-Anchor\" href=\"#注解-137\">#</a> 注解</h5>\n<p>从可以处理自赋值的成员所生成的默认复制操作是能够正确处理自赋值的。</p>\n<pre><code>struct Bar &#123;\n    vector&lt;pair&lt;int, int&gt;&gt; v;\n    map&lt;string, int&gt; m;\n    string s;\n&#125;;\n\nBar b;\n// ...\nb = b;   // 正确而且高效\n</code></pre>\n<h5 id=\"注解-138\"><a class=\"markdownIt-Anchor\" href=\"#注解-138\">#</a> 注解</h5>\n<p>可以通过明确检测自赋值来处理自赋值的情况，不过通常不进行这种检测会变得更快并且更优雅（比如说，<a href=\"#Rc-swap\">利用  <code>swap</code> </a>）。</p>\n<pre><code>class Foo &#123;\n    string s;\n    int i;\npublic:\n    Foo&amp; operator=(const Foo&amp; a);\n    // ...\n&#125;;\n\nFoo&amp; Foo::operator=(const Foo&amp; a)   // OK，但增加了成本\n&#123;\n    if (this == &amp;a) return *this;\n    s = a.s;\n    i = a.i;\n    return *this;\n&#125;\n</code></pre>\n<p>这显然是安全的，也貌似高效。<br>\n不过，如果一百万次赋值才会做一次自赋值会怎么样呢？<br>\n这样就有大约一百万次多余的测试（不过由于基本上每次的答案都相同，计算机的分支预测电路也基本上每次都会猜对）。<br>\n考虑：</p>\n<pre><code>Foo&amp; Foo::operator=(const Foo&amp; a)   // 更简单，而且可能也更好\n&#123;\n    s = a.s;\n    i = a.i;\n    return *this;\n&#125;\n</code></pre>\n<p><code>std::string</code>  的自赋值是安全的， <code>int</code>  也是如此。所有的成本都将花在（罕见的）自赋值情况中。</p>\n<h5 id=\"强制实施-102\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-102\">#</a> 强制实施</h5>\n<p>【简单】 赋值运算符不应当包含  <code>if (this == &amp;a) return *this;</code>  这样的代码模式？？？</p>\n<h3 id=\"a-namerc-move-assignmentac63-使移动赋值非-virtual接受-的参数并返回非-const\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-move-assignmentac63-使移动赋值非-virtual接受-的参数并返回非-const\">#</a> <a name=\"Rc-move-assignment\"></a>C.63: 使移动赋值非  <code>virtual</code> ，接受  <code>&amp;&amp;</code>  的参数，并返回非  <code>const&amp;</code></h3>\n<h5 id=\"理由-110\"><a class=\"markdownIt-Anchor\" href=\"#理由-110\">#</a> 理由</h5>\n<p>这样简单而且高效。</p>\n<p><strong>参见</strong>: <a href=\"#Rc-copy-assignment\">针对复制赋值的规则</a>。</p>\n<h5 id=\"强制实施-103\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-103\">#</a> 强制实施</h5>\n<p>和针对<a href=\"#Rc-copy-assignment\">复制赋值</a>所做的相同。</p>\n<ul>\n<li>【简单】 赋值运算符不能为  <code>virtual</code> 。有怪兽出没！</li>\n<li>【简单】 赋值运算符应当返回  <code>T&amp;</code>  以支持调用链，不要改为如  <code>const T&amp;</code>  等类型，这样会影响可组合性以及把对象放入容器的能力。</li>\n<li>【中等】 移动赋值运算符应当（隐式或者显式）调用所有的基类和成员的移动赋值运算符。</li>\n</ul>\n<h3 id=\"a-namerc-move-semanticac64-移动操作应当进行移动并使原对象处于有效状态\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-move-semanticac64-移动操作应当进行移动并使原对象处于有效状态\">#</a> <a name=\"Rc-move-semantic\"></a>C.64: 移动操作应当进行移动，并使原对象处于有效状态</h3>\n<h5 id=\"理由-111\"><a class=\"markdownIt-Anchor\" href=\"#理由-111\">#</a> 理由</h5>\n<p>这正是一般假定所具有的语义。<br>\n执行  <code>y=std::move(x)</code>  之后， <code>y</code>  的值应当为  <code>x</code>  曾经的值，而  <code>x</code>  应当处于有效状态。</p>\n<h5 id=\"示例-106\"><a class=\"markdownIt-Anchor\" href=\"#示例-106\">#</a> 示例</h5>\n<pre><code>class X &#123;   // OK: 值语义\npublic:\n    X();\n    X(X&amp;&amp; a) noexcept;  // 移动 X\n    X&amp; operator=(X&amp;&amp; a) noexcept; // 移动赋值 X\n    void modify();     // 改变 X 的值\n    // ...\n    ~X() &#123; delete[] p; &#125;\nprivate:\n    T* p;\n    int sz;\n&#125;;\n\nX::X(X&amp;&amp; a) noexcept\n    :p&#123;a.p&#125;, sz&#123;a.sz&#125;  // 窃取其表示\n&#123;\n    a.p = nullptr;     // 设其为“空”\n    a.sz = 0;\n&#125;\n\nvoid use()\n&#123;\n    X x&#123;&#125;;\n    // ...\n    X y = std::move(x);\n    x = X&#123;&#125;;   // OK\n&#125; // OK: x 可以销毁\n</code></pre>\n<h5 id=\"注解-139\"><a class=\"markdownIt-Anchor\" href=\"#注解-139\">#</a> 注解</h5>\n<p>理想情况下，被移走的对象应当为类型的默认值。<br>\n请确保体现这点，除非有非常好的理由不这样做。<br>\n然而，并非所有类型都有默认值，而有些类型建立默认值则是昂贵操作。<br>\n标准所要求的仅仅是被移走的对象应当可以被销毁。<br>\n我们通常也可以轻易且廉价地做得更好一些：标准库假定它可以向被移走的对象进行赋值。<br>\n请保证总是让被移走的对象处于某种（需要明确的）有效状态。</p>\n<h5 id=\"注解-140\"><a class=\"markdownIt-Anchor\" href=\"#注解-140\">#</a> 注解</h5>\n<p>请让  <code>x = std::move(y); y = z;</code>  按照惯例约定的语义工作，除非有某个十分强大的理由不这样做。</p>\n<h5 id=\"强制实施-104\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-104\">#</a> 强制实施</h5>\n<p>【无法强制实施】 检查移动操作中对成员的赋值。如果有默认构造函数的话，则把这些赋值和默认构造函数中的初始化之间进行比较。</p>\n<h3 id=\"a-namerc-move-selfac65-使移动赋值可以安全进行自赋值\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-move-selfac65-使移动赋值可以安全进行自赋值\">#</a> <a name=\"Rc-move-self\"></a>C.65: 使移动赋值可以安全进行自赋值</h3>\n<h5 id=\"理由-112\"><a class=\"markdownIt-Anchor\" href=\"#理由-112\">#</a> 理由</h5>\n<p>如果  <code>x = x</code>  会改变  <code>x</code>  的值的话，会让人惊异，并导致发生严重的错误（通常会含有资源泄漏）。不过，通常不会有人写出能够变成移动操作的自赋值代码，但它确实是会发生的。不管怎样， <code>std::swap</code>  就是利用移动操作来实现的，因此如果你不小心写了  <code>swap(a, b)</code>  而  <code>a</code>  和  <code>b</code>  指代相同的对象的话，未能处理自移动情况将是一种严重而且微妙的错误。</p>\n<h5 id=\"示例-107\"><a class=\"markdownIt-Anchor\" href=\"#示例-107\">#</a> 示例</h5>\n<pre><code>class Foo &#123;\n    string s;\n    int i;\npublic:\n    Foo&amp; operator=(Foo&amp;&amp; a);\n    // ...\n&#125;;\n\nFoo&amp; Foo::operator=(Foo&amp;&amp; a) noexcept  // OK，但增加了成本\n&#123;\n    if (this == &amp;a) return *this;  // 这行是多余的\n    s = std::move(a.s);\n    i = a.i;\n    return *this;\n&#125;\n</code></pre>\n<p><a href=\"#Rc-copy-self\">自赋值</a>中反对  <code>if (this == &amp;a) return *this;</code>  测试的 “每一百万次有一次” 的论点，在自移动的情况中更加适当。</p>\n<h5 id=\"注解-141\"><a class=\"markdownIt-Anchor\" href=\"#注解-141\">#</a> 注解</h5>\n<p>并不存在已知的通用方法，以在移动赋值中避免进行  <code>if (this == &amp;a) return *this;</code>  测试，又能使其得到正确的结果（亦即，执行  <code>x = x</code>  之后不改变  <code>x</code>  的值）。</p>\n<h5 id=\"注解-142\"><a class=\"markdownIt-Anchor\" href=\"#注解-142\">#</a> 注解</h5>\n<p>ISO 标准中对标准库容器类仅仅保证了 “有效但未指明” 的状态。貌似这样做在差不多十年的实验性和产品级代码的使用中并未造成什么问题。如果你找到了反例的话，请联系各位编辑。本条规则更多的是提醒小心并强调完全的安全性。</p>\n<h5 id=\"示例-108\"><a class=\"markdownIt-Anchor\" href=\"#示例-108\">#</a> 示例</h5>\n<p>下面是一种不进行测试而移动一个指针的方法（请想象这段代码来自某个移动赋值的实现）：</p>\n<pre><code>// 从 other.ptr 移动到 this-&gt;ptr\nT* temp = other.ptr;\nother.ptr = nullptr;\ndelete ptr; // 在自移动情况中，this-&gt;ptr 也为 null；delete 是空操作\nptr = temp; // 在自移动情况中，恢复了原 ptr\n</code></pre>\n<h5 id=\"强制实施-105\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-105\">#</a> 强制实施</h5>\n<ul>\n<li>【中级】 在自赋值的情况中，移动赋值运算符不应当使持有已经被  <code>delete</code>  或设为  <code>nullptr</code>  的指针成员。</li>\n<li>【无法强制实施】 查看标准库容器类型（包括  <code>string</code> ）的使用方式，在普通（非性命攸关）使用中将它们当作是安全的。</li>\n</ul>\n<h3 id=\"a-namerc-move-noexceptac66-使移动操作-noexcept\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-move-noexceptac66-使移动操作-noexcept\">#</a> <a name=\"Rc-move-noexcept\"></a>C.66: 使移动操作  <code>noexcept</code></h3>\n<h5 id=\"理由-113\"><a class=\"markdownIt-Anchor\" href=\"#理由-113\">#</a> 理由</h5>\n<p>能够抛出异常的移动操作将违反大多数人的合理假设。<br>\n不会抛出异常的移动操作可以更高效地被标准库和语言设施所利用。</p>\n<h5 id=\"示例-109\"><a class=\"markdownIt-Anchor\" href=\"#示例-109\">#</a> 示例</h5>\n<pre><code>template&lt;typename T&gt;\nclass Vector &#123;\npublic:\n    Vector(Vector&amp;&amp; a) noexcept :elem&#123;a.elem&#125;, sz&#123;a.sz&#125; &#123; a.sz = 0; a.elem = nullptr; &#125;\n    Vector&amp; operator=(Vector&amp;&amp; a) noexcept &#123; elem = a.elem; sz = a.sz; a.sz = 0; a.elem = nullptr; &#125;\n    // ...\nprivate:\n    T* elem;\n    int sz;\n&#125;;\n</code></pre>\n<p>这些操作不会抛出异常。</p>\n<h5 id=\"示例不好-40\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-40\">#</a> 示例，不好</h5>\n<pre><code>template&lt;typename T&gt;\nclass Vector2 &#123;\npublic:\n    Vector2(Vector2&amp;&amp; a) &#123; *this = a; &#125;             // 直接利用复制操作\n    Vector2&amp; operator=(Vector2&amp;&amp; a) &#123; *this = a; &#125;  // 直接利用复制操作\n    // ...\nprivate:\n    T* elem;\n    int sz;\n&#125;;\n</code></pre>\n<p><code>Vector2</code>  不仅低效，而且由于向量的复制需要分配内存而使其可能抛出异常。</p>\n<h5 id=\"强制实施-106\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-106\">#</a> 强制实施</h5>\n<p>【简单】 移动操作应当被标为  <code>noexcept</code> 。</p>\n<h3 id=\"a-namerc-copy-virtualac67-多态类应当抑制公开的移动复制操作\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-copy-virtualac67-多态类应当抑制公开的移动复制操作\">#</a> <a name=\"Rc-copy-virtual\"></a>C.67: 多态类应当抑制公开的移动 / 复制操作</h3>\n<h5 id=\"理由-114\"><a class=\"markdownIt-Anchor\" href=\"#理由-114\">#</a> 理由</h5>\n<p><em>多态类</em>是定义或继承了至少一个虚函数的类。它很可能要被用作其他具有多态行为的派生类的基类。如果不小心将其按值传递了，如果它带有隐式生成的复制构造函数和赋值的话，它就面临发生切片的风险：只会复制派生类对象的基类部分，但将损坏其多态行为。</p>\n<p>如果类中没有数据，则使其复制 / 移动函数  <code>=delete</code> 。否则，使它们为受保护的。</p>\n<h5 id=\"示例不好-41\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-41\">#</a> 示例，不好</h5>\n<pre><code>class B &#123; // 不好: 多态基类并未抑制复制操作\npublic:\n    virtual char m() &#123; return 'B'; &#125;\n    // ... 没有提供复制操作，使用预置实现 ...\n&#125;;\n\nclass D : public B &#123;\npublic:\n    char m() override &#123; return 'D'; &#125;\n    // ...\n&#125;;\n\nvoid f(B&amp; b)\n&#123;\n    auto b2 = b; // 啊呀，对象切片了；b2.m() 将返回 'B'\n&#125;\n\nD d;\nf(d);\n</code></pre>\n<h5 id=\"示例-110\"><a class=\"markdownIt-Anchor\" href=\"#示例-110\">#</a> 示例</h5>\n<pre><code>class B &#123; // 好: 多态类抑制了复制操作\npublic:\n    B() = default;\n    B(const B&amp;) = delete;\n    B&amp; operator=(const B&amp;) = delete;\n    virtual char m() &#123; return 'B'; &#125;\n    // ...\n&#125;;\n\nclass D : public B &#123;\npublic:\n    char m() override &#123; return 'D'; &#125;\n    // ...\n&#125;;\n\nvoid f(B&amp; b)\n&#123;\n    auto b2 = b; // ok，编译器能够检测到不恰当的复制并给出警告\n&#125;\n\nD d;\nf(d);\n</code></pre>\n<h5 id=\"注解-143\"><a class=\"markdownIt-Anchor\" href=\"#注解-143\">#</a> 注解</h5>\n<p>当需要创建多态对象的深拷贝副本时，应当使用  <code>clone()</code>  函数：参见 <a href=\"#Rh-copy\">C.130</a>。</p>\n<h5 id=\"例外-28\"><a class=\"markdownIt-Anchor\" href=\"#例外-28\">#</a> 例外</h5>\n<p>表示异常对象的类应当既是多态的，也可以进行复制构造。</p>\n<h5 id=\"强制实施-107\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-107\">#</a> 强制实施</h5>\n<ul>\n<li>对带有公开的复制操作的多态类进行标记。</li>\n<li>对多态类对象的赋值操作进行标记。</li>\n</ul>\n<h2 id=\"cother-默认操作的其他规则\"><a class=\"markdownIt-Anchor\" href=\"#cother-默认操作的其他规则\">#</a> C.other: 默认操作的其他规则</h2>\n<p>除了语言为之提供默认实现的操作之外，<br>\n还有一些操作也是非常基础的，需要对它们的定义给出专门的规则：<br>\n比较， <code>swap</code> ，以及  <code>hash</code> 。</p>\n<h3 id=\"a-namerc-eqdefaultac80-当需要明确使用缺省语义时使用-default\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-eqdefaultac80-当需要明确使用缺省语义时使用-default\">#</a> <a name=\"Rc-eqdefault\"></a>C.80: 当需要明确使用缺省语义时，使用  <code>=default</code></h3>\n<h5 id=\"理由-115\"><a class=\"markdownIt-Anchor\" href=\"#理由-115\">#</a> 理由</h5>\n<p>编译器能更正确地实现缺省语义，你所实现的这些函数也不会比编译器更好。</p>\n<h5 id=\"示例-111\"><a class=\"markdownIt-Anchor\" href=\"#示例-111\">#</a> 示例</h5>\n<pre><code>class Tracer &#123;\n    string message;\npublic:\n    Tracer(const string&amp; m) : message&#123;m&#125; &#123; cerr &lt;&lt; &quot;entering &quot; &lt;&lt; message &lt;&lt; '\\n'; &#125;\n    ~Tracer() &#123; cerr &lt;&lt; &quot;exiting &quot; &lt;&lt; message &lt;&lt; '\\n'; &#125;\n\n    Tracer(const Tracer&amp;) = default;\n    Tracer&amp; operator=(const Tracer&amp;) = default;\n    Tracer(Tracer&amp;&amp;) = default;\n    Tracer&amp; operator=(Tracer&amp;&amp;) = default;\n&#125;;\n</code></pre>\n<p>由于定义了析构函数，所以也得定义它的复制和移动操作。最佳且最简单的做法就是  <code>= default</code> 。</p>\n<h5 id=\"示例不好-42\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-42\">#</a> 示例，不好</h5>\n<pre><code>class Tracer2 &#123;\n    string message;\npublic:\n    Tracer2(const string&amp; m) : message&#123;m&#125; &#123; cerr &lt;&lt; &quot;entering &quot; &lt;&lt; message &lt;&lt; '\\n'; &#125;\n    ~Tracer2() &#123; cerr &lt;&lt; &quot;exiting &quot; &lt;&lt; message &lt;&lt; '\\n'; &#125;\n\n    Tracer2(const Tracer2&amp; a) : message&#123;a.message&#125; &#123;&#125;\n    Tracer2&amp; operator=(const Tracer2&amp; a) &#123; message = a.message; return *this; &#125;\n    Tracer2(Tracer2&amp;&amp; a) :message&#123;a.message&#125; &#123;&#125;\n    Tracer2&amp; operator=(Tracer2&amp;&amp; a) &#123; message = a.message; return *this; &#125;\n&#125;;\n</code></pre>\n<p>把复制和移动操作的函数体写明的做法，既啰嗦又乏味，而且易于出错。编译器则能干得更好。</p>\n<h5 id=\"强制实施-108\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-108\">#</a> 强制实施</h5>\n<p>【中级】 特殊操作的函数体不应当和编译器生成的版本具有同样的访问性和语义，因为这样做是多余的。</p>\n<h3 id=\"a-namerc-deleteac81-当需要关闭缺省行为且不需要替代的行为时使用-delete\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-deleteac81-当需要关闭缺省行为且不需要替代的行为时使用-delete\">#</a> <a name=\"Rc-delete\"></a>C.81: 当需要关闭缺省行为（且不需要替代的行为）时，使用  <code>=delete</code></h3>\n<h5 id=\"理由-116\"><a class=\"markdownIt-Anchor\" href=\"#理由-116\">#</a> 理由</h5>\n<p>少数情况下是不需要提供默认操作的。</p>\n<h5 id=\"示例-112\"><a class=\"markdownIt-Anchor\" href=\"#示例-112\">#</a> 示例</h5>\n<pre><code>class Immortal &#123;\npublic:\n    ~Immortal() = delete;   // 不允许进行销毁\n    // ...\n&#125;;\n\nvoid use()\n&#123;\n    Immortal ugh;   // 错误: ugh 无法销毁\n    Immortal* p = new Immortal&#123;&#125;;\n    delete p;       // 错误: 无法销毁 *p\n&#125;\n</code></pre>\n<h5 id=\"示例-113\"><a class=\"markdownIt-Anchor\" href=\"#示例-113\">#</a> 示例</h5>\n<p><code>unique_ptr</code>  可以移动但不能复制。为达成这点，其复制操作是被弃置的。为了避免发生复制，需要将其从左值进行复制的操作定义为  <code>=delete</code> ：</p>\n<pre><code>template&lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr &#123;\npublic:\n    // ...\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    // ...\n    unique_ptr(unique_ptr&amp;&amp; u) noexcept;   // 移动构造函数\n    // ...\n    unique_ptr(const unique_ptr&amp;) = delete; // 关闭从左值进行的复制\n    // ...\n&#125;;\n\nunique_ptr&lt;int&gt; make();   // 创建“某个对象”并以移动方式返回\n\nvoid f()\n&#123;\n    unique_ptr&lt;int&gt; pi &#123;&#125;;\n    auto pi2 &#123;pi&#125;;      // 错误: 不存在从左值进行的移动构造函数\n    auto pi3 &#123;make()&#125;;  // OK，进行移动: make() 的结果为右值\n&#125;\n</code></pre>\n<p>注意，弃置的函数应当是公开的。</p>\n<h5 id=\"强制实施-109\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-109\">#</a> 强制实施</h5>\n<p>消除一个默认操作，是（应当是）基于类所要达成的语义考虑的。应当对这样的类保持怀疑，但可以维护一个 “确认列表”，由人工断言其语义是正确的。</p>\n<h3 id=\"a-namerc-ctor-virtualac82-不要在构造函数和析构函数中调用虚函数\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-ctor-virtualac82-不要在构造函数和析构函数中调用虚函数\">#</a> <a name=\"Rc-ctor-virtual\"></a>C.82: 不要在构造函数和析构函数中调用虚函数</h3>\n<h5 id=\"理由-117\"><a class=\"markdownIt-Anchor\" href=\"#理由-117\">#</a> 理由</h5>\n<p>其中所调用的函数其实是目前所构造的对象的函数，而不是可能在派生类中覆盖它的函数。<br>\n这可能是最易混淆的。<br>\n更糟的是，从构造函数或析构函数中直接或间接调用未被实现的纯虚函数的话，还会导致未定义的行为。</p>\n<h5 id=\"示例不好-43\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-43\">#</a> 示例，不好</h5>\n<pre><code>class Base &#123;\npublic:\n    virtual void f() = 0;   // 未实现\n    virtual void g();       // 有 Base 版本的实现\n    virtual void h();       // 有 Base 版本的实现\n    virtual ~Base();        // 有 Base 版本的实现\n&#125;;\n\nclass Derived : public Base &#123;\npublic:\n    void g() override;   // 提供 Derived 版本的实现\n    void h() final;      // 提供 Derived 版本的实现\n\n    Derived()\n    &#123;\n        // 不好: 试图调用未经事先的虚函数\n        f();\n\n        // 不好: 想要调用 derived::g，但并未发生虚函数分派\n        g();\n\n        // 好: 明确说明想要调用的就是写明的版本\n        Derived::g();\n\n        // ok，不需要进行限定，h 为 final\n        h();\n    &#125;\n&#125;;\n</code></pre>\n<p>注意，调用一个明确限定的函数时，即便函数是  <code>virtual</code>  的，也不会发生虚函数调用。</p>\n<p><strong>参见</strong> <a href=\"#Rc-factory\">工厂函数</a>，以了解如何获得调用派生类函数的效果又不会引发未定义行为。</p>\n<h5 id=\"注解-144\"><a class=\"markdownIt-Anchor\" href=\"#注解-144\">#</a> 注解</h5>\n<p>其实在构造函数和析构函数中调用虚函数并不存在固有的错误。<br>\n这种调用的语义是类型安全的。<br>\n然而，经验表明这种调用很少真正需要，易于让维护者混淆，而且当被新手使用之后还会成为一种错误来源。</p>\n<h5 id=\"强制实施-110\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-110\">#</a> 强制实施</h5>\n<ul>\n<li>标记构造函数和析构函数中对虚函数的调用。</li>\n</ul>\n<h3 id=\"a-namerc-swapac83-考虑为值类型提供-noexcept-的-swap-函数\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-swapac83-考虑为值类型提供-noexcept-的-swap-函数\">#</a> <a name=\"Rc-swap\"></a>C.83: 考虑为值类型提供  <code>noexcept</code>  的  <code>swap</code>  函数</h3>\n<h5 id=\"理由-118\"><a class=\"markdownIt-Anchor\" href=\"#理由-118\">#</a> 理由</h5>\n<p><code>swap</code>  对于实现许多惯用法都很有用，其范围包括从平滑地进行对象移动，到轻易实现提供了受保证的提交功能的赋值操作以允许编写具有强异常安全性的调用代码。考虑利用  <code>swap</code>  来基于复制构造实现复制赋值操作。另见<a href=\"#Re-never-fail\">析构函数，回收，以及  <code>swap</code>  不允许失败</a>。</p>\n<h5 id=\"示例好-9\"><a class=\"markdownIt-Anchor\" href=\"#示例好-9\">#</a> 示例，好</h5>\n<pre><code>class Foo &#123;\npublic:\n    void swap(Foo&amp; rhs) noexcept\n    &#123;\n        m1.swap(rhs.m1);\n        std::swap(m2, rhs.m2);\n    &#125;\nprivate:\n    Bar m1;\n    int m2;\n&#125;;\n</code></pre>\n<p>为调用者方便起见，可以在类型所在的相同命名空间中提供一个非成员的  <code>swap</code>  函数。</p>\n<pre><code>void swap(Foo&amp; a, Foo&amp; b)\n&#123;\n    a.swap(b);\n&#125;\n</code></pre>\n<h5 id=\"强制实施-111\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-111\">#</a> 强制实施</h5>\n<ul>\n<li>可非平凡复制的类型应当提供成员  <code>swap</code>  或自由  <code>swap</code>  函数的重载。</li>\n<li>【简单】 当类带有  <code>swap</code>  成员函数时，它应当被声明为  <code>noexcept</code> 。</li>\n</ul>\n<h3 id=\"a-namerc-swap-failac84-swap-函数不能失败\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-swap-failac84-swap-函数不能失败\">#</a> <a name=\"Rc-swap-fail\"></a>C.84:  <code>swap</code>  函数不能失败</h3>\n<h5 id=\"理由-119\"><a class=\"markdownIt-Anchor\" href=\"#理由-119\">#</a> 理由</h5>\n<p><code>swap</code>  广泛地以假定永不失败的方式被使用，而且如果存在可能失败的  <code>swap</code>  函数的话，程序也很难编写为可以正确工作。如果元素类型的  <code>swap</code>  会失败的话，标准库的容器和算法也无法正确工作。</p>\n<h5 id=\"示例不好-44\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-44\">#</a> 示例，不好</h5>\n<pre><code>void swap(My_vector&amp; x, My_vector&amp; y)\n&#123;\n    auto tmp = x;   // 复制各元素\n    x = y;\n    y = tmp;\n&#125;\n</code></pre>\n<p>这样做不仅很慢，而且如果为  <code>tmp</code>  中的元素进行了内存分配的话，这个  <code>swap</code>  也可能抛出异常，并导致使用它的 STL 算法的失败。</p>\n<h5 id=\"强制实施-112\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-112\">#</a> 强制实施</h5>\n<p>【简单】 当类带有  <code>swap</code>  成员函数时，它应当被声明为  <code>noexcept</code> 。</p>\n<h3 id=\"a-namerc-swap-noexceptac85-使-swap-函数-noexcept\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-swap-noexceptac85-使-swap-函数-noexcept\">#</a> <a name=\"Rc-swap-noexcept\"></a>C.85: 使  <code>swap</code>  函数  <code>noexcept</code></h3>\n<h5 id=\"理由-120\"><a class=\"markdownIt-Anchor\" href=\"#理由-120\">#</a> 理由</h5>\n<p><a href=\"#Rc-swap-fail\"> <code>swap</code>  不能失败</a>。<br>\n如果  <code>swap</code>  试图用异常来退出的话，这就是严重的设计错误，程序最好理解终止 terminate。</p>\n<h5 id=\"强制实施-113\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-113\">#</a> 强制实施</h5>\n<p>【简单】 当类带有  <code>swap</code>  成员函数时，它应当被声明为  <code>noexcept</code> 。</p>\n<h3 id=\"a-namerc-eqac86-使-对操作数的类型对称并使之-noexcept\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-eqac86-使-对操作数的类型对称并使之-noexcept\">#</a> <a name=\"Rc-eq\"></a>C.86: 使  <code>==</code>  对操作数的类型对称，并使之  <code>noexcept</code></h3>\n<h5 id=\"理由-121\"><a class=\"markdownIt-Anchor\" href=\"#理由-121\">#</a> 理由</h5>\n<p>不对称的操作数是出人意料的，而且当可能发生类型转换时也是一种错误来源。<br>\n <code>==</code>  是一项基础操作，程序员应当能够随意使用而不担心失败。</p>\n<h5 id=\"示例-114\"><a class=\"markdownIt-Anchor\" href=\"#示例-114\">#</a> 示例</h5>\n<pre><code>struct X &#123;\n    string name;\n    int number;\n&#125;;\n\nbool operator==(const X&amp; a, const X&amp; b) noexcept &#123;\n    return a.name == b.name &amp;&amp; a.number == b.number;\n&#125;\n</code></pre>\n<h5 id=\"示例不好-45\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-45\">#</a> 示例，不好</h5>\n<pre><code>class B &#123;\n    string name;\n    int number;\n    bool operator==(const B&amp; a) const &#123;\n        return name == a.name &amp;&amp; number == a.number;\n    &#125;\n    // ...\n&#125;;\n</code></pre>\n<p><code>B</code>  的比较函数接受其第二个操作数上的类型转换，但第一个操作数不可以。</p>\n<h5 id=\"注解-145\"><a class=\"markdownIt-Anchor\" href=\"#注解-145\">#</a> 注解</h5>\n<p>如果类带有比如  <code>double</code>  的  <code>NaN</code>  这样的故障状态的话，就诱惑人们让与故障状态之间的比较抛出异常。<br>\n其替代方案是让两个故障状态的比较相等，而任何有效状态和故障状态的比较都不相等。</p>\n<h5 id=\"注解-146\"><a class=\"markdownIt-Anchor\" href=\"#注解-146\">#</a> 注解</h5>\n<p>本条规则适用于所有的常规比较运算符： <code>!=</code> ， <code>&lt;</code> ， <code>&lt;=</code> ， <code>&gt;</code> ，以及  <code>&gt;=</code> 。</p>\n<h5 id=\"强制实施-114\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-114\">#</a> 强制实施</h5>\n<ul>\n<li>对两个参数类型不同的  <code>operator==()</code>  进行标记；其他比较运算符也是如此： <code>!=</code> ， <code>&lt;</code> ， <code>&lt;=</code> ， <code>&gt;</code> ，和  <code>&gt;=</code> 。</li>\n<li>对成员  <code>operator==()</code>  进行标记；其他比较运算符也是如此： <code>!=</code> ， <code>&lt;</code> ， <code>&lt;=</code> ， <code>&gt;</code> ，和  <code>&gt;=</code> 。</li>\n</ul>\n<h3 id=\"a-namerc-eq-baseac87-请当心基类的\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-eq-baseac87-请当心基类的\">#</a> <a name=\"Rc-eq-base\"></a>C.87: 请当心基类的  <code>==</code></h3>\n<h5 id=\"理由-122\"><a class=\"markdownIt-Anchor\" href=\"#理由-122\">#</a> 理由</h5>\n<p>为类层次编写一个傻瓜式的并且有用处的  <code>==</code>  是相当困难的。</p>\n<h5 id=\"示例不好-46\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-46\">#</a> 示例，不好</h5>\n<pre><code>class B &#123;\n    string name;\n    int number;\npublic:\n    virtual bool operator==(const B&amp; a) const\n    &#123;\n         return name == a.name &amp;&amp; number == a.number;\n    &#125;\n    // ...\n&#125;;\n</code></pre>\n<p><code>B</code>  的比较函数接受对其第二个操作数的类型转换，但第一个则并非如此。</p>\n<pre><code>class D : public B &#123;\n    char character;\npublic:\n    virtual bool operator==(const D&amp; a) const\n    &#123;\n        return B::operator==(a) &amp;&amp; character == a.character;\n    &#125;\n    // ...\n&#125;;\n\nB b = ...\nD d = ...\nb == d;    // 比较了 name 和 number，但忽略了 d 的 character\nd == b;    // 比较了 name 和 number，但忽略了 d 的 character\nD d2;\nd == d2;   // 比较了 name、number 和 character\nB&amp; b2 = d2;\nb2 == d;   // 比较了 name 和 number，但忽略了 d2 和 d 的 character\n</code></pre>\n<p>显然有许多使  <code>==</code>  在类层次中可以工作的方式，但不成熟的方案是无法适应范围扩展的。</p>\n<h5 id=\"注解-147\"><a class=\"markdownIt-Anchor\" href=\"#注解-147\">#</a> 注解</h5>\n<p>本条规则适用于所有的常规比较运算符： <code>!=</code> ， <code>&lt;</code> ， <code>&lt;=</code> ， <code>&gt;</code> ， <code>&gt;=</code> ，以及  <code>&lt;=&gt;</code> 。</p>\n<h5 id=\"强制实施-115\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-115\">#</a> 强制实施</h5>\n<ul>\n<li>对虚的  <code>operator==()</code>  进行标记；其他比较运算符也是如此： <code>!=</code> ， <code>&lt;</code> ， <code>&lt;=</code> ， <code>&gt;</code> ， <code>&gt;=</code> ，以及  <code>&lt;=&gt;</code> 。</li>\n</ul>\n<h3 id=\"a-namerc-hashac89-使-hash-函数-noexcept\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-hashac89-使-hash-函数-noexcept\">#</a> <a name=\"Rc-hash\"></a>C.89: 使  <code>hash</code>  函数  <code>noexcept</code></h3>\n<h5 id=\"理由-123\"><a class=\"markdownIt-Anchor\" href=\"#理由-123\">#</a> 理由</h5>\n<p>哈希容器的使用者都会间接地使用  <code>hash</code> ，并且不会预期简单的访问操作也会抛出异常。<br>\n这是标准库的一条要求。</p>\n<h5 id=\"示例不好-47\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-47\">#</a> 示例，不好</h5>\n<pre><code>template&lt;&gt;\nstruct hash&lt;My_type&gt; &#123;  // 非常不好的 hash 特化\n    using result_type = size_t;\n    using argument_type = My_type;\n\n    size_t operator()(const My_type &amp; x) const\n    &#123;\n        size_t xs = x.s.size();\n        if (xs &lt; 4) throw Bad_My_type&#123;&#125;;    // &quot;没有人期待西班牙宗教裁判所！&quot;\n        return hash&lt;size_t&gt;()(x.s.size()) ^ trim(x.s);\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    unordered_map&lt;My_type, int&gt; m;\n    My_type mt&#123; &quot;asdfg&quot; &#125;;\n    m[mt] = 7;\n    cout &lt;&lt; m[My_type&#123; &quot;asdfg&quot; &#125;] &lt;&lt; '\\n';\n&#125;\n</code></pre>\n<p>如果你必须定义  <code>hash</code>  的特化的话，请尝试单纯地用  <code>^</code> （异或 xor）把标准库的  <code>hash</code>  特化进行组合。<br>\n这样做对于非专业人士来说往往会更好。</p>\n<h5 id=\"强制实施-116\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-116\">#</a> 强制实施</h5>\n<ul>\n<li>标记可能抛出异常的  <code>hash</code> 。</li>\n</ul>\n<h3 id=\"a-namerc-memsetac90-依靠构造函数和赋值运算符不要依靠-memset-和-memcpy\"><a class=\"markdownIt-Anchor\" href=\"#a-namerc-memsetac90-依靠构造函数和赋值运算符不要依靠-memset-和-memcpy\">#</a> <a name=\"Rc-memset\"></a>C.90: 依靠构造函数和赋值运算符，不要依靠  <code>memset</code>  和  <code>memcpy</code></h3>\n<h5 id=\"理由-124\"><a class=\"markdownIt-Anchor\" href=\"#理由-124\">#</a> 理由</h5>\n<p>构造某个类型的实例的标准 C++ 机制是调用其构造函数。如指导方针 <a href=\"#Rc-complete\">C.41</a> 所述：构造函数应当创建一个已完全初始化的对象。不应当需要进行如用  <code>memcpy</code>  来进行的额外初始化。<br>\n为适当地做出一个类的副本并维持类型的不变式，类型将提供复制构造函数和 / 或复制赋值运算符。使用  <code>memcpy</code>  来复制一个非可平凡复制的类型具有未定义的行为。这经常会导致切片，或者数据损坏。</p>\n<h5 id=\"示例好-10\"><a class=\"markdownIt-Anchor\" href=\"#示例好-10\">#</a> 示例，好</h5>\n<pre><code>struct base &#123;\n    virtual void update() = 0;\n    std::shared_ptr&lt;int&gt; sp;\n&#125;;\n\nstruct derived : public base &#123;\n    void update() override &#123;&#125;\n&#125;;\n</code></pre>\n<h5 id=\"示例不好-48\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-48\">#</a> 示例，不好</h5>\n<pre><code>void init(derived&amp; a) \n&#123; \n    memset(&amp;a, 0, sizeof(derived)); \n&#125; \n</code></pre>\n<p>这样做类型不安全并且会覆写掉虚表。</p>\n<h5 id=\"示例不好-49\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-49\">#</a> 示例，不好</h5>\n<pre><code>void copy(derived&amp; a, derived&amp; b) \n&#123; \n    memcpy(&amp;a, &amp;b, sizeof(derived)); \n&#125; \n</code></pre>\n<p>这样做同样类型不安全并且会覆写掉虚表。</p>\n<h5 id=\"强制实施-117\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-117\">#</a> 强制实施</h5>\n<ul>\n<li>对将非可平凡复制类型传递给  <code>memset</code>  或  <code>memcpy</code>  进行标记。</li>\n</ul>\n<h2 id=\"a-namess-containersaccon-容器和其他资源包装类\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-containersaccon-容器和其他资源包装类\">#</a> <a name=\"SS-containers\"></a>C.con: 容器和其他资源包装类</h2>\n<p>容器是一种持有某个类型的对象序列的对象； <code>std::vector</code>  就是一种典型的容器。<br>\n资源包装类是拥有某个资源的类； <code>std::vector</code>  是一种典型的资源包装类；它的资源就是其元素的序列。</p>\n<p>容器规则概览</p>\n<ul>\n<li><a href=\"#Rcon-stl\">C.100: 定义容器的时候要遵循 STL</a></li>\n<li><a href=\"#Rcon-val\">C.101: 为容器提供值语义</a></li>\n<li><a href=\"#Rcon-move\">C.102: 为容器提供移动操作</a></li>\n<li><a href=\"#Rcon-init\">C.103: 为容器提供一个初始化式列表构造函数</a></li>\n<li><a href=\"#Rcon-empty\">C.104: 为容器提供一个将之置空的默认构造函数</a></li>\n<li>???</li>\n<li><a href=\"#Rcon-ptr\">C.109: 当资源包装类具有指针语义时，应提供  <code>*</code>  和  <code>-&gt;</code> </a></li>\n</ul>\n<p><strong>参见</strong>: <a href=\"#S-resource\">资源</a></p>\n<h3 id=\"a-namercon-stlac100-定义容器的时候要遵循-stl\"><a class=\"markdownIt-Anchor\" href=\"#a-namercon-stlac100-定义容器的时候要遵循-stl\">#</a> <a name=\"Rcon-stl\"></a>C.100: 定义容器的时候要遵循 STL</h3>\n<h5 id=\"理由-125\"><a class=\"markdownIt-Anchor\" href=\"#理由-125\">#</a> 理由</h5>\n<p>大多数 C++ 程序员都熟悉 STL 容器，而且它们具有本质上十分健全的设计。</p>\n<h5 id=\"注解-148\"><a class=\"markdownIt-Anchor\" href=\"#注解-148\">#</a> 注解</h5>\n<p>当然也存在其他的本质上健全的设计风格，有时候也存在不遵循<br>\n标准程序库的设计风格的各种理由，但在没有非常坚实的理由的情况下，<br>\n让实现者和用户都遵循标准，既简单又容易。</p>\n<p>尤其是， <code>std::vector</code>  和  <code>std::map</code>  都提供了相当简单的模型。</p>\n<h5 id=\"示例-115\"><a class=\"markdownIt-Anchor\" href=\"#示例-115\">#</a> 示例</h5>\n<pre><code>// 简化版本（比如没有分配器）：\n\ntemplate&lt;typename T&gt;\nclass Sorted_vector &#123;\n    using value_type = T;\n    // ... 各迭代器类型 ...\n\n    Sorted_vector() = default;\n    Sorted_vector(initializer_list&lt;T&gt;);    // 初始化式列表构造函数：进行排序并存储\n    Sorted_vector(const Sorted_vector&amp;) = default;\n    Sorted_vector(Sorted_vector&amp;&amp;) = default;\n    Sorted_vector&amp; operator=(const Sorted_vector&amp;) = default;   // 复制赋值\n    Sorted_vector&amp; operator=(Sorted_vector&amp;&amp;) = default;        // 移动赋值\n    ~Sorted_vector() = default;\n\n    Sorted_vector(const std::vector&lt;T&gt;&amp; v);   // 存储并排序\n    Sorted_vector(std::vector&lt;T&gt;&amp;&amp; v);        // 排序并“窃取表示”\n\n    const T&amp; operator[](int i) const &#123; return rep[i]; &#125;\n    // 不提供非 const 的直接访问，以维持顺序\n\n    void push_back(const T&amp;);   // 在正确位置插入（不一定在末尾）\n    void push_back(T&amp;&amp;);        // 在正确位置插入（不一定在末尾）\n\n    // ... cbegin(), cend() ...\nprivate:\n    std::vector&lt;T&gt; rep;  // 用一个 std::vector 来持有各元素\n&#125;;\n\ntemplate&lt;typename T&gt; bool operator==(const Sorted_vector&lt;T&gt;&amp;, const Sorted_vector&lt;T&gt;&amp;);\ntemplate&lt;typename T&gt; bool operator!=(const Sorted_vector&lt;T&gt;&amp;, const Sorted_vector&lt;T&gt;&amp;);\n// ...\n</code></pre>\n<p>这段代码遵循 STL 风格但并不完整。<br>\n这种做法并不少见。<br>\n仅仅为特定的容器提供足以使其有意义的功能即可。<br>\n这里的关键在于，定义（对特定容器来说有意义的）符合约定的构造、赋值、析构函数和各迭代器<br>\n并提供它们符合约定的语义。<br>\n在此基础上，可以根据需要对这个容器进行扩展。<br>\n这里添加了来自  <code>std::vector</code>  的一些特殊构造函数。</p>\n<h5 id=\"强制实施-118\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-118\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namercon-valac101-为容器提供值语义\"><a class=\"markdownIt-Anchor\" href=\"#a-namercon-valac101-为容器提供值语义\">#</a> <a name=\"Rcon-val\"></a>C.101: 为容器提供值语义</h3>\n<h5 id=\"理由-126\"><a class=\"markdownIt-Anchor\" href=\"#理由-126\">#</a> 理由</h5>\n<p>常规对象的理解和推理要比非常规对象更加简单。<br>\n使人感觉熟悉。</p>\n<h5 id=\"注解-149\"><a class=\"markdownIt-Anchor\" href=\"#注解-149\">#</a> 注解</h5>\n<p>如果有意义的话，要使容器满足  <code>Regular</code> （概念）。<br>\n尤其是，确保对象与自身的副本比较时相等。</p>\n<h5 id=\"示例-116\"><a class=\"markdownIt-Anchor\" href=\"#示例-116\">#</a> 示例</h5>\n<pre><code>void f(const Sorted_vector&lt;string&gt;&amp; v)\n&#123;\n    Sorted_vector&lt;string&gt; v2 &#123;v&#125;;\n    if (v != v2)\n        cout &lt;&lt; &quot;Behavior against reason and logic.\\n&quot;;\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"强制实施-119\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-119\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namercon-moveac102-为容器提供移动操作\"><a class=\"markdownIt-Anchor\" href=\"#a-namercon-moveac102-为容器提供移动操作\">#</a> <a name=\"Rcon-move\"></a>C.102: 为容器提供移动操作</h3>\n<h5 id=\"理由-127\"><a class=\"markdownIt-Anchor\" href=\"#理由-127\">#</a> 理由</h5>\n<p>容器都有变大的趋势；没有移动构造函数和复制构造函数的对象<br>\n进行到处移动可以很昂贵，因而趋使人们转而传递指向它的指针，<br>\n从而带来资源管理方面的问题。</p>\n<h5 id=\"示例-117\"><a class=\"markdownIt-Anchor\" href=\"#示例-117\">#</a> 示例</h5>\n<pre><code>Sorted_vector&lt;int&gt; read_sorted(istream&amp; is)\n&#123;\n    vector&lt;int&gt; v;\n    cin &gt;&gt; v;   // 假定存在向量的读取操作\n    Sorted_vector&lt;int&gt; sv = v;  // 进行排序\n    return sv;\n&#125;\n</code></pre>\n<p>用户可以合理地假设返回一个标准程序库风格的容器是廉价的。</p>\n<h5 id=\"强制实施-120\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-120\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namercon-initac103-为容器提供一个初始化式列表构造函数\"><a class=\"markdownIt-Anchor\" href=\"#a-namercon-initac103-为容器提供一个初始化式列表构造函数\">#</a> <a name=\"Rcon-init\"></a>C.103: 为容器提供一个初始化式列表构造函数</h3>\n<h5 id=\"理由-128\"><a class=\"markdownIt-Anchor\" href=\"#理由-128\">#</a> 理由</h5>\n<p>人们期望能够以一组值来初始化一个容器。<br>\n使人感觉熟悉。</p>\n<h5 id=\"示例-118\"><a class=\"markdownIt-Anchor\" href=\"#示例-118\">#</a> 示例</h5>\n<pre><code>Sorted_vector&lt;int&gt; sv &#123;1, 3, -1, 7, 0, 0&#125;; // Sorted_vector 按需对其元素进行排序\n</code></pre>\n<h5 id=\"强制实施-121\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-121\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namercon-emptyac104-为容器提供一个将之置空的默认构造函数\"><a class=\"markdownIt-Anchor\" href=\"#a-namercon-emptyac104-为容器提供一个将之置空的默认构造函数\">#</a> <a name=\"Rcon-empty\"></a>C.104: 为容器提供一个将之置空的默认构造函数</h3>\n<h5 id=\"理由-129\"><a class=\"markdownIt-Anchor\" href=\"#理由-129\">#</a> 理由</h5>\n<p>使其满足  <code>Regular</code> 。</p>\n<h5 id=\"示例-119\"><a class=\"markdownIt-Anchor\" href=\"#示例-119\">#</a> 示例</h5>\n<pre><code>vector&lt;Sorted_sequence&lt;string&gt;&gt; vs(100);    // 100 个 Sorted_sequence，值均为 &quot;&quot;\n</code></pre>\n<h5 id=\"强制实施-122\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-122\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namercon-ptrac109-当资源包装类具有指针语义时应提供-和-\"><a class=\"markdownIt-Anchor\" href=\"#a-namercon-ptrac109-当资源包装类具有指针语义时应提供-和-\">#</a> <a name=\"Rcon-ptr\"></a>C.109: 当资源包装类具有指针语义时，应提供  <code>*</code>  和  <code>-&gt;</code></h3>\n<h5 id=\"理由-130\"><a class=\"markdownIt-Anchor\" href=\"#理由-130\">#</a> 理由</h5>\n<p>这正是对指针所预期的行为，<br>\n使人感觉熟悉。</p>\n<h5 id=\"示例-120\"><a class=\"markdownIt-Anchor\" href=\"#示例-120\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"强制实施-123\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-123\">#</a> 强制实施</h5>\n<p>???</p>\n<h2 id=\"a-namess-lambdasaclambdas-函数对象和-lambda\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-lambdasaclambdas-函数对象和-lambda\">#</a> <a name=\"SS-lambdas\"></a>C.lambdas: 函数对象和 lambda</h2>\n<p>函数对象是提供了重载的  <code>()</code>  的对象，因此可以进行调用。<br>\nLambda 表达式（通常通俗地简称为 “lambda”）是一种产生函数对象的写法。<br>\n函数对象应当可廉价地复制（因此可以<a href=\"#Rf-in\">按值传递</a>）。</p>\n<p>概要：</p>\n<ul>\n<li><a href=\"#Rf-name\">F.10: 若操作可被重用，则应为其命名</a></li>\n<li><a href=\"%5B#Rf-lambda\">F.11: 当需要仅在一处使用的简单函数对象时使用无名 lambda</a></li>\n<li><a href=\"#Rf-capture-vs-overload\">F.50: 无法用函数达成（捕捉局部变量，或者编写局部函数）时，应使用 lambda</a></li>\n<li><a href=\"#Rf-reference-capture\">F.52: 在将被局部范围内使用（包括将之传递给算法）的 lambda 中优先按引用捕捉</a></li>\n<li><a href=\"#Rf-value-capture\">F.53: 在不被局部范围内使用（包括存储在堆上，或传递给其他线程）的 lambda 中避免按引用捕捉</a></li>\n<li><a href=\"#Res-lambda-init\">ES.28: 针对复杂的初始化（尤其是  <code>const</code>  变量）使用 lambda</a></li>\n</ul>\n<h2 id=\"a-namess-hierachier-类层次oop\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-hierachier-类层次oop\">#</a> <a name=\"SS-hier\"></a>C.hier: 类层次（OOP）</h2>\n<p>构建类层次（仅）用于表达一组按层次组织的概念。<br>\n基类通常都表现为接口。<br>\n类层次有两种主要的用法，它们通常被叫做实现继承和接口继承。</p>\n<p>类层次规则概览：</p>\n<ul>\n<li><a href=\"#Rh-domain\">C.120: 类层次（仅）用于表达具有天然层次化结构的概念</a></li>\n<li><a href=\"#Rh-abstract\">C.121: 如果基类被用作接口的话，应使其成为纯抽象类</a></li>\n<li><a href=\"#Rh-separation\">C.122: 当需要完全区分接口和实现时，应当用抽象类作为接口</a></li>\n</ul>\n<p>类层次的设计规则概览：</p>\n<ul>\n<li><a href=\"#Rh-abstract-ctor\">C.126: 抽象类通常并不需要用户编写的构造函数</a></li>\n<li><a href=\"#Rh-dtor\">C.127: 带有虚函数的类应当带有虚的或受保护的析构函数</a></li>\n<li><a href=\"#Rh-override\">C.128: 虚函数应当指明  <code>virtual</code> 、 <code>override</code> 、 <code>final</code>  三者之一</a></li>\n<li><a href=\"#Rh-kind\">C.129: 当设计类层次时，应区分实现继承和接口继承</a></li>\n<li><a href=\"#Rh-copy\">C.130: 多态类的深拷贝；优先采用虚函数  <code>clone</code>  来替代公开复制构造 / 赋值</a></li>\n<li><a href=\"#Rh-get\">C.131: 避免无价值的取值和设值函数</a></li>\n<li><a href=\"#Rh-virtual\">C.132: 请勿无理由地使函数  <code>virtual</code> </a></li>\n<li><a href=\"#Rh-protected\">C.133: 避免  <code>protected</code>  数据</a></li>\n<li><a href=\"#Rh-public\">C.134: 确保所有非  <code>const</code>  数据成员有相同的访问级别</a></li>\n<li><a href=\"#Rh-mi-interface\">C.135: 用多继承来表达多个不同的接口</a></li>\n<li><a href=\"#Rh-mi-implementation\">C.136: 用多继承来表达一些实现特性的合并</a></li>\n<li><a href=\"#Rh-vbase\">C.137: 用  <code>virtual</code>  基类以避免过于通用的基类</a></li>\n<li><a href=\"#Rh-using\">C.138: 用  <code>using</code>  来为派生类和其基类建立重载集合</a></li>\n<li><a href=\"#Rh-final\">C.139: 对类运用  <code>final</code>  应当保守</a></li>\n<li><a href=\"#Rh-virtual-default-arg\">C.140: 不要在虚函数和其覆盖函数上提供不同的默认参数</a></li>\n</ul>\n<p>对类层次中的对象进行访问的规则概览：</p>\n<ul>\n<li><a href=\"#Rh-poly\">C.145: 通过指针和引用来访问多态对象</a></li>\n<li><a href=\"#Rh-dynamic_cast\">C.146: 当无法避免在类层次上进行导航时应使用  <code>dynamic_cast</code> </a></li>\n<li><a href=\"#Rh-ref-cast\">C.147: 当查找所需类的失败被当做一种错误时，应当对引用类型使用  <code>dynamic_cast</code> </a></li>\n<li><a href=\"#Rh-ptr-cast\">C.148: 当查找所需类的失败被当做一种有效的可能情况时，应当对指针类型使用  <code>dynamic_cast</code> </a></li>\n<li><a href=\"#Rh-smart\">C.149: 用  <code>unique_ptr</code>  或  <code>shared_ptr</code>  来避免忘记对以  <code>new</code>  所创建的对象进行  <code>delete</code>  的情况</a></li>\n<li><a href=\"#Rh-make_unique\">C.150: 用  <code>make_unique()</code>  来构建由  <code>unique_ptr</code>  所拥有的对象</a></li>\n<li><a href=\"#Rh-make_shared\">C.151: 用  <code>make_shared()</code>  来构建由  <code>shared_ptr</code>  所拥有的对象</a></li>\n<li><a href=\"#Rh-array\">C.152: 禁止把指向派生类对象的数组的指针赋值给指向基类的指针</a></li>\n<li><a href=\"#Rh-use-virtual\">C.153: 优先采用虚函数而不是强制转换</a></li>\n</ul>\n<h3 id=\"a-namerh-domainac120-使用类层次来表达具有天然层次化结构的概念\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-domainac120-使用类层次来表达具有天然层次化结构的概念\">#</a> <a name=\"Rh-domain\"></a>C.120: 使用类层次来表达具有天然层次化结构的概念</h3>\n<h5 id=\"理由-131\"><a class=\"markdownIt-Anchor\" href=\"#理由-131\">#</a> 理由</h5>\n<p>直接在代码中表达想法可以简化理解和维护工作。应当保证各个基类所表达的想法与全部派生类型精确匹配，并且确实找不到比使用继承所带来的紧耦合方式更好的表达方式。</p>\n<p>当单纯使用数据成员就能搞定时请<em>不要</em>使用继承。这种情况通常意味着派生类型需要覆盖某个基类虚函数或者需要访问某个受保护成员。</p>\n<h5 id=\"示例-121\"><a class=\"markdownIt-Anchor\" href=\"#示例-121\">#</a> 示例</h5>\n<pre><code>class DrawableUIElement &#123;\npublic:\n    virtual void render() const = 0;\n    // ...\n&#125;;\n\nclass AbstractButton : public DrawableUIElement &#123;\npublic:\n    virtual void onClick() = 0;\n    // ...\n&#125;;\n\nclass PushButton : public AbstractButton &#123;\n    void render() const override;\n    void onClick() override;\n    // ...\n&#125;;\n\nclass Checkbox : public AbstractButton &#123;\n// ...\n&#125;;\n</code></pre>\n<h5 id=\"示例不好-50\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-50\">#</a> 示例，不好</h5>\n<p>请<em>不要</em>把非层次化的领域概念表示成类层次。</p>\n<pre><code>template&lt;typename T&gt;\nclass Container &#123;\npublic:\n    // 列表操作：\n    virtual T&amp; get() = 0;\n    virtual void put(T&amp;) = 0;\n    virtual void insert(Position) = 0;\n    // ...\n    // 向量操作：\n    virtual T&amp; operator[](int) = 0;\n    virtual void sort() = 0;\n    // ...\n    // 树操作：\n    virtual void balance() = 0;\n    // ...\n&#125;;\n</code></pre>\n<p>大多数派生类都无法恰当实现这个接口所要求的大多数函数。<br>\n因而这个基类成为了一个实现负担。<br>\n此外， <code>Container</code>  的使用者无法依靠成员函数来相当高效地确实实施某个有意义的操作；<br>\n它可能会抛出某个异常。<br>\n因此使用者只得诉诸于运行时检查，并且<br>\n放弃使用这个（过于）一般化的接口，代之以某种运行时类型查询（比如  <code>dynamic_cast</code> ）所确定的接口。</p>\n<h5 id=\"强制实施-124\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-124\">#</a> 强制实施</h5>\n<ul>\n<li>寻找带有许多不干别的只会抛出异常的成员的类。</li>\n<li>对非公用基类  <code>B</code>  的每次使用进行标记，其中派生类  <code>D</code>  并未覆盖  <code>B</code>  的某个虚函数，或访问某个受保护成员，而  <code>B</code>  并非以下情况：为空，为  <code>D</code>  的模板参数或参数包组，或者为以  <code>D</code>  所特化的类模板。</li>\n</ul>\n<h3 id=\"a-namerh-abstractac121-如果基类被用作接口的话应使其成为纯抽象类\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-abstractac121-如果基类被用作接口的话应使其成为纯抽象类\">#</a> <a name=\"Rh-abstract\"></a>C.121: 如果基类被用作接口的话，应使其成为纯抽象类</h3>\n<h5 id=\"理由-132\"><a class=\"markdownIt-Anchor\" href=\"#理由-132\">#</a> 理由</h5>\n<p>不包含数据的类更加稳定（更不脆弱易变）。<br>\n接口通常都应当全部由公开的纯虚函数和一个预置的或为空的虚析构函数组成。</p>\n<h5 id=\"示例-122\"><a class=\"markdownIt-Anchor\" href=\"#示例-122\">#</a> 示例</h5>\n<pre><code>class My_interface &#123;\npublic:\n    // ... 只有一个纯虚函数 ...\n    virtual ~My_interface() &#123;&#125;   // 或者 =default\n&#125;;\n</code></pre>\n<h5 id=\"示例不好-51\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-51\">#</a> 示例，不好</h5>\n<pre><code>class Goof &#123;\npublic:\n    // ... 只有一个纯虚函数 ...\n    // 没有虚析构函数\n&#125;;\n\nclass Derived : public Goof &#123;\n    string s;\n    // ...\n&#125;;\n\nvoid use()\n&#123;\n    unique_ptr&lt;Goof&gt; p &#123;new Derived&#123;&quot;here we go&quot;&#125;&#125;;\n    f(p.get()); // 通过 Goof 接口使用 Derived\n    g(p.get()); // 通过 Goof 接口使用 Derived\n&#125; // 泄漏\n</code></pre>\n<p><code>Derived</code>  是通过其  <code>Goof</code>  接口而被  <code>delete</code>  的，而它的  <code>string</code>  则泄漏了。<br>\n为  <code>Goof</code>  提供虚析构函数就能使其都正常工作。</p>\n<h5 id=\"强制实施-125\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-125\">#</a> 强制实施</h5>\n<ul>\n<li>对任何含有数据成员同时带有并非从基类继承的可被覆盖（非  <code>final</code> ）的虚函数的类给出警告。</li>\n</ul>\n<h3 id=\"a-namerh-separationac122-当需要完全区分接口和实现时应当用抽象类作为接口\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-separationac122-当需要完全区分接口和实现时应当用抽象类作为接口\">#</a> <a name=\"Rh-separation\"></a>C.122: 当需要完全区分接口和实现时，应当用抽象类作为接口</h3>\n<h5 id=\"理由-133\"><a class=\"markdownIt-Anchor\" href=\"#理由-133\">#</a> 理由</h5>\n<p>诸如在 ABI（连接）边界这种地方。</p>\n<h5 id=\"示例-123\"><a class=\"markdownIt-Anchor\" href=\"#示例-123\">#</a> 示例</h5>\n<pre><code>struct Device &#123;\n    virtual ~Device() = default;\n    virtual void write(span&lt;const char&gt; outbuf) = 0;\n    virtual void read(span&lt;char&gt; inbuf) = 0;\n&#125;;\n\nclass D1 : public Device &#123;\n    // ... 数据 ...\n\n    void write(span&lt;const char&gt; outbuf) override;\n    void read(span&lt;char&gt; inbuf) override;\n&#125;;\n\nclass D2 : public Device &#123;\n    // ... 不同的数据 ...\n\n    void write(span&lt;const char&gt; outbuf) override;\n    void read(span&lt;char&gt; inbuf) override;\n&#125;;\n</code></pre>\n<p>使用者可以通过由  <code>Device</code>  所提供的接口来互换地使用  <code>D1</code>  和  <code>D2</code> 。<br>\n而且，只要其访问一直是通过  <code>Device</code>  进行的话，也可以以与老版本二进制不兼容的方式来更新  <code>D1</code>  和  <code>D2</code> 。</p>\n<h5 id=\"强制实施-126\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-126\">#</a> 强制实施</h5>\n<pre><code>???\n</code></pre>\n<h2 id=\"chierclass-类层次的设计\"><a class=\"markdownIt-Anchor\" href=\"#chierclass-类层次的设计\">#</a> C.hierclass: 类层次的设计：</h2>\n<h3 id=\"a-namerh-abstract-ctorac126-抽象类通常并不需要用户编写的构造函数\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-abstract-ctorac126-抽象类通常并不需要用户编写的构造函数\">#</a> <a name=\"Rh-abstract-ctor\"></a>C.126: 抽象类通常并不需要用户编写的构造函数</h3>\n<h5 id=\"理由-134\"><a class=\"markdownIt-Anchor\" href=\"#理由-134\">#</a> 理由</h5>\n<p>通常抽象类并没有任何需要由构造函数来初始化的对象。</p>\n<h5 id=\"示例-124\"><a class=\"markdownIt-Anchor\" href=\"#示例-124\">#</a> 示例</h5>\n<pre><code>class Shape &#123;\npublic:\n    // 抽象基类中不需要用户编写的构造函数\n    virtual Point center() const = 0;    // 纯虚\n    virtual void move(Point to) = 0;\n    // ... 其他纯虚函数 ...\n    virtual ~Shape() &#123;&#125;                 // 析构函数\n&#125;;\n\nclass Circle : public Shape &#123;\npublic:\n    Circle(Point p, int rad);           // 派生类中的构造函数\n    Point center() const override &#123; return x; &#125;\n&#125;;\n</code></pre>\n<h5 id=\"例外-29\"><a class=\"markdownIt-Anchor\" href=\"#例外-29\">#</a> 例外</h5>\n<ul>\n<li>有任务的基类构造函数，比如把对象注册到什么地方的时候，可能是需要构造函数的。</li>\n<li>在极端少见的情况下，你可能发觉让抽象类来包含一点所有派生类都会共享的数据是有意义的<br>\n（比如说，使用情况统计数据，调试信息等）；这样的类倾向于带有构造函数。但应当警醒的是：这样的类也倾向于要求进行虚继承。</li>\n</ul>\n<h5 id=\"强制实施-127\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-127\">#</a> 强制实施</h5>\n<p>对带有构造函数的抽象类进行标记。</p>\n<h3 id=\"a-namerh-dtorac127-带有虚函数的类应当带有虚的或受保护的析构函数\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-dtorac127-带有虚函数的类应当带有虚的或受保护的析构函数\">#</a> <a name=\"Rh-dtor\"></a>C.127: 带有虚函数的类应当带有虚的或受保护的析构函数</h3>\n<h5 id=\"理由-135\"><a class=\"markdownIt-Anchor\" href=\"#理由-135\">#</a> 理由</h5>\n<p>带有虚函数的类通常是通过指向基类的指针来使用的。一般来说，最后一个使用者必须在基类指针上执行  <code>delete</code> ，这常常是通过基类智能指针来做到的，因而析构函数应当为  <code>public</code>  和  <code>virtual</code> 。而不那么常见的情况是当并不打算支持通过基类指针来删除时，这时析构函数应当为  <code>protected</code>  和非  <code>virtual</code> ；参见 <a href=\"#Rc-dtor-virtual\">C.35</a>。</p>\n<h5 id=\"示例不好-52\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-52\">#</a> 示例，不好</h5>\n<pre><code>struct B &#123;\n    virtual int f() = 0;\n    // ... 没有用户编写的析构函数，缺省为 public 非 virtual ...\n&#125;;\n\n// 不好：继承于没有虚析构函数的类\nstruct D : B &#123;\n    string s &#123;&quot;default&quot;&#125;;\n    // ...\n&#125;;\n\nvoid use()\n&#123;\n    unique_ptr&lt;B&gt; p = make_unique&lt;D&gt;();\n    // ...\n&#125; // 未定义行为。可能仅仅调用了 B::~B 而字符串则被泄漏了\n</code></pre>\n<h5 id=\"注解-150\"><a class=\"markdownIt-Anchor\" href=\"#注解-150\">#</a> 注解</h5>\n<p>有些人不遵守本条规则，因为他们打算仅通过  <code>shared_ptr</code>  来使用这些类： <code>std::shared_ptr&lt;B&gt; p = std::make_shared&lt;D&gt;(args);</code>  这种情况下，由共享指针来负责删除对象，因此并不会发生不适当的基类  <code>delete</code>  所导致的泄漏。坚持一贯这样做的人可能会得到假阳性的警告，但这条规则其实很重要 —— 当通过  <code>make_unique</code>  分配对象时会如何呢？这样的话是不安全的，除非  <code>B</code>  的作者保证它不会被误用，比如可以让所有的构造函数为私有的并提供一个工厂函数，来强制保证分配都是通过  <code>make_shared</code>  进行。</p>\n<h5 id=\"强制实施-128\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-128\">#</a> 强制实施</h5>\n<ul>\n<li>带有任何虚函数的类的析构函数应当要么是  <code>public</code>  和  <code>virtual</code> ，要么是  <code>protected</code>  和非  <code>virtual</code>  的。</li>\n<li>把对带有虚函数但没有虚析构函数的类的  <code>delete</code>  标记出来。</li>\n</ul>\n<h3 id=\"a-namerh-overrideac128-虚函数应当指明-virtual-override-final-三者之一\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-overrideac128-虚函数应当指明-virtual-override-final-三者之一\">#</a> <a name=\"Rh-override\"></a>C.128: 虚函数应当指明  <code>virtual</code> 、 <code>override</code> 、 <code>final</code>  三者之一</h3>\n<h5 id=\"理由-136\"><a class=\"markdownIt-Anchor\" href=\"#理由-136\">#</a> 理由</h5>\n<p>可读性。<br>\n检测错误。<br>\n明确写下的  <code>virtual</code> 、 <code>override</code>  或  <code>final</code>  是自说明的，并使编译器可以检查到基类和派生类之间的类型和 / 或名字的不匹配。不过写出超过一个则不仅多余而且是潜在的错误来源。</p>\n<p>可以遵循简单明确的含义：</p>\n<ul>\n<li><code>virtual</code>  刚好仅仅表明 “这是一个新的虚函数”。</li>\n<li><code>override</code>  刚好仅仅表明 “这是一个非最终覆盖函数”。</li>\n<li><code>final</code>  刚好仅仅表明 “这是一个最终覆盖函数”。</li>\n</ul>\n<h5 id=\"示例不好-53\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-53\">#</a> 示例，不好</h5>\n<pre><code>struct B &#123;\n    void f1(int);\n    virtual void f2(int) const;\n    virtual void f3(int);\n    // ...\n&#125;;\n\nstruct D : B &#123;\n    void f1(int);        // 不好（希望会有警告）: D::f1() 隐藏了 B::f1()\n    void f2(int) const;  // 不好（但惯用且合法）: 没有明确 override\n    void f3(double);     // 不好（希望会有警告）: D::f3() 隐藏了 B::f3()\n    // ...\n&#125;;\n</code></pre>\n<h5 id=\"示例好-11\"><a class=\"markdownIt-Anchor\" href=\"#示例好-11\">#</a> 示例，好</h5>\n<pre><code>struct Better : B &#123;\n    void f1(int) override;        // 错误（被发现）: Better::f1() 隐藏了 B::f1()\n    void f2(int) const override;\n    void f3(double) override;     // 错误（被发现）: Better::f3() 隐藏了 B::f3()\n    // ...\n&#125;;\n</code></pre>\n<h4 id=\"讨论-3\"><a class=\"markdownIt-Anchor\" href=\"#讨论-3\">#</a> 讨论</h4>\n<p>我们希望消除两种特定类型的错误：</p>\n<ul>\n<li><strong>隐式虚函数</strong>：程序员有意使函数隐含为虚函数，而它确实如此（但代码的读者搞不清楚这点）；或者，程序员有意使函数隐含为虚函数，但它并非如此（例如，由于微妙的参数列表不匹配所导致）；或者，程序员并非有意使函数为虚函数，但它却成为虚函数（由于它刚好与基类中的某个虚函数具有相同的签名）</li>\n<li><strong>隐式覆盖</strong>：程序员有意使函数隐式地成为覆盖函数，而它确实如此（但代码的读者搞不清楚这点）；或者，程序员有意使函数隐式地成为覆盖函数，但它并非如此（例如，由于微妙的参数列表不匹配）；或者，程序员并非有意使函数成为覆盖函数，但它却成为覆盖函数（由于它刚好与基类中的某个虚函数具有相同的签名 – 注意无论这个函数是否被显式声明为虚函数都会发生这个问题，因为程序员的意图既可能是要创建一个新的虚函数也可能要创建一个新的非虚函数）</li>\n</ul>\n<p>注意：对于定义为  <code>final</code>  的类来说，是否在一个虚函数上标记  <code>override</code>  或  <code>final</code>  是无所谓的。</p>\n<p>注意：对函数使用  <code>final</code>  要保守。它不一定会带来优化，但会排除进一步的覆盖。</p>\n<h5 id=\"强制实施-129\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-129\">#</a> 强制实施</h5>\n<ul>\n<li>比较基类和派生类中的虚函数的名字，并对并未进行覆盖的相同名字的使用进行标记。</li>\n<li>对既没有  <code>override</code>  也没有  <code>final</code>  的覆盖函数进行标记。</li>\n<li>对函数声明中使用  <code>virtual</code> 、 <code>override</code>  和  <code>final</code>  中超过一个的情况进行标记。</li>\n</ul>\n<h3 id=\"a-namerh-kindac129-当设计类层次时应区分实现继承和接口继承\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-kindac129-当设计类层次时应区分实现继承和接口继承\">#</a> <a name=\"Rh-kind\"></a>C.129: 当设计类层次时，应区分实现继承和接口继承</h3>\n<h5 id=\"理由-137\"><a class=\"markdownIt-Anchor\" href=\"#理由-137\">#</a> 理由</h5>\n<p>接口中的实现细节会使接口变得脆弱；<br>\n就是说，当实现被改变时其用户不得不进行重新编译。<br>\n基类中的数据增加了基类实现的复杂性，而且会导致代码的重复。</p>\n<h5 id=\"注解-151\"><a class=\"markdownIt-Anchor\" href=\"#注解-151\">#</a> 注解</h5>\n<p>定义：</p>\n<ul>\n<li>接口继承，是使用继承来把用户和实现进行分离，<br>\n特别是允许添加和修改派生类而不影响基类的用户。</li>\n<li>实现继承，是使用继承来简化新设施的实现，<br>\n通过将有用的操作提供给相关的新操作的实现者（有时候称作 “差异式编程”）。</li>\n</ul>\n<p>纯粹的接口类只是一组纯虚函数；参见 <a href=\"#Ri-abstract\">I.25</a>。</p>\n<p>在早期的 OOP 时代（比如 80 和 90 年代），实现继承和接口继承通常是混在一起的，<br>\n而不良习惯则很难改掉。<br>\n即便是现在，这种混合在旧代码和老式的教学材料中也不少见。</p>\n<p>对两种继承进行区分的重要性随着以下情形而增长：</p>\n<ul>\n<li>类层次的大小（比如几十个派生类），</li>\n<li>类层次的使用时期（比如几十年），以及</li>\n<li>使用这个类层次的独立团体的数量<br>\n（比如，可能对分发和更新某个基类造成困难）</li>\n</ul>\n<h5 id=\"示例不好-54\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-54\">#</a> 示例，不好</h5>\n<pre><code>class Shape &#123;   // 不好，混合了接口和实现\npublic:\n    Shape();\n    Shape(Point ce = &#123;0, 0&#125;, Color co = none): cent&#123;ce&#125;, col &#123;co&#125; &#123; /* ... */&#125;\n\n    Point center() const &#123; return cent; &#125;\n    Color color() const &#123; return col; &#125;\n\n    virtual void rotate(int) = 0;\n    virtual void move(Point p) &#123; cent = p; redraw(); &#125;\n\n    virtual void redraw();\n\n    // ...\nprivate:\n    Point cent;\n    Color col;\n&#125;;\n\nclass Circle : public Shape &#123;\npublic:\n    Circle(Point c, int r) : Shape&#123;c&#125;, rad&#123;r&#125; &#123; /* ... */ &#125;\n\n    // ...\nprivate:\n    int rad;\n&#125;;\n\nclass Triangle : public Shape &#123;\npublic:\n    Triangle(Point p1, Point p2, Point p3); // 计算中心点\n    // ...\n&#125;;\n</code></pre>\n<p>问题：</p>\n<ul>\n<li>随着类层次的增长和向  <code>Shape</code>  添加更多的数据，构造函数会越发难于编写和维护。</li>\n<li>为什么要计算  <code>Triangle</code>  的中心点？我们也许从不用它。</li>\n<li>向  <code>Shape</code>  添加新的数据成员（比如绘制风格或者画布）<br>\n将导致所有派生于  <code>Shape</code>  的类和所有使用  <code>Shape</code>  的代码都需要进行复审，可能需要修改，而且很可能需要重新编译。</li>\n</ul>\n<p><code>Shape::move()</code>  的实现就是实现继承的一个例子：<br>\n我们为所有派生类一次性定义  <code>move()</code> 。<br>\n在这种基类成员函数实现中的代码越多，在基类中放入的共享数据越多，<br>\n就能获得越多的好处 —— 而类层次则越不稳定。</p>\n<h5 id=\"示例-125\"><a class=\"markdownIt-Anchor\" href=\"#示例-125\">#</a> 示例</h5>\n<p>这个  <code>Shape</code>  类层次可以用接口继承重新编写：</p>\n<pre><code>class Shape &#123;  // 纯接口\npublic:\n    virtual Point center() const = 0;\n    virtual Color color() const = 0;\n\n    virtual void rotate(int) = 0;\n    virtual void move(Point p) = 0;\n\n    virtual void redraw() = 0;\n\n    // ...\n&#125;;\n</code></pre>\n<p>注意纯接口很少会有构造函数：没什么需要构造的。</p>\n<pre><code>class Circle : public Shape &#123;\npublic:\n    Circle(Point c, int r, Color c) : cent&#123;c&#125;, rad&#123;r&#125;, col&#123;c&#125; &#123; /* ... */ &#125;\n\n    Point center() const override &#123; return cent; &#125;\n    Color color() const override &#123; return col; &#125;\n\n    // ...\nprivate:\n    Point cent;\n    int rad;\n    Color col;\n&#125;;\n</code></pre>\n<p>接口不再那么脆弱了，但成员函数的实现需要做更多工作。<br>\n比如说，每个派生于  <code>Shape</code>  的类都得实现  <code>center</code> 。</p>\n<h5 id=\"示例双类层次\"><a class=\"markdownIt-Anchor\" href=\"#示例双类层次\">#</a> 示例，双类层次</h5>\n<p>如何才能同时获得接口继承的稳定类层次的好处和实现继承的实现重用的好处呢？<br>\n一种流行的技巧是双类层次。<br>\n有许多实现双类层次的方式；这里，我们使用一种多重继承形式。</p>\n<p>首先规划一个接口类的层次：</p>\n<pre><code>class Shape &#123;   // 纯接口\npublic:\n    virtual Point center() const = 0;\n    virtual Color color() const = 0;\n\n    virtual void rotate(int) = 0;\n    virtual void move(Point p) = 0;\n\n    virtual void redraw() = 0;\n\n    // ...\n&#125;;\n\nclass Circle : public virtual Shape &#123;   // 纯接口\npublic:\n    virtual int radius() = 0;\n    // ...\n&#125;;\n</code></pre>\n<p>为使这个接口有用处，我们必须提供其实现类（我们这里用相同的名字，但放入  <code>Impl</code>  命名空间）：</p>\n<pre><code>class Impl::Shape : public virtual ::Shape &#123; // 实现\npublic:\n    // 构造函数，析构函数\n    // ...\n    Point center() const override &#123; /* ... */ &#125;\n    Color color() const override &#123; /* ... */ &#125;\n\n    void rotate(int) override &#123; /* ... */ &#125;\n    void move(Point p) override &#123; /* ... */ &#125;\n\n    void redraw() override &#123; /* ... */ &#125;\n\n    // ...\n&#125;;\n</code></pre>\n<p>现在  <code>Shape</code>  是一个贫乏的具有一个实现的类的例子，<br>\n但还请谅解，因为这只是用来展现一种针对更复杂的类层次的技巧的简单例子。</p>\n<pre><code>class Impl::Circle : public virtual ::Circle, public Impl::Shape &#123;   // 实现\npublic:\n    // 构造函数，析构函数\n\n    int radius() override &#123; /* ... */ &#125;\n    // ...\n&#125;;\n</code></pre>\n<p>我们可以通过添加一个  <code>Smiley</code>  类来扩展它（😃）：</p>\n<pre><code>class Smiley : public virtual Circle &#123; // 纯接口\npublic:\n    // ...\n&#125;;\n\nclass Impl::Smiley : public virtual ::Smiley, public Impl::Circle &#123;   // 实现\npublic:\n    // 构造函数，析构函数\n    // ...\n&#125;\n</code></pre>\n<p>这里有两个类层次：</p>\n<ul>\n<li>接口：Smiley -&gt; Circle -&gt; Shape</li>\n<li>实现：Impl::Smiley -&gt; Impl::Circle -&gt; Impl::Shape</li>\n</ul>\n<p>由于每个实现都同时派生于其接口和其实现基类，我们因此获得了一个晶格（DAG）：</p>\n<pre><code>Smiley     -&gt;         Circle     -&gt;  Shape\n  ^                     ^               ^\n  |                     |               |\nImpl::Smiley -&gt; Impl::Circle -&gt; Impl::Shape\n</code></pre>\n<p>我们曾经说过，这只是用来构造双类层次的一种方式。</p>\n<p>可以直接使用实现类层次，而不用通过抽象接口来进行。</p>\n<pre><code>void work_with_shape(Shape&amp;);\n\nint user()\n&#123;\n    Impl::Smiley my_smiley&#123; /* args */ &#125;;   // 创建具体的形状\n    // ...\n    my_smiley.some_member();        // 直接使用实现类\n    // ...\n    work_with_shape(my_smiley);     // 通过抽象接口使用实现\n    // ...\n&#125;\n</code></pre>\n<p>这种做法在实现类带有并未由抽象接口提供的成员时，<br>\n或者当直接使用某个成员具有优化机会（比如当实现成员函数为  <code>final</code> ）时，比较有用。</p>\n<h5 id=\"注解-152\"><a class=\"markdownIt-Anchor\" href=\"#注解-152\">#</a> 注解</h5>\n<p>分离接口和实现的另一个（相关的）技巧是 <a href=\"#Ri-pimpl\">Pimpl</a>。</p>\n<h5 id=\"注解-153\"><a class=\"markdownIt-Anchor\" href=\"#注解-153\">#</a> 注解</h5>\n<p>在提供公共的功能时，我们通常需要在作为（有实现的）基类函数和（在某个实现命名空间中的）<br>\n自由函数之间进行选择。<br>\n基类能够提供更简短的写法，以及更容易访问（基类中的）共享数据，<br>\n但所付出的是其功能将仅能被这个类层次的用户所使用。</p>\n<h5 id=\"强制实施-130\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-130\">#</a> 强制实施</h5>\n<ul>\n<li>若派生类向基类转换的基类同时具有数据和虚函数，则对其进行标记<br>\n（但排除在派生类成员中对基类成员的调用）。</li>\n<li>???</li>\n</ul>\n<h3 id=\"a-namerh-copyac130-多态类的深拷贝优先采用虚函数-clone-来替代公开复制构造赋值\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-copyac130-多态类的深拷贝优先采用虚函数-clone-来替代公开复制构造赋值\">#</a> <a name=\"Rh-copy\"></a>C.130: 多态类的深拷贝；优先采用虚函数  <code>clone</code>  来替代公开复制构造 / 赋值</h3>\n<h5 id=\"理由-138\"><a class=\"markdownIt-Anchor\" href=\"#理由-138\">#</a> 理由</h5>\n<p>由于切片的问题，不鼓励多态类的复制操作，参见 <a href=\"#Rc-copy-virtual\">C.67</a>。如果确实需要复制语义的话，应当进行深复制：提供一个虚  <code>clone</code>  函数，它复制的是真正的最终派生类型，并返回指向新对象的具有所有权的指针，而且在派生类中它返回的也是派生类型（利用协变返回类型）。</p>\n<h5 id=\"示例-126\"><a class=\"markdownIt-Anchor\" href=\"#示例-126\">#</a> 示例</h5>\n<pre><code>class B &#123;\npublic:\n    B() = default;\n    virtual ~B() = default;\n    virtual gsl::owner&lt;B*&gt; clone() const = 0;\nprotected:\n     B(const B&amp;) = default;\n     B&amp; operator=(const B&amp;) = default;\n     B(B&amp;&amp;) = default;\n     B&amp; operator=(B&amp;&amp;) = default;\n    // ...\n&#125;;\n\nclass D : public B &#123;\npublic:\n    gsl::owner&lt;D*&gt; clone() override\n    &#123;\n        return new D&#123;*this&#125;;\n    &#125;\n&#125;;\n</code></pre>\n<p>通常来说，推荐使用智能指针来表示所有权（参见 <a href=\"#Rr-owner\">R.20</a>）。不过根据语言规则，协变返回类型不能是智能指针：当  <code>B::clone</code>  返回  <code>unique_ptr&lt;B&gt;</code>  时  <code>D::clone</code>  不能返回  <code>unique_ptr&lt;D&gt;</code> 。因此，你得在所有覆盖函数中统一都返回  <code>unique_ptr&lt;B&gt;</code> ，或者也可以使用<a href=\"#SS-views\">指导方针支持库</a>中的  <code>owner&lt;&gt;</code>  工具类。</p>\n<h3 id=\"a-namerh-getac131-避免无价值的取值和设值函数\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-getac131-避免无价值的取值和设值函数\">#</a> <a name=\"Rh-get\"></a>C.131: 避免无价值的取值和设值函数</h3>\n<h5 id=\"理由-139\"><a class=\"markdownIt-Anchor\" href=\"#理由-139\">#</a> 理由</h5>\n<p>无价值的取值和设值函数没有提供语义价值；让数据项自己  <code>public</code>  是一样的。</p>\n<h5 id=\"示例-127\"><a class=\"markdownIt-Anchor\" href=\"#示例-127\">#</a> 示例</h5>\n<pre><code>class Point &#123;   // 不好：啰嗦\n    int x;\n    int y;\npublic:\n    Point(int xx, int yy) : x&#123;xx&#125;, y&#123;yy&#125; &#123; &#125;\n    int get_x() const &#123; return x; &#125;\n    void set_x(int xx) &#123; x = xx; &#125;\n    int get_y() const &#123; return y; &#125;\n    void set_y(int yy) &#123; y = yy; &#125;\n    // 没有有行为的成员函数\n&#125;;\n</code></pre>\n<p>应当考虑把这个类变为  <code>struct</code> —— 就是一组没有行为的变量，全部都是公开数据而没有成员函数。</p>\n<pre><code>struct Point &#123;\n    int x &#123;0&#125;;\n    int y &#123;0&#125;;\n&#125;;\n</code></pre>\n<p>注意，我们可以为成员变量提供默认初始化式：<a href=\"#Rc-initialize\">C.49: 优先进行初始化而不是在构造函数中赋值</a>.</p>\n<h5 id=\"注解-154\"><a class=\"markdownIt-Anchor\" href=\"#注解-154\">#</a> 注解</h5>\n<p>这条规则的关键在于取值和设值函数的语义是否是平凡的。虽然并非是对 “平凡” 的完整定义，但我们考虑在取值 / 设值函数，以及当使用公开数据成员之间除了语法上的差别之外是否存在什么差别。非平凡的语义的例子可能有：维护类的不变式，或者在某种内部类型和接口类型之间进行的转换。</p>\n<h5 id=\"强制实施-131\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-131\">#</a> 强制实施</h5>\n<p>对大量仅提供单纯的成员访问而没有其他语义的  <code>get</code>  和  <code>set</code>  成员函数进行标记。</p>\n<h3 id=\"a-namerh-virtualac132-请勿无理由地使函数-virtual\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-virtualac132-请勿无理由地使函数-virtual\">#</a> <a name=\"Rh-virtual\"></a>C.132: 请勿无理由地使函数  <code>virtual</code></h3>\n<h5 id=\"理由-140\"><a class=\"markdownIt-Anchor\" href=\"#理由-140\">#</a> 理由</h5>\n<p>多余的  <code>virtual</code>  会增加运行时间和对象代码的大小。<br>\n虚函数可以被覆盖，因此派生类中可能因此发生错误。<br>\n虚函数保证会在模板化的层次中造成代码重复。</p>\n<h5 id=\"示例不好-55\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-55\">#</a> 示例，不好</h5>\n<pre><code>template&lt;class T&gt;\nclass Vector &#123;\npublic:\n    // ...\n    virtual int size() const &#123; return sz; &#125;   // 不好：派生类能得到什么好处？\nprivate:\n    T* elem;   // 元素\n    int sz;    // 元素的数量\n&#125;;\n</code></pre>\n<p>这种类型的 “向量” 并非是为了让人用作基类的。</p>\n<h5 id=\"强制实施-132\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-132\">#</a> 强制实施</h5>\n<ul>\n<li>对带有虚函数但没有派生类的类进行标记。</li>\n<li>对所有成员函数都为虚函数并带有实现的类进行标记。</li>\n</ul>\n<h3 id=\"a-namerh-protectedac133-避免-protected-数据\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-protectedac133-避免-protected-数据\">#</a> <a name=\"Rh-protected\"></a>C.133: 避免  <code>protected</code>  数据</h3>\n<h5 id=\"理由-141\"><a class=\"markdownIt-Anchor\" href=\"#理由-141\">#</a> 理由</h5>\n<p><code>protected</code>  数据是复杂性和错误的一种来源。<br>\n <code>protected</code>  数据会把不变式的陈述搞复杂。<br>\n <code>protected</code>  数据天生违反了避免把数据放入基类的指导原则，而这样通常还会导致不得不采用虚继承。</p>\n<h5 id=\"示例不好-56\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-56\">#</a> 示例，不好</h5>\n<pre><code>class Shape &#123;\npublic:\n    // ... 接口函数 ...\nprotected:\n    // 为派生类所使用的数据：\n    Color fill_color;\n    Color edge_color;\n    Style st;\n&#125;;\n</code></pre>\n<p>这样，由每个所定义的  <code>Shape</code>  来保证对受保护数据正确进行操作。<br>\n这样做一度很流行，但同样是维护性问题的一种主要来源。<br>\n在大型的类层次中，很难保持对受保护数据的一致性使用，因为代码可能有很多，<br>\n分散于大量的类之中。<br>\n能够触碰这些数据的类的集合是开放的：任何人都可以派生一个新的类并开始操作这些受保护数据。<br>\n检查这些类的完整集合通常是不可能做到的，因此对类的表示进行任何改动都是不可行的。<br>\n这些受保护数据上并没有强加的不变式；它们更像是一组全局变量。<br>\n受保护数据在大块代码中事实上成为了全局变量。</p>\n<h5 id=\"注解-155\"><a class=\"markdownIt-Anchor\" href=\"#注解-155\">#</a> 注解</h5>\n<p>受保护数据经常看起来倾向于允许通过派生来进行任意的改进。<br>\n而通常你得到的是肆无忌惮的改动和各种错误。<br>\n应当<a href=\"#Rc-private\">优先采用  <code>private</code>  数据</a>并提供良好定义并强加的不变式。<br>\n或者通常更好的做法是，<a href=\"#Rh-abstract\">不要在用作接口的任何类中存放数据</a>。</p>\n<h5 id=\"注解-156\"><a class=\"markdownIt-Anchor\" href=\"#注解-156\">#</a> 注解</h5>\n<p>受保护的成员函数则没有问题。</p>\n<h5 id=\"强制实施-133\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-133\">#</a> 强制实施</h5>\n<p>对带有  <code>protected</code>  数据的类进行标记。</p>\n<h3 id=\"a-namerh-publicac134-确保所有非-const-数据成员有相同的访问级别\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-publicac134-确保所有非-const-数据成员有相同的访问级别\">#</a> <a name=\"Rh-public\"></a>C.134: 确保所有非  <code>const</code>  数据成员有相同的访问级别</h3>\n<h5 id=\"理由-142\"><a class=\"markdownIt-Anchor\" href=\"#理由-142\">#</a> 理由</h5>\n<p>防止出现会导致错误的逻辑混乱。<br>\n当非  <code>const</code>  数据成员的访问级别不同时，这个类型就会在它应当做什么上出现混乱。<br>\n这个类型是用来维持某个不变式的类型，还是仅仅集合了一组值而已？</p>\n<h5 id=\"探讨-2\"><a class=\"markdownIt-Anchor\" href=\"#探讨-2\">#</a> 探讨</h5>\n<p>其核心问题是：哪段代码应当负责为变量维护有意义 / 正确的值？</p>\n<p>确切地说存在两种数据成员：</p>\n<ul>\n<li>A: 不参与对象的不变式的数据成员。这些成员的任何值的互相组合都是有效的。</li>\n<li>B: 参与对象不变式的数据成员。并非每种值组合都是有意义的（否则就没有不变式了）。因此所有具有对这些变量的写访问权限的代码都应当了解这个不变式，了解其语义，并了解（而且积极实现并加强）用以维持值的正确性的规则。</li>\n</ul>\n<p>A 类别中的数据成员就应当是  <code>public</code> （或者很少情况下，当你只想在派生类中见到它们时为  <code>protected</code> ）。不需要对它们进行封装。系统中的所有代码都可以见到并操控它们。</p>\n<p>B 类别中的数据成员应当为  <code>private</code>  或  <code>const</code> 。这是因为封装很重要。让它们非  <code>private</code>  且非  <code>const</code>  可能意味着对象无法控制自身的状态：这个类以外的无限量的代码可能都需要了解这个不变式，并精确地参与它的维护工作 —— 当这些数据成员都是  <code>public</code>  时，这可能包括使用这个对象的所有调用方代码；而当它们为  <code>protected</code>  时，这可能包括当前以及未来的派生类的所有代码。这会导致易碎的且紧耦合的代码，而且很快将会成为维护的噩梦。任何代码如果把这些数据成员设值为无效的或者预料之外的值的组合，都可能搞坏对象以及随后对象的所有使用。</p>\n<p>大多数的类要么都是 A，要么都是 B：</p>\n<ul>\n<li><em>全 public</em>: 如果编写的是聚集一组变量而没有在这些变量之间维护不变式的话，所有这些变量都应当为  <code>public</code> 。<br>\n<a href=\"#Rc-struct\">依照惯例，应当把这样的类声明为  <code>struct</code>  而不是  <code>class</code> </a></li>\n<li><em>全 private</em>: 如果编写的类型维护了某个不变式，则所有的非  <code>const</code>  变量都应当是  <code>private</code> —— 应当对它进行封装。</li>\n</ul>\n<h5 id=\"例外-30\"><a class=\"markdownIt-Anchor\" href=\"#例外-30\">#</a> 例外</h5>\n<p>偶尔会出现混合了 A 和 B 的类，通常是为了方便调试。一个被封装的对象可能包含如非  <code>const</code>  调试信息的某种东西，它并不是不变式的一部分，因此属于 A 类别 —— 其实它并非对象的值的一部分，也不是这个对象的有意义的可观察状态。这种情况下，A 类别的部分应当按 A 的方式对待（使之  <code>public</code> ，或罕见情况下当它们只应对派生类可见时，使之为  <code>protected</code> ），而 B 类别的部分应当仍按 B 的方式对待（ <code>private</code>  或  <code>const</code> ）。</p>\n<h5 id=\"强制实施-134\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-134\">#</a> 强制实施</h5>\n<p>对包含具有不同访问级别的非  <code>const</code>  数据成员的类给出标记。</p>\n<h3 id=\"a-namerh-mi-interfaceac135-用多继承来表达多个不同的接口\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-mi-interfaceac135-用多继承来表达多个不同的接口\">#</a> <a name=\"Rh-mi-interface\"></a>C.135: 用多继承来表达多个不同的接口</h3>\n<h5 id=\"理由-143\"><a class=\"markdownIt-Anchor\" href=\"#理由-143\">#</a> 理由</h5>\n<p>并非所有的类都应当支持全部的接口，而且并非所有的调用方都应当处理所有的操作。<br>\n尤其应当把巨大的接口拆解为可以被某个给定派生类所支持的不同的行为 “方面”。</p>\n<h5 id=\"示例-128\"><a class=\"markdownIt-Anchor\" href=\"#示例-128\">#</a> 示例</h5>\n<pre><code>class iostream : public istream, public ostream &#123;   // 充分简化\n    // ...\n&#125;;\n</code></pre>\n<p><code>istream</code>  提供了输入操作的接口； <code>ostream</code>  提供了输出操作的接口。<br>\n <code>iostream</code>  提供了  <code>istream</code>  和  <code>ostream</code>  接口的并集，以及在单个流上同时允许二者所需的同步操作。</p>\n<h5 id=\"注解-157\"><a class=\"markdownIt-Anchor\" href=\"#注解-157\">#</a> 注解</h5>\n<p>这是非常常见的继承的用法，因为需要同一个实现提供多个不同接口是很常见的，<br>\n而通常把这种接口组织到一个单根层次中都是不容易的或者不自然的。</p>\n<h5 id=\"注解-158\"><a class=\"markdownIt-Anchor\" href=\"#注解-158\">#</a> 注解</h5>\n<p>这样的接口通常都是抽象类。</p>\n<h5 id=\"强制实施-135\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-135\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerh-mi-implementationac136-用多继承来表达一些实现特性的合并\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-mi-implementationac136-用多继承来表达一些实现特性的合并\">#</a> <a name=\"Rh-mi-implementation\"></a>C.136: 用多继承来表达一些实现特性的合并</h3>\n<h5 id=\"理由-144\"><a class=\"markdownIt-Anchor\" href=\"#理由-144\">#</a> 理由</h5>\n<p>一些形式的混元（Mixin）带有状态，并通常会有对其状态提供的操作。<br>\n如果这些操作是虚的，就必须进行继承，而如果不是虚的，使用继承也可以避免例行代码和转发函数。</p>\n<h5 id=\"示例-129\"><a class=\"markdownIt-Anchor\" href=\"#示例-129\">#</a> 示例</h5>\n<pre><code>  class iostream : public istream, public ostream &#123;   // 充分简化\n    // ...\n&#125;;\n</code></pre>\n<p><code>istream</code>  提供了输入操作的接口（以及一些数据）； <code>ostream</code>  提供了输出操作的接口（以及一些数据）。<br>\n <code>iostream</code>  提供了  <code>istream</code>  和  <code>ostream</code>  接口的并集，以及在单个流上同时允许二者所需的同步操作。</p>\n<h5 id=\"注解-159\"><a class=\"markdownIt-Anchor\" href=\"#注解-159\">#</a> 注解</h5>\n<p>这是一种相对少见的用法，因为实现通常都可以被组织到一个单根层次之中。</p>\n<h5 id=\"示例-130\"><a class=\"markdownIt-Anchor\" href=\"#示例-130\">#</a> 示例</h5>\n<p>有时候，“实现特性” 更像是 “混元”，决定实现的行为，<br>\n并向其中注入成员以使该实现提供其所要求的策略。<br>\n相关的例子可以参考  <code>std::enable_shared_from_this</code> <br>\n 或者 boost.intrusive 中的各种基类（例如  <code>list_base_hook</code>  和  <code>intrusive_ref_counter</code> ）。</p>\n<h5 id=\"强制实施-136\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-136\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerh-vbaseac137-用-virtual-基类以避免过于通用的基类\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-vbaseac137-用-virtual-基类以避免过于通用的基类\">#</a> <a name=\"Rh-vbase\"></a>C.137: 用  <code>virtual</code>  基类以避免过于通用的基类</h3>\n<h5 id=\"理由-145\"><a class=\"markdownIt-Anchor\" href=\"#理由-145\">#</a> 理由</h5>\n<p>允许共享的数据和接口的分离。<br>\n避免将所有共享数据都被放到一个终极基类之中。</p>\n<h5 id=\"示例-131\"><a class=\"markdownIt-Anchor\" href=\"#示例-131\">#</a> 示例</h5>\n<pre><code>struct Interface &#123;\n    virtual void f();\n    virtual int g();\n    // ... 没有数据 ...\n&#125;;\n\nclass Utility &#123;  // 带有数据\n    void utility1();\n    virtual void utility2();    // 定制点\npublic:\n    int x;\n    int y;\n&#125;;\n\nclass Derive1 : public Interface, virtual protected Utility &#123;\n    // 覆盖了 Iterface 的函数\n    // 可能覆盖 Utility 的虚函数\n    // ...\n&#125;;\n\nclass Derive2 : public Interface, virtual protected Utility &#123;\n    // 覆盖了 Iterface 的函数\n    // 可能覆盖 Utility 的虚函数\n    // ...\n&#125;;\n</code></pre>\n<p>如果许多派生类都共享了显著的 “实现细节”，弄一个  <code>Utility</code>  出来就是有意义的。</p>\n<h5 id=\"注解-160\"><a class=\"markdownIt-Anchor\" href=\"#注解-160\">#</a> 注解</h5>\n<p>很明显，这个例子过于 “理论化”，但确实很难找到一个<em>小型</em>的现实例子出来。<br>\n <code>Interface</code>  是一个<a href=\"#Rh-abstract\">接口层次</a>的根，<br>\n而  <code>Utility</code>  则是一个<a href=\"#Rh-kind\">实现层次</a>的根。<br>\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucXVvcmEuY29tL1doYXQtYXJlLXRoZS11c2VzLWFuZC1hZHZhbnRhZ2VzLW9mLXZpcnR1YWwtYmFzZS1jbGFzcy1pbi1DJTJCJTJCL2Fuc3dlci9MYW5jZS1EaWR1Y2s=\">一个稍微更现实的例子</span>，有一些解释。</p>\n<h5 id=\"注解-161\"><a class=\"markdownIt-Anchor\" href=\"#注解-161\">#</a> 注解</h5>\n<p>将层次结构线性化通常是更好的方案。</p>\n<h5 id=\"强制实施-137\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-137\">#</a> 强制实施</h5>\n<p>对接口和实现混合的层次进行标记。</p>\n<h3 id=\"a-namerh-usingac138-用-using-来为派生类和其基类建立重载集合\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-usingac138-用-using-来为派生类和其基类建立重载集合\">#</a> <a name=\"Rh-using\"></a>C.138: 用  <code>using</code>  来为派生类和其基类建立重载集合</h3>\n<h5 id=\"理由-146\"><a class=\"markdownIt-Anchor\" href=\"#理由-146\">#</a> 理由</h5>\n<p>没有 using 声明的话，派生类的成员函数将会隐藏全部其所继承的重载集合。</p>\n<h5 id=\"示例不好-57\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-57\">#</a> 示例，不好</h5>\n<pre><code>#include &lt;iostream&gt;\nclass B &#123;\npublic:\n    virtual int f(int i) &#123; std::cout &lt;&lt; &quot;f(int): &quot;; return i; &#125;\n    virtual double f(double d) &#123; std::cout &lt;&lt; &quot;f(double): &quot;; return d; &#125;\n    virtual ~B() = default;\n&#125;;\nclass D: public B &#123;\npublic:\n    int f(int i) override &#123; std::cout &lt;&lt; &quot;f(int): &quot;; return i + 1; &#125;\n&#125;;\nint main()\n&#123;\n    D d;\n    std::cout &lt;&lt; d.f(2) &lt;&lt; '\\n';   // 打印 &quot;f(int): 3&quot;\n    std::cout &lt;&lt; d.f(2.3) &lt;&lt; '\\n'; // 打印 &quot;f(int): 3&quot;\n&#125;\n</code></pre>\n<h5 id=\"示例好-12\"><a class=\"markdownIt-Anchor\" href=\"#示例好-12\">#</a> 示例，好</h5>\n<pre><code>class D: public B &#123;\npublic:\n    int f(int i) override &#123; std::cout &lt;&lt; &quot;f(int): &quot;; return i + 1; &#125;\n    using B::f; // 展露了 f(double)\n&#125;;\n</code></pre>\n<h5 id=\"注解-162\"><a class=\"markdownIt-Anchor\" href=\"#注解-162\">#</a> 注解</h5>\n<p>这个问题对虚的和非虚的成员函数都有影响。</p>\n<p>对于可变基类，C++17 引入了一种 using 声明的可变形式：</p>\n<pre><code>template&lt;class... Ts&gt;\nstruct Overloader : Ts... &#123;\n    using Ts::operator()...; // 展露了每个基类中的 operator()\n&#125;;\n</code></pre>\n<h5 id=\"强制实施-138\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-138\">#</a> 强制实施</h5>\n<p>诊断名字隐藏情况</p>\n<h3 id=\"a-namerh-finalac139-对类运用-final-应当保守\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-finalac139-对类运用-final-应当保守\">#</a> <a name=\"Rh-final\"></a>C.139: 对类运用  <code>final</code>  应当保守</h3>\n<h5 id=\"理由-147\"><a class=\"markdownIt-Anchor\" href=\"#理由-147\">#</a> 理由</h5>\n<p>用  <code>final</code>  类来把类层次封闭很少是由于逻辑上的原因而必须的，并可能破坏掉类层次的可扩展性。</p>\n<h5 id=\"示例不好-58\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-58\">#</a> 示例，不好</h5>\n<pre><code>class Widget &#123; /* ... */ &#125;;\n\n// 没有人会想要改进 My_widget（你可能这么觉得）\nclass My_widget final : public Widget &#123; /* ... */ &#125;;\n\nclass My_improved_widget : public My_widget &#123; /* ... */ &#125;;  // 错误: 办不到了\n</code></pre>\n<h5 id=\"注解-163\"><a class=\"markdownIt-Anchor\" href=\"#注解-163\">#</a> 注解</h5>\n<p>并非每个类都要作为基类的。<br>\n大多数标准库的类都是这样（比如， <code>std::vector</code>  和  <code>std::string</code>  都并非为了派生而设计）。<br>\n这条规则是关于在准备作为某个类层次的接口的带有虚函数的类中有关  <code>final</code>  的使用的。</p>\n<h5 id=\"注解-164\"><a class=\"markdownIt-Anchor\" href=\"#注解-164\">#</a> 注解</h5>\n<p>用  <code>final</code>  来把单个的虚函数封印则是易错的，因为在定义和覆盖一组函数时， <code>final</code>  是很容易被忽视的。<br>\n幸运的是，编译器能够捕捉到这种错误：你无法在派生类中重新声明 / 重新打开一个  <code>final</code>  成员。</p>\n<h5 id=\"注解-165\"><a class=\"markdownIt-Anchor\" href=\"#注解-165\">#</a> 注解</h5>\n<p>有关  <code>final</code>  带来的性能提升的断言是需要证实的。<br>\n非常常见的是，这种断言都是基于推测或者在其他语言上的经验而来的。</p>\n<p>有一些例子中的  <code>final</code>  对于逻辑和性能因素来说可能都是重要的。<br>\n一个例子是编译器和语言分析工具中的性能关键的 AST 层次结构。<br>\n其中并非每年都会添加新的派生类，而且只有程序库的实现者会做这种事。<br>\n不过，误用（或者至少曾经的误用）的情况远远比这常见。</p>\n<h5 id=\"强制实施-139\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-139\">#</a> 强制实施</h5>\n<p>标记出所有在类上使用的  <code>final</code> 。</p>\n<h3 id=\"a-namerh-virtual-default-argac140-不要在虚函数和其覆盖函数上提供不同的默认参数\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-virtual-default-argac140-不要在虚函数和其覆盖函数上提供不同的默认参数\">#</a> <a name=\"Rh-virtual-default-arg\"></a>C.140: 不要在虚函数和其覆盖函数上提供不同的默认参数</h3>\n<h5 id=\"理由-148\"><a class=\"markdownIt-Anchor\" href=\"#理由-148\">#</a> 理由</h5>\n<p>这会造成混乱：覆盖函数是不会继承默认参数的。</p>\n<h5 id=\"示例不好-59\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-59\">#</a> 示例，不好</h5>\n<pre><code>class Base &#123;\npublic:\n    virtual int multiply(int value, int factor = 2) = 0;\n    virtual ~Base() = default;\n&#125;;\n\nclass Derived : public Base &#123;\npublic:\n    int multiply(int value, int factor = 10) override;\n&#125;;\n\nDerived d;\nBase&amp; b = d;\n\nb.multiply(10);  // 这两次调用将会调用相同的函数，但分别\nd.multiply(10);  // 使用不同的默认实参，因此获得不同的结果\n</code></pre>\n<h5 id=\"强制实施-140\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-140\">#</a> 强制实施</h5>\n<p>对虚函数默认参数中，如果其在基类和派生类的声明中是不同的，则对其进行标记。</p>\n<h2 id=\"chier-access-对类层次中的对象进行访问\"><a class=\"markdownIt-Anchor\" href=\"#chier-access-对类层次中的对象进行访问\">#</a> C.hier-access: 对类层次中的对象进行访问</h2>\n<h3 id=\"a-namerh-polyac145-通过指针和引用来访问多态对象\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-polyac145-通过指针和引用来访问多态对象\">#</a> <a name=\"Rh-poly\"></a>C.145: 通过指针和引用来访问多态对象</h3>\n<h5 id=\"理由-149\"><a class=\"markdownIt-Anchor\" href=\"#理由-149\">#</a> 理由</h5>\n<p>如果类带有虚函数的话，你（通常）并不知道你所使用的函数是由哪个类提供的。</p>\n<h5 id=\"示例-132\"><a class=\"markdownIt-Anchor\" href=\"#示例-132\">#</a> 示例</h5>\n<pre><code>struct B &#123; int a; virtual int f(); virtual ~B() = default &#125;;\nstruct D : B &#123; int b; int f() override; &#125;;\n\nvoid use(B b)\n&#123;\n    D d;\n    B b2 = d;   // 切片\n    B b3 = b;\n&#125;\n\nvoid use2()\n&#123;\n    D d;\n    use(d);   // 切片\n&#125;\n</code></pre>\n<p>两个  <code>d</code>  都发生了切片。</p>\n<h5 id=\"例外-31\"><a class=\"markdownIt-Anchor\" href=\"#例外-31\">#</a> 例外</h5>\n<p>你可以安全地访问处于自身定义的作用域之内的具名多态对象，这并不会将之切片。</p>\n<pre><code>void use3()\n&#123;\n    D d;\n    d.f();   // OK\n&#125;\n</code></pre>\n<h5 id=\"另见\"><a class=\"markdownIt-Anchor\" href=\"#另见\">#</a> 另见</h5>\n<p><a href=\"#Rc-copy-virtual\">多态类应当抑制复制操作</a></p>\n<h5 id=\"强制实施-141\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-141\">#</a> 强制实施</h5>\n<p>对所有切片都进行标记。</p>\n<h3 id=\"a-namerh-dynamic_castac146-当无法避免在类层次上进行导航时应使用-dynamic_cast\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-dynamic_castac146-当无法避免在类层次上进行导航时应使用-dynamic_cast\">#</a> <a name=\"Rh-dynamic_cast\"></a>C.146: 当无法避免在类层次上进行导航时应使用  <code>dynamic_cast</code></h3>\n<h5 id=\"理由-150\"><a class=\"markdownIt-Anchor\" href=\"#理由-150\">#</a> 理由</h5>\n<p><code>dynamic_cast</code>  是运行时检查。</p>\n<h5 id=\"示例-133\"><a class=\"markdownIt-Anchor\" href=\"#示例-133\">#</a> 示例</h5>\n<pre><code>struct B &#123;   // 接口\n    virtual void f();\n    virtual void g();\n    virtual ~B();\n&#125;;\n\nstruct D : B &#123;   // 更宽的接口\n    void f() override;\n    virtual void h();\n&#125;;\n\nvoid user(B* pb)\n&#123;\n    if (D* pd = dynamic_cast&lt;D*&gt;(pb)) &#123;\n        // ... 使用 D 的接口 ...\n    &#125;\n    else &#123;\n        // ... 通过 B 的接口做事 ...\n    &#125;\n&#125;\n</code></pre>\n<p>使用其他的强制转换可能会违反类型安全，导致程序中所访问的某个真实类型为  <code>X</code>  的变量，被当做具有某个无关的类型  <code>Z</code>  而进行访问：</p>\n<pre><code>void user2(B* pb)   // 不好\n&#123;\n    D* pd = static_cast&lt;D*&gt;(pb);    // I know that pb really points to a D; trust me\n    // ... 使用 D 的接口 ...\n&#125;\n\nvoid user3(B* pb)    // 不安全\n&#123;\n    if (some_condition) &#123;\n        D* pd = static_cast&lt;D*&gt;(pb);   // I know that pb really points to a D; trust me\n        // ... 使用 D 的接口 ...\n    &#125;\n    else &#123;\n        // ... 通过 B 的接口做事 ...\n    &#125;\n&#125;\n\nvoid f()\n&#123;\n    B b;\n    user(&amp;b);   // OK\n    user2(&amp;b);  // 糟糕的错误\n    user3(&amp;b);  // OK，*如果*程序员已经正确检查了 some_condition 的话\n&#125;\n</code></pre>\n<h5 id=\"注解-166\"><a class=\"markdownIt-Anchor\" href=\"#注解-166\">#</a> 注解</h5>\n<p>和其他强制转换一样， <code>dynamic_cast</code>  被过度使用了。<br>\n<a href=\"#Rh-use-virtual\">优先使用虚函数而不是强制转换</a>。<br>\n如果可行（无须运行时决议）并且相当便利的话，优先使用<a href=\"#???\">静态多态</a>而不是<br>\n继承层次的导航。</p>\n<h5 id=\"注解-167\"><a class=\"markdownIt-Anchor\" href=\"#注解-167\">#</a> 注解</h5>\n<p>一些人会在  <code>typeid</code>  更合适的时候使用  <code>dynamic_cast</code> ；<br>\n <code>dynamic_cast</code>  是一个通用的 “是一个” 操作，用以发现对象上的最佳接口，<br>\n而  <code>typeid</code>  是 “报告对象的精确类型” 操作，用以发现对象的真实类型。<br>\n后者本质上就是更简单的操作，因而应当更快一些。<br>\n后者（ <code>typeid</code> ）是可以在需要时进行手工模仿的（比如说，当工作在（因为某种原因）禁止使用 RTTI 的系统上），<br>\n而前者（ <code>dynamic_cast</code> ）要正确地实现则要困难得多。</p>\n<p>考虑：</p>\n<pre><code>struct B &#123;\n    const char* name &#123;&quot;B&quot;&#125;;\n    // 若 pb1-&gt;id() == pb2-&gt;id() 则 *pb1 与 *pb2 类型相同\n    virtual const char* id() const &#123; return name; &#125;\n    // ...\n&#125;;\n\nstruct D : B &#123;\n    const char* name &#123;&quot;D&quot;&#125;;\n    const char* id() const override &#123; return name; &#125;\n    // ...\n&#125;;\n\nvoid use()\n&#123;\n    B* pb1 = new B;\n    B* pb2 = new D;\n\n    cout &lt;&lt; pb1-&gt;id(); // &quot;B&quot;\n    cout &lt;&lt; pb2-&gt;id(); // &quot;D&quot;\n\n\n    if (pb1-&gt;id() == &quot;D&quot;) &#123;         // 貌似没问题\n        D* pd = static_cast&lt;D*&gt;(pb1);\n        // ...\n    &#125;\n    // ...\n&#125;\n</code></pre>\n<p><code>pb2-&gt;id == &quot;D&quot;</code>  的结果实际上是由实现定义的。<br>\n我们加上这个是为了警告自造的 RTTI 中的危险之处。<br>\n这个代码可能可以多年正常工作，但只在不会对字符字面量进行唯一化的新机器，新编译器，或者新的连接器上失败。</p>\n<p>当实现你自己的 RTTI 时，请当心这一点。</p>\n<h5 id=\"例外-32\"><a class=\"markdownIt-Anchor\" href=\"#例外-32\">#</a> 例外</h5>\n<p>如果你所用的实现提供的  <code>dynamic_cast</code>  确实很慢的话，你可能只得使用一种替代方案了。<br>\n不过，所有无法静态决议的替代方案都涉及显式的强制转换（通常为  <code>static_cast</code> ），而且易于出错。<br>\n你基本上都将会创建自己的特殊目的  <code>dynamic_cast</code> 。<br>\n因此，首先应当确定你的  <code>dynamic_cast</code>  确实和你想的一样慢（其实有相当多的并不被支持的流言），<br>\n而且你使用的  <code>dynamic_cast</code>  确实是性能十分关键的。</p>\n<p>我们的观点是，当前的实现中的  <code>dynamic_cast</code>  并非很慢。<br>\n比如说，在合适的条件下，是可以以<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9mYXN0X2R5bmFtaWNfY2FzdGluZy5wZGY=\">快速常量时间</span>来实施  <code>dynamic_cast</code>  的。<br>\n但是，兼容性问题使得作出改变很难，虽然大家都同意对优化付出的努力是值得的。</p>\n<p>在很罕见的情况下，如果你已经测量出  <code>dynamic_cast</code>  的开销确实有影响，你也有其他的方式来静态地保证向下转换的成功（比如说小心地应用 CRTP 时），而且其中并不涉及虚继承的话，可以考虑战术性地使用  <code>static_cast</code>  并带上显著的代码注释和免责声明，概述这个段落，而且由于类型系统无法验证其正确性而在维护中需要人工的关切。即便是这样，以我们的经验来说，这种 “我知道我在干什么” 的情况仍然是一种已知的 BUG 来源。</p>\n<h5 id=\"例外-33\"><a class=\"markdownIt-Anchor\" href=\"#例外-33\">#</a> 例外</h5>\n<p>考虑：</p>\n<pre><code>template&lt;typename B&gt;\nclass Dx : B &#123;\n    // ...\n&#125;;\n</code></pre>\n<h5 id=\"强制实施-142\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-142\">#</a> 强制实施</h5>\n<ul>\n<li>对所有用  <code>static_cast</code>  来进行向下转换进行标记，其中也包括实施  <code>static_cast</code>  的 C 风格的强制转换。</li>\n<li>本条规则属于<a href=\"#Pro-type-downcast\">类型安全性剖面配置</a>。</li>\n</ul>\n<h3 id=\"a-namerh-ref-castac147-当查找所需类的失败被当做一种错误时应当对引用类型使用-dynamic_cast\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-ref-castac147-当查找所需类的失败被当做一种错误时应当对引用类型使用-dynamic_cast\">#</a> <a name=\"Rh-ref-cast\"></a>C.147: 当查找所需类的失败被当做一种错误时，应当对引用类型使用  <code>dynamic_cast</code></h3>\n<h5 id=\"理由-151\"><a class=\"markdownIt-Anchor\" href=\"#理由-151\">#</a> 理由</h5>\n<p>对引用进行的强制转换，所表达的意图是最终会获得一个有效对象，因此这种强制转换必须成功。如果无法成功的话， <code>dynamic_cast</code>  将会抛出异常。</p>\n<h5 id=\"示例-134\"><a class=\"markdownIt-Anchor\" href=\"#示例-134\">#</a> 示例</h5>\n<pre><code>std::string f(Base&amp; b)\n&#123;\n    return dynamic_cast&lt;Derived&amp;&gt;(b).to_string();\n&#125;\n</code></pre>\n<h5 id=\"强制实施-143\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-143\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerh-ptr-castac148-当查找所需类的失败被当做一种有效的可能情况时应当对指针类型使用-dynamic_cast\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-ptr-castac148-当查找所需类的失败被当做一种有效的可能情况时应当对指针类型使用-dynamic_cast\">#</a> <a name=\"Rh-ptr-cast\"></a>C.148: 当查找所需类的失败被当做一种有效的可能情况时，应当对指针类型使用  <code>dynamic_cast</code></h3>\n<h5 id=\"理由-152\"><a class=\"markdownIt-Anchor\" href=\"#理由-152\">#</a> 理由</h5>\n<p><code>dynamic_cast</code>  转换允许测试指针是否指向某个其类层次中包含给定类的多态对象。由于其找不到类时仅会返回空值，因而可以在运行时予以测试。这允许编写的代码可以基于其结果而选择不同的代码路径。</p>\n<p>与此相对，<a href=\"#Rh-ref-cast\">C.147</a> 中失败即是错误，而且不能用于条件执行。</p>\n<h5 id=\"示例-135\"><a class=\"markdownIt-Anchor\" href=\"#示例-135\">#</a> 示例</h5>\n<p>下面的例子的  <code>Shape_owner</code>  的  <code>add</code>  函数获取构造的  <code>Shape</code>  对象的所有权。这些对象也根据其几何特性被存储到了不同视图中。<br>\n这个例子中的  <code>Shape</code>  并不继承于  <code>Geometric_attributes</code> ，而是其各个子类继承。</p>\n<pre><code>void add(Shape * const item)\n&#123;\n  // 总是获得其所有权\n  owned_shapes.emplace_back(item);\n\n  // 检查 Geometric_attribute 并将该形状加入到（零个/一个/某些/全部）视图中\n\n  if (auto even = dynamic_cast&lt;Even_sided*&gt;(item))\n  &#123;\n    view_of_evens.emplace_back(even);\n  &#125;\n\n  if (auto trisym = dynamic_cast&lt;Trilaterally_symmetrical*&gt;(item))\n  &#123;\n    view_of_trisyms.emplace_back(trisym);\n  &#125;\n&#125;\n</code></pre>\n<h5 id=\"注解-168\"><a class=\"markdownIt-Anchor\" href=\"#注解-168\">#</a> 注解</h5>\n<p>找不到所需的类时  <code>dynamic_cast</code>  将返回空值，而解引用空指针将导致未定义的行为。<br>\n因此  <code>dynamic_cast</code>  的结果应当总是当做可能包含空值并进行测试。</p>\n<h5 id=\"强制实施-144\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-144\">#</a> 强制实施</h5>\n<ul>\n<li>【复杂】 除非在指针类型  <code>dynamic_cast</code>  的结果上进行了空值测试，否则就对该指针的解引用给出警告。</li>\n</ul>\n<h3 id=\"a-namerh-smartac149-用-unique_ptr-或-shared_ptr-来避免忘记对以-new-所创建的对象进行-delete-的情况\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-smartac149-用-unique_ptr-或-shared_ptr-来避免忘记对以-new-所创建的对象进行-delete-的情况\">#</a> <a name=\"Rh-smart\"></a>C.149: 用  <code>unique_ptr</code>  或  <code>shared_ptr</code>  来避免忘记对以  <code>new</code>  所创建的对象进行  <code>delete</code>  的情况</h3>\n<h5 id=\"理由-153\"><a class=\"markdownIt-Anchor\" href=\"#理由-153\">#</a> 理由</h5>\n<p>避免资源泄漏。</p>\n<h5 id=\"示例-136\"><a class=\"markdownIt-Anchor\" href=\"#示例-136\">#</a> 示例</h5>\n<pre><code>void use(int i)\n&#123;\n    auto p = new int &#123;7&#125;;           // 不好: 用 new 来初始化局部指针\n    auto q = make_unique&lt;int&gt;(9);   // ok: 保证了为 9 所分配的内存会被回收\n    if (0 &lt; i) return;              // 可能会返回并泄漏\n    delete p;                       // 太晚了\n&#125;\n</code></pre>\n<h5 id=\"强制实施-145\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-145\">#</a> 强制实施</h5>\n<ul>\n<li>标记用  <code>new</code>  的结果来对裸指针所进行的初始化。</li>\n<li>标记对局部变量的  <code>delete</code> 。</li>\n</ul>\n<h3 id=\"a-namerh-make_uniqueac150-用-make_unique-来构建由-unique_ptr-所拥有的对象\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-make_uniqueac150-用-make_unique-来构建由-unique_ptr-所拥有的对象\">#</a> <a name=\"Rh-make_unique\"></a>C.150: 用  <code>make_unique()</code>  来构建由  <code>unique_ptr</code>  所拥有的对象</h3>\n<p>参见 <a href=\"#Rr-make_unique\">R.23</a>。</p>\n<h3 id=\"a-namerh-make_sharedac151-用-make_shared-来构建由-shared_ptr-所拥有的对象\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-make_sharedac151-用-make_shared-来构建由-shared_ptr-所拥有的对象\">#</a> <a name=\"Rh-make_shared\"></a>C.151: 用  <code>make_shared()</code>  来构建由  <code>shared_ptr</code>  所拥有的对象</h3>\n<p>参见 <a href=\"#Rr-make_shared\">R.22</a>。</p>\n<h3 id=\"a-namerh-arrayac152-禁止把指向派生类对象的数组的指针赋值给指向基类的指针\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-arrayac152-禁止把指向派生类对象的数组的指针赋值给指向基类的指针\">#</a> <a name=\"Rh-array\"></a>C.152: 禁止把指向派生类对象的数组的指针赋值给指向基类的指针</h3>\n<h5 id=\"理由-154\"><a class=\"markdownIt-Anchor\" href=\"#理由-154\">#</a> 理由</h5>\n<p>对所得到的基类指针进行下标操作，将导致无效的对象访问并且可能造成内存损坏。</p>\n<h5 id=\"示例-137\"><a class=\"markdownIt-Anchor\" href=\"#示例-137\">#</a> 示例</h5>\n<pre><code>struct B &#123; int x; &#125;;\nstruct D : B &#123; int y; &#125;;\n\nvoid use(B*);\n\nD a[] = &#123;&#123; \"&#123;&#123;\" &#125;&#125;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;&#125;;\nB* p = a;     // 不好: a 退化为 &amp;a[0]，并被转换为 B*\np[1].x = 7;   // 覆盖了 a[0].y\n\nuse(a);       // 不好: a 退化为 &amp;a[0]，并被转换为 B*\n</code></pre>\n<h5 id=\"强制实施-146\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-146\">#</a> 强制实施</h5>\n<ul>\n<li>对任何的数组退化和基类向派生类转换之间的组合进行标记。</li>\n<li>应当将数组作为  <code>span</code>  而不是指针来进行传递，而且不能让数组的名字在放入  <code>span</code>  之前经手派生类向基类的转换。</li>\n</ul>\n<h3 id=\"a-namerh-use-virtualac153-优先采用虚函数而不是强制转换\"><a class=\"markdownIt-Anchor\" href=\"#a-namerh-use-virtualac153-优先采用虚函数而不是强制转换\">#</a> <a name=\"Rh-use-virtual\"></a>C.153: 优先采用虚函数而不是强制转换</h3>\n<h5 id=\"理由-155\"><a class=\"markdownIt-Anchor\" href=\"#理由-155\">#</a> 理由</h5>\n<p>虚函数调用安全，而强制转换易错。<br>\n虚函数调用达到全派生函数，而强制转换可能达到某个中间类<br>\n而得到错误的结果（尤其是当类层次在维护中被修改之后）。</p>\n<h5 id=\"示例-138\"><a class=\"markdownIt-Anchor\" href=\"#示例-138\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"强制实施-147\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-147\">#</a> 强制实施</h5>\n<p>参见 <a href=\"#Rh-dynamic_cast\">C.146</a> 和？？？</p>\n<h2 id=\"a-namess-overloadacover-重载和运算符重载\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-overloadacover-重载和运算符重载\">#</a> <a name=\"SS-overload\"></a>C.over: 重载和运算符重载</h2>\n<p>可以对普通函数，函数模板，以及运算符进行重载。<br>\n不能重载函数对象。</p>\n<p>重载规则概览：</p>\n<ul>\n<li><a href=\"#Ro-conventional\">C.160: 定义运算符应当主要用于模仿传统用法</a></li>\n<li><a href=\"#Ro-symmetric\">C.161: 对于对称的运算符应当采用非成员函数</a></li>\n<li><a href=\"#Ro-equivalent\">C.162: 重载的操作之间应当大体上是等价的</a></li>\n<li><a href=\"#Ro-equivalent-2\">C.163: 应当仅对大体上等价的操作进行重载</a></li>\n<li><a href=\"#Ro-conversion\">C.164: 避免隐式转换运算符</a></li>\n<li><a href=\"#Ro-custom\">C.165: 为定制点采用  <code>using</code> </a></li>\n<li><a href=\"#Ro-address-of\">C.166: 一元  <code>&amp;</code>  的重载只能作为某个智能指针或引用系统的一部分而提供</a></li>\n<li><a href=\"#Ro-overload\">C.167: 应当为带有传统含义的操作提供运算符</a></li>\n<li><a href=\"#Ro-namespace\">C.168: 应当在操作数所在的命名空间中定义重载运算符</a></li>\n<li><a href=\"#Ro-lambda\">C.170: 当想要重载 lambda 时，应当使用泛型 lambda</a></li>\n</ul>\n<h3 id=\"a-namero-conventionalac160-定义运算符应当主要用于模仿传统用法\"><a class=\"markdownIt-Anchor\" href=\"#a-namero-conventionalac160-定义运算符应当主要用于模仿传统用法\">#</a> <a name=\"Ro-conventional\"></a>C.160: 定义运算符应当主要用于模仿传统用法</h3>\n<h5 id=\"理由-156\"><a class=\"markdownIt-Anchor\" href=\"#理由-156\">#</a> 理由</h5>\n<p>最小化意外情况。</p>\n<h5 id=\"示例-139\"><a class=\"markdownIt-Anchor\" href=\"#示例-139\">#</a> 示例</h5>\n<pre><code>class X &#123;\npublic:\n    // ...\n    X&amp; operator=(const X&amp;); // 定义赋值的成员函数\n    friend bool operator==(const X&amp;, const X&amp;); // == 需要访问其内部表示\n                                                // 执行 a = b 之后将有 a == b\n    // ...\n&#125;;\n</code></pre>\n<p>这里维持了传统的语义：<a href=\"#SS-copy\">副本之间相等</a>。</p>\n<h5 id=\"示例不好-60\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-60\">#</a> 示例，不好</h5>\n<pre><code>X operator+(X a, X b) &#123; return a.v - b.v; &#125;   // 不好: 让 + 执行减法\n</code></pre>\n<h5 id=\"注解-169\"><a class=\"markdownIt-Anchor\" href=\"#注解-169\">#</a> 注解</h5>\n<p>非成员运算符应当要么是友元，要么定义于<a href=\"#Ro-namespace\">其操作数所在的命名空间中</a>。<br>\n<a href=\"#Ro-symmetric\">二元运算符应当等价地对待其两个操作数</a>。</p>\n<h5 id=\"强制实施-148\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-148\">#</a> 强制实施</h5>\n<p>也许是不可能的。</p>\n<h3 id=\"a-namero-symmetricac161-对于对称的运算符应当采用非成员函数\"><a class=\"markdownIt-Anchor\" href=\"#a-namero-symmetricac161-对于对称的运算符应当采用非成员函数\">#</a> <a name=\"Ro-symmetric\"></a>C.161: 对于对称的运算符应当采用非成员函数</h3>\n<h5 id=\"理由-157\"><a class=\"markdownIt-Anchor\" href=\"#理由-157\">#</a> 理由</h5>\n<p>如果使用的是成员函数的话，就需要两个才行。<br>\n如果为（比如） <code>==</code>  采用的不是非成员函数的话， <code>a == b</code>  和  <code>b == a</code>  就会存在微妙的差别。</p>\n<h5 id=\"示例-140\"><a class=\"markdownIt-Anchor\" href=\"#示例-140\">#</a> 示例</h5>\n<pre><code>bool operator==(Point a, Point b) &#123; return a.x == b.x &amp;&amp; a.y == b.y; &#125;\n</code></pre>\n<h5 id=\"强制实施-149\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-149\">#</a> 强制实施</h5>\n<p>标记成员运算符函数。</p>\n<h3 id=\"a-namero-equivalentac162-重载的操作之间应当大体上是等价的\"><a class=\"markdownIt-Anchor\" href=\"#a-namero-equivalentac162-重载的操作之间应当大体上是等价的\">#</a> <a name=\"Ro-equivalent\"></a>C.162: 重载的操作之间应当大体上是等价的</h3>\n<h5 id=\"理由-158\"><a class=\"markdownIt-Anchor\" href=\"#理由-158\">#</a> 理由</h5>\n<p>让逻辑上互相等价的操作对不同的参数类型使用不同的名字会带来混乱，导致在函数名字中编码类型信息，并妨碍泛型编程。</p>\n<h5 id=\"示例-141\"><a class=\"markdownIt-Anchor\" href=\"#示例-141\">#</a> 示例</h5>\n<p>考虑：</p>\n<pre><code>void print(int a);\nvoid print(int a, int base);\nvoid print(const string&amp;);\n</code></pre>\n<p>这三个函数都对其参数进行（适当的）打印。相对而言：</p>\n<pre><code>void print_int(int a);\nvoid print_based(int a, int base);\nvoid print_string(const string&amp;);\n</code></pre>\n<p>这三个函数也都对其参数进行（适当的）打印。在名字上附加仅仅增添了啰嗦程度，而且妨碍了泛型代码。</p>\n<h5 id=\"强制实施-150\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-150\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namero-equivalent-2ac163-应当仅对大体上等价的操作进行重载\"><a class=\"markdownIt-Anchor\" href=\"#a-namero-equivalent-2ac163-应当仅对大体上等价的操作进行重载\">#</a> <a name=\"Ro-equivalent-2\"></a>C.163: 应当仅对大体上等价的操作进行重载</h3>\n<h5 id=\"理由-159\"><a class=\"markdownIt-Anchor\" href=\"#理由-159\">#</a> 理由</h5>\n<p>让逻辑上不同的函数使用相同的名字会带来混乱，并导致在泛型编程时发生错误。</p>\n<h5 id=\"示例-142\"><a class=\"markdownIt-Anchor\" href=\"#示例-142\">#</a> 示例</h5>\n<p>考虑：</p>\n<pre><code>void open_gate(Gate&amp; g);   // 把车库出口通道的障碍移除\nvoid fopen(const char* name, const char* mode);   // 打开文件\n</code></pre>\n<p>这两个操作本质上就是不同的（而且没有关联），因此让它们的名字相区别是正确的。相对而言：</p>\n<pre><code>void open(Gate&amp; g);   // 把车库出口通道的障碍移除\nvoid open(const char* name, const char* mode =&quot;r&quot;);   // 打开文件\n</code></pre>\n<p>这两个操作仍旧本质不同（且没有关联），但它们的名字缩减成了（共同的）最小词，并带来了发生混乱的机会。<br>\n幸运的是，类型系统能够识别出许多这种错误。</p>\n<h5 id=\"注解-170\"><a class=\"markdownIt-Anchor\" href=\"#注解-170\">#</a> 注解</h5>\n<p>对于一般性的和流行的名字，比如  <code>open</code> 、 <code>move</code> 、 <code>+</code>  和  <code>==</code>  等等，应当特别小心。</p>\n<h5 id=\"强制实施-151\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-151\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namero-conversionac164-避免隐式转换运算符\"><a class=\"markdownIt-Anchor\" href=\"#a-namero-conversionac164-避免隐式转换运算符\">#</a> <a name=\"Ro-conversion\"></a>C.164: 避免隐式转换运算符</h3>\n<h5 id=\"理由-160\"><a class=\"markdownIt-Anchor\" href=\"#理由-160\">#</a> 理由</h5>\n<p>隐式类型转换可以很基础（比如  <code>double</code>  向  <code>int</code> ），但经常会导致意外（比如  <code>String</code>  到 C 风格的字符串）。</p>\n<h5 id=\"注解-171\"><a class=\"markdownIt-Anchor\" href=\"#注解-171\">#</a> 注解</h5>\n<p>优先采用明确命名的转换，除非给出了一条很重要的需求。<br>\n我们所谓 “很重要的需求” 的意思是，它在其应用领域中是基本的（比如整数向复数的转换），<br>\n并且经常需要用到。不要仅仅为了微小的便利就（通过转换运算符或非  <code>explicit</code>  构造函数）<br>\n引入隐式的类型转换。</p>\n<h5 id=\"示例-143\"><a class=\"markdownIt-Anchor\" href=\"#示例-143\">#</a> 示例</h5>\n<pre><code>struct S1 &#123;\n    string s;\n    // ...\n    operator char*() &#123; return s.data(); &#125; // 不好，可能会引起以外\n&#125;\n\nstruct S2 &#123;\n    string s;\n    // ...\n    explicit operator char*() &#123; return s.data(); &#125;\n&#125;;\n\nvoid f(S1 s1, S2 s2)\n&#123;\n    char* x1 = s1;     // 可以，但在许多情况下会引起意外\n    char* x2 = s2;     // 错误，这通常是一件好事\n    char* x3 = static_cast&lt;char*&gt;(s2); // 我们可以明确（在你的头脑里）\n&#125;\n</code></pre>\n<p>可能在任意的难以发现的上下文里发生令人惊讶且可能具有破坏性的隐式转换，例如，</p>\n<pre><code>S1 ff();\n\nchar* g()\n&#123;\n    return ff();\n&#125;\n</code></pre>\n<p>由 `ff（）返回的字符串在返回它的指针之前被销毁。</p>\n<h5 id=\"强制实施-152\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-152\">#</a> 强制实施</h5>\n<p>标记所有的非显式转换运算符。</p>\n<h3 id=\"a-namero-customac165-为定制点采用-using\"><a class=\"markdownIt-Anchor\" href=\"#a-namero-customac165-为定制点采用-using\">#</a> <a name=\"Ro-custom\"></a>C.165: 为定制点采用  <code>using</code></h3>\n<h5 id=\"理由-161\"><a class=\"markdownIt-Anchor\" href=\"#理由-161\">#</a> 理由</h5>\n<p>以便找到在一个独立的命名空间中所定义的函数对象或函数，它们对一个一般性函数进行了 “定制”。</p>\n<h5 id=\"示例-144\"><a class=\"markdownIt-Anchor\" href=\"#示例-144\">#</a> 示例</h5>\n<p>考虑  <code>swap</code> 。这是一个通用的（标准库）函数，其定义可以在任何类型上工作。<br>\n不过，通常需要为特定的类型定义专门的  <code>swap()</code> 。<br>\n例如说，通用的  <code>swap()</code>  会对互相交换的两个  <code>vector</code>  的元素进行复制，而一个好的专门实现则完全不会复制任何元素。</p>\n<pre><code>namespace N &#123;\n    My_type X &#123; /* ... */ &#125;;\n    void swap(X&amp;, X&amp;);   // 针对 N::X 所优化的 swap\n    // ...\n&#125;\n\nvoid f1(N::X&amp; a, N::X&amp; b)\n&#123;\n    std::swap(a, b);   // 可能不是我们所要的: 调用 std::swap()\n&#125;\n</code></pre>\n<p><code>f1()</code>  中的  <code>std::swap()</code>  严格做了我们所要求的工作：它调用了命名空间  <code>std</code>  中的  <code>swap()</code> 。<br>\n不幸的是，这可能并非我们想要的。<br>\n怎样让其考虑  <code>N::X</code>  呢？</p>\n<pre><code>void f2(N::X&amp; a, N::X&amp; b)\n&#123;\n    swap(a, b);   // 调用了 N::swap\n&#125;\n</code></pre>\n<p>但这也许并不是我们在泛型代码中所要的。<br>\n通常如果专门的函数存在的话我们就想用它，否则的话我们则需要通用的函数。<br>\n这是通过在函数的查找中包含通用函数而达成的：</p>\n<pre><code>void f3(N::X&amp; a, N::X&amp; b)\n&#123;\n    using std::swap;  // 使得 std::swap 可用\n    swap(a, b);        // 如果存在 N::swap 则调用之，否则为 std::swap\n&#125;\n</code></pre>\n<h5 id=\"强制实施-153\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-153\">#</a> 强制实施</h5>\n<p>不大可能，除非是如  <code>swap</code>  这样的已知的定制点。<br>\n问题在于无限定和带限定的名字查找都有其作用。</p>\n<h3 id=\"a-namero-address-ofac166-一元-的重载只能作为某个智能指针或引用系统的一部分而提供\"><a class=\"markdownIt-Anchor\" href=\"#a-namero-address-ofac166-一元-的重载只能作为某个智能指针或引用系统的一部分而提供\">#</a> <a name=\"Ro-address-of\"></a>C.166: 一元  <code>&amp;</code>  的重载只能作为某个智能指针或引用系统的一部分而提供</h3>\n<h5 id=\"理由-162\"><a class=\"markdownIt-Anchor\" href=\"#理由-162\">#</a> 理由</h5>\n<p><code>&amp;</code>  运算符在 C++ 中很基本。<br>\nC++ 语义中的很多部分都假定了其默认的含义。</p>\n<h5 id=\"示例-145\"><a class=\"markdownIt-Anchor\" href=\"#示例-145\">#</a> 示例</h5>\n<pre><code>class Ptr &#123; // 一种智能指针\n    Ptr(X* pp) : p(pp) &#123; /* 检查 */ &#125;\n    X* operator-&gt;() &#123; /* 检查 */ return p; &#125;\n    X operator[](int i);\n    X operator*();\nprivate:\n    T* p;\n&#125;;\n\nclass X &#123;\n    Ptr operator&amp;() &#123; return Ptr&#123;this&#125;; &#125;\n    // ...\n&#125;;\n</code></pre>\n<h5 id=\"注解-172\"><a class=\"markdownIt-Anchor\" href=\"#注解-172\">#</a> 注解</h5>\n<p>如果你要 “折腾” 运算符  <code>&amp;</code>  的话，请保证其定义和  <code>-&gt;</code> ， <code>[]</code> ， <code>*</code>  和  <code>.</code>  在结果类型上具有匹配的含义。<br>\n注意，运算符  <code>.</code>  现在是无法重载的，因此不可能做出一个完美的系统。<br>\n我们打算修正这一点： <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcGVuLXN0ZC5vcmcvanRjMS9zYzIyL3dnMjEvZG9jcy9wYXBlcnMvMjAxNS9uNDQ3Ny5wZGY=\">Operator Dot (R2)</span>。<br>\n注意  <code>std::addressof()</code>  总会产生一个内建指针。</p>\n<h5 id=\"强制实施-154\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-154\">#</a> 强制实施</h5>\n<p>比较微妙。如果用户定义了  <code>&amp;</code>  而并未同时为其结果类型定义  <code>-&gt;</code> ，则进行警告。</p>\n<h3 id=\"a-namero-overloadac167-应当为带有传统含义的操作提供运算符\"><a class=\"markdownIt-Anchor\" href=\"#a-namero-overloadac167-应当为带有传统含义的操作提供运算符\">#</a> <a name=\"Ro-overload\"></a>C.167: 应当为带有传统含义的操作提供运算符</h3>\n<h5 id=\"理由-163\"><a class=\"markdownIt-Anchor\" href=\"#理由-163\">#</a> 理由</h5>\n<p>可读性。约定。可重用性。支持泛型代码。</p>\n<h5 id=\"示例-146\"><a class=\"markdownIt-Anchor\" href=\"#示例-146\">#</a> 示例</h5>\n<pre><code>void cout_my_class(const My_class&amp; c) // 含糊，并非传统约定，非泛型\n&#123;\n    std::cout &lt;&lt; /* 此处为类成员 */;\n&#125;\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const my_class&amp; c) // OK\n&#123;\n    return os &lt;&lt; /* 此处为类成员 */;\n&#125;\n</code></pre>\n<p>对于其自身而言， <code>cout_my_class</code>  也许是没问题的，但它无法用在（或组合到）依赖于  <code>&lt;&lt;</code>  的输出用法约定代码之中：</p>\n<pre><code>My_class var &#123; /* ... */ &#125;;\n// ...\ncout &lt;&lt; &quot;var = &quot; &lt;&lt; var &lt;&lt; '\\n';\n</code></pre>\n<h5 id=\"注解-173\"><a class=\"markdownIt-Anchor\" href=\"#注解-173\">#</a> 注解</h5>\n<p>大多数运算符都有很强烈和活跃的含义约定用法，比如</p>\n<ul>\n<li>比较： <code>==</code> ， <code>!=</code> ， <code>&lt;</code> ， <code>&lt;=</code> ， <code>&gt;</code> ， <code>&gt;=</code> ，以及  <code>&lt;=&gt;</code></li>\n<li>算术操作： <code>+</code> ， <code>-</code> ， <code>*</code> ， <code>/</code> ，以及  <code>%</code></li>\n<li>访问操作： <code>.</code> ， <code>-&gt;</code> ，一元  <code>*</code> ，以及  <code>[]</code></li>\n<li>赋值： <code>=</code></li>\n</ul>\n<p>请勿定义违反约定的用法，请勿为它们发明自己的名字。</p>\n<h5 id=\"强制实施-155\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-155\">#</a> 强制实施</h5>\n<p>比较棘手。需要洞悉其语义。</p>\n<h3 id=\"a-namero-namespaceac168-应当在操作数所在的命名空间中定义重载运算符\"><a class=\"markdownIt-Anchor\" href=\"#a-namero-namespaceac168-应当在操作数所在的命名空间中定义重载运算符\">#</a> <a name=\"Ro-namespace\"></a>C.168: 应当在操作数所在的命名空间中定义重载运算符</h3>\n<h5 id=\"理由-164\"><a class=\"markdownIt-Anchor\" href=\"#理由-164\">#</a> 理由</h5>\n<p>可读性。<br>\n通过 ADL 寻找运算符的能力。<br>\n避免不同命名空间中的定义之间不一致。</p>\n<h5 id=\"示例-147\"><a class=\"markdownIt-Anchor\" href=\"#示例-147\">#</a> 示例</h5>\n<pre><code>struct S &#123; &#125;;\nS operator+(S, S);   // OK: 和 S 在相同的命名空间，甚至紧跟着 S\nS s;\n\nS r = s + s;\n</code></pre>\n<h5 id=\"示例-148\"><a class=\"markdownIt-Anchor\" href=\"#示例-148\">#</a> 示例</h5>\n<pre><code>namespace N &#123;\n    struct S &#123; &#125;;\n    S operator+(S, S);   // OK: 和 S 在相同的命名空间，甚至紧跟着 S\n&#125;\n\nN::S s;\n\nS r = s + s;  // 通过 ADL 找到了 N::operator+()\n</code></pre>\n<h5 id=\"示例不好-61\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-61\">#</a> 示例，不好</h5>\n<pre><code>struct S &#123; &#125;;\nS s;\n\nnamespace N &#123;\n    bool operator!(S a) &#123; return true; &#125;\n    bool not_s = !s;\n&#125;\n\nnamespace M &#123;\n    bool operator!(S a) &#123; return false; &#125;\n    bool not_s = !s;\n&#125;\n</code></pre>\n<p>这里的  <code>!s</code>  的含义在  <code>N</code>  和  <code>M</code>  中是不同的。<br>\n这可能是最易混淆的一点。<br>\n移除  <code>namespace M</code>  的定义之后，混乱就被一种犯错的机会所代替。</p>\n<h5 id=\"注解-174\"><a class=\"markdownIt-Anchor\" href=\"#注解-174\">#</a> 注解</h5>\n<p>当为定义于不同命名空间的两个类型定义一个二元运算符时，无法遵循这条规则。<br>\n例如：</p>\n<pre><code>Vec::Vector operator*(const Vec::Vector&amp;, const Mat::Matrix&amp;);\n</code></pre>\n<p>也许最好避免这种情形。</p>\n<h5 id=\"参见-2\"><a class=\"markdownIt-Anchor\" href=\"#参见-2\">#</a> 参见</h5>\n<p>这是这条规则的一种特殊情况：<a href=\"#Rc-helper\">辅助函数应当定义于它们的类相同的命名空间之中</a>。</p>\n<h5 id=\"强制实施-156\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-156\">#</a> 强制实施</h5>\n<ul>\n<li>对并非处于其操作数的命名空间中的运算符的定义进行标记。</li>\n</ul>\n<h3 id=\"a-namero-lambdaac170-当想要重载-lambda-时应当使用泛型-lambda\"><a class=\"markdownIt-Anchor\" href=\"#a-namero-lambdaac170-当想要重载-lambda-时应当使用泛型-lambda\">#</a> <a name=\"Ro-lambda\"></a>C.170: 当想要重载 lambda 时，应当使用泛型 lambda</h3>\n<h5 id=\"理由-165\"><a class=\"markdownIt-Anchor\" href=\"#理由-165\">#</a> 理由</h5>\n<p>无法通过定义两个带有相同名字的不同 lambda 来进行重载。</p>\n<h5 id=\"示例-149\"><a class=\"markdownIt-Anchor\" href=\"#示例-149\">#</a> 示例</h5>\n<pre><code>void f(int);\nvoid f(double);\nauto f = [](char);   // 错误: 无法重载变量和函数\n\nauto g = [](int) &#123; /* ... */ &#125;;\nauto g = [](double) &#123; /* ... */ &#125;;   // 错误: 无法重载变量\n\nauto h = [](auto) &#123; /* ... */ &#125;;   // OK\n</code></pre>\n<h5 id=\"强制实施-157\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-157\">#</a> 强制实施</h5>\n<p>编译期会查明对 lambda 进行重载的企图。</p>\n<h2 id=\"a-namess-unionacunion-联合体\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-unionacunion-联合体\">#</a> <a name=\"SS-union\"></a>C.union: 联合体</h2>\n<p><code>union</code>  是一种  <code>struct</code> ，其所有成员都开始于相同的地址，因而它同时只能持有一个成员。<br>\n <code>union</code>  并不会跟踪其所存储的是哪个成员，因此必须由程序员来保证其正确；<br>\n这本质上就是易错的，但有一些弥补的办法。</p>\n<p>由一个  <code>union</code>  加上一个用于指出其当前持有哪个成员的指示符构成的类型被称为<em>带标记联合体（tagged union）</em>，<em>区分性联合体（discriminated union）</em>，或者<em>变异体（variant）</em>。</p>\n<p>联合体规则概览：</p>\n<ul>\n<li><a href=\"#Ru-union\">C.180: 采用  <code>union</code>  用以节省内存</a></li>\n<li><a href=\"#Ru-naked\">C.181: 避免 “裸”  <code>union</code> </a></li>\n<li><a href=\"#Ru-anonymous\">C.182: 利用匿名  <code>union</code>  实现带标记联合体</a></li>\n<li><a href=\"#Ru-pun\">C.183: 不要将  <code>union</code>  用于类型双关</a></li>\n<li>???</li>\n</ul>\n<h3 id=\"a-nameru-unionac180-采用-union-用以节省内存\"><a class=\"markdownIt-Anchor\" href=\"#a-nameru-unionac180-采用-union-用以节省内存\">#</a> <a name=\"Ru-union\"></a>C.180: 采用  <code>union</code>  用以节省内存</h3>\n<h5 id=\"理由-166\"><a class=\"markdownIt-Anchor\" href=\"#理由-166\">#</a> 理由</h5>\n<p><code>union</code>  可以让一块内存在不同的时间用于不同类型的数据。<br>\n因此，当我们有几个不可能同时使用的对象时，可以用它来节省内存。</p>\n<h5 id=\"示例-150\"><a class=\"markdownIt-Anchor\" href=\"#示例-150\">#</a> 示例</h5>\n<pre><code>union Value &#123;\n    int x;\n    double d;\n&#125;;\n\nValue v = &#123; 123 &#125;;  // 现在 v 持有一个 int\ncout &lt;&lt; v.x &lt;&lt; '\\n';    // 写下 123\nv.d = 987.654;  // 现在 v 持有一个 double\ncout &lt;&lt; v.d &lt;&lt; '\\n';    // 写下 987.654\n</code></pre>\n<p>但请你留意这个警告：<a href=\"#Ru-naked\">避免 “裸” <code>union</code> </a>。</p>\n<h5 id=\"示例-151\"><a class=\"markdownIt-Anchor\" href=\"#示例-151\">#</a> 示例</h5>\n<pre><code>// 短字符串优化\n\nconstexpr size_t buffer_size = 16; // 比指针的大小稍大\n\nclass Immutable_string &#123;\npublic:\n    Immutable_string(const char* str) :\n        size(strlen(str))\n    &#123;\n        if (size &lt; buffer_size)\n            strcpy_s(string_buffer, buffer_size, str);\n        else &#123;\n            string_ptr = new char[size + 1];\n            strcpy_s(string_ptr, size + 1, str);\n        &#125;\n    &#125;\n\n    ~Immutable_string()\n    &#123;\n        if (size &gt;= buffer_size)\n            delete[] string_ptr;\n    &#125;\n\n    const char* get_str() const\n    &#123;\n        return (size &lt; buffer_size) ? string_buffer : string_ptr;\n    &#125;\n\nprivate:\n    // 当字符串足够短时，可以以其自己保存字符串\n    // 而不是指向字符串的指针。\n    union &#123;\n        char* string_ptr;\n        char string_buffer[buffer_size];\n    &#125;;\n\n    const size_t size;\n&#125;;\n</code></pre>\n<h5 id=\"强制实施-158\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-158\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-nameru-nakedac181-避免裸-union\"><a class=\"markdownIt-Anchor\" href=\"#a-nameru-nakedac181-避免裸-union\">#</a> <a name=\"Ru-naked\"></a>C.181: 避免 “裸”  <code>union</code></h3>\n<h5 id=\"理由-167\"><a class=\"markdownIt-Anchor\" href=\"#理由-167\">#</a> 理由</h5>\n<p>* 裸联合体（naked union）* 是没有相关的指示其持有哪个成员（如果有）的指示器的联合体，<br>\n程序员必须保持对它的跟踪。<br>\n裸联合体是类型错误的一种来源。</p>\n<h5 id=\"example-bad\"><a class=\"markdownIt-Anchor\" href=\"#example-bad\">#</a> Example, bad</h5>\n<pre><code>union Value &#123;\n    int x;\n    double d;\n&#125;;\n\nValue v;\nv.d = 987.654;  // v 持有一个 double\n</code></pre>\n<p>至此为止还都不错，但我们可能会轻易地误用这个  <code>union</code> ：</p>\n<pre><code>cout &lt;&lt; v.x &lt;&lt; '\\n';    // 不好，未定义的行为：v 持有一个 double，但我们将之当做一个 int 来读取\n</code></pre>\n<p>注意这个类型错误的发生并没有任何明确的强制转换。<br>\n当我们测试程序时，其所打印的最后一个值是  <code>1683627180</code> ，这是  <code>987.654</code>  的位模式的整数值。<br>\n我们这里遇到的是一个 “不可见” 的类型错误，它刚好给出的结果轻易可能被看作是无辜清白的。</p>\n<p>对于 “不可见” 来说，下面的代码不会产生任何输出：</p>\n<pre><code>v.x = 123;\ncout &lt;&lt; v.d &lt;&lt; '\\n';    // 不好：未定义的行为\n</code></pre>\n<h5 id=\"替代方案-8\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-8\">#</a> 替代方案</h5>\n<p>将它们和一个类型字段一起包装到类之中。</p>\n<p>可以使用 C++17 的  <code>variant</code>  类型（在  <code>&lt;variant&gt;</code>  中可以找到）：</p>\n<pre><code>variant&lt;int, double&gt; v;\nv = 123;        // v 持有一个 int\nint x = get&lt;int&gt;(v);\nv = 123.456;    // v 持有一个 double\nw = get&lt;double&gt;(v);\n</code></pre>\n<h5 id=\"强制实施-159\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-159\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-nameru-anonymousac182-利用匿名-union-实现带标记联合体\"><a class=\"markdownIt-Anchor\" href=\"#a-nameru-anonymousac182-利用匿名-union-实现带标记联合体\">#</a> <a name=\"Ru-anonymous\"></a>C.182: 利用匿名  <code>union</code>  实现带标记联合体</h3>\n<h5 id=\"理由-168\"><a class=\"markdownIt-Anchor\" href=\"#理由-168\">#</a> 理由</h5>\n<p>设计良好的带标记联合体是类型安全的。<br>\n<em>匿名</em>联合体可以简化这种带有 (tag, union) 对的类的定义。</p>\n<h5 id=\"示例-152\"><a class=\"markdownIt-Anchor\" href=\"#示例-152\">#</a> 示例</h5>\n<p>这个例子基本上是从 TC++PL4 pp216-218 借鉴而来的。<br>\n你可以查看原文以获得其介绍。</p>\n<p>这段代码多少有点复杂。<br>\n处理一个带有用户定义的赋值和析构函数的类型是比较麻烦的。<br>\n在标准中包含  <code>variant</code>  的原因之一就是避免程序员不得不编写这样的代码。</p>\n<pre><code>class Value &#123; // 以一个联合体来表现两个候选表示\nprivate:\n    enum class Tag &#123; number, text &#125;;\n    Tag type; // 区分\n\n    union &#123; // 表示（注意这是匿名联合体）\n        int i;\n        string s; // string 带有默认构造函数，复制操作，和析构函数\n    &#125;;\npublic:\n    struct Bad_entry &#123; &#125;; // 用作异常\n\n    ~Value();\n    Value&amp; operator=(const Value&amp;);   // 因为 string 变体的缘故而需要这个\n    Value(const Value&amp;);\n    // ...\n    int number() const;\n    string text() const;\n\n    void set_number(int n);\n    void set_text(const string&amp;);\n    // ...\n&#125;;\n\nint Value::number() const\n&#123;\n    if (type != Tag::number) throw Bad_entry&#123;&#125;;\n    return i;\n&#125;\n\nstring Value::text() const\n&#123;\n    if (type != Tag::text) throw Bad_entry&#123;&#125;;\n    return s;\n&#125;\n\nvoid Value::set_number(int n)\n&#123;\n    if (type == Tag::text) &#123;\n        s.~string();      // 显式销毁 string\n        type = Tag::number;\n    &#125;\n    i = n;\n&#125;\n\nvoid Value::set_text(const string&amp; ss)\n&#123;\n    if (type == Tag::text)\n        s = ss;\n    else &#123;\n        new(&amp;s) string&#123;ss&#125;;   // 放置式 new: 显式构造 string\n        type = Tag::text;\n    &#125;\n&#125;\n\nValue&amp; Value::operator=(const Value&amp; e)   // 因为 string 变体的缘故而需要这个\n&#123;\n    if (type == Tag::text &amp;&amp; e.type == Tag::text) &#123;\n        s = e.s;    // 常规的 string 赋值\n        return *this;\n    &#125;\n\n    if (type == Tag::text) s.~string(); // 显式销毁\n\n    switch (e.type) &#123;\n    case Tag::number:\n        i = e.i;\n        break;\n    case Tag::text:\n        new(&amp;s) string(e.s);   // 放置式 new: 显式构造\n    &#125;\n\n    type = e.type;\n    return *this;\n&#125;\n\nValue::~Value()\n&#123;\n    if (type == Tag::text) s.~string(); // 显式销毁\n&#125;\n</code></pre>\n<h5 id=\"强制实施-160\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-160\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-nameru-punac183-不要将-union-用于类型双关\"><a class=\"markdownIt-Anchor\" href=\"#a-nameru-punac183-不要将-union-用于类型双关\">#</a> <a name=\"Ru-pun\"></a>C.183: 不要将  <code>union</code>  用于类型双关</h3>\n<h5 id=\"理由-169\"><a class=\"markdownIt-Anchor\" href=\"#理由-169\">#</a> 理由</h5>\n<p>读取一个  <code>union</code>  曾写入的成员不同类型的成员是未定义的行为。<br>\n这种双关是不可见的，或者至少比具名强制转换更难于找出。<br>\n使用  <code>union</code>  的类型双关是一种错误来源。</p>\n<h5 id=\"示例不好-62\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-62\">#</a> 示例，不好</h5>\n<pre><code>union Pun &#123;\n    int x;\n    unsigned char c[sizeof(int)];\n&#125;;\n</code></pre>\n<p><code>Pun</code>  的想法是要能够查看  <code>int</code>  的字符表示。</p>\n<pre><code>void bad(Pun&amp; u)\n&#123;\n    u.x = 'x';\n    cout &lt;&lt; u.c[0] &lt;&lt; '\\n';     // 未定义行为\n&#125;\n</code></pre>\n<p>如果你想要查看  <code>int</code>  的字节的话，应使用（具名）强制转换：</p>\n<pre><code>void if_you_must_pun(int&amp; x)\n&#123;\n    auto p = reinterpret_cast&lt;std::byte*&gt;(&amp;x);\n    cout &lt;&lt; p[0] &lt;&lt; '\\n';     // OK；好多了\n    // ...\n&#125;\n</code></pre>\n<p>对从对象的声明类型向  <code>char*</code> ， <code>unsigned char*</code> ，或  <code>std::byte*</code>  进行  <code>reinterpret_cast</code>  的结果进行访问是有定义的行为。（不建议使用  <code>reinterpret_cast</code> ，<br>\n但至少我们可以发觉发生了某种微妙的事情。）</p>\n<h5 id=\"注解-175\"><a class=\"markdownIt-Anchor\" href=\"#注解-175\">#</a> 注解</h5>\n<p>不幸的是， <code>union</code>  经常被用于类型双关。<br>\n我们认为 “它有时候能够按预期工作” 并不是一种令人信服的理由。</p>\n<p>C++17 引入了一个独立类型  <code>std::byte</code>  以支持在原始对象表示上进行的操作。在这些操作中应当使用这个类型代替  <code>unsigned char</code>  或  <code>char</code> 。</p>\n<h5 id=\"强制实施-161\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-161\">#</a> 强制实施</h5>\n<p>???</p>\n<h1 id=\"a-names-enumaenum-枚举\"><a class=\"markdownIt-Anchor\" href=\"#a-names-enumaenum-枚举\">#</a> <a name=\"S-enum\"></a>Enum: 枚举</h1>\n<p>枚举用于定义整数值的集合，并用于为这种值集定义类型。有两种类型的枚举，<br>\n“普通” 的  <code>enum</code>  和  <code>class enum</code> 。</p>\n<p>枚举规则概览：</p>\n<ul>\n<li><a href=\"#Renum-macro\">Enum.1: 优先采用枚举而不是宏</a></li>\n<li><a href=\"#Renum-set\">Enum.2: 采用枚举来表示相关的具名常量的集合</a></li>\n<li><a href=\"#Renum-class\">Enum.3: 优先采用  <code>enum class</code>  而不是 “普通” <code>enum</code> </a></li>\n<li><a href=\"#Renum-oper\">Enum.4: 针对安全和简单的用法来为枚举定义操作</a></li>\n<li><a href=\"#Renum-caps\">Enum.5: 请勿为枚举符采用  <code>ALL_CAPS</code>  命名方式</a></li>\n<li><a href=\"#Renum-unnamed\">Enum.6: 避免使用无名枚举</a></li>\n<li><a href=\"#Renum-underlying\">Enum.7: 仅在必要时才为枚举指定其底层类型</a></li>\n<li><a href=\"#Renum-value\">Enum.8: 仅在必要时才指定枚举符的值</a></li>\n</ul>\n<h3 id=\"a-namerenum-macroaenum1-优先采用-enum-而不是宏\"><a class=\"markdownIt-Anchor\" href=\"#a-namerenum-macroaenum1-优先采用-enum-而不是宏\">#</a> <a name=\"Renum-macro\"></a>Enum.1: 优先采用  <code>enum</code>  而不是宏</h3>\n<h5 id=\"理由-170\"><a class=\"markdownIt-Anchor\" href=\"#理由-170\">#</a> 理由</h5>\n<p>宏不遵守作用域和类型规则。而且，宏的名字在预处理中就被移除，因而通常不会出现在如调试器这样的工具中。</p>\n<h5 id=\"示例-153\"><a class=\"markdownIt-Anchor\" href=\"#示例-153\">#</a> 示例</h5>\n<p>首先是一些不好的老代码：</p>\n<pre><code>// webcolors.h (第三方头文件)\n#define RED   0xFF0000\n#define GREEN 0x00FF00\n#define BLUE  0x0000FF\n\n// productinfo.h\n// 以下则基于颜色定义了产品的子类型\n#define RED    0\n#define PURPLE 1\n#define BLUE   2\n\nint webby = BLUE;   // webby == 2; 可能不是我们所想要的\n</code></pre>\n<p>代之以  <code>enum</code> ：</p>\n<pre><code>enum class Web_color &#123; red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF &#125;;\nenum class Product_info &#123; red = 0, purple = 1, blue = 2 &#125;;\n\nint webby = blue;   // 错误: 应当明确\nWeb_color webby = Web_color::blue;\n</code></pre>\n<p>我们用  <code>enum class</code>  来避免名字冲突。</p>\n<h5 id=\"强制实施-162\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-162\">#</a> 强制实施</h5>\n<p>标记定义整数值的宏。</p>\n<h3 id=\"a-namerenum-setaenum2-采用枚举来表示相关的具名常量的集合\"><a class=\"markdownIt-Anchor\" href=\"#a-namerenum-setaenum2-采用枚举来表示相关的具名常量的集合\">#</a> <a name=\"Renum-set\"></a>Enum.2: 采用枚举来表示相关的具名常量的集合</h3>\n<h5 id=\"理由-171\"><a class=\"markdownIt-Anchor\" href=\"#理由-171\">#</a> 理由</h5>\n<p>枚举展示其枚举符之间是有关联的，且可以用作具名类型。</p>\n<h5 id=\"示例-154\"><a class=\"markdownIt-Anchor\" href=\"#示例-154\">#</a> 示例</h5>\n<pre><code>enum class Web_color &#123; red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF &#125;;\n</code></pre>\n<h5 id=\"注解-176\"><a class=\"markdownIt-Anchor\" href=\"#注解-176\">#</a> 注解</h5>\n<p>对枚举的  <code>switch</code>  是很常见的，编译器可以对不平常的  <code>case</code>  标签进行警告。例如：</p>\n<pre><code>enum class Product_info &#123; red = 0, purple = 1, blue = 2 &#125;;\n\nvoid print(Product_info inf)\n&#123;\n    switch (inf) &#123;\n    case Product_info::red: cout &lt;&lt; &quot;red&quot;; break;\n    case Product_info::purple: cout &lt;&lt; &quot;purple&quot;; break;\n    &#125;\n&#125;\n</code></pre>\n<p>这种漏掉一个的  <code>switch</code>  语句通常是添加枚举符并缺少测试的结果。</p>\n<h5 id=\"强制实施-163\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-163\">#</a> 强制实施</h5>\n<ul>\n<li>当  <code>switch</code>  语句的  <code>case</code>  标签并未覆盖枚举的全部枚举符时，对其进行标记。</li>\n<li>当  <code>switch</code>  语句的  <code>case</code>  覆盖了枚举的几个枚举符，但没有  <code>default</code>  时，对其进行标记。</li>\n</ul>\n<h3 id=\"a-namerenum-classaenum3-优先采用-class-enum-而不是普通enum\"><a class=\"markdownIt-Anchor\" href=\"#a-namerenum-classaenum3-优先采用-class-enum-而不是普通enum\">#</a> <a name=\"Renum-class\"></a>Enum.3: 优先采用  <code>class enum</code>  而不是 “普通” <code>enum</code></h3>\n<h5 id=\"理由-172\"><a class=\"markdownIt-Anchor\" href=\"#理由-172\">#</a> 理由</h5>\n<p>最小化意外情况：传统的  <code>enum</code>  太容易转换为  <code>int</code>  了。</p>\n<h5 id=\"示例-155\"><a class=\"markdownIt-Anchor\" href=\"#示例-155\">#</a> 示例</h5>\n<pre><code>void Print_color(int color);\n\nenum Web_color &#123; red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF &#125;;\nenum Product_info &#123; red = 0, purple = 1, blue = 2 &#125;;\n\nWeb_color webby = Web_color::blue;\n\n// 显然至少有一个调用是有问题的。\nPrint_color(webby);\nPrint_color(Product_info::blue);\n</code></pre>\n<p>代之以  <code>enum class</code> ：</p>\n<pre><code>void Print_color(int color);\n\nenum class Web_color &#123; red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF &#125;;\nenum class Product_info &#123; red = 0, purple = 1, blue = 2 &#125;;\n\nWeb_color webby = Web_color::blue;\nPrint_color(webby);  // 错误: 无法转换 Web_color 为 int。\nPrint_color(Product_info::red);  // 错误: 无法转换 Product_info 为 int。\n</code></pre>\n<h5 id=\"强制实施-164\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-164\">#</a> 强制实施</h5>\n<p>【简单】 对所有非  <code>class enum</code>  定义进行警告。</p>\n<h3 id=\"a-namerenum-operaenum4-针对安全和简单的用法来为枚举定义操作\"><a class=\"markdownIt-Anchor\" href=\"#a-namerenum-operaenum4-针对安全和简单的用法来为枚举定义操作\">#</a> <a name=\"Renum-oper\"></a>Enum.4: 针对安全和简单的用法来为枚举定义操作</h3>\n<h5 id=\"理由-173\"><a class=\"markdownIt-Anchor\" href=\"#理由-173\">#</a> 理由</h5>\n<p>便于使用并避免犯错。</p>\n<h5 id=\"示例-156\"><a class=\"markdownIt-Anchor\" href=\"#示例-156\">#</a> 示例</h5>\n<pre><code>enum Day &#123; mon, tue, wed, thu, fri, sat, sun &#125;;\n\nDay&amp; operator++(Day&amp; d)\n&#123;\n    return d = (d == Day::sun) ? Day::mon : static_cast&lt;Day&gt;(static_cast&lt;int&gt;(d)+1);\n&#125;\n\nDay today = Day::sat;\nDay tomorrow = ++today;\n</code></pre>\n<p>这里使用  <code>static_cast</code>  有点不好，但</p>\n<pre><code>Day&amp; operator++(Day&amp; d)\n&#123;\n    return d = (d == Day::sun) ? Day::mon : Day(++d);    // 错误\n&#125;\n</code></pre>\n<p>是无限递归，而且不用强制转换而使用一个针对所有情况的  <code>switch</code>  太冗长了。</p>\n<h5 id=\"强制实施-165\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-165\">#</a> 强制实施</h5>\n<p>对重复出现的强制转换回枚举的表达式进行标记。</p>\n<h3 id=\"a-namerenum-capsaenum5-请勿为枚举符采用-all_caps-命名方式\"><a class=\"markdownIt-Anchor\" href=\"#a-namerenum-capsaenum5-请勿为枚举符采用-all_caps-命名方式\">#</a> <a name=\"Renum-caps\"></a>Enum.5: 请勿为枚举符采用  <code>ALL_CAPS</code>  命名方式</h3>\n<h5 id=\"理由-174\"><a class=\"markdownIt-Anchor\" href=\"#理由-174\">#</a> 理由</h5>\n<p>避免和宏之间发生冲突</p>\n<h5 id=\"示例不好-63\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-63\">#</a> 示例，不好</h5>\n<pre><code> // webcolors.h （第三方头文件）\n#define RED   0xFF0000\n#define GREEN 0x00FF00\n#define BLUE  0x0000FF\n\n// productinfo.h\n// 以下则基于颜色定义了产品的子类型\n\nenum class Product_info &#123; RED, PURPLE, BLUE &#125;;   // 语法错误\n</code></pre>\n<h5 id=\"强制实施-166\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-166\">#</a> 强制实施</h5>\n<p>标记 ALL_CAPS 风格的枚举符。</p>\n<h3 id=\"a-namerenum-unnamedaenum6-避免使用无名枚举\"><a class=\"markdownIt-Anchor\" href=\"#a-namerenum-unnamedaenum6-避免使用无名枚举\">#</a> <a name=\"Renum-unnamed\"></a>Enum.6: 避免使用无名枚举</h3>\n<h5 id=\"理由-175\"><a class=\"markdownIt-Anchor\" href=\"#理由-175\">#</a> 理由</h5>\n<p>如果无法对枚举命名的话，它的值之间就是没有关联的。</p>\n<h5 id=\"示例不好-64\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-64\">#</a> 示例，不好</h5>\n<pre><code>enum &#123; red = 0xFF0000, scale = 4, is_signed = 1 &#125;;\n</code></pre>\n<p>这种代码在出现指定整数常量的其他方便方式之前并不少见。</p>\n<h5 id=\"替代方案-9\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-9\">#</a> 替代方案</h5>\n<p>代之以使用  <code>constexpr</code>  值。例如：</p>\n<pre><code>constexpr int red = 0xFF0000;\nconstexpr short scale = 4;\nconstexpr bool is_signed = true;\n</code></pre>\n<h5 id=\"强制实施-167\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-167\">#</a> 强制实施</h5>\n<p>对无名枚举进行标记。</p>\n<h3 id=\"a-namerenum-underlyingaenum7-仅在必要时才为枚举指定其底层类型\"><a class=\"markdownIt-Anchor\" href=\"#a-namerenum-underlyingaenum7-仅在必要时才为枚举指定其底层类型\">#</a> <a name=\"Renum-underlying\"></a>Enum.7: 仅在必要时才为枚举指定其底层类型</h3>\n<h5 id=\"理由-176\"><a class=\"markdownIt-Anchor\" href=\"#理由-176\">#</a> 理由</h5>\n<p>缺省情况的读写都是最简单的。<br>\n <code>int</code>  是缺省的整数类型。<br>\n <code>int</code>  是和 C 的  <code>enum</code>  相兼容的。</p>\n<h5 id=\"示例-157\"><a class=\"markdownIt-Anchor\" href=\"#示例-157\">#</a> 示例</h5>\n<pre><code>enum class Direction : char &#123; n, s, e, w,\n                              ne, nw, se, sw &#125;;  // 底层类型可以节省空间\n\nenum class Web_color : int32_t &#123; red   = 0xFF0000,\n                                 green = 0x00FF00,\n                                 blue  = 0x0000FF &#125;;  // 底层类型是多余的\n</code></pre>\n<h5 id=\"注解-177\"><a class=\"markdownIt-Anchor\" href=\"#注解-177\">#</a> 注解</h5>\n<p>对 <code>enum</code>  或 <code>enum class</code>  前向声明时有必要指定底层类型：</p>\n<pre><code>enum Flags : char;\n\nvoid f(Flags);\n\n// ....\n\nenum Flags : char &#123; /* ... */ &#125;;\n</code></pre>\n<p>或者用以确保该类型的值具有指定的位精度：</p>\n<pre><code>enum Bitboard : uint64_t &#123; /* ... */ &#125;;\n</code></pre>\n<h5 id=\"强制实施-168\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-168\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerenum-valueaenum8-仅在必要时才指定枚举符的值\"><a class=\"markdownIt-Anchor\" href=\"#a-namerenum-valueaenum8-仅在必要时才指定枚举符的值\">#</a> <a name=\"Renum-value\"></a>Enum.8: 仅在必要时才指定枚举符的值</h3>\n<h5 id=\"理由-177\"><a class=\"markdownIt-Anchor\" href=\"#理由-177\">#</a> 理由</h5>\n<p>这是最简单的。<br>\n避免了枚举符值发生重复。<br>\n缺省情况会提供一组连续的值，并有利于  <code>switch</code>  语句的实现。</p>\n<h5 id=\"示例-158\"><a class=\"markdownIt-Anchor\" href=\"#示例-158\">#</a> 示例</h5>\n<pre><code>enum class Col1 &#123; red, yellow, blue &#125;;\nenum class Col2 &#123; red = 1, yellow = 2, blue = 2 &#125;; // 打错字\nenum class Month &#123; jan = 1, feb, mar, apr, may, jun,\n                   jul, august, sep, oct, nov, dec &#125;; // 传统是从 1 开始\nenum class Base_flag &#123; dec = 1, oct = dec &lt;&lt; 1, hex = dec &lt;&lt; 2 &#125;; // 位的集合\n</code></pre>\n<p>为了和传统的值相匹配（比如  <code>Month</code> ），以及当连续的值不合要求<br>\n（比如像  <code>Base_flag</code>  一样分配不同的位），是需要指定值的。</p>\n<h5 id=\"强制实施-169\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-169\">#</a> 强制实施</h5>\n<ul>\n<li>标记重复的枚举值</li>\n<li>对明确指定的全部连续的枚举符的值进行标记。</li>\n</ul>\n<h1 id=\"a-names-resourcear-资源管理\"><a class=\"markdownIt-Anchor\" href=\"#a-names-resourcear-资源管理\">#</a> <a name=\"S-resource\"></a>R: 资源管理</h1>\n<p>本章节中包含于资源相关的各项规则。<br>\n资源，就是任何必须进行获取，并（显式或隐式）进行释放的东西，比如内存、文件句柄、Socket 和锁等等。<br>\n其必须进行释放的原因在于它们是短缺的，因而即便是采用延迟释放也许也是有害的。<br>\n基本的目标是要确保不会泄漏任何资源，而且不会持有不在需要的任何资源。<br>\n负责释放某个资源的实体被称作是其所有者。</p>\n<p>少数情况下，发生泄漏是可接受的甚至是理想的：<br>\n如果所编写的程序只是基于输入来产生输出，而其所需的内存正比于输入的大小，那么最理想的（性能和开发便利性）策略有时候恰是不要删除任何东西。<br>\n如果有足够的内存来处理最大输入的话，让其泄漏即可，但如果并非如此，应当保证给出一条恰当的错误消息。<br>\n这里，我们将忽略这样的情况。</p>\n<ul>\n<li>\n<p>资源管理规则概览：</p>\n<ul>\n<li><a href=\"#Rr-raii\">R.1: 利用资源句柄和 RAII（资源获取即初始化）来自动管理资源</a></li>\n<li><a href=\"#Rr-use-ptr\">R.2: 接口中的原生指针（仅）代表个体对象</a></li>\n<li><a href=\"#Rr-ptr\">R.3: 原生指针（ <code>T*</code> ）没有所有权</a></li>\n<li><a href=\"#Rr-ref\">R.4: 原生引用（ <code>T&amp;</code> ）没有所有权</a></li>\n<li><a href=\"#Rr-scoped\">R.5: 优先采用有作用域的对象，避免不必要的堆分配</a></li>\n<li><a href=\"#Rr-global\">R.6: 避免非  <code>const</code>  的全局变量</a></li>\n</ul>\n</li>\n<li>\n<p>分配和回收规则概览：</p>\n<ul>\n<li><a href=\"#Rr-mallocfree\">R.10: 避免  <code>malloc()</code>  和  <code>free()</code> </a></li>\n<li><a href=\"#Rr-newdelete\">R.11: 避免显式调用  <code>new</code>  和  <code>delete</code> </a></li>\n<li><a href=\"#Rr-immediate-alloc\">R.12: 显式资源分配的结果应当立即交给一个管理对象</a></li>\n<li><a href=\"#Rr-single-alloc\">R.13: 单个表达式语句中至多进行一次显式资源分配</a></li>\n<li><a href=\"#Rr-ap\">R.14: 避免使用  <code>[]</code>  形参，优先使用  <code>span</code> </a></li>\n<li><a href=\"#Rr-pair\">R.15: 总是同时重载相匹配的分配、回收函数对</a></li>\n</ul>\n</li>\n<li>\n<p><a name=\"Rr-summary-smartptrs\"></a>智能指针规则概览：</p>\n<ul>\n<li><a href=\"#Rr-owner\">R.20: 用  <code>unique_ptr</code>  或  <code>shared_ptr</code>  表示所有权</a></li>\n<li><a href=\"#Rr-unique\">R.21: 优先采用  <code>unique_ptr</code>  而不是  <code>shared_ptr</code> ，除非需要共享所有权</a></li>\n<li><a href=\"#Rr-make_shared\">R.22: 使用  <code>make_shared()</code>  创建  <code>shared_ptr</code> </a></li>\n<li><a href=\"#Rr-make_unique\">R.23: 使用  <code>make_unique()</code>  创建  <code>unique_ptr</code> </a></li>\n<li><a href=\"#Rr-weak_ptr\">R.24: 使用  <code>std::weak_ptr</code>  来打断  <code>shared_ptr</code>  的循环引用</a></li>\n<li><a href=\"#Rr-smartptrparam\">R.30: 以智能指针为参数，仅用于明确表达生存期语义</a></li>\n<li><a href=\"#Rr-smart\">R.31: 非  <code>std</code>  的智能指针，应当遵循  <code>std</code>  的行为模式</a></li>\n<li><a href=\"#Rr-uniqueptrparam\">R.32:  <code>unique_ptr&lt;widget&gt;</code>  参数用以表达函数假定获得  <code>widget</code>  的所有权</a></li>\n<li><a href=\"#Rr-reseat\">R.33:  <code>unique_ptr&lt;widget&gt;&amp;</code>  参数用以表达函数对该  <code>widget</code>  重新置位</a></li>\n<li><a href=\"#Rr-sharedptrparam-owner\">R.34:  <code>shared_ptr&lt;widget&gt;</code>  参数用以表达函数是所有者的一份子</a></li>\n<li><a href=\"#Rr-sharedptrparam\">R.35:  <code>shared_ptr&lt;widget&gt;&amp;</code>  参数用以表达函数可能会对共享的指针重新置位</a></li>\n<li><a href=\"#Rr-sharedptrparam-const\">R.36:  <code>const shared_ptr&lt;widget&gt;&amp;</code>  参数用以表达它可能将保留一个对对象的引用？？？</a></li>\n<li><a href=\"#Rr-smartptrget\">R.37: 不要把来自某个智能指针别名的指针或引用传递出去</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"a-namerr-raiiar1-利用资源句柄和-raii资源获取即初始化来自动管理资源\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-raiiar1-利用资源句柄和-raii资源获取即初始化来自动管理资源\">#</a> <a name=\"Rr-raii\"></a>R.1: 利用资源句柄和 RAII（资源获取即初始化）来自动管理资源</h3>\n<h5 id=\"理由-178\"><a class=\"markdownIt-Anchor\" href=\"#理由-178\">#</a> 理由</h5>\n<p>避免资源泄漏和人工资源管理的复杂性。<br>\nC++ 语言确保的构造函数 / 析构函数对称性，反映了资源的获取 / 释放函数对（比如  <code>fopen</code> / <code>fclose</code> ， <code>lock</code> / <code>unlock</code> ，以及  <code>new</code> / <code>delete</code>  等）的对称性本质。<br>\n每当需要处理某个需要成对儿的获取 / 释放函数调用的资源时，应当将资源封装到保证这种配对调用的对象之中 —— 在构造函数中获取资源，并在其析构函数中释放它。</p>\n<h5 id=\"示例不好-65\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-65\">#</a> 示例，不好</h5>\n<p>考虑：</p>\n<pre><code>void send(X* x, string_view destination)\n&#123;\n    auto port = open_port(destination);\n    my_mutex.lock();\n    // ...\n    send(port, x);\n    // ...\n    my_mutex.unlock();\n    close_port(port);\n    delete x;\n&#125;\n</code></pre>\n<p>这段代码中，你必须记得在所有路径中调用  <code>unlock</code> 、 <code>close_port</code>  和  <code>delete</code> ，并且每个都恰好调用一次。<br>\n而且，一旦上面标有  <code>...</code>  的任何代码抛出了异常， <code>x</code>  就会泄漏，而  <code>my_mutex</code>  则保持锁定。</p>\n<h5 id=\"示例-159\"><a class=\"markdownIt-Anchor\" href=\"#示例-159\">#</a> 示例</h5>\n<p>考虑：</p>\n<pre><code>void send(unique_ptr&lt;X&gt; x, string_view destination)  // x 拥有这个 X\n&#123;\n    Port port&#123;destination&#125;;            // port 拥有这个 PortHandle\n    lock_guard&lt;mutex&gt; guard&#123;my_mutex&#125;; // guard 拥有这个锁\n    // ...\n    send(port, x);\n    // ...\n&#125; // 自动解锁 my_mutex 并删除 x 中的指针\n</code></pre>\n<p>现在所有的资源清理都是自动进行的，不管是否发生了异常，所有路径中都会执行一次。额外的好处是，该函数现在明确声称它将接过指针的所有权。</p>\n<p><code>Port</code>  又是什么呢？是一个封装资源的便利句柄：</p>\n<pre><code>class Port &#123;\n    PortHandle port;\npublic:\n    Port(string_view destination) : port&#123;open_port(destination)&#125; &#123; &#125;\n    ~Port() &#123; close_port(port); &#125;\n    operator PortHandle() &#123; return port; &#125;\n\n    // port 句柄通常是不能克隆的，因此根据需要关闭了复制和赋值\n    Port(const Port&amp;) = delete;\n    Port&amp; operator=(const Port&amp;) = delete;\n&#125;;\n</code></pre>\n<h5 id=\"注解-178\"><a class=\"markdownIt-Anchor\" href=\"#注解-178\">#</a> 注解</h5>\n<p>一旦发现一个 “表现不良” 的资源并未以带有析构函数的类来表示，就用一个类来包装它，或者使用 <a href=\"#Re-finally\"> <code>finally</code> </a>。</p>\n<p><strong>参见</strong>: <a href=\"#Re-raii\">RAII</a></p>\n<h3 id=\"a-namerr-use-ptrar2-接口中的原生指针仅代表个体对象\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-use-ptrar2-接口中的原生指针仅代表个体对象\">#</a> <a name=\"Rr-use-ptr\"></a>R.2: 接口中的原生指针（仅）代表个体对象</h3>\n<h5 id=\"理由-179\"><a class=\"markdownIt-Anchor\" href=\"#理由-179\">#</a> 理由</h5>\n<p>最好用某个容器类型（比如  <code>vector</code> ，拥有数据），或者用  <code>span</code> （不拥有数据）来表示数组。<br>\n这些容器和视图都带有足够的信息来进行范围检查。</p>\n<h5 id=\"示例不好-66\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-66\">#</a> 示例，不好</h5>\n<pre><code>void f(int* p, int n)   // n 为 p[] 中的元素数量\n&#123;\n    // ...\n    p[2] = 7;   // 不好: 对原生指针采用下标\n    // ...\n&#125;\n</code></pre>\n<p>编译期不会读注释，而如果不读其他代码的话你也无法指导  <code>p</code>  是否真的指向了  <code>n</code>  个元素。<br>\n应当代之以  <code>span</code> 。</p>\n<h5 id=\"示例-160\"><a class=\"markdownIt-Anchor\" href=\"#示例-160\">#</a> 示例</h5>\n<pre><code>void g(int* p, int fmt)   // 用格式 fmt 打印 *p\n&#123;\n    // ... 只使用 *p 和 p[0] ...\n&#125;\n</code></pre>\n<h5 id=\"例外-34\"><a class=\"markdownIt-Anchor\" href=\"#例外-34\">#</a> 例外</h5>\n<p>C 风格的字符串是以单个指向以零结尾的字符序列的指针来传递的。<br>\n为了表明对这种约定的依赖，应当使用  <code>zstring</code>  而不是  <code>char*</code> 。</p>\n<h5 id=\"注解-179\"><a class=\"markdownIt-Anchor\" href=\"#注解-179\">#</a> 注解</h5>\n<p>当前许多的单元素指针的用法其实都应当用引用。<br>\n不过，如果  <code>nullptr</code>  是可能的值的话，也许引用就不是合理的替代方案了。</p>\n<h5 id=\"强制实施-170\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-170\">#</a> 强制实施</h5>\n<ul>\n<li>对并非来自容器、视图或迭代器的指针进行的指针算术（包括  <code>++</code> ）进行标记。<br>\n这条规则对比较老的代码库实施时，可能会产生巨量的误报。</li>\n<li>对把数组名被传递为单纯的指针进行标记。</li>\n</ul>\n<h3 id=\"a-namerr-ptrar3-原生指针t没有所有权\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-ptrar3-原生指针t没有所有权\">#</a> <a name=\"Rr-ptr\"></a>R.3: 原生指针（ <code>T*</code> ）没有所有权</h3>\n<h5 id=\"理由-180\"><a class=\"markdownIt-Anchor\" href=\"#理由-180\">#</a> 理由</h5>\n<p>对此（C++ 标准中和大多数代码中都）没有异议，大多数原生指针都是无所有权的。<br>\n我们希望将有所有权的指针标示出来，以使得可以可靠和高效地删除由有所有权指针所指向的对象。</p>\n<h5 id=\"示例-161\"><a class=\"markdownIt-Anchor\" href=\"#示例-161\">#</a> 示例</h5>\n<pre><code>void f()\n&#123;\n    int* p1 = new int&#123;7&#125;;           // 不好: 原生指针拥有了所有权\n    auto p2 = make_unique&lt;int&gt;(7);  // OK: int 被一个唯一指针所拥有\n    // ...\n&#125;\n</code></pre>\n<p><code>unique_ptr</code>  保证对它的对象进行删除（即便是发生异常时也如此），以此保护不发生泄漏。而  <code>T*</code>  做不到这点。</p>\n<h5 id=\"示例-162\"><a class=\"markdownIt-Anchor\" href=\"#示例-162\">#</a> 示例</h5>\n<pre><code>template&lt;typename T&gt;\nclass X &#123;\npublic:\n    T* p;   // 不好: 不清楚 p 是不是带有所有权\n    T* q;   // 不好: 不清楚 q 是不是带有所有权\n    // ...\n&#125;;\n</code></pre>\n<p>可以通过明确所有权来修正这个问题：</p>\n<pre><code>template&lt;typename T&gt;\nclass X2 &#123;\npublic:\n    owner&lt;T*&gt; p;  // OK: p 具有所有权\n    T* q;         // OK: q 没有所有权\n    // ...\n&#125;;\n</code></pre>\n<h5 id=\"例外-35\"><a class=\"markdownIt-Anchor\" href=\"#例外-35\">#</a> 例外</h5>\n<p>最主要的例外就是遗留代码，尤其是那些必须维持可以用 C 编译或者通过 ABI 来建立 C 和 C 风格的 C++ 之间的接口的代码。<br>\n亿万行的代码都违反本条规则而让  <code>T*</code>  具有所有权的现实是无法被忽略的。<br>\n我们由衷希望看到程序变换工具把这些 20 岁以上的 “遗留” 代码转换成光鲜的现代代码，<br>\n我们鼓励这种工具的开发、部署和使用，<br>\n我们希望这里的各项指导方针能够有助于这种工具的开发，<br>\n而且我们也在这一领域的研发工作中持续作出贡献。<br>\n但是，这是需要时间的：“遗留代码” 的产生比我们能翻新的老代码还要快，因此这将会花费许多年的时间。</p>\n<p>这些代码是无法被全部重写的（即便假定有良好的代码转换软件），尤其不会很快发生。<br>\n这个问题是不能简单通过把所有有所有权的指针都转换成  <code>unique_ptr</code>  和  <code>shared_ptr</code>  来（大规模）解决的，<br>\n这部分是因为我们确实需要在基础的资源句柄的实现中一起使用有所有权的 “原生指针” 和简单的指针。<br>\n例如，常见的  <code>vector</code>  实现中都有一个有所有权的指针和两个没有所有权的指针。<br>\n许多 ABI（以及基本上全部的面向 C 的接口代码）都使用  <code>T*</code> ，其中不少都是有所有权的。<br>\n一些接口是无法简单地用  <code>owner</code>  来标记的，因为它们需要维持可以作为 C 来编译<br>\n，（这可能是少见的恰当的使用宏的场合，它仅在 C++ 模式中扩展为  <code>owner</code> ）。</p>\n<h5 id=\"注解-180\"><a class=\"markdownIt-Anchor\" href=\"#注解-180\">#</a> 注解</h5>\n<p><code>owner&lt;T*&gt;</code>  并没有超出  <code>T*</code>  的默认语义。使用它可以不改动任何使用方代码，也不会影响 ABI。<br>\n它只不过是一项针对程序员和分析工具的提示。<br>\n比如说，当  <code>owner&lt;T*&gt;</code>  是某个类的成员时，这个类最好提供一个析构函数来  <code>delete</code>  它。</p>\n<h5 id=\"示例不好-67\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-67\">#</a> 示例，不好</h5>\n<p>返回（原生）指针的做法向调用方暴露了在生存期管理上的不确定性；就是说，谁应该删除其所指向的对象呢？</p>\n<pre><code>Gadget* make_gadget(int n)\n&#123;\n    auto p = new Gadget&#123;n&#125;;\n    // ...\n    return p;\n&#125;\n\nvoid caller(int n)\n&#123;\n    auto p = make_gadget(n);   // 要记得 delete p\n    // ...\n    delete p;\n&#125;\n</code></pre>\n<p>除了遭受<a href=\"#???\">资源泄漏</a>的问题外，这也带来了一组假性的分配和回收操作，而这其实是不必要的。如果 Gadget 可以廉价地从函数转移出来（就是说，它很小，或者具有高效的移动操作）的话，直接 “按值” 返回即可（参见<a href=\"#Rf-out\">输出返回值</a>）：</p>\n<pre><code>Gadget make_gadget(int n)\n&#123;\n    Gadget g&#123;n&#125;;\n    // ...\n    return g;\n&#125;\n</code></pre>\n<h5 id=\"注解-181\"><a class=\"markdownIt-Anchor\" href=\"#注解-181\">#</a> 注解</h5>\n<p>这条规则适用于工厂函数。</p>\n<h5 id=\"注解-182\"><a class=\"markdownIt-Anchor\" href=\"#注解-182\">#</a> 注解</h5>\n<p>如果指针语义是必须的（比如说，因为返回类型需要指代类层次中的基类（或接口）），则可以返回 “智能指针”。</p>\n<h5 id=\"强制实施-171\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-171\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】 对在并非  <code>owner&lt;T&gt;</code>  的原生指针上进行的  <code>delete</code>  给出警告。</li>\n<li>【中等】 对一个  <code>owner&lt;T&gt;</code>  指针，当并非每个代码路径中都要么进行  <code>reset</code>  要么明确  <code>delete</code> ，则给出警告。</li>\n<li>【简单】 当  <code>new</code>  的返回值被赋值给原生指针时，给出警告。</li>\n<li>【简单】 当函数所返回的对象是在函数中所分配的，并且它具有移动构造函数时，给出警告。<br>\n建议代之以按值返回。</li>\n</ul>\n<h3 id=\"a-namerr-refar4-原生引用t没有所有权\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-refar4-原生引用t没有所有权\">#</a> <a name=\"Rr-ref\"></a>R.4: 原生引用（ <code>T&amp;</code> ）没有所有权</h3>\n<h5 id=\"理由-181\"><a class=\"markdownIt-Anchor\" href=\"#理由-181\">#</a> 理由</h5>\n<p>对此（C++ 标准中和大多数代码中都）没有异议，大多数原生引用都是无所有权的。<br>\n我们希望将所有者都标示出来，以使得可以可靠和高效地删除由有所有权指针所指向的对象。</p>\n<h5 id=\"示例-163\"><a class=\"markdownIt-Anchor\" href=\"#示例-163\">#</a> 示例</h5>\n<pre><code>void f()\n&#123;\n    int&amp; r = *new int&#123;7&#125;;  // 不好: 原生的具有所有权的引用\n    // ...\n    delete &amp;r;             // 不好: 违反了有关删除原生指针的规则\n&#125;\n</code></pre>\n<p><strong>参见</strong>: <a href=\"#Rr-ptr\">原生指针的规则</a></p>\n<h5 id=\"强制实施-172\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-172\">#</a> 强制实施</h5>\n<p>参见<a href=\"#Rr-ptr\">原生指针的规则</a></p>\n<h3 id=\"a-namerr-scopedar5-优先采用有作用域的对象避免不必要的堆分配\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-scopedar5-优先采用有作用域的对象避免不必要的堆分配\">#</a> <a name=\"Rr-scoped\"></a>R.5: 优先采用有作用域的对象，避免不必要的堆分配</h3>\n<h5 id=\"理由-182\"><a class=\"markdownIt-Anchor\" href=\"#理由-182\">#</a> 理由</h5>\n<p>有作用域的对象是局部对象、全局对象，或者成员。<br>\n它们也意味着在其所在作用域或者所在对象之外无须花费单独的分配和回收成本。<br>\n有作用域对象的成员自身也是有作用域的，有作用域对象的构造函数和析构函数负责管理其成员的生存期。</p>\n<h5 id=\"示例-164\"><a class=\"markdownIt-Anchor\" href=\"#示例-164\">#</a> 示例</h5>\n<p>下面的例子效率不佳（因为无必要的分配和回收），在  <code>...</code>  中抛出异常和返回也是脆弱的（导致发生泄漏），而且也比较啰嗦：</p>\n<pre><code>void f(int n)\n&#123;\n    auto p = new Gadget&#123;n&#125;;\n    // ...\n    delete p;\n&#125;\n</code></pre>\n<p>可以用局部变量来代替它：</p>\n<pre><code>void f(int n)\n&#123;\n    Gadget g&#123;n&#125;;\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"强制实施-173\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-173\">#</a> 强制实施</h5>\n<ul>\n<li>【中级】 如果分配了某个对象，又在函数内的所有路径中都进行了回收，则给出警告。建议它应当被代之以一个局部的栈对象。</li>\n<li>【简单】 当局部的  <code>Unique_pointer</code>  或  <code>Shared_pointer</code>  在其生存期结束前未被移动、复制、赋值或  <code>reset</code> ，则给出警告。<br>\n例外：不对指向无界数组的局部  <code>Unique_pointer</code>  产生这种警告。（见下文）</li>\n</ul>\n<h5 id=\"例外-36\"><a class=\"markdownIt-Anchor\" href=\"#例外-36\">#</a> 例外</h5>\n<p>创建指向堆分配缓冲区的局部  <code>const unique_ptr&lt;T[]&gt;</code>  是没问题的，这是一种有效的表现有作用域的动态数组的方法。</p>\n<h5 id=\"示例-165\"><a class=\"markdownIt-Anchor\" href=\"#示例-165\">#</a> 示例</h5>\n<p>一个局部  <code>const unique_ptr&lt;T[]&gt;</code>  变量的有效用例：</p>\n<pre><code>int get_median_value(const std::list&lt;int&gt;&amp; integers)\n&#123;\n  const auto size = integers.size();\n\n  // OK: declaring a local unique_ptr&lt;T[]&gt;.\n  const auto local_buffer = std::make_unique_for_overwrite&lt;int[]&gt;(size);\n\n  std::copy_n(begin(integers), size, local_buffer.get());\n  std::nth_element(local_buffer.get(), local_buffer.get() + size/2, local_buffer.get() + size);\n\n  return local_buffer[size/2];\n&#125;\n</code></pre>\n<h3 id=\"a-namerr-globalar6-避免非-const-的全局变量\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-globalar6-避免非-const-的全局变量\">#</a> <a name=\"Rr-global\"></a>R.6: 避免非  <code>const</code>  的全局变量</h3>\n<p>参见 <a href=\"#Ri-global\">I.2</a></p>\n<h2 id=\"a-namess-allocaralloc-分配与回收\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-allocaralloc-分配与回收\">#</a> <a name=\"SS-alloc\"></a>R.alloc: 分配与回收</h2>\n<h3 id=\"a-namerr-mallocfreear10-避免-malloc-和-free\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-mallocfreear10-避免-malloc-和-free\">#</a> <a name=\"Rr-mallocfree\"></a>R.10: 避免  <code>malloc()</code>  和  <code>free()</code></h3>\n<h5 id=\"理由-183\"><a class=\"markdownIt-Anchor\" href=\"#理由-183\">#</a> 理由</h5>\n<p><code>malloc()</code>  和  <code>free()</code>  并不支持构造和销毁，而且无法同  <code>new</code>  和  <code>delete</code>  之间进行混用。</p>\n<h5 id=\"示例-166\"><a class=\"markdownIt-Anchor\" href=\"#示例-166\">#</a> 示例</h5>\n<pre><code>class Record &#123;\n    int id;\n    string name;\n    // ...\n&#125;;\n\nvoid use()\n&#123;\n    // p1 可能是 nullptr\n    // *p1 并未初始化；尤其是，\n    // 其中的 string 也还不是一个 string，而是一片和 string 大小相同的字节而已\n    Record* p1 = static_cast&lt;Record*&gt;(malloc(sizeof(Record)));\n\n    auto p2 = new Record;\n\n    // 如果没有抛出异常的话，*p2 就经过了默认初始化\n    auto p3 = new(nothrow) Record;\n    // p3 可能为 nullptr；否则 *p3 就经过了默认初始化\n\n    // ...\n\n    delete p1;    // 错误: 不能 delete 由 malloc() 分配的对象\n    free(p2);    // 错误: 不能 free() 由 new 分配的对象\n&#125;\n</code></pre>\n<p>在某些实现中， <code>delete</code>  和  <code>free()</code>  可能可以工作，或者也可能引发运行时的错误。</p>\n<h5 id=\"例外-37\"><a class=\"markdownIt-Anchor\" href=\"#例外-37\">#</a> 例外</h5>\n<p>有些应用程序或者代码段是不能接受异常的。<br>\n它们的最佳例子就是那些性命攸关的硬实时代码。<br>\n但要注意的是，许多对异常的禁止其实是基于某种（不良的）迷信，<br>\n或者来源于对没有进行系统性的资源管理的老式代码库的关注（很不幸，但这经常是必须的）。<br>\n在这些情况下，应当考虑使用  <code>nothrow</code>  版本的  <code>new</code> 。</p>\n<h5 id=\"强制实施-174\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-174\">#</a> 强制实施</h5>\n<p>对  <code>malloc</code>  和  <code>free</code>  的使用进行标记。</p>\n<h3 id=\"a-namerr-newdeletear11-避免显式调用-new-和-delete\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-newdeletear11-避免显式调用-new-和-delete\">#</a> <a name=\"Rr-newdelete\"></a>R.11: 避免显式调用  <code>new</code>  和  <code>delete</code></h3>\n<h5 id=\"理由-184\"><a class=\"markdownIt-Anchor\" href=\"#理由-184\">#</a> 理由</h5>\n<p>由  <code>new</code>  所返回的指针应当属于一个资源句柄（它将调用  <code>delete</code> ）。<br>\n若由  <code>new</code>  所返回的指针被赋值给普通的裸指针，那么这个对象就可能会泄漏。</p>\n<h5 id=\"注解-183\"><a class=\"markdownIt-Anchor\" href=\"#注解-183\">#</a> 注解</h5>\n<p>大型程序中，裸露的  <code>delete</code> （即出现于应用程序代码中，而不是专门进行资源管理的代码中）<br>\n很可能是一个 BUG：如果已经有了 N 个  <code>delete</code>  的话，怎么确定我们需要的不是 N+1 或者 N-1 个呢？<br>\n这种 BUG 可能会潜伏起来：它也许只会在维护过程中才暴露出来。<br>\n如果出现了裸露的  <code>new</code> ，那就可能在别的什么地方需要一个裸露的  <code>delete</code> ，因而可能也是一个 BUG。</p>\n<h5 id=\"强制实施-175\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-175\">#</a> 强制实施</h5>\n<p>【简单】 对任何  <code>new</code>  和  <code>delete</code>  的显式使用都给出警告。建议代之以  <code>make_unique</code> 。</p>\n<h3 id=\"a-namerr-immediate-allocar12-显式资源分配的结果应当立即交给一个管理对象\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-immediate-allocar12-显式资源分配的结果应当立即交给一个管理对象\">#</a> <a name=\"Rr-immediate-alloc\"></a>R.12: 显式资源分配的结果应当立即交给一个管理对象</h3>\n<h5 id=\"理由-185\"><a class=\"markdownIt-Anchor\" href=\"#理由-185\">#</a> 理由</h5>\n<p>如果不这样做的话，当发生异常或者返回时就可能造成泄露。</p>\n<h5 id=\"示例不好-68\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-68\">#</a> 示例，不好</h5>\n<pre><code>void func(const string&amp; name)\n&#123;\n    FILE* f = fopen(name, &quot;r&quot;);            // 打开文件\n    vector&lt;char&gt; buf(1024);\n    auto _ = finally([f] &#123; fclose(f); &#125;);  // 记得要关闭文件\n    // ...\n&#125;\n</code></pre>\n<p><code>buf</code>  的分配可能会失败，并导致文件句柄的泄漏。</p>\n<h5 id=\"示例-167\"><a class=\"markdownIt-Anchor\" href=\"#示例-167\">#</a> 示例</h5>\n<pre><code>void func(const string&amp; name)\n&#123;\n    ifstream f&#123;name&#125;;   // 打开文件\n    vector&lt;char&gt; buf(1024);\n    // ...\n&#125;\n</code></pre>\n<p>对文件句柄（在  <code>ifstream</code>  中）的使用是简单、高效而且安全的。</p>\n<h5 id=\"强制实施-176\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-176\">#</a> 强制实施</h5>\n<ul>\n<li>将用于初始化指针的显式分配标记出来。（问题：我们能识别出多少直接资源分配呢？）</li>\n</ul>\n<h3 id=\"a-namerr-single-allocar13-单个表达式语句中至多进行一次显式资源分配\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-single-allocar13-单个表达式语句中至多进行一次显式资源分配\">#</a> <a name=\"Rr-single-alloc\"></a>R.13: 单个表达式语句中至多进行一次显式资源分配</h3>\n<h5 id=\"理由-186\"><a class=\"markdownIt-Anchor\" href=\"#理由-186\">#</a> 理由</h5>\n<p>如果在一条语句中进行两次显式资源分配的话就可能发生资源泄漏，这是因为许多的子表达式（包括函数参数）的求值顺序都是未指明的。</p>\n<h5 id=\"示例-168\"><a class=\"markdownIt-Anchor\" href=\"#示例-168\">#</a> 示例</h5>\n<pre><code>void fun(shared_ptr&lt;Widget&gt; sp1, shared_ptr&lt;Widget&gt; sp2);\n</code></pre>\n<p>可以这样调用  <code>fun</code> ：</p>\n<pre><code>// 不好：可能会泄漏\nfun(shared_ptr&lt;Widget&gt;(new Widget(a, b)), shared_ptr&lt;Widget&gt;(new Widget(c, d)));\n</code></pre>\n<p>这是异常不安全的，因为编译器可能会把两个用以创建函数的两个参数的表达式重新排序。<br>\n特别是，编译器是可以交错执行这两个表达式的：<br>\n它可能会首先为两个对象都（通过调用  <code>operator new</code> ）进行内存分配，然后再试图调用二者的  <code>Widget</code>  构造函数。<br>\n一旦其中一个构造函数调用抛出了异常，那么另一个对象的内存可能永远不会被释放了！</p>\n<p>这个微妙的问题其实有一种简单的解决方案：永远不要在一条表达式语句中进行多于一次的显式资源分配。<br>\n例如：</p>\n<pre><code>shared_ptr&lt;Widget&gt; sp1(new Widget(a, b)); // 好多了，但不太干净\nfun(sp1, new Widget(c, d));\n</code></pre>\n<p>最佳的方案是使用返回所有者对象的工厂函数，而完全避免显式的分配：</p>\n<pre><code>fun(make_shared&lt;Widget&gt;(a, b), make_shared&lt;Widget&gt;(c, d)); // 最佳\n</code></pre>\n<p>如果还没有，请自己编写一个工厂包装。</p>\n<h5 id=\"强制实施-177\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-177\">#</a> 强制实施</h5>\n<ul>\n<li>将包含多次显式资源分配的表达式标记出来。（问题：我们能识别出多少直接资源分配呢？）</li>\n</ul>\n<h3 id=\"a-namerr-apar14-避免使用-形参优先使用-span\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-apar14-避免使用-形参优先使用-span\">#</a> <a name=\"Rr-ap\"></a>R.14: 避免使用  <code>[]</code>  形参，优先使用  <code>span</code></h3>\n<h5 id=\"理由-187\"><a class=\"markdownIt-Anchor\" href=\"#理由-187\">#</a> 理由</h5>\n<p>数组会退化为指针，因而丢失其大小信息，并留下了发生范围错误的机会。<br>\n使用  <code>span</code>  来保留大小信息。</p>\n<h5 id=\"示例-169\"><a class=\"markdownIt-Anchor\" href=\"#示例-169\">#</a> 示例</h5>\n<pre><code>void f(int[]);          // 不建议的做法\n\nvoid f(int*);           // 对多个对象不建议的做法\n                        // （指针应当指向单个对象，不要进行下标运算）\n\nvoid f(gsl::span&lt;int&gt;); // 好，建议的做法\n</code></pre>\n<h5 id=\"强制实施-178\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-178\">#</a> 强制实施</h5>\n<p>标记出  <code>[]</code>  参数。代之以使用  <code>span</code> 。</p>\n<h3 id=\"a-namerr-pairar15-总是同时重载相匹配的分配-回收函数对\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-pairar15-总是同时重载相匹配的分配-回收函数对\">#</a> <a name=\"Rr-pair\"></a>R.15: 总是同时重载相匹配的分配、回收函数对</h3>\n<h5 id=\"理由-188\"><a class=\"markdownIt-Anchor\" href=\"#理由-188\">#</a> 理由</h5>\n<p>不然的话就出现不匹配的操作，并导致混乱。</p>\n<h5 id=\"示例-170\"><a class=\"markdownIt-Anchor\" href=\"#示例-170\">#</a> 示例</h5>\n<pre><code>class X &#123;\n    // ...\n    void* operator new(size_t s);\n    void operator delete(void*);\n    // ...\n&#125;;\n</code></pre>\n<h5 id=\"注解-184\"><a class=\"markdownIt-Anchor\" href=\"#注解-184\">#</a> 注解</h5>\n<p>如果想要无法进行回收的内存的话，可以将回收操作  <code>=delete</code> 。<br>\n请勿留下它而不进行声明。</p>\n<h5 id=\"强制实施-179\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-179\">#</a> 强制实施</h5>\n<p>标记出不完全的操作对。</p>\n<h2 id=\"a-namess-smartarsmart-智能指针\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-smartarsmart-智能指针\">#</a> <a name=\"SS-smart\"></a>R.smart: 智能指针</h2>\n<h3 id=\"a-namerr-ownerar20-用-unique_ptr-或-shared_ptr-表示所有权\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-ownerar20-用-unique_ptr-或-shared_ptr-表示所有权\">#</a> <a name=\"Rr-owner\"></a>R.20: 用  <code>unique_ptr</code>  或  <code>shared_ptr</code>  表示所有权</h3>\n<h5 id=\"理由-189\"><a class=\"markdownIt-Anchor\" href=\"#理由-189\">#</a> 理由</h5>\n<p>它们可以避免资源泄漏。</p>\n<h5 id=\"示例-171\"><a class=\"markdownIt-Anchor\" href=\"#示例-171\">#</a> 示例</h5>\n<p>考虑：</p>\n<pre><code>void f()\n&#123;\n    X* p1 &#123; new X &#125;;              // 不好，p1 会泄漏\n    auto p4 = make_unique&lt;X&gt;();   // 好，唯一所有权\n    auto p5 = make_shared&lt;X&gt;();   // 好，共享所有权\n&#125;\n</code></pre>\n<p>这里（只有）初始化  <code>p1</code>  的对象将会泄漏。</p>\n<h5 id=\"强制实施-180\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-180\">#</a> 强制实施</h5>\n<p>【简单】 如果  <code>new</code>  的返回值被赋值给了原生指针，就给出警告。<br>\n【简单】 如果返回带所有权原始指针的函数的结果被赋值给了原生指针，就给出警告。</p>\n<h3 id=\"a-namerr-uniquear21-优先采用-unique_ptr-而不是-shared_ptr除非需要共享所有权\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-uniquear21-优先采用-unique_ptr-而不是-shared_ptr除非需要共享所有权\">#</a> <a name=\"Rr-unique\"></a>R.21: 优先采用  <code>unique_ptr</code>  而不是  <code>shared_ptr</code> ，除非需要共享所有权</h3>\n<h5 id=\"理由-190\"><a class=\"markdownIt-Anchor\" href=\"#理由-190\">#</a> 理由</h5>\n<p><code>unique_ptr</code>  概念上要更简单且更可预测（知道它何时会销毁），而且更快（不需要暗中维护引用计数）。</p>\n<h5 id=\"示例不好-69\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-69\">#</a> 示例，不好</h5>\n<p>这里并不需要维护一个引用计数。</p>\n<pre><code>void f()\n&#123;\n    shared_ptr&lt;Base&gt; base = make_shared&lt;Derived&gt;();\n    // 局部范围中使用 base，并未进行复制——引用计数不会超过 1\n&#125; // 销毁 base\n</code></pre>\n<h5 id=\"示例-172\"><a class=\"markdownIt-Anchor\" href=\"#示例-172\">#</a> 示例</h5>\n<p>这样更加高效：</p>\n<pre><code>void f()\n&#123;\n    unique_ptr&lt;Base&gt; base = make_unique&lt;Derived&gt;();\n    // 局部范围中使用 base\n&#125; // 销毁 base\n</code></pre>\n<h5 id=\"强制实施-181\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-181\">#</a> 强制实施</h5>\n<p>【简单】 如果函数所使用的  <code>Shared_pointer</code>  的对象是函数之内所分配的，而且既不会将这个  <code>Shared_pointer</code>  返回，也不会将其传递给其他接受  <code>Shared_pointer&amp;</code>  的函数的话，就给出警告。建议代之以  <code>unique_ptr</code> 。</p>\n<h3 id=\"a-namerr-make_sharedar22-使用-make_shared-创建-shared_ptr\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-make_sharedar22-使用-make_shared-创建-shared_ptr\">#</a> <a name=\"Rr-make_shared\"></a>R.22: 使用  <code>make_shared()</code>  创建  <code>shared_ptr</code></h3>\n<h5 id=\"理由-191\"><a class=\"markdownIt-Anchor\" href=\"#理由-191\">#</a> 理由</h5>\n<p><code>make_shared</code>  为构造提供了更精炼的语句。<br>\n它也提供了一个机会，通过把  <code>shared_ptr</code>  的使用计数和对象相邻放置，来消除为引用计数进行独立的内存分配操作。</p>\n<h5 id=\"示例-173\"><a class=\"markdownIt-Anchor\" href=\"#示例-173\">#</a> 示例</h5>\n<p>考虑：</p>\n<pre><code>shared_ptr&lt;X&gt; p1 &#123; new X&#123;2&#125; &#125;; // 不好\nauto p = make_shared&lt;X&gt;(2);    // 好\n</code></pre>\n<p><code>make_shared()</code>  版本仅提到一次  <code>X</code> ，因而它通常比显式的  <code>new</code>  方式要更简短（而且更快）。</p>\n<h5 id=\"强制实施-182\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-182\">#</a> 强制实施</h5>\n<p>【简单】 如果  <code>shared_ptr</code>  从  <code>new</code>  的结果而不是  <code>make_shared</code>  进行构造，就给出警告。</p>\n<h3 id=\"a-namerr-make_uniquear23-使用-make_unique-创建-unique_ptr\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-make_uniquear23-使用-make_unique-创建-unique_ptr\">#</a> <a name=\"Rr-make_unique\"></a>R.23: 使用  <code>make_unique()</code>  创建  <code>unique_ptr</code></h3>\n<h5 id=\"理由-192\"><a class=\"markdownIt-Anchor\" href=\"#理由-192\">#</a> 理由</h5>\n<p><code>make_unique</code>  为构造提供了更精炼的语句。<br>\n它也保证了复杂表达式中的异常安全性。</p>\n<h5 id=\"示例-174\"><a class=\"markdownIt-Anchor\" href=\"#示例-174\">#</a> 示例</h5>\n<pre><code>unique_ptr&lt;Foo&gt; p &#123;new Foo&#123;7&#125;&#125;;    // OK: 不过有重复\n\nauto q = make_unique&lt;Foo&gt;(7);      // 有改善: 并未重复 Foo\n</code></pre>\n<h5 id=\"强制实施-183\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-183\">#</a> 强制实施</h5>\n<p>【简单】 如果  <code>unique_ptr</code>  从  <code>new</code>  的结果而不是  <code>make_unique</code>  进行构造，就给出警告。</p>\n<h3 id=\"a-namerr-weak_ptrar24-使用-stdweak_ptr-来打断-shared_ptr-的循环引用\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-weak_ptrar24-使用-stdweak_ptr-来打断-shared_ptr-的循环引用\">#</a> <a name=\"Rr-weak_ptr\"></a>R.24: 使用  <code>std::weak_ptr</code>  来打断  <code>shared_ptr</code>  的循环引用</h3>\n<h5 id=\"理由-193\"><a class=\"markdownIt-Anchor\" href=\"#理由-193\">#</a> 理由</h5>\n<p><code>shared_ptr</code>  是基于引用计数的，而带有循环的结构中的引用计数不可能变为零，因此我们需要一种机制<br>\n来打破带有循环的结构。</p>\n<h5 id=\"示例-175\"><a class=\"markdownIt-Anchor\" href=\"#示例-175\">#</a> 示例</h5>\n<pre><code>#include &lt;memory&gt;\n\nclass bar;\n\nclass foo &#123;\npublic:\n  explicit foo(const std::shared_ptr&lt;bar&gt;&amp; forward_reference)\n    : forward_reference_(forward_reference)\n  &#123; &#125;\nprivate:\n  std::shared_ptr&lt;bar&gt; forward_reference_;\n&#125;;\n\nclass bar &#123;\npublic:\n  explicit bar(const std::weak_ptr&lt;foo&gt;&amp; back_reference)\n    : back_reference_(back_reference)\n  &#123; &#125;\n  void do_something()\n  &#123;\n    if (auto shared_back_reference = back_reference_.lock()) &#123;\n      // 使用 *shared_back_reference\n    &#125;\n  &#125;\nprivate:\n  std::weak_ptr&lt;foo&gt; back_reference_;\n&#125;;\n</code></pre>\n<h5 id=\"注解-185\"><a class=\"markdownIt-Anchor\" href=\"#注解-185\">#</a> 注解</h5>\n<p>??? (HS: 许多人都说要 “打破循环引用”，不过我觉得 “临时性共享所有权” 可能更关键。)<br>\n???(BS: 打破循环引用是必须达成的目标；临时性共享所有权则是达成的方式。<br>\n你也可以仅仅使用另一个  <code>shared_ptr</code>  来得到 “临时性共享所有权”。)</p>\n<h5 id=\"强制实施-184\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-184\">#</a> 强制实施</h5>\n<p>??? 可能无法做到。如果能够静态地检测出循环引用的话，我们就不需要  <code>weak_ptr</code>  了。</p>\n<h3 id=\"a-namerr-smartptrparamar30-以智能指针为参数仅用于明确表达生存期语义\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-smartptrparamar30-以智能指针为参数仅用于明确表达生存期语义\">#</a> <a name=\"Rr-smartptrparam\"></a>R.30: 以智能指针为参数，仅用于明确表达生存期语义</h3>\n<p>参见 <a href=\"#Rf-smart\">F.7</a>。</p>\n<h3 id=\"a-namerr-smartar31-非-std-的智能指针应当遵循-std-的行为模式\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-smartar31-非-std-的智能指针应当遵循-std-的行为模式\">#</a> <a name=\"Rr-smart\"></a>R.31: 非  <code>std</code>  的智能指针，应当遵循  <code>std</code>  的行为模式</h3>\n<h5 id=\"理由-194\"><a class=\"markdownIt-Anchor\" href=\"#理由-194\">#</a> 理由</h5>\n<p>下面段落中的规则同样适用于第三方和自定义的其他种类的智能指针，而且对于诊断引发导致了性能和正确性问题的一般性的智能指针错误来说也是非常有帮助的。<br>\n你将会期望你所使用的所有智能指针都遵循这些规则。</p>\n<p>任何重载了一元  <code>*</code>  和  <code>-&gt;</code>  的类型（无论主模板还是特化）都被当成是智能指针：</p>\n<ul>\n<li>如果它可以复制，则将其当做一种具有引用计数的  <code>Shared_ptr</code> 。</li>\n<li>如果它不能复制，则将其当做一种唯一的  <code>Unique_ptr</code> 。</li>\n</ul>\n<h5 id=\"示例不好-70\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-70\">#</a> 示例，不好</h5>\n<pre><code>// 使用 Boost 的 intrusive_ptr\n#include &lt;boost/intrusive_ptr.hpp&gt;\nvoid f(boost::intrusive_ptr&lt;widget&gt; p)  // 根据 'sharedptrparam' 规则是错误的\n&#123;\n    p-&gt;foo();\n&#125;\n\n// 使用 Microsoft 的 CComPtr\n#include &lt;atlbase.h&gt;\nvoid f(CComPtr&lt;widget&gt; p)               // 根据 'sharedptrparam' 规则是错误的\n&#123;\n    p-&gt;foo();\n&#125;\n</code></pre>\n<p>上面两段根据 <a href=\"#Rr-smartptrparam\"> <code>sharedptrparam</code>  指导方针</a>来说都是错误的：<br>\n <code>p</code>  是一个  <code>Shared_pointer</code> ，但其共享性质完全没有被用到，而对其进行按值传递则是一种暗含的劣化；<br>\n这两个函数应当仅当它们需要参与  <code>widget</code>  的生存期管理时才接受智能指针。否则当可以为  <code>nullptr</code>  时它们就应当接受  <code>widget*</code> ，否则，理想情况下，函数应当接受  <code>widget&amp;</code> 。<br>\n这些智能指针都符合  <code>Shared_pointer</code>  的概念，因此这些强制实施指导方针的规则可以直接应用，并使得这种一般性的劣化情况暴露出来。</p>\n<h3 id=\"a-namerr-uniqueptrparamar32-unique_ptrwidget-参数用以表达函数假定获得-widget-的所有权\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-uniqueptrparamar32-unique_ptrwidget-参数用以表达函数假定获得-widget-的所有权\">#</a> <a name=\"Rr-uniqueptrparam\"></a>R.32:  <code>unique_ptr&lt;widget&gt;</code>  参数用以表达函数假定获得  <code>widget</code>  的所有权</h3>\n<h5 id=\"理由-195\"><a class=\"markdownIt-Anchor\" href=\"#理由-195\">#</a> 理由</h5>\n<p>以这种方式使用  <code>unique_ptr</code>  同时说明并强制施加了函数调用时的所有权转移。</p>\n<h5 id=\"示例-176\"><a class=\"markdownIt-Anchor\" href=\"#示例-176\">#</a> 示例</h5>\n<pre><code>void sink(unique_ptr&lt;widget&gt;); // 获得这个 widget 的所有权\n\nvoid uses(widget*);            // 仅仅使用了这个 widget\n</code></pre>\n<h5 id=\"示例不好-71\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-71\">#</a> 示例，不好</h5>\n<pre><code>void thinko(const unique_ptr&lt;widget&gt;&amp;); // 通常不是你想要的\n</code></pre>\n<h5 id=\"强制实施-185\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-185\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】 如果函数以左值引用接受  <code>Unique_pointer&lt;T&gt;</code>  参数，但并未在至少一个代码路径中向其赋值或者对其调用  <code>reset()</code> ，则给出警告。建议代之以接受  <code>T*</code>  或  <code>T&amp;</code> 。</li>\n<li>【简单】〔基础〕 如果函数以  <code>const</code>  引用接受  <code>Unique_pointer&lt;T&gt;</code>  参数，则给出警告。建议代之以接受  <code>const T*</code>  或  <code>const T&amp;</code> 。</li>\n</ul>\n<h3 id=\"a-namerr-reseatar33-unique_ptrwidget-参数用以表达函数对该-widget-重新置位\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-reseatar33-unique_ptrwidget-参数用以表达函数对该-widget-重新置位\">#</a> <a name=\"Rr-reseat\"></a>R.33:  <code>unique_ptr&lt;widget&gt;&amp;</code>  参数用以表达函数对该  <code>widget</code>  重新置位</h3>\n<h5 id=\"示例-177\"><a class=\"markdownIt-Anchor\" href=\"#示例-177\">#</a> 示例</h5>\n<p>以这种方式使用  <code>unique_ptr</code>  同时说明并强制施加了函数调用时的重新置位语义。</p>\n<h5 id=\"注解-186\"><a class=\"markdownIt-Anchor\" href=\"#注解-186\">#</a> 注解</h5>\n<p>所谓 “重新置位（Reseat）” 的含义是 “让指针或智能指针指代某个不同的对象”。</p>\n<h5 id=\"示例-178\"><a class=\"markdownIt-Anchor\" href=\"#示例-178\">#</a> 示例</h5>\n<pre><code>void reseat(unique_ptr&lt;widget&gt;&amp;); // “将要”或“可能”重新置位指针\n</code></pre>\n<h5 id=\"示例不好-72\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-72\">#</a> 示例，不好</h5>\n<pre><code>void thinko(const unique_ptr&lt;widget&gt;&amp;); // 通常不是你想要的\n</code></pre>\n<h5 id=\"强制实施-186\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-186\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】 如果函数以左值引用接受  <code>Unique_pointer&lt;T&gt;</code>  参数，但并未在至少一个代码路径中向其赋值或者对其调用  <code>reset()</code> ，则给出警告。建议代之以接受  <code>T*</code>  或  <code>T&amp;</code> 。</li>\n<li>【简单】〔基础〕 如果函数以  <code>const</code>  引用接受  <code>Unique_pointer&lt;T&gt;</code>  参数，则给出警告。建议代之以接受  <code>const T*</code>  或  <code>const T&amp;</code> 。</li>\n</ul>\n<h3 id=\"a-namerr-sharedptrparam-ownerar34-用-shared_ptrwidget-参数表达共享所有权\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-sharedptrparam-ownerar34-用-shared_ptrwidget-参数表达共享所有权\">#</a> <a name=\"Rr-sharedptrparam-owner\"></a>R.34: 用  <code>shared_ptr&lt;widget&gt;</code>  参数表达共享所有权</h3>\n<h5 id=\"理由-196\"><a class=\"markdownIt-Anchor\" href=\"#理由-196\">#</a> 理由</h5>\n<p>这样做明确了函数的所有权共享语义。</p>\n<h5 id=\"示例好-13\"><a class=\"markdownIt-Anchor\" href=\"#示例好-13\">#</a> 示例，好</h5>\n<pre><code>class WidgetUser\n&#123;\npublic:\n    // WidgetUser 将会共享这个 widget 的所有权\n    explicit WidgetUser(std::shared_ptr&lt;widget&gt; w) noexcept:\n        m_widget&#123;std::move(w)&#125; &#123;&#125;\n    // ...\nprivate:\n    std::shared_ptr&lt;widget&gt; m_widget;\n&#125;;\n</code></pre>\n<h5 id=\"强制实施-187\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-187\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】 如果函数以左值引用接受  <code>Shared_pointer&lt;T&gt;</code>  参数，但并未在至少一个代码路径中向其赋值或者对其调用  <code>reset()</code> ，则给出警告。建议代之以接受  <code>T*</code>  或  <code>T&amp;</code> 。</li>\n<li>【简单】〔基础〕 如果函数按值或者以  <code>const</code>  引用接受  <code>Shared_pointer&lt;T&gt;</code>  参数，但并未在至少一个代码路径中将其复制或移动给另一个  <code>Shared_pointer</code> ，则给出警告。建议代之以接受  <code>T*</code>  或  <code>T&amp;</code> 。</li>\n<li>【简单】〔基础〕 如果函数以右值引用接受  <code>Shared_pointer&lt;T&gt;</code>  参数，则给出警告。建议代之以按值传递。</li>\n</ul>\n<h3 id=\"a-namerr-sharedptrparamar35-shared_ptrwidget-参数用以表达函数可能会对共享的指针重新置位\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-sharedptrparamar35-shared_ptrwidget-参数用以表达函数可能会对共享的指针重新置位\">#</a> <a name=\"Rr-sharedptrparam\"></a>R.35:  <code>shared_ptr&lt;widget&gt;&amp;</code>  参数用以表达函数可能会对共享的指针重新置位</h3>\n<h5 id=\"理由-197\"><a class=\"markdownIt-Anchor\" href=\"#理由-197\">#</a> 理由</h5>\n<p>这样做明确了函数的重新置位语义。</p>\n<h5 id=\"注解-187\"><a class=\"markdownIt-Anchor\" href=\"#注解-187\">#</a> 注解</h5>\n<p>所谓 “重新置位（Reseat）” 的含义是 “让引用或智能指针指代某个不同的对象”。</p>\n<h5 id=\"示例好-14\"><a class=\"markdownIt-Anchor\" href=\"#示例好-14\">#</a> 示例，好</h5>\n<pre><code>void ChangeWidget(std::shared_ptr&lt;widget&gt;&amp; w)\n&#123;\n    // 这将会改变调用方的 widget\n    w = std::make_shared&lt;widget&gt;(widget&#123;&#125;);\n&#125;\n</code></pre>\n<h5 id=\"强制实施-188\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-188\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】 如果函数以左值引用接受  <code>Shared_pointer&lt;T&gt;</code>  参数，但并未在至少一个代码路径中向其赋值或者对其调用  <code>reset()</code> ，则给出警告。建议代之以接受  <code>T*</code>  或  <code>T&amp;</code> 。</li>\n<li>【简单】〔基础〕 如果函数按值或者以  <code>const</code>  引用接受  <code>Shared_pointer&lt;T&gt;</code>  参数，但并未在至少一个代码路径中将其复制或移动给另一个  <code>Shared_pointer</code> ，则给出警告。建议代之以接受  <code>T*</code>  或  <code>T&amp;</code> 。</li>\n<li>【简单】〔基础〕 如果函数以右值引用接受  <code>Shared_pointer&lt;T&gt;</code>  参数，则给出警告。建议代之以按值传递。</li>\n</ul>\n<h3 id=\"a-namerr-sharedptrparam-constar36-const-shared_ptrwidget-参数用以表达它可能将保留一个对对象的引用\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-sharedptrparam-constar36-const-shared_ptrwidget-参数用以表达它可能将保留一个对对象的引用\">#</a> <a name=\"Rr-sharedptrparam-const\"></a>R.36:  <code>const shared_ptr&lt;widget&gt;&amp;</code>  参数用以表达它可能将保留一个对对象的引用？？？</h3>\n<h5 id=\"理由-198\"><a class=\"markdownIt-Anchor\" href=\"#理由-198\">#</a> 理由</h5>\n<p>这样做明确了函数的？？？语义。</p>\n<h5 id=\"示例好-15\"><a class=\"markdownIt-Anchor\" href=\"#示例好-15\">#</a> 示例，好</h5>\n<pre><code>void share(shared_ptr&lt;widget&gt;);            // 共享——“将会”保持一个引用计数\n\nvoid reseat(shared_ptr&lt;widget&gt;&amp;);          // “可能”重新置位指针\n\nvoid may_share(const shared_ptr&lt;widget&gt;&amp;); // “可能”保持一个引用计数\n</code></pre>\n<h5 id=\"强制实施-189\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-189\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】 如果函数以左值引用接受  <code>Shared_pointer&lt;T&gt;</code>  参数，但并未在至少一个代码路径中向其赋值或者对其调用  <code>reset()</code> ，则给出警告。建议代之以接受  <code>T*</code>  或  <code>T&amp;</code> 。</li>\n<li>【简单】〔基础〕 如果函数按值或者以  <code>const</code>  引用接受  <code>Shared_pointer&lt;T&gt;</code>  参数，但并未在至少一个代码路径中将其复制或移动给另一个  <code>Shared_pointer</code> ，则给出警告。建议代之以接受  <code>T*</code>  或  <code>T&amp;</code> 。</li>\n<li>【简单】〔基础〕 如果函数以右值引用接受  <code>Shared_pointer&lt;T&gt;</code>  参数，则给出警告。建议代之以按值传递。</li>\n</ul>\n<h3 id=\"a-namerr-smartptrgetar37-不要把来自某个智能指针别名的指针或引用传递出去\"><a class=\"markdownIt-Anchor\" href=\"#a-namerr-smartptrgetar37-不要把来自某个智能指针别名的指针或引用传递出去\">#</a> <a name=\"Rr-smartptrget\"></a>R.37: 不要把来自某个智能指针别名的指针或引用传递出去</h3>\n<h5 id=\"理由-199\"><a class=\"markdownIt-Anchor\" href=\"#理由-199\">#</a> 理由</h5>\n<p>违反这条规则，是导致引用计数的丢失和出现悬挂指针的首要原因。<br>\n函数应当优先向其调用链中传递原生指针和引用。<br>\n在调用树的顶层，原生指针或引用是从用以保持对象存活的智能指针中获得的。<br>\n我们需要确保这个智能指针不会在调用树的下面被疏忽地进行重置或者重新赋值。</p>\n<h5 id=\"注解-188\"><a class=\"markdownIt-Anchor\" href=\"#注解-188\">#</a> 注解</h5>\n<p>为了做到这点，有时候需要获得智能指针的一个局部副本，它可以确保在函数及其调用树的执行期间维持对象存活。</p>\n<h5 id=\"示例-179\"><a class=\"markdownIt-Anchor\" href=\"#示例-179\">#</a> 示例</h5>\n<p>考虑下面的代码：</p>\n<pre><code>// 全局（静态或堆）对象，或者有别名的局部对象 ...\nshared_ptr&lt;widget&gt; g_p = ...;\n\nvoid f(widget&amp; w)\n&#123;\n    g();\n    use(w);  // A\n&#125;\n\nvoid g()\n&#123;\n    g_p = ...; // 噢，如果这就是这个 widget 的最后一个 shared_ptr 的话，这会销毁这个 widget\n&#125;\n</code></pre>\n<p>下面的代码是不应该通过代码评审的：</p>\n<pre><code>void my_code()\n&#123;\n    // 不好: 传递的是从非局部的智能指针中获得的指针或引用\n    //       而这可能会在 f 或其调用的函数中的某处被不经意地重置掉\n    f(*g_p);\n\n    // 不好: 原因相同，只不过将其作为“this”指针传递\n    g_p-&gt;func();\n&#125;\n</code></pre>\n<p>修正很简单 —— 获取该指针的一个局部副本，为调用树 “保持一个引用计数”：</p>\n<pre><code>void my_code()\n&#123;\n    // 很廉价: 一次增量就搞定了整个函数以及下面的所有调用树\n    auto pin = g_p;\n\n    // 好: 传递的是从局部的无别名智能指针中获得的指针或引用\n    f(*pin);\n\n    // 好: 原因相同\n    pin-&gt;func();\n&#125;\n</code></pre>\n<h5 id=\"强制实施-190\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-190\">#</a> 强制实施</h5>\n<ul>\n<li>【简单】 如果从非局部或局部但潜在具有别名的智能指针变量（ <code>Unique_pointer</code>  或  <code>Shared_pointer</code> ）中所获取的指针或引用，被用于进行函数调用，则给出警告。如果智能指针是一个  <code>Shared_pointer</code> ，则建议代之以获取该智能指针的一个局部副本并从中获取指针或引用。</li>\n</ul>\n<h1 id=\"a-names-expraes-表达式和语句\"><a class=\"markdownIt-Anchor\" href=\"#a-names-expraes-表达式和语句\">#</a> <a name=\"S-expr\"></a>ES: 表达式和语句</h1>\n<p>表达式和语句是用以表达动作和计算的最底层也是最直接的方式。局部作用域中的声明也是语句。</p>\n<p>有关命名、注释和缩进的规则，参见 <a href=\"#S-naming\">NL: 命名与代码布局</a>。</p>\n<p>一般规则：</p>\n<ul>\n<li><a href=\"#Res-lib\">ES.1: 优先采用标准库而不是其他的库或者 “手工自制代码”</a></li>\n<li><a href=\"#Res-abstr\">ES.2: 优先采用适当的抽象而不是直接使用语言功能特性</a></li>\n<li><a href=\"#Res-DRY\">ES.3: 避免重复（DRY），避免冗余代码</a></li>\n</ul>\n<p>声明的规则：</p>\n<ul>\n<li><a href=\"#Res-scope\">ES.5: 保持作用域尽量小</a></li>\n<li><a href=\"#Res-cond\">ES.6: 在 for 语句的初始化式和条件中声明名字以限制其作用域</a></li>\n<li><a href=\"#Res-name-length\">ES.7: 保持常用的和局部的名字尽量简短，而让非常用的和非局部的名字较长</a></li>\n<li><a href=\"#Res-name-similar\">ES.8: 避免使用看起来相似的名字</a></li>\n<li><a href=\"#Res-not-CAPS\">ES.9: 避免  <code>ALL_CAPS</code>  式的名字</a></li>\n<li><a href=\"#Res-name-one\">ES.10: 每条声明中（仅）声明一个名字</a></li>\n<li><a href=\"#Res-auto\">ES.11: 使用  <code>auto</code>  来避免类型名字的多余重复</a></li>\n<li><a href=\"#Res-reuse\">ES.12: 不要在嵌套作用域中重用名字</a></li>\n<li><a href=\"#Res-always\">ES.20: 坚持为对象进行初始化</a></li>\n<li><a href=\"#Res-introduce\">ES.21: 不要在确实需要使用变量（或常量）之前就引入它</a></li>\n<li><a href=\"#Res-init\">ES.22: 要等到获得了用以初始化变量的值之后才声明变量</a></li>\n<li><a href=\"#Res-list\">ES.23: 优先使用  <code>&#123;&#125;</code>  初始化式语法</a></li>\n<li><a href=\"#Res-unique\">ES.24: 用  <code>unique_ptr&lt;T&gt;</code>  来保存指针</a></li>\n<li><a href=\"#Res-const\">ES.25: 应当将对象声明为  <code>const</code>  或  <code>constexpr</code> ，除非后面需要修改其值</a></li>\n<li><a href=\"#Res-recycle\">ES.26: 不要用一个变量来达成两个不相关的目的</a></li>\n<li><a href=\"#Res-stack\">ES.27: 使用  <code>std::array</code>  或  <code>stack_array</code>  作为栈上的数组</a></li>\n<li><a href=\"#Res-lambda-init\">ES.28: 为复杂的初始化（尤其是  <code>const</code>  变量）使用 lambda</a></li>\n<li><a href=\"#Res-macros\">ES.30: 不要用宏来操纵程序文本</a></li>\n<li><a href=\"#Res-macros2\">ES.31: 不要用宏来作为常量或 “函数”</a></li>\n<li><a href=\"#Res-ALL_CAPS\">ES.32: 对所有的宏名采用  <code>ALL_CAPS</code>  命名方式</a></li>\n<li><a href=\"#Res-MACROS\">ES.33: 如果必须使用宏的话，请为之提供唯一的名字</a></li>\n<li><a href=\"#Res-ellipses\">ES.34: 不要定义（C 风格的）变参函数</a></li>\n</ul>\n<p>表达式的规则：</p>\n<ul>\n<li><a href=\"#Res-complicated\">ES.40: 避免复杂的表达式</a></li>\n<li><a href=\"#Res-parens\">ES.41: 对运算符优先级不保准时应使用括号</a></li>\n<li><a href=\"#Res-ptr\">ES.42: 保持单纯直接的指针使用方式</a></li>\n<li><a href=\"#Res-order\">ES.43: 避免带有未定义的求值顺序的表达式</a></li>\n<li><a href=\"#Res-order-fct\">ES.44: 不要对函数参数求值顺序有依赖</a></li>\n<li><a href=\"#Res-magic\">ES.45: 避免 “魔法常量”，采用符号化常量</a></li>\n<li><a href=\"#Res-narrowing\">ES.46: 避免窄化转换</a></li>\n<li><a href=\"#Res-nullptr\">ES.47: 使用  <code>nullptr</code>  而不是  <code>0</code>  或  <code>NULL</code> </a></li>\n<li><a href=\"#Res-casts\">ES.48: 避免强制转换</a></li>\n<li><a href=\"#Res-casts-named\">ES.49: 当必须使用强制转换时，使用具名的强制转换</a></li>\n<li><a href=\"#Res-casts-const\">ES.50: 不要强制掉  <code>const</code> </a></li>\n<li><a href=\"#Res-range-checking\">ES.55: 避免发生对范围检查的需要</a></li>\n<li><a href=\"#Res-move\">ES.56: 仅在确实需要明确移动某个对象到别的作用域时才使用  <code>std::move()</code> </a></li>\n<li><a href=\"#Res-new\">ES.60: 避免在资源管理函数之外使用  <code>new</code>  和  <code>delete</code> </a></li>\n<li><a href=\"#Res-del\">ES.61: 用  <code>delete[]</code>  删除数组，用  <code>delete</code>  删除非数组对象</a></li>\n<li><a href=\"#Res-arr2\">ES.62: 不要在不同的数组之间进行指针比较</a></li>\n<li><a href=\"#Res-slice\">ES.63: 不要产生切片</a></li>\n<li><a href=\"#Res-construct\">ES.64: 使用  <code>T&#123;e&#125;</code>  写法来进行构造</a></li>\n<li><a href=\"#Res-deref\">ES.65: 不要解引用无效指针</a></li>\n</ul>\n<p>语句的规则：</p>\n<ul>\n<li><a href=\"#Res-switch-if\">ES.70: 面临选择时，优先采用  <code>switch</code>  语句而不是  <code>if</code>  语句</a></li>\n<li><a href=\"#Res-for-range\">ES.71: 面临选择时，优先采用范围式  <code>for</code>  语句而不是普通  <code>for</code>  语句</a></li>\n<li><a href=\"#Res-for-while\">ES.72: 当存在显然的循环变量时，优先采用  <code>for</code>  语句而不是  <code>while</code>  语句</a></li>\n<li><a href=\"#Res-while-for\">ES.73: 当没有显然的循环变量时，优先采用  <code>while</code>  语句而不是  <code>for</code>  语句</a></li>\n<li><a href=\"#Res-for-init\">ES.74: 优先在  <code>for</code>  语句的初始化部分中声明循环变量</a></li>\n<li><a href=\"#Res-do\">ES.75: 避免使用  <code>do</code>  语句</a></li>\n<li><a href=\"#Res-goto\">ES.76: 避免  <code>goto</code> </a></li>\n<li><a href=\"#Res-continue\">ES.77: 尽量减少循环中使用的  <code>break</code>  和  <code>continue</code> </a></li>\n<li><a href=\"#Res-break\">ES.78: 不要依靠  <code>switch</code>  语句中的隐含直落行为</a></li>\n<li><a href=\"#Res-default\">ES.79:  <code>default</code> （仅）用于处理一般情况</a></li>\n<li><a href=\"#Res-noname\">ES.84: 不要试图声明没有名字的局部变量</a></li>\n<li><a href=\"#Res-empty\">ES.85: 让空语句显著可见</a></li>\n<li><a href=\"#Res-loop-counter\">ES.86: 避免在原生的  <code>for</code>  循环中修改循环控制变量</a></li>\n<li><a href=\"#Res-if\">ES.87: 请勿在条件上添加多余的  <code>==</code>  或  <code>!=</code> </a></li>\n</ul>\n<p>算术规则：</p>\n<ul>\n<li><a href=\"#Res-mix\">ES.100: 不要进行有符号和无符号混合运算</a></li>\n<li><a href=\"#Res-unsigned\">ES.101: 使用无符号类型进行位操作</a></li>\n<li><a href=\"#Res-signed\">ES.102: 使用有符号类型进行算术运算</a></li>\n<li><a href=\"#Res-overflow\">ES.103: 避免上溢出</a></li>\n<li><a href=\"#Res-underflow\">ES.104: 避免下溢出</a></li>\n<li><a href=\"#Res-zero\">ES.105: 避免除整数零</a></li>\n<li><a href=\"#Res-nonnegative\">ES.106: 不要试图用  <code>unsigned</code>  来防止负数值</a></li>\n<li><a href=\"#Res-subscripts\">ES.107: 不要对下标使用  <code>unsigned</code> ，优先使用  <code>gsl::index</code> </a></li>\n</ul>\n<h3 id=\"a-nameres-libaes1-优先采用标准库而不是其他的库或者手工自制代码\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-libaes1-优先采用标准库而不是其他的库或者手工自制代码\">#</a> <a name=\"Res-lib\"></a>ES.1: 优先采用标准库而不是其他的库或者 “手工自制代码”</h3>\n<h5 id=\"理由-200\"><a class=\"markdownIt-Anchor\" href=\"#理由-200\">#</a> 理由</h5>\n<p>使用程序库的代码要远比直接使用语言功能特性的代码易于编写，更为简短，更倾向于更高的抽象层次，而且程序库代码假定已经经过测试。<br>\nISO C++ 标准库是最广为了解而且经过最好测试的程序库之一。<br>\n它是任何 C++ 实现的一部分。</p>\n<h5 id=\"示例-180\"><a class=\"markdownIt-Anchor\" href=\"#示例-180\">#</a> 示例</h5>\n<pre><code>auto sum = accumulate(begin(a), end(a), 0.0);   // 好\n</code></pre>\n<p><code>accumulate</code>  的范围版本就更好了：</p>\n<pre><code>auto sum = accumulate(v, 0.0); // 更好\n</code></pre>\n<p>但请不要手工编写众所周知的算法：</p>\n<pre><code>int max = v.size();   // 不好：啰嗦，目的不清晰\ndouble sum = 0.0;\nfor (int i = 0; i &lt; max; ++i)\n    sum = sum + v[i];\n</code></pre>\n<h5 id=\"例外-38\"><a class=\"markdownIt-Anchor\" href=\"#例外-38\">#</a> 例外</h5>\n<p>标准库的很大部分都依赖于动态分配（自由存储）。这些部分，尤其是容器但并不包括算法，并不适用于某些硬实时和嵌入式的应用的。在这些情况下，请考虑提供或使用类似的设施，比如说某个标准库风格的采用池分配器的容器实现。</p>\n<h5 id=\"强制实施-191\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-191\">#</a> 强制实施</h5>\n<p>并不容易。??? 寻找混乱的循环，嵌套的循环，长函数，函数调用的缺失，缺乏使用内建类型。圈复杂度？</p>\n<h3 id=\"a-nameres-abstraes2-优先采用适当的抽象而不是直接使用语言功能特性\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-abstraes2-优先采用适当的抽象而不是直接使用语言功能特性\">#</a> <a name=\"Res-abstr\"></a>ES.2: 优先采用适当的抽象而不是直接使用语言功能特性</h3>\n<h5 id=\"理由-201\"><a class=\"markdownIt-Anchor\" href=\"#理由-201\">#</a> 理由</h5>\n<p>“适当的抽象”（比如程序库或者类），更加贴近应用的概念而不是语言概念，将带来更简洁的代码，而且更容易进行测试。</p>\n<h5 id=\"示例-181\"><a class=\"markdownIt-Anchor\" href=\"#示例-181\">#</a> 示例</h5>\n<pre><code>vector&lt;string&gt; read1(istream&amp; is)   // 好\n&#123;\n    vector&lt;string&gt; res;\n    for (string s; is &gt;&gt; s;)\n        res.push_back(s);\n    return res;\n&#125;\n</code></pre>\n<p>与之近乎等价的更传统且更低层的代码，更长、更混乱、更难编写正确，而且很可能更慢：</p>\n<pre><code>char** read2(istream&amp; is, int maxelem, int maxstring, int* nread)   // 不好：啰嗦而且不完整\n&#123;\n    auto res = new char*[maxelem];\n    int elemcount = 0;\n    while (is &amp;&amp; elemcount &lt; maxelem) &#123;\n        auto s = new char[maxstring];\n        is.read(s, maxstring);\n        res[elemcount++] = s;\n    &#125;\n    *nread = elemcount;\n    return res;\n&#125;\n</code></pre>\n<p>一旦添加了溢出检查和错误处理，代码就变得相当混乱了，而且还有个要记得  <code>delete</code>  其所返回的指针以及数组所包含的 C 风格字符串的问题。</p>\n<h5 id=\"强制实施-192\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-192\">#</a> 强制实施</h5>\n<p>并不容易。??? 寻找混乱的循环，嵌套的循环，长函数，函数调用的缺失，缺乏使用内建类型。圈复杂度？</p>\n<h3 id=\"a-nameres-dryaes3-避免重复dry避免冗余代码\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-dryaes3-避免重复dry避免冗余代码\">#</a> <a name=\"Res-DRY\"></a>ES.3: 避免重复（DRY），避免冗余代码</h3>\n<p>重复或者冗余的代码会干扰编码意图，导致对逻辑的理解变得困难，并使维护变得困难，以及一些其他问题。它经常出现于拷贝粘贴式编程中。</p>\n<p>只要合适就使用标准算法，而不是编写自己的实现。</p>\n<p><strong>另请参见</strong>: <a href=\"#Rsl-lib\">SL.1</a>, <a href=\"#Res-auto\">ES.11</a></p>\n<h5 id=\"示例-182\"><a class=\"markdownIt-Anchor\" href=\"#示例-182\">#</a> 示例</h5>\n<pre><code>void func(bool flag)    // 不好，重复代码\n&#123;\n    if (flag) &#123;\n        x();\n        y();\n    &#125;\n    else &#123;\n        x();\n        z();\n    &#125;\n&#125;\n\nvoid func(bool flag)    // 更好，没有重复代码\n&#123;\n    x();\n\n    if (flag)\n        y();\n    else\n        z();\n&#125;\n</code></pre>\n<h5 id=\"强制实施-193\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-193\">#</a> 强制实施</h5>\n<ul>\n<li>采用静态分析器。它至少会找出一些重复的代码构造。</li>\n<li>代码评审</li>\n</ul>\n<h2 id=\"esdcl-声明\"><a class=\"markdownIt-Anchor\" href=\"#esdcl-声明\">#</a> ES.dcl: 声明</h2>\n<p>声明也是语句。一条声明向一个作用域中引入一个名字，并可能导致对一个具名对象进行构造。</p>\n<h3 id=\"a-nameres-scopeaes5-保持作用域尽量小\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-scopeaes5-保持作用域尽量小\">#</a> <a name=\"Res-scope\"></a>ES.5: 保持作用域尽量小</h3>\n<h5 id=\"理由-202\"><a class=\"markdownIt-Anchor\" href=\"#理由-202\">#</a> 理由</h5>\n<p>可读性。最小化资源持有率。避免值的意外误用。</p>\n<p><strong>其他形式</strong>：不要把名字在不必要的大作用域中进行声明。</p>\n<h5 id=\"示例-183\"><a class=\"markdownIt-Anchor\" href=\"#示例-183\">#</a> 示例</h5>\n<pre><code>void use()\n&#123;\n    int i;    // 不好: 循环之后并不需要访问 i\n    for (i = 0; i &lt; 20; ++i) &#123; /* ... */ &#125;\n    // 此处不存在对 i 的有意使用\n    for (int i = 0; i &lt; 20; ++i) &#123; /* ... */ &#125;  // 好: i 局部于 for 循环\n\n    if (auto pc = dynamic_cast&lt;Circle*&gt;(ps)) &#123;  // 好: pc 局部于 if 语句\n        // ... 处理 Circle ...\n    &#125;\n    else &#123;\n        // ... 处理错误 ...\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"示例不好-73\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-73\">#</a> 示例，不好</h5>\n<pre><code>void use(const string&amp; name)\n&#123;\n    string fn = name + &quot;.txt&quot;;\n    ifstream is &#123;fn&#125;;\n    Record r;\n    is &gt;&gt; r;\n    // ... 200 行代码，都不存在使用 fn 或 is 的意图 ...\n&#125;\n</code></pre>\n<p>大多数测量都会称这个函数太长了，但其关键点是  <code>fn</code>  所使用的资源和  <code>is</code>  所持有的文件句柄<br>\n所持有的时间比其所需长太多了，而且可能在函数后面意外地出现对  <code>is</code>  和  <code>fn</code>  的使用。<br>\n这种情况下，把读取操作重构出来可能是一个好主意：</p>\n<pre><code>Record load_record(const string&amp; name)\n&#123;\n    string fn = name + &quot;.txt&quot;;\n    ifstream is &#123;fn&#125;;\n    Record r;\n    is &gt;&gt; r;\n    return r;\n&#125;\n\nvoid use(const string&amp; name)\n&#123;\n    Record r = load_record(name);\n    // ... 200 行代码 ...\n&#125;\n</code></pre>\n<h5 id=\"强制实施-194\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-194\">#</a> 强制实施</h5>\n<ul>\n<li>对声明于循环之外，且在循环之后不再使用的循环变量进行标记。</li>\n<li>当诸如文件句柄和锁这样的昂贵资源超过 N 行未被使用时进行标记（对某个适当的 N）。</li>\n</ul>\n<h3 id=\"a-nameres-condaes6-在-for-语句的初始化式和条件中声明名字以限制其作用域\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-condaes6-在-for-语句的初始化式和条件中声明名字以限制其作用域\">#</a> <a name=\"Res-cond\"></a>ES.6: 在 for 语句的初始化式和条件中声明名字以限制其作用域</h3>\n<h5 id=\"理由-203\"><a class=\"markdownIt-Anchor\" href=\"#理由-203\">#</a> 理由</h5>\n<p>可读性。<br>\n将循环变量的可见性限制到循环范围内。<br>\n避免在循环之后将循环变量用于其他目的。<br>\n最小化资源持有率。</p>\n<h5 id=\"理由-204\"><a class=\"markdownIt-Anchor\" href=\"#理由-204\">#</a> 理由</h5>\n<pre><code>void use()\n&#123;\n    for (string s; cin &gt;&gt; s;)\n        v.push_back(s);\n\n    for (int i = 0; i &lt; 20; ++i) &#123;   // 好: i 局部于 for 循环\n        // ...\n    &#125;\n\n    if (auto pc = dynamic_cast&lt;Circle*&gt;(ps)) &#123;   // 好: pc 局部于 if 语句\n        // ... 处理 Circle ...\n    &#125;\n    else &#123;\n        // ... 处理错误 ...\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"示例请勿如此\"><a class=\"markdownIt-Anchor\" href=\"#示例请勿如此\">#</a> 示例，请勿如此</h5>\n<pre><code>int j;                            // 不好：j 在循环之外可见\nfor (j = 0; j &lt; 100; ++j) &#123;\n    // ...\n&#125;\n// j 在此处仍可见但并不需要\n</code></pre>\n<p><strong>另请参见</strong>: <a href=\"#Res-recycle\">不要用一个变量来达成两个不相关的目的</a></p>\n<h5 id=\"强制实施-195\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-195\">#</a> 强制实施</h5>\n<ul>\n<li>若在  <code>for</code>  语句中修改的变量是在循环之外声明的，但并未在循环之外使用，则给出警告。</li>\n<li>【困难】 对声明与循环之前，且在循环之后用于某个无关用途的循环变量进行标记。</li>\n</ul>\n<p><strong>讨论</strong>：限制循环变量的作用域到循环体还相当有助于代码优化。认识到引入的变量仅在循环体中可以访问，<br>\n允许进行诸如外提（hoisting），强度消减，循环不变式代码外提等等优化。</p>\n<h5 id=\"c17-和-c20-示例\"><a class=\"markdownIt-Anchor\" href=\"#c17-和-c20-示例\">#</a> C<ins>17 和 C</ins>20 示例</h5>\n<p>注：C<ins>17 和 C</ins>20 还增加了  <code>if</code> 、 <code>switch</code>  和范围式  <code>for</code>  的初始化式语句。以下代码要求支持 C<ins>17 和 C</ins>20。</p>\n<pre><code>map&lt;int, string&gt; mymap;\n\nif (auto result = mymap.insert(value); result.second) &#123;\n    // 本代码块中，插入成功且 result 有效\n    use(result.first);  // ok\n    // ...\n&#125; // result 在此处销毁\n</code></pre>\n<h5 id=\"c17-和-c20-强制实施当使用-c17-或-c20-编译器时\"><a class=\"markdownIt-Anchor\" href=\"#c17-和-c20-强制实施当使用-c17-或-c20-编译器时\">#</a> C<ins>17 和 C</ins>20 强制实施（当使用 C<ins>17 或 C</ins>20 编译器时）</h5>\n<ul>\n<li>选择 / 循环变量，若其在选择或循环体之前声明而在其之后不再使用，则对其进行标记</li>\n<li>【困难】 选择 / 循环变量，若其在选择或循环体之前声明而在其之后用于某个无关目的，则对其进行标记</li>\n</ul>\n<h3 id=\"a-nameres-name-lengthaes7-保持常用的和局部的名字尽量简短而让非常用的和非局部的名字较长\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-name-lengthaes7-保持常用的和局部的名字尽量简短而让非常用的和非局部的名字较长\">#</a> <a name=\"Res-name-length\"></a>ES.7: 保持常用的和局部的名字尽量简短，而让非常用的和非局部的名字较长</h3>\n<h5 id=\"理由-205\"><a class=\"markdownIt-Anchor\" href=\"#理由-205\">#</a> 理由</h5>\n<p>可读性。减低在无关的非局部名字之间发生冲突的机会。</p>\n<h5 id=\"示例-184\"><a class=\"markdownIt-Anchor\" href=\"#示例-184\">#</a> 示例</h5>\n<p>符合管理的简短的局部名字能够增强可读性：</p>\n<pre><code>template&lt;typename T&gt;    // 好\nvoid print(ostream&amp; os, const vector&lt;T&gt;&amp; v)\n&#123;\n    for (gsl::index i = 0; i &lt; v.size(); ++i)\n        os &lt;&lt; v[i] &lt;&lt; '\\n';\n&#125;\n</code></pre>\n<p>索引根据惯例称为  <code>i</code> ，而这个泛型函数中不存在有关这个 vector 的含义的提示，因此和其他名字一样，  <code>v</code>  也没问题。与之相比，</p>\n<pre><code>template&lt;typename Element_type&gt;   // 不好: 啰嗦，难于阅读\nvoid print(ostream&amp; target_stream, const vector&lt;Element_type&gt;&amp; current_vector)\n&#123;\n    for (gsl::index current_element_index = 0;\n         current_element_index &lt; current_vector.size();\n         ++current_element_index\n    )\n    target_stream &lt;&lt; current_vector[current_element_index] &lt;&lt; '\\n';\n&#125;\n</code></pre>\n<p>当然，这是一个讽刺，但我们还见过更糟糕的。</p>\n<h5 id=\"示例-185\"><a class=\"markdownIt-Anchor\" href=\"#示例-185\">#</a> 示例</h5>\n<p>不合惯例而简短的非局部名字则会搞乱代码：</p>\n<pre><code>void use1(const string&amp; s)\n&#123;\n    // ...\n    tt(s);   // 不好: tt() 是什么？\n    // ...\n&#125;\n</code></pre>\n<p>更好的做法是，为非局部实体提供可读的名字：</p>\n<pre><code>void use1(const string&amp; s)\n&#123;\n    // ...\n    trim_tail(s);   // 好多了\n    // ...\n&#125;\n</code></pre>\n<p>这样的话，有可能读者指导  <code>trim_tail</code>  是什么意思，而且读者可以找一下它并回忆起来。</p>\n<h5 id=\"示例不好-74\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-74\">#</a> 示例，不好</h5>\n<p>大型函数的参数的名字实际上可当作是非局部的，因此应当有意义：</p>\n<pre><code>void complicated_algorithm(vector&lt;Record&gt;&amp; vr, const vector&lt;int&gt;&amp; vi, map&lt;string, int&gt;&amp; out)\n// 根据 vi 中的索引，从 vr 中读取事件（并标记所用的 Record），\n// 向 out 中放置（名字，索引）对\n&#123;\n    // ... 500 行的代码，使用 vr，vi，和 out ...\n&#125;\n</code></pre>\n<p>我们建议保持函数短小，但这条规则并不受到普遍坚持，而命名应当能反映这一点。</p>\n<h5 id=\"强制实施-196\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-196\">#</a> 强制实施</h5>\n<p>检查局部和非局部的名字的长度。同时考虑函数的长度。</p>\n<h3 id=\"a-nameres-name-similaraes8-避免使用看起来相似的名字\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-name-similaraes8-避免使用看起来相似的名字\">#</a> <a name=\"Res-name-similar\"></a>ES.8: 避免使用看起来相似的名字</h3>\n<h5 id=\"理由-206\"><a class=\"markdownIt-Anchor\" href=\"#理由-206\">#</a> 理由</h5>\n<p>代码清晰性和可读性。太过相似的名字会拖慢理解过程并增加出错的可能性。</p>\n<h5 id=\"示例不好-75\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-75\">#</a> 示例，不好</h5>\n<pre><code>if (readable(i1 + l1 + ol + o1 + o0 + ol + o1 + I0 + l0)) surprise();\n</code></pre>\n<h5 id=\"示例不好-76\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-76\">#</a> 示例，不好</h5>\n<p>不要在同一个作用域中用和类型相同的名字声明一个非类型实体。这样做将消除为区分它们所需的关键字  <code>struct</code>  或  <code>enum</code>  等。这同样消除了一种错误来源，因为  <code>struct X</code>  在对  <code>X</code>  的查找失败时会隐含地声明新的  <code>X</code> 。</p>\n<pre><code>struct foo &#123; int n; &#125;;\nstruct foo foo();       // 不好, foo 在作用域中已经是一个类型了\nstruct foo x = foo();   // 需要进行区分\n</code></pre>\n<h5 id=\"例外-39\"><a class=\"markdownIt-Anchor\" href=\"#例外-39\">#</a> 例外</h5>\n<p>很古老的头文件中可能会用在相同作用域中用同一个名字同时声明非类型实体和类型。</p>\n<h5 id=\"强制实施-197\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-197\">#</a> 强制实施</h5>\n<ul>\n<li>用一个已知的易混淆字母和数字组合的列表来对名字进行检查。</li>\n<li>当变量、函数或枚举符的声明隐藏了在相同作用域中所声明的类或枚举时，给出警告。</li>\n</ul>\n<h3 id=\"a-nameres-not-capsaes9-避免-all_caps-式的名字\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-not-capsaes9-避免-all_caps-式的名字\">#</a> <a name=\"Res-not-CAPS\"></a>ES.9: 避免  <code>ALL_CAPS</code>  式的名字</h3>\n<h5 id=\"理由-207\"><a class=\"markdownIt-Anchor\" href=\"#理由-207\">#</a> 理由</h5>\n<p>这样的名字通常是用于宏的。因此， <code>ALL_CAPS</code>  这样的名字可能遭受意外的宏替换。</p>\n<h5 id=\"示例-186\"><a class=\"markdownIt-Anchor\" href=\"#示例-186\">#</a> 示例</h5>\n<pre><code>// 某个头文件中：\n#define NE !=\n\n// 某个别的头文件中的别处：\nenum Coord &#123; N, NE, NW, S, SE, SW, E, W &#125;;\n\n// 某个糟糕程序员的 .cpp 中的第三处：\nswitch (direction) &#123;\ncase N:\n    // ...\ncase NE:\n    // ...\n// ...\n&#125;\n</code></pre>\n<h5 id=\"注解-189\"><a class=\"markdownIt-Anchor\" href=\"#注解-189\">#</a> 注解</h5>\n<p>不要仅仅因为常量曾经是宏，就使用  <code>ALL_CAPS</code>  作为常量。</p>\n<h5 id=\"强制实施-198\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-198\">#</a> 强制实施</h5>\n<p>对所有的 ALL CAPS 进行标记。对于老代码，则接受宏名字的 ALL CAPS 而标记所有的非 ALL-CAPS 的宏名字。</p>\n<h3 id=\"a-nameres-name-oneaes10-每条声明中仅声明一个名字\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-name-oneaes10-每条声明中仅声明一个名字\">#</a> <a name=\"Res-name-one\"></a>ES.10: 每条声明中（仅）声明一个名字</h3>\n<h5 id=\"理由-208\"><a class=\"markdownIt-Anchor\" href=\"#理由-208\">#</a> 理由</h5>\n<p>每行一条声明的做法增加可读性并可避免与 C++ 的文法<br>\n相关的错误。这样做也为更具描述性的行尾注释留下了<br>\n空间。</p>\n<h5 id=\"示例不好-77\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-77\">#</a> 示例，不好</h5>\n<pre><code>char *p, c, a[7], *pp[7], **aa[10];   // 讨厌！\n</code></pre>\n<h5 id=\"例外-40\"><a class=\"markdownIt-Anchor\" href=\"#例外-40\">#</a> 例外</h5>\n<p>函数声明中可以包含多个函数参数声明。</p>\n<h5 id=\"例外-41\"><a class=\"markdownIt-Anchor\" href=\"#例外-41\">#</a> 例外</h5>\n<p>结构化绑定（C++17）就是专门设计用于引入多个变量的：</p>\n<pre><code>auto [iter, inserted] = m.insert_or_assign(k, val);\nif (inserted) &#123; /* 已插入新条目 */ &#125;\n</code></pre>\n<h5 id=\"示例-187\"><a class=\"markdownIt-Anchor\" href=\"#示例-187\">#</a> 示例</h5>\n<pre><code>template&lt;class InputIterator, class Predicate&gt;\nbool any_of(InputIterator first, InputIterator last, Predicate pred);\n</code></pre>\n<p>用 concept 则更佳：</p>\n<pre><code>bool any_of(input_iterator auto first, input_iterator auto last, predicate auto pred);\n</code></pre>\n<h5 id=\"示例-188\"><a class=\"markdownIt-Anchor\" href=\"#示例-188\">#</a> 示例</h5>\n<pre><code>double scalbn(double x, int n);   // OK: x * pow(FLT_RADIX, n); FLT_RADIX 通常为 2\n</code></pre>\n<p>或者：</p>\n<pre><code>double scalbn(    // 有改善: x * pow(FLT_RADIX, n); FLT_RADIX 通常为 2\n    double x,     // 基数\n    int n         // 指数\n);\n</code></pre>\n<p>或者：</p>\n<pre><code>// 有改善: base * pow(FLT_RADIX, exponent); FLT_RADIX 通常为 2\ndouble scalbn(double base, int exponent);\n</code></pre>\n<h5 id=\"示例-189\"><a class=\"markdownIt-Anchor\" href=\"#示例-189\">#</a> 示例</h5>\n<pre><code>int a = 10, b = 11, c = 12, d, e = 14, f = 15;\n</code></pre>\n<p>在较长的声明符列表中，很容易忽视某个未能初始化的变量。</p>\n<h5 id=\"强制实施-199\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-199\">#</a> 强制实施</h5>\n<p>对具有多个声明符的变量或常量的声明式（比如  <code>int* p, q;</code> ）进行标记。</p>\n<h3 id=\"a-nameres-autoaes11-使用-auto-来避免类型名字的多余重复\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-autoaes11-使用-auto-来避免类型名字的多余重复\">#</a> <a name=\"Res-auto\"></a>ES.11: 使用  <code>auto</code>  来避免类型名字的多余重复</h3>\n<h5 id=\"理由-209\"><a class=\"markdownIt-Anchor\" href=\"#理由-209\">#</a> 理由</h5>\n<ul>\n<li>单纯的重复既麻烦又易错。</li>\n<li>当使用  <code>auto</code>  时，所声明的实体的名字是处于声明的固定位置的，这增加了可读性。</li>\n<li>函数模板声明的返回类型可能是某个成员类型。</li>\n</ul>\n<h5 id=\"示例-190\"><a class=\"markdownIt-Anchor\" href=\"#示例-190\">#</a> 示例</h5>\n<p>考虑：</p>\n<pre><code>auto p = v.begin();      // vector&lt;DataRecord&gt;::iterator\nauto z1 = v[3];          // 产生 DataRecord 的副本\nauto&amp; z2 = v[3];         // 避免复制\nconst auto&amp; z3 = v[3];   // const 并避免复制\nauto h = t.future();\nauto q = make_unique&lt;int[]&gt;(s);\nauto f = [](int x) &#123; return x + 10; &#125;;\n</code></pre>\n<p>以上都避免了写下冗长又难记的类型，它们是编译器已知的，但程序员则可能会搞错。</p>\n<h5 id=\"示例-191\"><a class=\"markdownIt-Anchor\" href=\"#示例-191\">#</a> 示例</h5>\n<pre><code>template&lt;class T&gt;\nauto Container&lt;T&gt;::first() -&gt; Iterator;   // Container&lt;T&gt;::Iterator\n</code></pre>\n<h5 id=\"例外-42\"><a class=\"markdownIt-Anchor\" href=\"#例外-42\">#</a> 例外</h5>\n<p>当使用初始化式列表，而所需要的确切类型是已知的，同时某个初始化式可能需要转换时，应当避免使用  <code>auto</code> 。</p>\n<h5 id=\"示例-192\"><a class=\"markdownIt-Anchor\" href=\"#示例-192\">#</a> 示例</h5>\n<pre><code>auto lst = &#123; 1, 2, 3 &#125;;   // lst 是一个 initializer_list\nauto x&#123;1&#125;;   // x 是一个 int（C++17；在 C++11 中则为 initializer_list）\n</code></pre>\n<h5 id=\"注解-190\"><a class=\"markdownIt-Anchor\" href=\"#注解-190\">#</a> 注解</h5>\n<p>C++20 的情况是，我们可以（而且应该）使用概念来更加明确地说明所推断的类型：</p>\n<pre><code>// ...\nforward_iterator auto p = algo(x, y, z);\n</code></pre>\n<h5 id=\"示例c17\"><a class=\"markdownIt-Anchor\" href=\"#示例c17\">#</a> 示例（C++17）</h5>\n<pre><code>std::set&lt;int&gt; values;\n// ...\nauto [ position, newly_inserted ] = values.insert(5);   // 展开 std::pair 的成员\n</code></pre>\n<h5 id=\"强制实施-200\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-200\">#</a> 强制实施</h5>\n<p>对声明中多余的类型名字进行标记。</p>\n<h3 id=\"a-nameres-reuseaes12-不要在嵌套作用域中重用名字\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-reuseaes12-不要在嵌套作用域中重用名字\">#</a> <a name=\"Res-reuse\"></a>ES.12: 不要在嵌套作用域中重用名字</h3>\n<h5 id=\"理由-210\"><a class=\"markdownIt-Anchor\" href=\"#理由-210\">#</a> 理由</h5>\n<p>这样很容易把所用的是哪个变量搞混。<br>\n会造成维护问题。</p>\n<h5 id=\"示例不好-78\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-78\">#</a> 示例，不好</h5>\n<pre><code>int d = 0;\n// ...\nif (cond) &#123;\n    // ...\n    d = 9;\n    // ...\n&#125;\nelse &#123;\n    // ...\n    int d = 7;\n    // ...\n    d = value_to_be_returned;\n    // ...\n&#125;\n\nreturn d;\n</code></pre>\n<p>这是个大型的  <code>if</code>  语句，很容易忽视在内部作用域中所引入的新的  <code>d</code> 。<br>\n这是一种已知的 BUG 来源。<br>\n这种在内部作用域中的名字重用有时候被称为 “遮蔽 “。</p>\n<h5 id=\"注解-191\"><a class=\"markdownIt-Anchor\" href=\"#注解-191\">#</a> 注解</h5>\n<p>当函数变得过大和过于复杂时，遮蔽是一种主要的问题。</p>\n<h5 id=\"示例-193\"><a class=\"markdownIt-Anchor\" href=\"#示例-193\">#</a> 示例</h5>\n<p>语言不允许在函数的最外层块中遮蔽函数参数：</p>\n<pre><code>void f(int x)\n&#123;\n    int x = 4;  // 错误：重用函数参数的名字\n\n    if (x) &#123;\n        int x = 7;  // 允许，但不好\n        // ...\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"示例不好-79\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-79\">#</a> 示例，不好</h5>\n<p>把成员名重用为局部变量也会造成问题：</p>\n<pre><code>struct S &#123;\n    int m;\n    void f(int x);\n&#125;;\n\nvoid S::f(int x)\n&#123;\n    m = 7;    // 对成员赋值\n    if (x) &#123;\n        int m = 9;\n        // ...\n        m = 99; // 对局部变量赋值\n        // ...\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"例外-43\"><a class=\"markdownIt-Anchor\" href=\"#例外-43\">#</a> 例外</h5>\n<p>我们经常在派生类中重用基类中的函数名：</p>\n<pre><code>struct B &#123;\n    void f(int);\n&#125;;\n\nstruct D : B &#123;\n    void f(double);\n    using B::f;\n&#125;;\n</code></pre>\n<p>这样做是易错的。<br>\n例如，要是忘了 using 声明式的话， <code>d.f(1)</code>  的调用就不会找到  <code>int</code>  版本的  <code>f</code> 。</p>\n<p>??? 我们需要为类层次中的遮蔽 / 隐藏给出专门的规则吗？</p>\n<h5 id=\"强制实施-201\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-201\">#</a> 强制实施</h5>\n<ul>\n<li>对嵌套局部作用域中的名字重用进行标记。</li>\n<li>对成员函数中将成员名重用为局部变量进行标记。</li>\n<li>对把全局名字重用为局部变量或成员的名字进行标记。</li>\n<li>对在派生类中重用（除函数名之外的）基类成员名进行标记。</li>\n</ul>\n<h3 id=\"a-nameres-alwaysaes20-坚持为对象进行初始化\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-alwaysaes20-坚持为对象进行初始化\">#</a> <a name=\"Res-always\"></a>ES.20: 坚持为对象进行初始化</h3>\n<h5 id=\"理由-211\"><a class=\"markdownIt-Anchor\" href=\"#理由-211\">#</a> 理由</h5>\n<p>避免发生 “设值前使用” 的错误及其所关联的未定义行为。<br>\n避免由复杂的初始化的理解所带来的问题。<br>\n简化重构。</p>\n<h5 id=\"示例-194\"><a class=\"markdownIt-Anchor\" href=\"#示例-194\">#</a> 示例</h5>\n<pre><code>void use(int arg)\n&#123;\n    int i;   // 不好: 未初始化的变量\n    // ...\n    i = 7;   // 初始化 i\n&#125;\n</code></pre>\n<p>错了， <code>i = 7</code>  并不是  <code>i</code>  的初始化；它是向其赋值。而且  <code>i</code>  也可能在  <code>...</code>  的部分中被读取。更好的做法是：</p>\n<pre><code>void use(int arg)   // OK\n&#123;\n    int i = 7;   // OK: 初始化\n    string s;    // OK: 默认初始化\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"注释-2\"><a class=\"markdownIt-Anchor\" href=\"#注释-2\">#</a> 注释</h5>\n<p>我们有意让<em>总是进行初始化</em>规则比<em>对象在使用前必须设值</em>的语言规则更强。<br>\n后者是较为宽松的规则，虽然能够识别出技术上的 BUG，不过：</p>\n<ul>\n<li>它会导致较不可读的代码，</li>\n<li>它鼓励人们在比所需的更大的作用域中声明名字，</li>\n<li>它会导致较难于阅读的代码，</li>\n<li>它会因为鼓励复杂的代码而导致出现逻辑 BUG，</li>\n<li>它会妨碍进行重构。</li>\n</ul>\n<p>而<em>总是进行初始化</em>规则则是以提升可维护性为目标的一条风格规则，同样也是保护避免出现 “设值前使用” 错误的规则。</p>\n<h5 id=\"示例-195\"><a class=\"markdownIt-Anchor\" href=\"#示例-195\">#</a> 示例</h5>\n<p>这个例子经常被当成是用来展示需要更宽松的初始化规则的例子。</p>\n<pre><code>widget i;    // &quot;widget&quot; 是一个初始化操作昂贵的类型，可能是一种大型 POD\nwidget j;\n\nif (cond) &#123;  // 不好: i 和 j 进行了“延迟”初始化\n    i = f1();\n    j = f2();\n&#125;\nelse &#123;\n    i = f3();\n    j = f4();\n&#125;\n</code></pre>\n<p>这段代码是无法简单重写为用初始化式来对  <code>i</code>  和  <code>j</code>  进行初始化的。<br>\n注意，对于带有默认构造函数的类型来说，试图延后初始化只会导致变为一次默认初始化之后跟着一次赋值的做法。<br>\n这种例子的一种更加流行的理由是 “效率”，不过可以检查出是否出现 “设置前使用” 错误的编译器，同样可以消除任何多余的双重初始化。</p>\n<p>假定  <code>i</code>  和  <code>j</code>  之间存在某种逻辑关联，则这种关联可能应当在函数中予以表达：</p>\n<pre><code>pair&lt;widget, widget&gt; make_related_widgets(bool x)\n&#123;\n    return (x) ? &#123;f1(), f2()&#125; : &#123;f3(), f4()&#125;;\n&#125;\n\nauto [i, j] = make_related_widgets(cond);    // C++17\n</code></pre>\n<p>如果除此之外  <code>make_related_widgets</code>  函数是多余的，<br>\n可以使用 lambda <a href=\"#Res-lambda-init\">ES.28</a> 来消除之：</p>\n<pre><code>auto [i, j] = [x] &#123; return (x) ? pair&#123;f1(), f2()&#125; : pair&#123;f3(), f4()&#125; &#125;();    // C++17\n</code></pre>\n<p>用一个值代表  <code>uninitialized</code>  只是一种问题的症状，而不是一种解决方案：</p>\n<pre><code>widget i = uninit;  // 不好\nwidget j = uninit;\n\n// ...\nuse(i);         // 可能发生设值前使用\n// ...\n\nif (cond) &#123;     // 不好: i 和 j 进行了“延迟”初始化\n    i = f1();\n    j = f2();\n&#125;\nelse &#123;\n    i = f3();\n    j = f4();\n&#125;\n</code></pre>\n<p>这样的话编译器甚至无法再简单地检测出 “设值前使用”。而且我们也在 widget 的状态空间中引入了复杂性：哪些操作对  <code>uninit</code>  的 widget 是有效的，哪些不是？</p>\n<h5 id=\"注解-192\"><a class=\"markdownIt-Anchor\" href=\"#注解-192\">#</a> 注解</h5>\n<p>几十年来，精明的程序员中都流行进行复杂的初始化。<br>\n这样做也是一种错误和复杂性的主要来源。<br>\n而许多这样的错误都是在最初实现之后的多年之后的维护过程中所引入的。</p>\n<h5 id=\"示例-196\"><a class=\"markdownIt-Anchor\" href=\"#示例-196\">#</a> 示例</h5>\n<p>本条规则涵盖成员变量。</p>\n<pre><code>class X &#123;\npublic:\n    X(int i, int ci) : m2&#123;i&#125;, cm2&#123;ci&#125; &#123;&#125;\n    // ...\n\nprivate:\n    int m1 = 7;\n    int m2;\n    int m3;\n\n    const int cm1 = 7;\n    const int cm2;\n    const int cm3;\n&#125;;\n</code></pre>\n<p>编译器能够标记  <code>cm3</code>  为未初始化（因其为  <code>const</code> ），但它无法发觉  <code>m3</code>  缺少初始化。<br>\n通常来说，以很少不恰当的成员初始化来消除错误，要比缺乏初始化更有价值，<br>\n而且优化器是可以消除冗余的初始化的（比如紧跟在赋值之前的初始化）。</p>\n<h5 id=\"例外-44\"><a class=\"markdownIt-Anchor\" href=\"#例外-44\">#</a> 例外</h5>\n<p>当声明一个即将从输入进行初始化的对象时，其初始化就可能导致发生双重初始化。<br>\n不过，应当注意这也可能造成输入之后留下未初始化的数据 —— 而这已经是一种错误和安全攻击的重大来源：</p>\n<pre><code>constexpr int max = 8 * 1024;\nint buf[max];         // OK, 但是可疑: 未初始化\nf.read(buf, max);\n</code></pre>\n<p>由于数组和  <code>std::array</code>  的有所限制的初始化规则，它们提供了对于需要这种例外的大多数有意义的例子。</p>\n<p>某些情况下，这个数组进行初始化的成本可能是显著的。<br>\n但是，这样的例子确实倾向于留下可访问到的未初始化变量，因而应当严肃对待它们。</p>\n<pre><code>constexpr int max = 8 * 1024;\nint buf[max] = &#123;&#125;;   // 某些情况下更好\nf.read(buf, max);\n</code></pre>\n<p>如果可行的话，应当用某个已知不会溢出的库函数。例如：</p>\n<pre><code>string s;   // s 默认初始化为 &quot;&quot;\ncin &gt;&gt; s;   // s 进行扩充以持有字符串\n</code></pre>\n<p>不要把用于输入操作的简单变量作为本条规则的例外：</p>\n<pre><code>int i;   // 不好\n// ...\ncin &gt;&gt; i;\n</code></pre>\n<p>在并不罕见的情况下，当输入目标和输入操作分开（其实不应该）时，就带来了发生 “设值前使用” 的可能性。</p>\n<pre><code>int i2 = 0;   // 更好，假设 0 是 i2 可接受的值\n// ...\ncin &gt;&gt; i2;\n</code></pre>\n<p>优秀的优化器应当能够识别输入操作并消除这种多余的操作。</p>\n<h5 id=\"注解-193\"><a class=\"markdownIt-Anchor\" href=\"#注解-193\">#</a> 注解</h5>\n<p>有时候，可以用 lambda 作为初始化式以避免未初始化变量：</p>\n<pre><code>error_code ec;\nValue v = [&amp;] &#123;\n    auto p = get_value();   // get_value() 返回 pair&lt;error_code, Value&gt;\n    ec = p.first;\n    return p.second;\n&#125;();\n</code></pre>\n<p>还可以是：</p>\n<pre><code>Value v = [] &#123;\n    auto p = get_value();   // get_value() 返回 pair&lt;error_code, Value&gt;\n    if (p.first) throw Bad_value&#123;p.first&#125;;\n    return p.second;\n&#125;();\n</code></pre>\n<p><strong>参见</strong>: <a href=\"#Res-lambda-init\">ES.28</a></p>\n<h5 id=\"强制实施-202\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-202\">#</a> 强制实施</h5>\n<ul>\n<li>标记出每个未初始化的变量。<br>\n不要对具有默认构造函数的自定义类型的变量进行标记。</li>\n<li>检查未初始化的缓冲区是否在声明后<em>立即</em>进行了写入。<br>\n将未初始化变量作为一个非  <code>const</code>  的引用参数进行传递可以被假定为向变量进行的写入。</li>\n</ul>\n<h3 id=\"a-nameres-introduceaes21-不要在确实需要使用变量或常量之前就引入它\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-introduceaes21-不要在确实需要使用变量或常量之前就引入它\">#</a> <a name=\"Res-introduce\"></a>ES.21: 不要在确实需要使用变量（或常量）之前就引入它</h3>\n<h5 id=\"理由-212\"><a class=\"markdownIt-Anchor\" href=\"#理由-212\">#</a> 理由</h5>\n<p>可读性。限制变量可以被使用的范围。</p>\n<h5 id=\"示例-197\"><a class=\"markdownIt-Anchor\" href=\"#示例-197\">#</a> 示例</h5>\n<pre><code>int x = 7;\n// ... 这里没有对 x 的使用 ...\n++x;\n</code></pre>\n<h5 id=\"强制实施-203\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-203\">#</a> 强制实施</h5>\n<p>对离其首次使用很远的声明进行标记。</p>\n<h3 id=\"a-nameres-initaes22-要等到获得了用以初始化变量的值之后才声明变量\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-initaes22-要等到获得了用以初始化变量的值之后才声明变量\">#</a> <a name=\"Res-init\"></a>ES.22: 要等到获得了用以初始化变量的值之后才声明变量</h3>\n<h5 id=\"理由-213\"><a class=\"markdownIt-Anchor\" href=\"#理由-213\">#</a> 理由</h5>\n<p>可读性。限制变量可以被使用的范围。避免 “设值前使用” 的风险。初始化通常比赋值更加高效。</p>\n<h5 id=\"示例不好-80\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-80\">#</a> 示例，不好</h5>\n<pre><code>string s;\n// ... 此处没有 s 的使用 ...\ns = &quot;what a waste&quot;;\n</code></pre>\n<h5 id=\"示例不好-81\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-81\">#</a> 示例，不好</h5>\n<pre><code>SomeLargeType var;  // 很难读的驼峰变量\n\nif (cond)   // 某个不简单的条件\n    Set(&amp;var);\nelse if (cond2 || !cond3) &#123;\n    var = Set2(3.14);\n&#125;\nelse &#123;\n    var = 0;\n    for (auto&amp; e : something)\n        var += e;\n&#125;\n\n// 使用 var; 可以仅通过控制流而静态地保证这并不会过早进行\n</code></pre>\n<p>如果  <code>SomeLargeType</code>  的默认初始化并非过于昂贵的话就没什么问题。<br>\n不过，程序员可能十分想知道是否所有的穿过这个条件迷宫的路径都已经被覆盖到了。<br>\n如果没有的话，就存在一个 “设值前使用” 的 BUG。这是维护工作的一个陷阱。</p>\n<p>对于具有必要复杂性的初始化式，也包括  <code>const</code>  变量的初始化式，应当考虑使用 lambda 来表达它；参见 <a href=\"#Res-lambda-init\">ES.28</a>。</p>\n<h5 id=\"强制实施-204\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-204\">#</a> 强制实施</h5>\n<ul>\n<li>如果具有默认初始化的声明在其首次被读取前就进行赋值，则对其进行标记。</li>\n<li>对于任何在未初始化变量之后且在其使用之前进行的复杂计算进行标记。</li>\n</ul>\n<h3 id=\"a-nameres-listaes23-优先使用-初始化式语法\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-listaes23-优先使用-初始化式语法\">#</a> <a name=\"Res-list\"></a>ES.23: 优先使用  <code>&#123;&#125;</code>  初始化式语法</h3>\n<h5 id=\"理由-214\"><a class=\"markdownIt-Anchor\" href=\"#理由-214\">#</a> 理由</h5>\n<p>优先使用  <code>&#123;&#125;</code> 。 <code>&#123;&#125;</code>  初始化的规则比其他形式的初始化更简单，更通用，更少歧义，而且更安全。</p>\n<p>仅当你确定不存在窄化转换时才可使用  <code>=</code> 。对于内建算术类型， <code>=</code>  仅和  <code>auto</code>  一起使用。</p>\n<p>避免  <code>()</code>  初始化，它会导致解析中的歧义。</p>\n<h5 id=\"示例-198\"><a class=\"markdownIt-Anchor\" href=\"#示例-198\">#</a> 示例</h5>\n<pre><code>int x &#123;f(99)&#125;;\nint y = x;\nvector&lt;int&gt; v = &#123;1, 2, 3, 4, 5, 6&#125;;\n</code></pre>\n<h5 id=\"例外-45\"><a class=\"markdownIt-Anchor\" href=\"#例外-45\">#</a> 例外</h5>\n<p>对于容器来说，存在用  <code>&#123;...&#125;</code>  给出元素列表而用  <code>(...)</code>  给出大小的传统做法：</p>\n<pre><code>vector&lt;int&gt; v1(10);    // vector 有 10 个具有默认值 0 的元素\nvector&lt;int&gt; v2&#123;10&#125;;    // vector 有 1 个值为 10 的元素\n\nvector&lt;int&gt; v3(1, 2);  // vector 有 1 个值为 2 的元素\nvector&lt;int&gt; v4&#123;1, 2&#125;;  // vector 有 2 个值为 1 和 2 的元素\n</code></pre>\n<h5 id=\"注解-194\"><a class=\"markdownIt-Anchor\" href=\"#注解-194\">#</a> 注解</h5>\n<p><code>&#123;&#125;</code>  初始化式不允许进行窄化转换（这点通常都很不错），并允许使用显式构造函数（这没有问题，我们的意图就是初始化一个新变量）。</p>\n<h5 id=\"示例-199\"><a class=\"markdownIt-Anchor\" href=\"#示例-199\">#</a> 示例</h5>\n<pre><code>int x &#123;7.9&#125;;   // 错误: 发生窄化\nint y = 7.9;   // OK: y 变为 7. 希望编译器给出了警告消息\nint z = gsl::narrow_cast&lt;int&gt;(7.9);  // OK: 这个正是你想要的\n</code></pre>\n<h5 id=\"注解-195\"><a class=\"markdownIt-Anchor\" href=\"#注解-195\">#</a> 注解</h5>\n<p><code>&#123;&#125;</code>  初始化可以用于几乎所有的初始化；而其他的初始化则不行：</p>\n<pre><code>auto p = new vector&lt;int&gt; &#123;1, 2, 3, 4, 5&#125;;   // 初始化 vector\nD::D(int a, int b) :m&#123;a, b&#125; &#123;   // 成员初始化式（比如说 m 可能是 pair）\n    // ...\n&#125;;\nX var &#123;&#125;;   // 初始化 var 为空\nstruct S &#123;\n    int m &#123;7&#125;;   // 成员的默认初始化\n    // ...\n&#125;;\n</code></pre>\n<p>由于这个原因，以  <code>&#123;&#125;</code>  进行初始化通常被称为 “统一初始化”，<br>\n（但很可惜存在少数不符合规则的例外）。</p>\n<h5 id=\"注解-196\"><a class=\"markdownIt-Anchor\" href=\"#注解-196\">#</a> 注解</h5>\n<p>对以  <code>auto</code>  声明的变量用单个值进行的初始化，比如  <code>&#123;v&#125;</code> ，直到 C<ins>17 之前都还具有令人意外的含义。<br>\nC</ins>17 的规则多少会少些意外：</p>\n<pre><code>auto x1 &#123;7&#125;;        // x1 是一个值为 7 的 int\nauto x2 = &#123;7&#125;;      // x2 是一个具有一个元素 7 的 initializer_list&lt;int&gt;\n\nauto x11 &#123;7, 8&#125;;    // 错误: 两个初始化式\nauto x22 = &#123;7, 8&#125;;  // x22 是一个具有元素 7 和 8 的 initializer_list&lt;int&gt;\n</code></pre>\n<p>如果确实需要一个  <code>initializer_list&lt;T&gt;</code>  的话，可以使用  <code>=&#123;...&#125;</code> ：</p>\n<pre><code>auto fib10 = &#123;1, 1, 2, 3, 5, 8, 13, 21, 34, 55&#125;;   // fib10 是一个列表\n</code></pre>\n<h5 id=\"注解-197\"><a class=\"markdownIt-Anchor\" href=\"#注解-197\">#</a> 注解</h5>\n<p><code>=&#123;&#125;</code>  进行的是复制初始化，而  <code>&#123;&#125;</code>  则进行直接初始化。<br>\n与在复制初始化和直接初始化自身之间存在的区别类似的是，这里也可能带来一些意外情况。<br>\n <code>&#123;&#125;</code>  可以接受  <code>explicit</code>  构造函数；而  <code>=&#123;&#125;</code>  则不能。例如：</p>\n<pre><code>struct Z &#123; explicit Z() &#123;&#125; &#125;;\n\nZ z1&#123;&#125;;     // OK: 直接初始化，使用的是 explicit 构造函数\nZ z2 = &#123;&#125;;  // 错误: 复制初始化，不能使用 explicit 构造函数\n</code></pre>\n<p>除非特别要求禁止使用显式构造函数，否则都应当使用普通的  <code>&#123;&#125;</code>  初始化。</p>\n<h5 id=\"示例-200\"><a class=\"markdownIt-Anchor\" href=\"#示例-200\">#</a> 示例</h5>\n<pre><code>template&lt;typename T&gt;\nvoid f()\n&#123;\n    T x1(1);    // T 以 1 进行初始化\n    T x0();     // 不好: 函数声明（一般都是一个错误）\n\n    T y1 &#123;1&#125;;   // T 以 1 进行初始化\n    T y0 &#123;&#125;;    // 默认初始化 T\n    // ...\n&#125;\n</code></pre>\n<p><strong>参见</strong>: <a href=\"#???\">讨论</a></p>\n<h5 id=\"强制实施-205\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-205\">#</a> 强制实施</h5>\n<ul>\n<li>当使用  <code>=</code>  初始化算术类型并发生窄化转换时予以标记。</li>\n<li>当使用  <code>()</code>  初始化语法但实际上是声明式时予以标记。（许多编译器已经可就此给出警告。）</li>\n</ul>\n<h3 id=\"a-nameres-uniqueaes24-用-unique_ptrt-来保存指针\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-uniqueaes24-用-unique_ptrt-来保存指针\">#</a> <a name=\"Res-unique\"></a>ES.24: 用  <code>unique_ptr&lt;T&gt;</code>  来保存指针</h3>\n<h5 id=\"理由-215\"><a class=\"markdownIt-Anchor\" href=\"#理由-215\">#</a> 理由</h5>\n<p>使用  <code>std::unique_ptr</code>  是避免泄漏的最简单方法。它是可靠的，它<br>\n利用类型系统完成验证所有权安全性的大部分工作，它<br>\n增加可读性，而且它没有或近乎没有运行时成本。</p>\n<h5 id=\"示例-201\"><a class=\"markdownIt-Anchor\" href=\"#示例-201\">#</a> 示例</h5>\n<pre><code>void use(bool leak)\n&#123;\n    auto p1 = make_unique&lt;int&gt;(7);   // OK\n    int* p2 = new int&#123;7&#125;;            // 不好: 可能泄漏\n    // ... 未对 p2 赋值 ...\n    if (leak) return;\n    // ... 未对 p2 赋值 ...\n    vector&lt;int&gt; v(7);\n    v.at(7) = 0;                    // 抛出异常\n    delete p2;                      // 避免泄漏已太晚了\n    // ...\n&#125;\n</code></pre>\n<p>当  <code>leak == true</code>  时， <code>p2</code>  所指向的对象就会泄漏，而  <code>p1</code>  所指向的对象则不会。<br>\n当  <code>at()</code>  抛出异常时也是同样的情况。两种情况下，都没能到达  <code>delete p2</code>  语句。</p>\n<h5 id=\"强制实施-206\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-206\">#</a> 强制实施</h5>\n<p>寻找作为这些函数的目标的原生指针： <code>new</code> ， <code>malloc()</code> ，或者可能返回这类指针的函数。</p>\n<h3 id=\"a-nameres-constaes25-应当将对象声明为-const-或-constexpr除非后面需要修改其值\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-constaes25-应当将对象声明为-const-或-constexpr除非后面需要修改其值\">#</a> <a name=\"Res-const\"></a>ES.25: 应当将对象声明为  <code>const</code>  或  <code>constexpr</code> ，除非后面需要修改其值</h3>\n<h5 id=\"理由-216\"><a class=\"markdownIt-Anchor\" href=\"#理由-216\">#</a> 理由</h5>\n<p>这样的话你就不会误改掉这个值。而且这种方式可能会给编译器的带来优化机会。</p>\n<h5 id=\"示例-202\"><a class=\"markdownIt-Anchor\" href=\"#示例-202\">#</a> 示例</h5>\n<pre><code>void f(int n)\n&#123;\n    const int bufmax = 2 * n + 2;  // 好: 无法意外改掉 bufmax\n    int xmax = n;                  // 可疑: xmax 是不是会改掉？\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"强制实施-207\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-207\">#</a> 强制实施</h5>\n<p>查看变量是不是真的被改动过，若并非如此就进行标记。<br>\n不幸的是，也许不可能检测出某个非  <code>const</code>  是不是<br>\n<em>有意</em>要改动，还是仅仅是没被改动而已。</p>\n<h3 id=\"a-nameres-recycleaes26-不要用一个变量来达成两个不相关的目的\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-recycleaes26-不要用一个变量来达成两个不相关的目的\">#</a> <a name=\"Res-recycle\"></a>ES.26: 不要用一个变量来达成两个不相关的目的</h3>\n<h5 id=\"理由-217\"><a class=\"markdownIt-Anchor\" href=\"#理由-217\">#</a> 理由</h5>\n<p>可读性和安全性。</p>\n<h5 id=\"示例不好-82\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-82\">#</a> 示例，不好</h5>\n<pre><code>void use()\n&#123;\n    int i;\n    for (i = 0; i &lt; 20; ++i) &#123; /* ... */ &#125;\n    for (i = 0; i &lt; 200; ++i) &#123; /* ... */ &#125; // 不好: i 重复使用了\n&#125;\n</code></pre>\n<p>+##### 注解</p>\n<p>也许你想把一个缓冲区当做暂存器来重复使用以作为一种优化措施，但即便如此也请尽可能限定该变量的作用域，还要当心不要导致由于遗留在重用的缓冲区中的数据而引发的 BUG，这是安全性 BUG 的一种常见来源。</p>\n<pre><code>void write_to_file()\n&#123;\n    std::string buffer;             // 以避免每次循环重复中的重新分配\n    for (auto&amp; o : objects) &#123;\n        // 第一部分工作。\n        generate_first_string(buffer, o);\n        write_to_file(buffer);\n\n        // 第二部分工作。\n        generate_second_string(buffer, o);\n        write_to_file(buffer);\n\n        // 等等...\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"强制实施-208\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-208\">#</a> 强制实施</h5>\n<p>标记被重复使用的变量。</p>\n<h3 id=\"a-nameres-stackaes27-使用-stdarray-或-stack_array-作为栈上的数组\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-stackaes27-使用-stdarray-或-stack_array-作为栈上的数组\">#</a> <a name=\"Res-stack\"></a>ES.27: 使用  <code>std::array</code>  或  <code>stack_array</code>  作为栈上的数组</h3>\n<h5 id=\"理由-218\"><a class=\"markdownIt-Anchor\" href=\"#理由-218\">#</a> 理由</h5>\n<p>它们是可读的，而且不会隐式转换为指针。<br>\n它们不会和内建数组的非标准扩展相混淆。</p>\n<h5 id=\"示例不好-83\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-83\">#</a> 示例，不好</h5>\n<pre><code>const int n = 7;\nint m = 9;\n\nvoid f()\n&#123;\n    int a1[n];\n    int a2[m];   // 错误: 并非 ISO C++\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"注解-198\"><a class=\"markdownIt-Anchor\" href=\"#注解-198\">#</a> 注解</h5>\n<p><code>a1</code>  的定义是合法的 C++ 而且一直都是。<br>\n存在大量的这类代码。<br>\n不过它是易错的，尤其当它的界并非局部时更是如此。<br>\n而且它也是一种 “流行” 的错误来源（缓冲区溢出，数组退化而成的指针，等等）。<br>\n而  <code>a2</code>  的定义符合 C 但不符合 C++，而且被认为存在安全性风险。</p>\n<h5 id=\"示例-203\"><a class=\"markdownIt-Anchor\" href=\"#示例-203\">#</a> 示例</h5>\n<pre><code>const int n = 7;\nint m = 9;\n\nvoid f()\n&#123;\n    array&lt;int, n&gt; a1;\n    stack_array&lt;int&gt; a2(m);\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"强制实施-209\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-209\">#</a> 强制实施</h5>\n<ul>\n<li>对具有非常量界的数组（C 风格的 VLA）作出标记。</li>\n<li>对具有非局部的常量界的数组作出标记。</li>\n</ul>\n<h3 id=\"a-nameres-lambda-initaes28-为复杂的初始化尤其是-const-变量使用-lambda\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-lambda-initaes28-为复杂的初始化尤其是-const-变量使用-lambda\">#</a> <a name=\"Res-lambda-init\"></a>ES.28: 为复杂的初始化（尤其是  <code>const</code>  变量）使用 lambda</h3>\n<h5 id=\"理由-219\"><a class=\"markdownIt-Anchor\" href=\"#理由-219\">#</a> 理由</h5>\n<p>它可以很好地封装局部的初始化，包括对仅为初始化所需的临时变量进行清理，而且避免了创建不必要的非局部而且无法重用的函数。它对于应当为  <code>const</code>  的变量也可以工作，不过必须先进行一些初始化。</p>\n<h5 id=\"示例不好-84\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-84\">#</a> 示例，不好</h5>\n<pre><code>widget x;   // 应当为 const, 不过:\nfor (auto i = 2; i &lt;= N; ++i) &#123;          // 这是由 x 的\n    x += some_obj.do_something_with(i);  // 初始化所需的\n&#125;                                        // 一段任意长的代码\n// 自此开始，x 应当为 const，不过我们无法在这种风格的代码中做到这点\n</code></pre>\n<h5 id=\"示例好-16\"><a class=\"markdownIt-Anchor\" href=\"#示例好-16\">#</a> 示例，好</h5>\n<pre><code>const widget x = [&amp;] &#123;\n    widget val;                                // 假定 widget 具有默认构造函数\n    for (auto i = 2; i &lt;= N; ++i) &#123;            // 这是由 x 的\n        val += some_obj.do_something_with(i);  // 初始化所需的\n    &#125;                                          // 一段任意长的代码\n    return val;\n&#125;();\n</code></pre>\n<p>如果可能的话，应当将条件缩减成一个后续的简单集合（比如一个  <code>enum</code> ），并避免把选择和初始化相互混合起来。</p>\n<h5 id=\"强制实施-210\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-210\">#</a> 强制实施</h5>\n<p>很难。最多是某种启发式方案。查找跟随某个未初始化变量之后的循环中向其赋值。</p>\n<h3 id=\"a-nameres-macrosaes30-不要用宏来操纵程序文本\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-macrosaes30-不要用宏来操纵程序文本\">#</a> <a name=\"Res-macros\"></a>ES.30: 不要用宏来操纵程序文本</h3>\n<h5 id=\"理由-220\"><a class=\"markdownIt-Anchor\" href=\"#理由-220\">#</a> 理由</h5>\n<p>宏是 BUG 的一个主要来源。<br>\n宏不遵守常规的作用域和类型规则。<br>\n宏保证会让人读到的东西和编译器见到的东西不一样。<br>\n宏使得工具的建造复杂化。</p>\n<h5 id=\"示例不好-85\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-85\">#</a> 示例，不好</h5>\n<pre><code>#define Case break; case   /* 不好 */\n</code></pre>\n<p>这个貌似无害的宏会把某个大写的  <code>C</code>  替换为小写的  <code>c</code>  导致一个严重的控制流错误。</p>\n<h5 id=\"注解-199\"><a class=\"markdownIt-Anchor\" href=\"#注解-199\">#</a> 注解</h5>\n<p>这条规则并不禁止在  <code>#ifdef</code>  等部分中使用用于 “配置控制” 的宏。</p>\n<p>将来，模块可能会消除配置控制中对宏的需求。</p>\n<h5 id=\"注解-200\"><a class=\"markdownIt-Anchor\" href=\"#注解-200\">#</a> 注解</h5>\n<p>此规则也意味着不鼓励使用  <code>#</code>  进行字符串化和使用  <code>##</code>  进行连接。<br>\n照例，宏有一些 “无害” 的用途，但即使这些也会给工具带来麻烦，<br>\n例如自动完成器、静态分析器和调试器。<br>\n通常，使用花式宏的欲望是过于复杂的设计的标志。<br>\n另外， <code>＃</code>  和  <code>##</code>  促进了宏的定义和使用：</p>\n<pre><code>#define CAT(a, b) a ## b\n#define STRINGIFY(a) #a\n\nvoid f(int x, int y)\n&#123;\n    string CAT(x, y) = &quot;asdf&quot;;   // 不好: 工具难以处理（也很丑陋）\n    string sx2 = STRINGIFY(x);\n    // ...\n&#125;\n</code></pre>\n<p>有使用宏进行低级字符串操作的变通方法。例如：</p>\n<pre><code>string s = &quot;asdf&quot; &quot;lkjh&quot;;   // 普通的字符串文字连接\n\nenum E &#123; a, b &#125;;\n\ntemplate&lt;int x&gt;\nconstexpr const char* stringify()\n&#123;\n    switch (x) &#123;\n    case a: return &quot;a&quot;;\n    case b: return &quot;b&quot;;\n    &#125;\n&#125;\n\nvoid f(int x, int y)\n&#123;\n    string sx = stringify&lt;x&gt;();\n    // ...\n&#125;\n</code></pre>\n<p>这不像定义宏那样方便，但是易于使用、零开销，并且是类型化的和作用域化的。</p>\n<p>将来，静态反射可能会消除对程序文本操作的预处理器的最终需求。</p>\n<h5 id=\"强制实施-211\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-211\">#</a> 强制实施</h5>\n<p>见到并非仅用于源代码控制（比如  <code>#ifdef</code> ）的宏时应当大声尖叫。</p>\n<h3 id=\"a-nameres-macros2aes31-不要用宏来作为常量或函数\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-macros2aes31-不要用宏来作为常量或函数\">#</a> <a name=\"Res-macros2\"></a>ES.31: 不要用宏来作为常量或 “函数”</h3>\n<h5 id=\"理由-221\"><a class=\"markdownIt-Anchor\" href=\"#理由-221\">#</a> 理由</h5>\n<p>宏是 BUG 的一个主要来源。<br>\n宏不遵守常规的作用域和类型规则。<br>\n宏不遵守常规的参数传递规则。<br>\n宏保证会让人读到的东西和编译器见到的东西不一样。<br>\n宏使得工具的建造复杂化。</p>\n<h5 id=\"示例不好-86\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-86\">#</a> 示例，不好</h5>\n<pre><code>#define PI 3.14\n#define SQUARE(a, b) (a * b)\n</code></pre>\n<p>即便我们并未在  <code>SQUARE</code>  中留下这个众所周知的 BUG，也存在多种表现好得多的替代方式；比如：</p>\n<pre><code>constexpr double pi = 3.14;\ntemplate&lt;typename T&gt; T square(T a, T b) &#123; return a * b; &#125;\n</code></pre>\n<h5 id=\"强制实施-212\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-212\">#</a> 强制实施</h5>\n<p>见到并非仅用于源代码控制（比如  <code>#ifdef</code> ）的宏时应当大声尖叫。</p>\n<h3 id=\"a-nameres-all_capsaes32-对所有的宏名采用-all_caps-命名方式\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-all_capsaes32-对所有的宏名采用-all_caps-命名方式\">#</a> <a name=\"Res-ALL_CAPS\"></a>ES.32: 对所有的宏名采用  <code>ALL_CAPS</code>  命名方式</h3>\n<h5 id=\"理由-222\"><a class=\"markdownIt-Anchor\" href=\"#理由-222\">#</a> 理由</h5>\n<p>遵循约定。可读性。区分宏。</p>\n<h5 id=\"示例-204\"><a class=\"markdownIt-Anchor\" href=\"#示例-204\">#</a> 示例</h5>\n<pre><code>#define forever for (;;)   /* 非常不好 */\n\n#define FOREVER for (;;)   /* 仍然很邪恶，但至少对人来说是可见的 */\n</code></pre>\n<h5 id=\"强制实施-213\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-213\">#</a> 强制实施</h5>\n<p>见到小写的宏时应当大声尖叫。</p>\n<h3 id=\"a-nameres-macrosaes33-如果必须使用宏的话请为之提供唯一的名字\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-macrosaes33-如果必须使用宏的话请为之提供唯一的名字\">#</a> <a name=\"Res-MACROS\"></a>ES.33: 如果必须使用宏的话，请为之提供唯一的名字</h3>\n<h5 id=\"理由-223\"><a class=\"markdownIt-Anchor\" href=\"#理由-223\">#</a> 理由</h5>\n<p>宏并不遵守作用域规则。</p>\n<h5 id=\"示例-205\"><a class=\"markdownIt-Anchor\" href=\"#示例-205\">#</a> 示例</h5>\n<pre><code>#define MYCHAR        /* 不好，最终将会和别人的 MYCHAR 相冲突 */\n\n#define ZCORP_CHAR    /* 还是不好，但冲突的机会较小 */\n</code></pre>\n<h5 id=\"注解-201\"><a class=\"markdownIt-Anchor\" href=\"#注解-201\">#</a> 注解</h5>\n<p>如果可能就应当避免使用宏：<a href=\"#Res-macros\">ES.30</a>，<a href=\"#Res-macros2\">ES.31</a>，以及 <a href=\"#Res-ALL_CAPS\">ES.32</a>。<br>\n然而，存在亿万行的代码中包含宏，以及一种使用并过度使用宏的长期传统。<br>\n如果你被迫使用宏的话，请使用长名字，而且应当带有唯一前缀（比如你的组织机构的名字）以减少冲突的可能性。</p>\n<h5 id=\"强制实施-214\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-214\">#</a> 强制实施</h5>\n<p>对较短的宏名给出警告。</p>\n<h3 id=\"a-nameres-ellipsesa-es34-不要定义c-风格的变参函数\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-ellipsesa-es34-不要定义c-风格的变参函数\">#</a> <a name=\"Res-ellipses\"></a> ES.34: 不要定义（C 风格的）变参函数</h3>\n<h5 id=\"理由-224\"><a class=\"markdownIt-Anchor\" href=\"#理由-224\">#</a> 理由</h5>\n<p>它并非类型安全。<br>\n而且需要杂乱的满是强制转换和宏的代码才能正确工作。</p>\n<h5 id=\"示例-206\"><a class=\"markdownIt-Anchor\" href=\"#示例-206\">#</a> 示例</h5>\n<pre><code>#include &lt;cstdarg&gt;\n\n// &quot;severity&quot; 后面跟着以零终结的 char* 列表；将 C 风格字符串写入 cerr\nvoid error(int severity ...)\n&#123;\n    va_list ap;             // 一个持有参数的神奇类型\n    va_start(ap, severity); // 参数启动：&quot;severity&quot; 是 error() 的第一个参数\n\n    for (;;) &#123;\n        // 将下一个变量看作 char*；没有检查：经过伪装的强制转换\n        char* p = va_arg(ap, char*);\n        if (!p) break;\n        cerr &lt;&lt; p &lt;&lt; ' ';\n    &#125;\n\n    va_end(ap);             // 参数清理（不能忘了这个）\n\n    cerr &lt;&lt; '\\n';\n    if (severity) exit(severity);\n&#125;\n\nvoid use()\n&#123;\n    error(7, &quot;this&quot;, &quot;is&quot;, &quot;an&quot;, &quot;error&quot;, nullptr);\n    error(7); // 崩溃\n    error(7, &quot;this&quot;, &quot;is&quot;, &quot;an&quot;, &quot;error&quot;);  // 崩溃\n    const char* is = &quot;is&quot;;\n    string an = &quot;an&quot;;\n    error(7, &quot;this&quot;, &quot;is&quot;, an, &quot;error&quot;); // 崩溃\n&#125;\n</code></pre>\n<p><strong>替代方案</strong>：重载。模板。变参模板。</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid error(int severity)\n&#123;\n    std::cerr &lt;&lt; '\\n';\n    std::exit(severity);\n&#125;\n\ntemplate&lt;typename T, typename... Ts&gt;\nconstexpr void error(int severity, T head, Ts... tail)\n&#123;\n    std::cerr &lt;&lt; head;\n    error(severity, tail...);\n&#125;\n\nvoid use()\n&#123;\n    error(7); // 不会崩溃！\n    error(5, &quot;this&quot;, &quot;is&quot;, &quot;not&quot;, &quot;an&quot;, &quot;error&quot;); // 不会崩溃！\n\n    std::string an = &quot;an&quot;;\n    error(7, &quot;this&quot;, &quot;is&quot;, &quot;not&quot;, an, &quot;error&quot;); // 不会崩溃！\n\n    error(5, &quot;oh&quot;, &quot;no&quot;, nullptr); // 编译器报错！不需要 nullptr。\n&#125;\n</code></pre>\n<h5 id=\"注解-202\"><a class=\"markdownIt-Anchor\" href=\"#注解-202\">#</a> 注解</h5>\n<p>这基本上就是  <code>printf</code>  的实现方式。</p>\n<h5 id=\"强制实施-215\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-215\">#</a> 强制实施</h5>\n<ul>\n<li>对 C 风格的变参函数的定义作出标记。</li>\n<li>对  <code>#include &lt;cstdarg&gt;</code>  和  <code>#include &lt;stdarg.h&gt;</code>  作出标记。</li>\n</ul>\n<h2 id=\"esexpr-表达式\"><a class=\"markdownIt-Anchor\" href=\"#esexpr-表达式\">#</a> ES.expr: 表达式</h2>\n<p>表达式对值进行操作。</p>\n<h3 id=\"a-nameres-complicatedaes40-避免复杂的表达式\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-complicatedaes40-避免复杂的表达式\">#</a> <a name=\"Res-complicated\"></a>ES.40: 避免复杂的表达式</h3>\n<h5 id=\"理由-225\"><a class=\"markdownIt-Anchor\" href=\"#理由-225\">#</a> 理由</h5>\n<p>复杂的表达式是易错的。</p>\n<h5 id=\"示例-207\"><a class=\"markdownIt-Anchor\" href=\"#示例-207\">#</a> 示例</h5>\n<pre><code>// 不好: 在子表达式中藏有赋值\nwhile ((c = getc()) != -1)\n\n// 不好: 在一个子表达式中对两个非局部变量进行了赋值\nwhile ((cin &gt;&gt; c1, cin &gt;&gt; c2), c1 == c2)\n\n// 有改善，但可能仍然过于复杂\nfor (char c1, c2; cin &gt;&gt; c1 &gt;&gt; c2 &amp;&amp; c1 == c2;)\n\n// OK: 若 i 和 j 并非别名\nint x = ++i + ++j;\n\n// OK: 若 i != j 且 i != k\nv[i] = v[j] + v[k];\n\n// 不好: 子表达式中“隐藏”了多个赋值\nx = a + (b = f()) + (c = g()) * 7;\n\n// 不好: 依赖于经常被误解的优先级规则\nx = a &amp; b + c * d &amp;&amp; e ^ f == 7;\n\n// 不好: 未定义行为\nx = x++ + x++ + ++x;\n</code></pre>\n<p>这些表达式中有几个是无条件不好的（比如说依赖于未定义行为）。其他的只不过过于复杂和不常见，即便是优秀的程序员匆忙中也可能会误解或者忽略其中的某个问题。</p>\n<h5 id=\"注解-203\"><a class=\"markdownIt-Anchor\" href=\"#注解-203\">#</a> 注解</h5>\n<p>C++17 收紧了有关求值顺序的规则<br>\n（除了赋值中从右向左，以及函数实参求值顺序未指明外均为从左向右，<a href=\"#Res-order\">参见 ES.43</a>），<br>\n但这并不影响复杂表达式很容易引起混乱的事实。</p>\n<h5 id=\"注解-204\"><a class=\"markdownIt-Anchor\" href=\"#注解-204\">#</a> 注解</h5>\n<p>程序员应当了解并运用表达式的基本规则。</p>\n<h5 id=\"示例-208\"><a class=\"markdownIt-Anchor\" href=\"#示例-208\">#</a> 示例</h5>\n<pre><code>x = k * y + z;             // OK\n\nauto t1 = k * y;           // 不好: 不必要的啰嗦\nx = t1 + z;\n\nif (0 &lt;= x &amp;&amp; x &lt; max)   // OK\n\nauto t1 = 0 &lt;= x;        // 不好: 不必要的啰嗦\nauto t2 = x &lt; max;\nif (t1 &amp;&amp; t2)            // ...\n</code></pre>\n<h5 id=\"强制实施-216\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-216\">#</a> 强制实施</h5>\n<p>很麻烦。多复杂的表达式才能被当成复杂的？把计算写成每条语句一个操作同样是让人混乱的。需要考虑的有：</p>\n<ul>\n<li>副作用：（对于某种非局部性定义，）多个非局部变量上发生副作用是值得怀疑的，尤其是当这些副作用是在不同的子表达式中时</li>\n<li>向别名变量的写入</li>\n<li>超过 N 个运算符（N 应当为多少？）</li>\n<li>依赖于微妙的优先级规则</li>\n<li>使用了未定义行为（我们是否应当识别所有的未定义行为？）</li>\n<li>实现定义的行为？</li>\n<li>???</li>\n</ul>\n<h3 id=\"a-nameres-parensaes41-对运算符优先级不保准时应使用括号\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-parensaes41-对运算符优先级不保准时应使用括号\">#</a> <a name=\"Res-parens\"></a>ES.41: 对运算符优先级不保准时应使用括号</h3>\n<h5 id=\"理由-226\"><a class=\"markdownIt-Anchor\" href=\"#理由-226\">#</a> 理由</h5>\n<p>避免错误。可读性。不是每个人都能记住运算符表格。</p>\n<h5 id=\"示例-209\"><a class=\"markdownIt-Anchor\" href=\"#示例-209\">#</a> 示例</h5>\n<pre><code>const unsigned int flag = 2;\nunsigned int a = flag;\n\nif (a &amp; flag != 0)  // 不好: 含义为 a&amp;(flag != 0)\n</code></pre>\n<p>注意：我们建议程序员了解算术运算和逻辑运算的优先级表，但应当考虑当按位逻辑运算和其他运算符混合使用时需要采用括号。</p>\n<pre><code>if ((a &amp; flag) != 0)  // OK: 按预期工作\n</code></pre>\n<h5 id=\"注解-205\"><a class=\"markdownIt-Anchor\" href=\"#注解-205\">#</a> 注解</h5>\n<p>你应当了解足够的知识以避免在这样的情况下需要括号：</p>\n<pre><code>if (a &lt; 0 || a &lt;= max) &#123;\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"强制实施-217\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-217\">#</a> 强制实施</h5>\n<ul>\n<li>当按位逻辑运算符合其他运算符组合时进行标记。</li>\n<li>当赋值运算符不是最左边的运算符时进行标记。</li>\n<li>???</li>\n</ul>\n<h3 id=\"a-nameres-ptraes42-保持单纯直接的指针使用方式\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-ptraes42-保持单纯直接的指针使用方式\">#</a> <a name=\"Res-ptr\"></a>ES.42: 保持单纯直接的指针使用方式</h3>\n<h5 id=\"理由-227\"><a class=\"markdownIt-Anchor\" href=\"#理由-227\">#</a> 理由</h5>\n<p>复杂的指针操作是一种重大的错误来源。</p>\n<h5 id=\"注解-206\"><a class=\"markdownIt-Anchor\" href=\"#注解-206\">#</a> 注解</h5>\n<p>代之以使用  <code>gsl::span</code> 。<br>\n指针<a href=\"#Ri-array\">只应当指代单个对象</a>。<br>\n指针算术是脆弱而易错的，是许多许多糟糕的 BUG 和安全漏洞的来源。<br>\n <code>span</code>  是一种用于访问数组对象的带有边界检查的安全类型。<br>\n以常量为下标来访问已知边界的数组，编译器可以进行验证。</p>\n<h5 id=\"示例不好-87\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-87\">#</a> 示例，不好</h5>\n<pre><code>void f(int* p, int count)\n&#123;\n    if (count &lt; 2) return;\n\n    int* q = p + 1;    // 不好\n\n    ptrdiff_t d;\n    int n;\n    d = (p - &amp;n);      // OK\n    d = (q - p);       // OK\n\n    int n = *p++;      // 不好\n\n    if (count &lt; 6) return;\n\n    p[4] = 1;          // 不好\n\n    p[count - 1] = 2;  // 不好\n\n    use(&amp;p[0], 3);     // 不好\n&#125;\n</code></pre>\n<h5 id=\"示例好-17\"><a class=\"markdownIt-Anchor\" href=\"#示例好-17\">#</a> 示例，好</h5>\n<pre><code>void f(span&lt;int&gt; a) // 好多了：函数声明中使用了 span\n&#123;\n    if (a.size() &lt; 2) return;\n\n    int n = a[0];      // OK\n\n    span&lt;int&gt; q = a.subspan(1); // OK\n\n    if (a.size() &lt; 6) return;\n\n    a[4] = 1;          // OK\n\n    a[a.size() - 1] = 2;  // OK\n\n    use(a.data(), 3);  // OK\n&#125;\n</code></pre>\n<h5 id=\"注解-207\"><a class=\"markdownIt-Anchor\" href=\"#注解-207\">#</a> 注解</h5>\n<p>用变量做下标，对于工具和人类来说都是很难将其验证为安全的。<br>\n <code>span</code>  是一种用于访问数组对象的带有运行时边界检查的安全类型。<br>\n <code>at()</code>  是可以保证单次访问进行边界检查的另一种替代方案。<br>\n如果需要用迭代器来访问数组的话，应使用构造于数组之上的  <code>span</code>  所提供的迭代器。</p>\n<h5 id=\"示例不好-88\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-88\">#</a> 示例，不好</h5>\n<pre><code>void f(array&lt;int, 10&gt; a, int pos)\n&#123;\n    a[pos / 2] = 1; // 不好\n    a[pos - 1] = 2; // 不好\n    a[-1] = 3;    // 不好（但易于被工具查出） - 没有替代方案，请勿这样做\n    a[10] = 4;    // 不好（但易于被工具查出） - 没有替代方案，请勿这样做\n&#125;\n</code></pre>\n<h5 id=\"示例好-18\"><a class=\"markdownIt-Anchor\" href=\"#示例好-18\">#</a> 示例，好</h5>\n<p>使用  <code>span</code> ：</p>\n<pre><code>void f1(span&lt;int, 10&gt; a, int pos) // A1: 将参数类型改为使用 span\n&#123;\n    a[pos / 2] = 1; // OK\n    a[pos - 1] = 2; // OK\n&#125;\n\nvoid f2(array&lt;int, 10&gt; arr, int pos) // A2: 增加局部的 span 并使用之\n&#123;\n    span&lt;int&gt; a = &#123;arr.data(), pos&#125;;\n    a[pos / 2] = 1; // OK\n    a[pos - 1] = 2; // OK\n&#125;\n</code></pre>\n<p>使用  <code>at()</code> ：</p>\n<pre><code>void f3(array&lt;int, 10&gt; a, int pos) // 替代方案 B: 用 at() 进行访问\n&#123;\n    at(a, pos / 2) = 1; // OK\n    at(a, pos - 1) = 2; // OK\n&#125;\n</code></pre>\n<h5 id=\"示例不好-89\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-89\">#</a> 示例，不好</h5>\n<pre><code>void f()\n&#123;\n    int arr[COUNT];\n    for (int i = 0; i &lt; COUNT; ++i)\n        arr[i] = i; // 不好，不能使用非常量索引\n&#125;\n</code></pre>\n<h5 id=\"示例好-19\"><a class=\"markdownIt-Anchor\" href=\"#示例好-19\">#</a> 示例，好</h5>\n<p>使用  <code>span</code> ：</p>\n<pre><code>void f1()\n&#123;\n    int arr[COUNT];\n    span&lt;int&gt; av = arr;\n    for (int i = 0; i &lt; COUNT; ++i)\n        av[i] = i;\n&#125;\n</code></pre>\n<p>使用  <code>span</code>  和基于范围的  <code>for</code> ：</p>\n<pre><code>void f1a()\n&#123;\n     int arr[COUNT];\n     span&lt;int, COUNT&gt; av = arr;\n     int i = 0;\n     for (auto&amp; e : av)\n         e = i++;\n&#125;\n</code></pre>\n<p>使用  <code>at()</code>  进行访问：</p>\n<pre><code>void f2()\n&#123;\n    int arr[COUNT];\n    int i = 0;\n    for (int i = 0; i &lt; COUNT; ++i)\n        at(arr, i) = i;\n&#125;\n</code></pre>\n<p>使用基于范围的  <code>for</code> ：</p>\n<pre><code>void f3()\n&#123;\n     int arr[COUNT];\n     for (auto&amp; e : arr)\n         e = i++;\n&#125;\n</code></pre>\n<h5 id=\"注解-208\"><a class=\"markdownIt-Anchor\" href=\"#注解-208\">#</a> 注解</h5>\n<p>工具可以提供重写能力，以将涉及动态索引表达式的数组访问替换为使用  <code>at()</code>  进行访问：</p>\n<pre><code>static int a[10];\n\nvoid f(int i, int j)\n&#123;\n    a[i + j] = 12;      // 不好，可以重写为 ...\n    at(a, i + j) = 12;  // OK - 带有边界检查\n&#125;\n</code></pre>\n<h5 id=\"示例-210\"><a class=\"markdownIt-Anchor\" href=\"#示例-210\">#</a> 示例</h5>\n<p>把数组转变为指针（语言基本上总会这样做），移除了进行检查的机会，因此应当予以避免</p>\n<pre><code>void g(int* p);\n\nvoid f()\n&#123;\n    int a[5];\n    g(a);        // 不好：是要传递一个数组吗？\n    g(&amp;a[0]);    // OK：传递单个对象\n&#125;\n</code></pre>\n<p>如果要传递数组的话，应该这样：</p>\n<pre><code>void g(int* p, size_t length);  // 老的（危险）代码\n\nvoid g1(span&lt;int&gt; av); // 好多了：改动了 g()。\n\nvoid f()\n&#123;\n    int a[5];\n    span&lt;int&gt; av = a;\n\n    g(av.data(), av.size());   // OK, 如果没有其他选择的话\n    g1(a);                     // OK - 这里没有退化，而是使用了隐式的 span 构造函数\n&#125;\n</code></pre>\n<h5 id=\"强制实施-218\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-218\">#</a> 强制实施</h5>\n<ul>\n<li>对任何在指针类型的表达式上进行的产生指针类型的值的算术运算进行标记。</li>\n<li>对任何数组类型的表达式或变量（无论是静态数组还是  <code>std::array</code> ）上进行索引的表达式，若其索引不是值为从  <code>0</code>  到数组上界之内的编译期常量表达式，则进行标记。</li>\n<li>对任何可能依赖于从数组类型向指针类型的隐式转换的表达式进行标记。</li>\n</ul>\n<p>本条规则属于<a href=\"#SS-bounds\">边界安全性剖面配置</a>。</p>\n<h3 id=\"a-nameres-orderaes43-避免带有未定义的求值顺序的表达式\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-orderaes43-避免带有未定义的求值顺序的表达式\">#</a> <a name=\"Res-order\"></a>ES.43: 避免带有未定义的求值顺序的表达式</h3>\n<h5 id=\"理由-228\"><a class=\"markdownIt-Anchor\" href=\"#理由-228\">#</a> 理由</h5>\n<p>你没办法搞清楚这种代码会做什么。可移植性。<br>\n即便它做到了对你可能有意义的事情，它在别的编译器（比如你的编译器的下个版本）或者不同的优化设置中也可能会做出不同的事情。</p>\n<h5 id=\"注解-209\"><a class=\"markdownIt-Anchor\" href=\"#注解-209\">#</a> 注解</h5>\n<p>C++17 收紧了有关求值顺序的规则：<br>\n除了赋值中从右向左，以及函数实参求值顺序未指明外均为从左向右。</p>\n<p>不过，要记住你的代码可能是由 C++17 之前的编译器进行编译的（比如通过复制粘贴），请勿自作聪明。</p>\n<h5 id=\"示例-211\"><a class=\"markdownIt-Anchor\" href=\"#示例-211\">#</a> 示例</h5>\n<pre><code>v[i] = ++i;   //  其结果是未定义的\n</code></pre>\n<p>一条不错经验法则是，你不应当在一个表达式中两次读取你所写入的值。</p>\n<h5 id=\"强制实施-219\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-219\">#</a> 强制实施</h5>\n<p>可以由优秀的分析器检测出来。</p>\n<h3 id=\"a-nameres-order-fctaes44-不要对函数参数求值顺序有依赖\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-order-fctaes44-不要对函数参数求值顺序有依赖\">#</a> <a name=\"Res-order-fct\"></a>ES.44: 不要对函数参数求值顺序有依赖</h3>\n<h5 id=\"理由-229\"><a class=\"markdownIt-Anchor\" href=\"#理由-229\">#</a> 理由</h5>\n<p>因为这种顺序是未定义的。</p>\n<h5 id=\"注解-210\"><a class=\"markdownIt-Anchor\" href=\"#注解-210\">#</a> 注解</h5>\n<p>C++17 收紧了有关求值顺序的规则，但函数实参求值顺序仍然是未指明的。</p>\n<h5 id=\"示例-212\"><a class=\"markdownIt-Anchor\" href=\"#示例-212\">#</a> 示例</h5>\n<pre><code>int i = 0;\nf(++i, ++i);\n</code></pre>\n<p>在 C<ins>17 之前，其行为是未定义的。因此其行为可能是任何事（比如  <code>f(2, 2)</code> ）。<br>\n自 C</ins>17 起，中这段代码没有未定义行为，但仍未指定是哪个实参被首先求值。这个调用会是  <code>f(0, 1)</code>  或  <code>f(1, 0)</code> ，但你不知道是哪个。</p>\n<h5 id=\"示例-213\"><a class=\"markdownIt-Anchor\" href=\"#示例-213\">#</a> 示例</h5>\n<p>重载运算符可能导致求值顺序问题：</p>\n<pre><code>f1()-&gt;m(f2());          // m(f1(), f2())\ncout &lt;&lt; f1() &lt;&lt; f2();   // operator&lt;&lt;(operator&lt;&lt;(cout, f1()), f2())\n</code></pre>\n<p>在 C++17 中，这些例子将按预期工作（自左向右），而赋值则按自右向左求值（ <code>=</code>  正是自右向左绑定的）</p>\n<pre><code>f1() = f2();    // C++14 中为未定义行为；C++17 中 f2() 在 f1() 之前求值\n</code></pre>\n<h5 id=\"强制实施-220\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-220\">#</a> 强制实施</h5>\n<p>可以由优秀的分析器检测出来。</p>\n<h3 id=\"a-nameres-magicaes45-避免魔法常量采用符号化常量\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-magicaes45-避免魔法常量采用符号化常量\">#</a> <a name=\"Res-magic\"></a>ES.45: 避免 “魔法常量”，采用符号化常量</h3>\n<h5 id=\"理由-230\"><a class=\"markdownIt-Anchor\" href=\"#理由-230\">#</a> 理由</h5>\n<p>表达式中内嵌的无名的常量很容易被忽略，而且经常难于理解：</p>\n<h5 id=\"示例-214\"><a class=\"markdownIt-Anchor\" href=\"#示例-214\">#</a> 示例</h5>\n<pre><code>for (int m = 1; m &lt;= 12; ++m)   // 请勿如此: 魔法常量 12\n    cout &lt;&lt; month[m] &lt;&lt; '\\n';\n</code></pre>\n<p>不是所有人都知道一年中有 12 个月份，号码是 1 到 12。更好的做法是：</p>\n<pre><code>// 月份索引值为 1..12\nconstexpr int first_month = 1;\nconstexpr int last_month = 12;\n\nfor (int m = first_month; m &lt;= last_month; ++m)   // 好多了\n    cout &lt;&lt; month[m] &lt;&lt; '\\n';\n</code></pre>\n<p>更好的做法是，不要暴露常量：</p>\n<pre><code>for (auto m : month)\n    cout &lt;&lt; m &lt;&lt; '\\n';\n</code></pre>\n<h5 id=\"强制实施-221\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-221\">#</a> 强制实施</h5>\n<p>标记代码中的字面量。让  <code>0</code> ， <code>1</code> ， <code>nullptr</code> ， <code>\\n'</code> ， <code>&quot;&quot;</code> ，以及某个确认列表中的其他字面量通过检查。</p>\n<h3 id=\"a-nameres-narrowingaes46-避免丢失数据窄化-截断的算术转换\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-narrowingaes46-避免丢失数据窄化-截断的算术转换\">#</a> <a name=\"Res-narrowing\"></a>ES.46: 避免丢失数据（窄化、截断）的算术转换</h3>\n<h5 id=\"理由-231\"><a class=\"markdownIt-Anchor\" href=\"#理由-231\">#</a> 理由</h5>\n<p>窄化转换会销毁信息，通常是不期望发生的。</p>\n<h5 id=\"示例不好-90\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-90\">#</a> 示例，不好</h5>\n<p>关键的例子就是基本的窄化：</p>\n<pre><code>double d = 7.9;\nint i = d;    // 不好: 窄化: i 变为了 7\ni = (int) d;  // 不好: 我们打算声称这样的做法仍然不够明确\n\nvoid f(int x, long y, double d)\n&#123;\n    char c1 = x;   // 不好: 窄化\n    char c2 = y;   // 不好: 窄化\n    char c3 = d;   // 不好: 窄化\n&#125;\n</code></pre>\n<h5 id=\"注解-211\"><a class=\"markdownIt-Anchor\" href=\"#注解-211\">#</a> 注解</h5>\n<p>指导方针支持库提供了一个  <code>narrow_cast</code>  操作，用以指名发生窄化是可接受的，以及一个  <code>narrow</code> （“窄化判定”）当窄化将会损失合法值时将会抛出一个异常：</p>\n<pre><code>i = gsl::narrow_cast&lt;int&gt;(d);   // OK (明确需要): 窄化: i 变为了 7\ni = gsl::narrow&lt;int&gt;(d);        // OK: 抛出 narrowing_error\n</code></pre>\n<p>其中还包含了一些含有损失的算术强制转换，比如从负的浮点类型到无符号整型类型的强制转换：</p>\n<pre><code>double d = -7.9;\nunsigned u = 0;\n\nu = d;                               // 不好：发生窄化\nu = gsl::narrow_cast&lt;unsigned&gt;(d);   // OK (明确需要): u 变为了 4294967289\nu = gsl::narrow&lt;unsigned&gt;(d);        // OK：抛出 narrowing_error\n</code></pre>\n<h5 id=\"注解-212\"><a class=\"markdownIt-Anchor\" href=\"#注解-212\">#</a> 注解</h5>\n<p>这条规则不适用于<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2xhbmd1YWdlL2ltcGxpY2l0X2NvbnZlcnNpb24jQ29udGV4dHVhbF9jb252ZXJzaW9ucw==\">按语境转换为 bool</span> 的情形：</p>\n<pre><code>if (ptr) do_something(*ptr);   // OK：ptr 被用作条件\nbool b = ptr;                  // 不好：发生窄化\n</code></pre>\n<h5 id=\"强制实施-222\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-222\">#</a> 强制实施</h5>\n<p>优良的分析器可以检测到所有的窄化转换。不过，对所有的窄化转换都进行标记将带来大量的误报。建议的做法是：</p>\n<ul>\n<li>标记出所有的浮点向整数转换（可能只有  <code>float</code> -&gt; <code>char</code>  和  <code>double</code> -&gt; <code>int</code> 。这里有问题！需要数据支持）。</li>\n<li>标记出所有的  <code>long</code> -&gt; <code>char</code> （我怀疑  <code>int</code> -&gt; <code>char</code>  非常常见。这里有问题！需要数据支持）。</li>\n<li>在函数参数上发生的窄化转换特别值得怀疑。</li>\n</ul>\n<h3 id=\"a-nameres-nullptraes47-使用-nullptr-而不是-0-或-null\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-nullptraes47-使用-nullptr-而不是-0-或-null\">#</a> <a name=\"Res-nullptr\"></a>ES.47: 使用  <code>nullptr</code>  而不是  <code>0</code>  或  <code>NULL</code></h3>\n<h5 id=\"理由-232\"><a class=\"markdownIt-Anchor\" href=\"#理由-232\">#</a> 理由</h5>\n<p>可读性。最小化意外： <code>nullptr</code>  不可能和  <code>int</code>  混淆。<br>\n <code>nullptr</code>  还有一个严格定义的（非常严格）类型，且因此<br>\n可以在类型推断可能在  <code>NULL</code>  或  <code>0</code>  上犯错的场合中仍能<br>\n正常工作。</p>\n<h5 id=\"示例-215\"><a class=\"markdownIt-Anchor\" href=\"#示例-215\">#</a> 示例</h5>\n<p>考虑：</p>\n<pre><code>void f(int);\nvoid f(char*);\nf(0);         // 调用 f(int)\nf(nullptr);   // 调用 f(char*)\n</code></pre>\n<h5 id=\"强制实施-223\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-223\">#</a> 强制实施</h5>\n<p>对用作指针的  <code>0</code>  和  <code>NULL</code>  进行标记。可以用简单的程序变换来达成这种变换。</p>\n<h3 id=\"a-nameres-castsaes48-避免强制转换\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-castsaes48-避免强制转换\">#</a> <a name=\"Res-casts\"></a>ES.48: 避免强制转换</h3>\n<h5 id=\"理由-233\"><a class=\"markdownIt-Anchor\" href=\"#理由-233\">#</a> 理由</h5>\n<p>强制转换是众所周知的错误来源，它们使得一些优化措施变得不可靠。</p>\n<h5 id=\"示例不好-91\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-91\">#</a> 示例，不好</h5>\n<pre><code>double d = 2;\nauto p = (long*)&amp;d;\nauto q = (long long*)&amp;d;\ncout &lt;&lt; d &lt;&lt; ' ' &lt;&lt; *p &lt;&lt; ' ' &lt;&lt; *q &lt;&lt; '\\n';\n</code></pre>\n<p>你觉得这段代码会打印出什么呢？结果最好由实现定义。我得到的是</p>\n<pre><code>2 0 4611686018427387904\n</code></pre>\n<p>加上这些</p>\n<pre><code>*q = 666;\ncout &lt;&lt; d &lt;&lt; ' ' &lt;&lt; *p &lt;&lt; ' ' &lt;&lt; *q &lt;&lt; '\\n';\n</code></pre>\n<p>得到的是</p>\n<pre><code>3.29048e-321 666 666\n</code></pre>\n<p>奇怪吗？我很庆幸程序没有崩溃掉。</p>\n<h5 id=\"注解-213\"><a class=\"markdownIt-Anchor\" href=\"#注解-213\">#</a> 注解</h5>\n<p>写下强制转换的程序员通常认为他们知道所做的是什么事情，<br>\n或者写出强制转换能让程序 “更易读”。<br>\n而实际上，他们这样经常会禁止掉使用值的一些一般规则。<br>\n如果存在正确的函数的话，重载决议和模板实例化通常都能挑选出正确的函数。<br>\n如果没有的话，则可能本应如此，而不应该进行某种局部的修补（强制转换）。</p>\n<h5 id=\"注解-214\"><a class=\"markdownIt-Anchor\" href=\"#注解-214\">#</a> 注解</h5>\n<p>强制转换在系统编程语言中是必要的。例如，否则我们怎么<br>\n才能把设备寄存器的地址放入一个指针呢？然而，强制转换<br>\n却被严重过度使用了，而且也是一种主要的错误来源。</p>\n<p>当你觉得需要进行大量强制转换时，可能存在一个基本的设计问题。</p>\n<p><a href=\"#Pro-type-reinterpretcast\">类型剖面配置</a> 禁止使用  <code>reinterpret_cast</code>  和 C 风格强制转换。</p>\n<p>不要以强制转换为  <code>(void)</code>  来忽略  <code>[[nodiscard]]</code>  返回值。<br>\n当你有意要丢弃这种返回值时，应当首先深入思考这是不是确实是个好主意（通常，这个函数或者使用了  <code>[[nodiscard]]</code>  的返回类型的作者，当初确实是有充分理由的）。<br>\n要是你仍然觉得这样做是合适的，而且你的代码评审者也同意的话，使用  <code>std::ignore =</code>  来关闭这个警告，这既简单，可移植，也易于 grep。</p>\n<h5 id=\"替代方案-10\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-10\">#</a> 替代方案</h5>\n<p>强制转换被广泛（误）用了。现代 C++ 已经提供了一些规则和语言构造，消除了许多语境中对强制转换的需求，比如</p>\n<ul>\n<li>使用模板</li>\n<li>使用  <code>std::variant</code></li>\n<li>借助良好定义的，安全的，指针类型之间的隐式转换</li>\n<li>使用  <code>std::ignore =</code>  来忽略  <code>[[nodiscard]]</code>  值</li>\n</ul>\n<h5 id=\"强制实施-224\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-224\">#</a> 强制实施</h5>\n<ul>\n<li>对包括向  <code>void</code>  在内的所有 C 风格强制转换进行标记。</li>\n<li>对使用  <code>Type(value)</code>  的函数风格强制转换进行标记。应代之以使用不会发生窄化的  <code>Type&#123;value&#125;</code> 。（参见 <a href=\"#Res-construct\">ES.64</a>。）</li>\n<li>对指针类型之间的<a href=\"#Pro-type-identitycast\">同一强制转换</a>，若其中的源类型和目标类型相同 (#Pro-type-identitycast) 则进行标记。</li>\n<li>对可以作为<a href=\"#Pro-type-implicitpointercast\">隐式转换</a>的显示指针强制转换进行标记。</li>\n</ul>\n<h3 id=\"a-nameres-casts-namedaes49-当必须使用强制转换时使用具名的强制转换\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-casts-namedaes49-当必须使用强制转换时使用具名的强制转换\">#</a> <a name=\"Res-casts-named\"></a>ES.49: 当必须使用强制转换时，使用具名的强制转换</h3>\n<h5 id=\"理由-234\"><a class=\"markdownIt-Anchor\" href=\"#理由-234\">#</a> 理由</h5>\n<p>可读性。避免错误。<br>\n具名的强制转换比 C 风格或函数风格的强制转换更加特殊，允许编译器捕捉到某些错误。</p>\n<p>具名的强制转换包括：</p>\n<ul>\n<li><code>static_cast</code></li>\n<li><code>const_cast</code></li>\n<li><code>reinterpret_cast</code></li>\n<li><code>dynamic_cast</code></li>\n<li><code>std::move</code>          //  <code>move(x)</code>  是指代  <code>x</code>  的右值引用</li>\n<li><code>std::forward</code>       //  <code>forward&lt;T&gt;(x)</code>  是指代  <code>x</code>  的左值或右值引用（取决于  <code>T</code> ）</li>\n<li><code>gsl::narrow_cast</code>   //  <code>narrow_cast&lt;T&gt;(x)</code>  就是  <code>static_cast&lt;T&gt;(x)</code></li>\n<li><code>gsl::narrow</code>        //  <code>narrow&lt;T&gt;(x)</code>  在当  <code>static_cast&lt;T&gt;(x) == x</code>  时即为  <code>static_cast&lt;T&gt;(x)</code>  否则会抛出  <code>narrowing_error</code></li>\n</ul>\n<h5 id=\"示例-216\"><a class=\"markdownIt-Anchor\" href=\"#示例-216\">#</a> 示例</h5>\n<pre><code>class B &#123; /* ... */ &#125;;\nclass D &#123; /* ... */ &#125;;\n\ntemplate&lt;typename D&gt; D* upcast(B* pb)\n&#123;\n    D* pd0 = pb;                        // 错误：不存在从 B* 向 D* 的隐式转换\n    D* pd1 = (D*)pb;                    // 合法，但干了什么？\n    D* pd2 = static_cast&lt;D*&gt;(pb);       // 错误：D 并非派生于 B\n    D* pd3 = reinterpret_cast&lt;D*&gt;(pb);  // OK：你自己负责！\n    D* pd4 = dynamic_cast&lt;D*&gt;(pb);      // OK：返回 nullptr\n    // ...\n&#125;\n</code></pre>\n<p>这个例子是从真实世界的 BUG 合成的，其中  <code>D</code>  曾经派生于  <code>B</code> ，但某个人重构了继承层次。<br>\nC 风格的强制转换很危险，因为它可以进行任何种类的转换，使我们丧失了今后受保护不犯错的机会。</p>\n<h5 id=\"注解-215\"><a class=\"markdownIt-Anchor\" href=\"#注解-215\">#</a> 注解</h5>\n<p>当在类型之间进行没有信息丢失的转换时（比如从  <code>float</code>  到<br>\n <code>double</code>  或者从  <code>int32</code>  到  <code>int64</code> ），可以代之以使用花括号初始化。</p>\n<pre><code>double d &#123;some_float&#125;;\nint64_t i &#123;some_int32&#125;;\n</code></pre>\n<p>这样做明确了有意进行类型转换，而且同样避免了<br>\n发生可能导致精度损失的结果的类型转换。（比如说，<br>\n试图用这种风格来从  <code>double</code>  初始化  <code>float</code>  会导致<br>\n编译错误。）</p>\n<h5 id=\"注解-216\"><a class=\"markdownIt-Anchor\" href=\"#注解-216\">#</a> 注解</h5>\n<p><code>reinterpret_cast</code>  可以很基础，但其基础用法（如将机器地址转化为指针）并不是类型安全的：</p>\n<pre><code>auto p = reinterpret_cast&lt;Device_register&gt;(0x800);  // 天生危险\n</code></pre>\n<h5 id=\"强制实施-225\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-225\">#</a> 强制实施</h5>\n<ul>\n<li>对包括向  <code>void</code>  在内的所有 C 风格强制转换进行标记。</li>\n<li>对使用  <code>Type(value)</code>  的函数风格强制转换进行标记。应代之以使用不会发生窄化的  <code>Type&#123;value&#125;</code> 。（参见 <a href=\"#Res-construct\">ES.64</a>。）</li>\n<li><a href=\"#Pro-type-reinterpretcast\">类型剖面配置</a>禁用了  <code>reinterpret_cast</code> 。</li>\n<li><a href=\"#Pro-type-arithmeticcast\">类型剖面配置</a>对于在算术类型之间使用  <code>static_cast</code>  时给出警告。</li>\n</ul>\n<h3 id=\"a-nameres-casts-constaes50-不要强制掉-const\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-casts-constaes50-不要强制掉-const\">#</a> <a name=\"Res-casts-const\"></a>ES.50: 不要强制掉  <code>const</code></h3>\n<h5 id=\"理由-235\"><a class=\"markdownIt-Anchor\" href=\"#理由-235\">#</a> 理由</h5>\n<p>这是在  <code>const</code>  上说谎。<br>\n若变量确实声明为  <code>const</code> ，修改它将导致未定义的行为。</p>\n<h5 id=\"示例不好-92\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-92\">#</a> 示例，不好</h5>\n<pre><code>void f(const int&amp; x)\n&#123;\n    const_cast&lt;int&amp;&gt;(x) = 42;   // 不好\n&#125;\n\nstatic int i = 0;\nstatic const int j = 0;\n\nf(i); // 暗藏的副作用\nf(j); // 未定义的行为\n</code></pre>\n<h5 id=\"示例-217\"><a class=\"markdownIt-Anchor\" href=\"#示例-217\">#</a> 示例</h5>\n<p>有时候，你可能倾向于借助  <code>const_cast</code>  来避免代码重复，比如两个访问函数仅在是否  <code>const</code>  上有区别而实现相似的情况。例如：</p>\n<pre><code>class Bar;\n\nclass Foo &#123;\npublic:\n    // 不好，逻辑重复\n    Bar&amp; get_bar()\n    &#123;\n        /* 获取 my_bar 的非 const 引用前后的复杂逻辑 */\n    &#125;\n\n    const Bar&amp; get_bar() const\n    &#123;\n        /* 获取 my_bar 的 const 引用前后的相同的复杂逻辑 */\n    &#125;\nprivate:\n    Bar my_bar;\n&#125;;\n</code></pre>\n<p>应当改为共享实现。通常可以直接让非  <code>const</code>  函数来调用  <code>const</code>  函数。不过当逻辑复杂的时候这可能会导致下面这样的模式，仍然需要借助于  <code>const_cast</code> ：</p>\n<pre><code>class Foo &#123;\npublic:\n    // 不大好，非 const 函数调用 const 版本但借助于 const_cast\n    Bar&amp; get_bar()\n    &#123;\n        return const_cast&lt;Bar&amp;&gt;(static_cast&lt;const Foo&amp;&gt;(*this).get_bar());\n    &#125;\n    const Bar&amp; get_bar() const\n    &#123;\n        /* 获取 my_bar 的 const 引用前后的复杂逻辑 */\n    &#125;\nprivate:\n    Bar my_bar;\n&#125;;\n</code></pre>\n<p>虽然这个模式如果恰当应用的话是安全的（因为调用方必然以一个非  <code>const</code>  对象来开始），但这并不理想，因为其安全性无法作为检查工具的规则而自动强制实施。</p>\n<p>换种方式，可以优先将公共代码放入一个公共辅助函数中，并将之作为模板以使其推断  <code>const</code> 。这完全不会用到  <code>const_cast</code> ：</p>\n<pre><code>class Foo &#123;\npublic:                         // 好\n          Bar&amp; get_bar()       &#123; return get_bar_impl(*this); &#125;\n    const Bar&amp; get_bar() const &#123; return get_bar_impl(*this); &#125;\nprivate:\n    Bar my_bar;\n\n    template&lt;class T&gt;           // 好，推断出 T 是 const 还是非 const\n    static auto&amp; get_bar_impl(T&amp; t)\n        &#123; /* 获取 my_bar 的可能为 const 的引用前后的复杂逻辑 */ &#125;\n&#125;;\n</code></pre>\n<p>注意：不要在模板中编写大型的非待决代码，因为它将导致代码爆炸。例如，进一步改进是当  <code>get_bar_impl</code>  的全部或部分代码是非待决代码时将之重构移出到一个公共的非模板函数中去，这可能会使代码大小显著变小。</p>\n<h5 id=\"例外-46\"><a class=\"markdownIt-Anchor\" href=\"#例外-46\">#</a> 例外</h5>\n<p>当调用  <code>const</code>  不正确的函数时，你可能需要强制掉  <code>const</code> 。<br>\n应当优先将这种函数包装到内联的  <code>const</code>  正确的包装函数中，以将强制转换封装到一处中。</p>\n<h5 id=\"示例-218\"><a class=\"markdownIt-Anchor\" href=\"#示例-218\">#</a> 示例</h5>\n<p>有时候，“强制掉  <code>const</code> ” 是为了允许对本来无法改动的对象中的某种临时性的信息进行更新操作。<br>\n其例子包括进行缓存，备忘，以及预先计算等。<br>\n这样的例子，通常可以通过使用  <code>mutable</code>  或者通过一层间接进行处理，而同使用  <code>const_cast</code>  一样甚或比之更好。</p>\n<p>考虑为昂贵操作将之前所计算的结果保留下来：</p>\n<pre><code>int compute(int x); // 为 x 计算一个值；假设这是昂贵的\n\nclass Cache &#123;   // 为 int-&gt;int 操作实现一种高速缓存的某个类型\npublic:\n    pair&lt;bool, int&gt; find(int x) const;   // 有针对 x 的值吗？\n    void set(int x, int v);             // 使 y 成为针对 x 的值\n    // ...\nprivate:\n    // ...\n&#125;;\n\nclass X &#123;\npublic:\n    int get_val(int x)\n    &#123;\n        auto p = cache.find(x);\n        if (p.first) return p.second;\n        int val = compute(x);\n        cache.set(x, val); // 插入针对 x 的值\n        return val;\n    &#125;\n    // ...\nprivate:\n    Cache cache;\n&#125;;\n</code></pre>\n<p>这里的  <code>get_val()</code>  逻辑上是个常量，因此我们想使其成为  <code>const</code>  成员。<br>\n为此我们仍然需要改动  <code>cache</code> ，因此人们有时候会求助于  <code>const_cast</code> ：</p>\n<pre><code>class X &#123;   // 基于强制转换的可疑的方案\npublic:\n    int get_val(int x) const\n    &#123;\n        auto p = cache.find(x);\n        if (p.first) return p.second;\n        int val = compute(x);\n        const_cast&lt;Cache&amp;&gt;(cache).set(x, val);   // 很难看\n        return val;\n    &#125;\n    // ...\nprivate:\n    Cache cache;\n&#125;;\n</code></pre>\n<p>幸运的是，有一种更好的方案：<br>\n将  <code>cache</code>  称为即便对于  <code>const</code>  对象来说也是可改变的：</p>\n<pre><code>class X &#123;   // 更好的方案\npublic:\n    int get_val(int x) const\n    &#123;\n        auto p = cache.find(x);\n        if (p.first) return p.second;\n        int val = compute(x);\n        cache.set(x, val);\n        return val;\n    &#125;\n    // ...\nprivate:\n    mutable Cache cache;\n&#125;;\n</code></pre>\n<p>另一种替代方案是存储指向  <code>cache</code>  的指针：</p>\n<pre><code>class X &#123;   // OK，但有点麻烦的方案\npublic:\n    int get_val(int x) const\n    &#123;\n        auto p = cache-&gt;find(x);\n        if (p.first) return p.second;\n        int val = compute(x);\n        cache-&gt;set(x, val);\n        return val;\n    &#125;\n    // ...\nprivate:\n    unique_ptr&lt;Cache&gt; cache;\n&#125;;\n</code></pre>\n<p>这个方案最灵活，但需要显式进行  <code>*cache</code>  的构造和销毁<br>\n（最可能发生于  <code>X</code>  的构造函数和析构函数中）。</p>\n<p>无论采用哪种形式，在多线程代码中都需要保护对  <code>cache</code>  的数据竞争，可能需要使用一个  <code>std::mutex</code> 。</p>\n<h5 id=\"强制实施-226\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-226\">#</a> 强制实施</h5>\n<ul>\n<li>标记  <code>const_cast</code> 。</li>\n<li>本条规则属于<a href=\"#Pro-type-constcast\">类型安全性剖面配置</a>。</li>\n</ul>\n<h3 id=\"a-nameres-range-checkingaes55-避免发生对范围检查的需要\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-range-checkingaes55-避免发生对范围检查的需要\">#</a> <a name=\"Res-range-checking\"></a>ES.55: 避免发生对范围检查的需要</h3>\n<h5 id=\"理由-236\"><a class=\"markdownIt-Anchor\" href=\"#理由-236\">#</a> 理由</h5>\n<p>无法溢出的构造时不会溢出的（而且通常运行得更快）：</p>\n<h5 id=\"示例-219\"><a class=\"markdownIt-Anchor\" href=\"#示例-219\">#</a> 示例</h5>\n<pre><code>for (auto&amp; x : v)      // 打印 v 的所有元素\n    cout &lt;&lt; x &lt;&lt; '\\n';\n\nauto p = find(v, x);   // 在 v 中寻找 x\n</code></pre>\n<h5 id=\"强制实施-227\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-227\">#</a> 强制实施</h5>\n<p>查找显式的范围检查，并启发式地给出替代方案建议。</p>\n<h3 id=\"a-nameres-moveaes56-仅在确实需要明确移动某个对象到别的作用域时才使用-stdmove\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-moveaes56-仅在确实需要明确移动某个对象到别的作用域时才使用-stdmove\">#</a> <a name=\"Res-move\"></a>ES.56: 仅在确实需要明确移动某个对象到别的作用域时才使用  <code>std::move()</code></h3>\n<h5 id=\"理由-237\"><a class=\"markdownIt-Anchor\" href=\"#理由-237\">#</a> 理由</h5>\n<p>我们用移动而不是复制，以避免发生重复并提升性能。</p>\n<p>一次移动通常会遗留一个空对象（<a href=\"#Rc-move-semantic\">C.64</a>），这可能令人意外甚至很危险，因此我们试图避免从左值进行移动（它们可能随后会被访问到）。</p>\n<h5 id=\"注解-217\"><a class=\"markdownIt-Anchor\" href=\"#注解-217\">#</a> 注解</h5>\n<p>当来源是右值（比如  <code>return</code>  的值或者函数的结果）时就会隐式地进行移动，因此请不要在这些情况下明确写下  <code>move</code>  而无意义地使代码复杂化。可以代之以编写简短的返回值的函数，这样的话无论是函数的返回还是调用方的返回值接收，都会很自然地得到优化。</p>\n<p>一般来说，遵循本文档中的指导方针（包括不要让变量的作用域无必要地变大，编写返回值的简短函数，返回局部变量等），有助于消除大多数对显式使用  <code>std::move</code>  的需要。</p>\n<p>显式的  <code>move</code>  需要用于把某个对象明确移动到另一个作用域，尤其是将其传递给某个 “接收器” 函数，以及移动操作自身（移动构造函数，移动赋值运算符）和交换（ <code>swap</code> ）操作的实现之中。</p>\n<h5 id=\"示例不好-93\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-93\">#</a> 示例，不好</h5>\n<pre><code>void sink(X&amp;&amp; x);   // sink 接收 x 的所有权\n\nvoid user()\n&#123;\n    X x;\n    // 错误: 无法将作者绑定到右值引用\n    sink(x);\n    // OK: sink 接收了 x 的内容，x 随即必须假定为空\n    sink(std::move(x));\n\n    // ...\n\n    // 可能是个错误\n    use(x);\n&#125;\n</code></pre>\n<p>通常来说， <code>std::move()</code>  都用做某个  <code>&amp;&amp;</code>  形参的实参。<br>\n而这点之后，应当假定对象已经被移走（参见 <a href=\"#Rc-move-semantic\">C.64</a>），而直到首次向它设置某个新值之前，请勿再次读取它的状态。</p>\n<pre><code>void f()\n&#123;\n    string s1 = &quot;supercalifragilisticexpialidocious&quot;;\n\n    string s2 = s1;             // ok, 接收了一个副本\n    assert(s1 == &quot;supercalifragilisticexpialidocious&quot;);  // ok\n\n    // 不好, 如果你打算保留 s1 的值的话\n    string s3 = move(s1);\n\n    // 不好, assert 很可能会失败, s1 很可能被改动了\n    assert(s1 == &quot;supercalifragilisticexpialidocious&quot;);\n&#125;\n</code></pre>\n<h5 id=\"示例-220\"><a class=\"markdownIt-Anchor\" href=\"#示例-220\">#</a> 示例</h5>\n<pre><code>void sink(unique_ptr&lt;widget&gt; p);  // 将 p 的所有权传递给 sink()\n\nvoid f()\n&#123;\n    auto w = make_unique&lt;widget&gt;();\n    // ...\n    sink(std::move(w));               // ok, 交给 sink()\n    // ...\n    sink(w);    // 错误: unique_ptr 经过严格设计，你无法复制它\n&#125;\n</code></pre>\n<h5 id=\"注解-218\"><a class=\"markdownIt-Anchor\" href=\"#注解-218\">#</a> 注解</h5>\n<p><code>std::move()</code>  经过伪装的向  <code>&amp;&amp;</code>  的强制转换；其自身并不会移动任何东西，但会把具名的对象标记为可被移动的候选者。<br>\n语言中已经了解了对象可以被移动的一般情况，尤其是从函数返回时，因此请不要用多余的  <code>std::move()</code>  使代码复杂化。</p>\n<p>绝不要仅仅因为听说过 “这样更加高效” 就使用  <code>std::move()</code> 。<br>\n通常来说，请不要相信那些没有支持数据的有关 “效率” 的断言。(???).<br>\n 通常来说，请不要无理由地使代码复杂化。(??)<br>\n 绝不要在 const 对象上  <code>std::move()</code> ，它只会暗中将其转变成一个副本（参见 <a href=\"#Meyers15\">Meyers15</a> 的条款 23)。</p>\n<h5 id=\"示例不好-94\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-94\">#</a> 示例，不好</h5>\n<pre><code>vector&lt;int&gt; make_vector()\n&#123;\n    vector&lt;int&gt; result;\n    // ... 加载 result 的数据\n    return std::move(result);       // 不好; 直接写 &quot;return result;&quot; 即可\n&#125;\n</code></pre>\n<p>绝不要写  <code>return move(local_variable);</code> ，这是因为语言已经知道这个变量是移动的候选了。<br>\n在这段代码中用  <code>move</code>  并不会带来帮助，而且可能实际上是有害的，因为它创建了局部变量的一个额外引用别名，而在某些编译器中这回对 RVO（返回值优化）造成影响。</p>\n<h5 id=\"示例不好-95\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-95\">#</a> 示例，不好</h5>\n<pre><code>vector&lt;int&gt; v = std::move(make_vector());   // 不好; 这个 std::move 完全是多余的\n</code></pre>\n<p>绝不在返回值上使用  <code>move</code> ，如  <code>x = move(f());</code> ，其中的  <code>f</code>  按值返回。<br>\n语言已经知道返回值是临时对象而且可以被移动。</p>\n<h5 id=\"示例-221\"><a class=\"markdownIt-Anchor\" href=\"#示例-221\">#</a> 示例</h5>\n<pre><code>void mover(X&amp;&amp; x)\n&#123;\n    call_something(std::move(x));         // ok\n    call_something(std::forward&lt;X&gt;(x));   // 不好, 请勿对右值引用 std::forward\n    call_something(x);                    // 可疑  为什么不用std:: move?\n&#125;\n\ntemplate&lt;class T&gt;\nvoid forwarder(T&amp;&amp; t)\n&#123;\n    call_something(std::move(t));         // 不好, 请勿对转发引用 std::move\n    call_something(std::forward&lt;T&gt;(t));   // ok\n    call_something(t);                    // 可疑, 为什么不用 std::forward?\n&#125;\n</code></pre>\n<h5 id=\"强制实施-228\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-228\">#</a> 强制实施</h5>\n<ul>\n<li>对于  <code>std::move(x)</code>  的使用，当  <code>x</code>  是右值，或者语言已经将其当做右值，这包括  <code>return std::move(local_variable);</code>  以及在按值返回的函数上的  <code>std::move(f())</code> ，进行标记</li>\n<li>当没有接受  <code>const S&amp;</code>  的函数重载来处理左值时，对接受  <code>S&amp;&amp;</code>  参数的函数进行标记。</li>\n<li>若实参经过  <code>std::move</code>  传递给形参则进行标记，除非形参的类型为右值引用  <code>X&amp;&amp;</code> ，或者类型是只能移动的而该形参为按值传递。</li>\n<li>当对转发引用（ <code>T&amp;&amp;</code>  其中  <code>T</code>  为模板参数类型）使用  <code>std::move</code>  时进行标记。应当代之以使用  <code>std::forward</code> 。</li>\n<li>当对并非非 const 右值引用的变量使用  <code>std::move</code>  时进行标记。（这是前一条规则的更一般的情况，以覆盖非转发的情况。）</li>\n<li>当对右值引用（ <code>X&amp;&amp;</code>  其中  <code>X</code>  为非模板形参类型）使用  <code>std::forward</code>  时进行标记。应当代之以使用  <code>std::move</code> 。</li>\n<li>当对并非转发引用使用  <code>std::forward</code>  时进行标记。（这是前一条规则的更一般的情况，以覆盖非移动的情况。）</li>\n<li>如果对象潜在地被移动走之后的下一个操作是  <code>const</code>  操作的话，则进行标记；首先应当交错进行一个非  <code>const</code>  操作，最好是赋值，以首先对对象的值进行重置。</li>\n</ul>\n<h3 id=\"a-nameres-newaes60-避免在资源管理函数之外使用-new-和-delete\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-newaes60-避免在资源管理函数之外使用-new-和-delete\">#</a> <a name=\"Res-new\"></a>ES.60: 避免在资源管理函数之外使用  <code>new</code>  和  <code>delete</code></h3>\n<h5 id=\"理由-238\"><a class=\"markdownIt-Anchor\" href=\"#理由-238\">#</a> 理由</h5>\n<p>应用程序代码中的直接资源管理既易错又麻烦。</p>\n<h5 id=\"注解-219\"><a class=\"markdownIt-Anchor\" href=\"#注解-219\">#</a> 注解</h5>\n<p>通常也被称为 “禁止裸  <code>new</code> ！” 规则。</p>\n<h5 id=\"示例不好-96\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-96\">#</a> 示例，不好</h5>\n<pre><code>void f(int n)\n&#123;\n    auto p = new X[n];   // n 个默认构造的 X\n    // ...\n    delete[] p;\n&#125;\n</code></pre>\n<p><code>...</code>  部分中的代码可能导致  <code>delete</code>  永远不会发生。</p>\n<p><strong>参见</strong>: <a href=\"#S-resource\">R: 资源管理</a></p>\n<h5 id=\"强制实施-229\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-229\">#</a> 强制实施</h5>\n<p>对裸的  <code>new</code>  和裸的  <code>delete</code>  进行标记。</p>\n<h3 id=\"a-nameres-delaes61-用-delete-删除数组用-delete-删除非数组对象\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-delaes61-用-delete-删除数组用-delete-删除非数组对象\">#</a> <a name=\"Res-del\"></a>ES.61: 用  <code>delete[]</code>  删除数组，用  <code>delete</code>  删除非数组对象</h3>\n<h5 id=\"理由-239\"><a class=\"markdownIt-Anchor\" href=\"#理由-239\">#</a> 理由</h5>\n<p>这正是语言的要求，而且所犯的错误将导致资源释放的错误以及内存破坏。</p>\n<h5 id=\"示例不好-97\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-97\">#</a> 示例，不好</h5>\n<pre><code>void f(int n)\n&#123;\n    auto p = new X[n];   // n 个默认初始化的 X\n    // ...\n    delete p;   // 错误: 仅仅删除了对象 p，而并未删除数组 p[]\n&#125;\n</code></pre>\n<h5 id=\"注解-220\"><a class=\"markdownIt-Anchor\" href=\"#注解-220\">#</a> 注解</h5>\n<p>这个例子不仅像上前一个例子一样违反了<a href=\"#Res-new\">禁止裸  <code>new</code>  规则</a>，它还有更多的问题。</p>\n<h5 id=\"强制实施-230\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-230\">#</a> 强制实施</h5>\n<ul>\n<li>如果  <code>new</code>  和  <code>delete</code>  在同一个作用域中的话，就可以标记出现错误。</li>\n<li>如果  <code>new</code>  和  <code>delete</code>  出现在构造函数 / 析构函数对之中的话，就可以标记出现错误。</li>\n</ul>\n<h3 id=\"a-nameres-arr2aes62-不要在不同的数组之间进行指针比较\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-arr2aes62-不要在不同的数组之间进行指针比较\">#</a> <a name=\"Res-arr2\"></a>ES.62: 不要在不同的数组之间进行指针比较</h3>\n<h5 id=\"理由-240\"><a class=\"markdownIt-Anchor\" href=\"#理由-240\">#</a> 理由</h5>\n<p>这样做的结果是未定义的。</p>\n<h5 id=\"示例不好-98\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-98\">#</a> 示例，不好</h5>\n<pre><code>void f()\n&#123;\n    int a1[7];\n    int a2[9];\n    if (&amp;a1[5] &lt; &amp;a2[7]) &#123;&#125;       // 不好: 未定义\n    if (0 &lt; &amp;a1[5] - &amp;a2[7]) &#123;&#125;   // 不好: 未定义\n&#125;\n</code></pre>\n<h5 id=\"注解-221\"><a class=\"markdownIt-Anchor\" href=\"#注解-221\">#</a> 注解</h5>\n<p>这个例子中有许多问题。</p>\n<h5 id=\"强制实施-231\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-231\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-nameres-sliceaes63-不要产生切片\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-sliceaes63-不要产生切片\">#</a> <a name=\"Res-slice\"></a>ES.63: 不要产生切片</h3>\n<h5 id=\"理由-241\"><a class=\"markdownIt-Anchor\" href=\"#理由-241\">#</a> 理由</h5>\n<p>切片 —— 亦即使用赋值或初始化而只对对象的一部分进行复制 —— 通常会导致错误，<br>\n这是因为对象总是被当成是一个整体。<br>\n在罕见的进行蓄意的切片的代码中，其代码会让人意外。</p>\n<h5 id=\"示例-222\"><a class=\"markdownIt-Anchor\" href=\"#示例-222\">#</a> 示例</h5>\n<pre><code>class Shape &#123; /* ... */ &#125;;\nclass Circle : public Shape &#123; /* ... */ Point c; int r; &#125;;\n\nCircle c &#123;&#123; \"&#123;&#123;\" &#125;&#125;0, 0&#125;, 42&#125;;\nShape s &#123;c&#125;;    // 仅复制构造了 Circle 中的 Shape 部分\ns = c;          // 仅复制赋值了 Circle 中的 Shape 部分\n\nvoid assign(const Shape&amp; src, Shape&amp; dest)\n&#123;\n    dest = src;\n&#125;\nCircle c2 &#123;&#123; \"&#123;&#123;\" &#125;&#125;1, 1&#125;, 43&#125;;\nassign(c, c2);   // 噢，传递的并不是整个状态\nassert(c == c2); // 如果提供复制操作，就也得提供比较操作，\n                 //   但这里很可能返回 false\n</code></pre>\n<p>这样的结果是无意义的，因为不会把中心和半径从  <code>c</code>  复制给  <code>s</code> 。<br>\n针对这个的第一条防线是<a href=\"#Rc-copy-virtual\">将基类  <code>Shape</code>  定义为不允许这样做</a>。</p>\n<h5 id=\"替代方案-11\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-11\">#</a> 替代方案</h5>\n<p>如果确实需要切片的话，应当为之定义一个明确的操作。<br>\n这会避免读者产生混乱。<br>\n例如：</p>\n<pre><code>class Smiley : public Circle &#123;\n    public:\n    Circle copy_circle();\n    // ...\n&#125;;\n\nSmiley sm &#123; /* ... */ &#125;;\n</code></pre>\n<p>Circle c1 {sm};  // 理想情况下由 Circle 的定义所禁止<br>\n Circle c2 {sm.copy_circle ()};</p>\n<h5 id=\"强制实施-232\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-232\">#</a> 强制实施</h5>\n<p>针对切片给出警告。</p>\n<h3 id=\"a-nameres-constructaes64-使用-te-写法来进行构造\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-constructaes64-使用-te-写法来进行构造\">#</a> <a name=\"Res-construct\"></a>ES.64: 使用  <code>T&#123;e&#125;</code>  写法来进行构造</h3>\n<h5 id=\"理由-242\"><a class=\"markdownIt-Anchor\" href=\"#理由-242\">#</a> 理由</h5>\n<p>对象构造语法  <code>T&#123;e&#125;</code>  明确了所需进行的构造。<br>\n对象构造语法  <code>T&#123;e&#125;</code>  不允许发生窄化。<br>\n <code>T&#123;e&#125;</code>  是唯一安全且通用的由表达式  <code>e</code>  构造一个  <code>T</code>  类型的值的表达式。<br>\n强制转换的写法  <code>T(e)</code>  和  <code>(T)e</code>  既不安全也不通用。</p>\n<h5 id=\"示例-223\"><a class=\"markdownIt-Anchor\" href=\"#示例-223\">#</a> 示例</h5>\n<p>对于内建类型，构造的写法保护了不发生窄化和重解释</p>\n<pre><code>void use(char ch, int i, double d, char* p, long long lng)\n&#123;\n    int x1 = int&#123;ch&#125;;     // OK，但多余\n    int x2 = int&#123;d&#125;;      // 错误：double-&gt;int 窄化；如果需要的话应使用强制转换\n    int x3 = int&#123;p&#125;;      // 错误：指针-&gt;int；如果确实需要的话应使用 reinterpret_cast\n    int x4 = int&#123;lng&#125;;    // 错误：long long-&gt;int 窄化；如果需要的话应使用强制转换\n\n    int y1 = int(ch);     // OK，但多余\n    int y2 = int(d);      // 不好：double-&gt;int 窄化；如果需要的话应使用强制转换\n    int y3 = int(p);      // 不好：指针-&gt;int；如果确实需要的话应使用 reinterpret_cast\n    int y4 = int(lng);    // 不好：long long-&gt;int 窄化；如果需要的话应使用强制转换\n\n    int z1 = (int)ch;     // OK，但多余\n    int z2 = (int)d;      // 不好：double-&gt;int 窄化；如果需要的话应使用强制转换\n    int z3 = (int)p;      // 不好：指针-&gt;int；如果确实需要的话应使用 reinterpret_cast\n    int z4 = (int)lng;    // 不好：long long-&gt;int 窄化；如果需要的话应使用强制转换\n&#125;\n</code></pre>\n<p>整数和指针之间的转换，在使用  <code>T(e)</code>  和  <code>(T)e</code>  时是由实现定义的，<br>\n而且在不同整数和指针大小的平台之间不可移植。</p>\n<h5 id=\"注解-222\"><a class=\"markdownIt-Anchor\" href=\"#注解-222\">#</a> 注解</h5>\n<p><a href=\"#Res-casts\">避免强制转换</a>（显式类型转换），如果必须要做的话<a href=\"#Res-casts-named\">优先采用具名强制转换</a>。</p>\n<h5 id=\"注解-223\"><a class=\"markdownIt-Anchor\" href=\"#注解-223\">#</a> 注解</h5>\n<p>当没有歧义时，可以不写  <code>T&#123;e&#125;</code>  中的  <code>T</code> 。</p>\n<pre><code>complex&lt;double&gt; f(complex&lt;double&gt;);\n\nauto z = f(&#123;2*pi,1&#125;);\n</code></pre>\n<h5 id=\"注解-224\"><a class=\"markdownIt-Anchor\" href=\"#注解-224\">#</a> 注解</h5>\n<p>对象构造语法是最通用的<a href=\"#Res-list\">初始化式语法</a>。</p>\n<h5 id=\"例外-47\"><a class=\"markdownIt-Anchor\" href=\"#例外-47\">#</a> 例外</h5>\n<p><code>std::vector</code>  和其他的容器是在  <code>&#123;&#125;</code>  作为对象构造语法之前定义的。<br>\n考虑：</p>\n<pre><code>vector&lt;string&gt; vs &#123;10&#125;;                           // 十个空字符串\nvector&lt;int&gt; vi1 &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;  // 十个元素 1..10\nvector&lt;int&gt; vi2 &#123;10&#125;;                             // 一个值为 10 的元素\n</code></pre>\n<p>如何得到包含十个默认初始化的  <code>int</code>  的  <code>vector</code> ？</p>\n<pre><code>vector&lt;int&gt; v3(10); // 十个值为 0 的元素\n</code></pre>\n<p>使用  <code>()</code>  而不是  <code>&#123;&#125;</code>  作为元素数量是一种约定（源于 1980 年代早期），很难改变，<br>\n但仍然是一个设计错误：对于元素类型与元素数量可能发生混淆的容器，必须解决<br>\n其中的歧义。<br>\n约定的方案是将  <code>&#123;10&#125;</code>  解释为单个元素的列表，而用  <code>(10)</code>  来指定大小。</p>\n<p>不应当在新代码中重复这个错误。<br>\n可以定义一个类型来表示元素的数量：</p>\n<pre><code>struct Count &#123; int n; &#125;;\n\ntemplate&lt;typename T&gt;\nclass Vector &#123;\npublic:\n    Vector(Count n);                     // n 个默认构造的元素\n    Vector(initializer_list&lt;T&gt; init);    // init.size() 个元素\n    // ...\n&#125;;\n\nVector&lt;int&gt; v1&#123;10&#125;;\nVector&lt;int&gt; v2&#123;Count&#123;10&#125;&#125;;\nVector&lt;Count&gt; v3&#123;Count&#123;10&#125;&#125;;    // 这里仍有一个很小的问题\n</code></pre>\n<p>剩下的主要问题就是为  <code>Count</code>  找个合适的名字了。</p>\n<h5 id=\"强制实施-233\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-233\">#</a> 强制实施</h5>\n<p>标记 C 风格的  <code>(T)e</code>  和函数式风格的  <code>T(e)</code>  强制转换。</p>\n<h3 id=\"a-nameres-derefaes65-不要解引用无效指针\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-derefaes65-不要解引用无效指针\">#</a> <a name=\"Res-deref\"></a>ES.65: 不要解引用无效指针</h3>\n<h5 id=\"理由-243\"><a class=\"markdownIt-Anchor\" href=\"#理由-243\">#</a> 理由</h5>\n<p>解引用如  <code>nullptr</code>  这样的无效指针是未定义的行为，通常会导致程序立刻崩溃，<br>\n产生错误结果，或者内存被损坏。</p>\n<h5 id=\"注解-225\"><a class=\"markdownIt-Anchor\" href=\"#注解-225\">#</a> 注解</h5>\n<p>本条规则是显然并且广为知晓的语言规则，但其可能难于遵守。<br>\n这需要良好的编码风格，程序库支持，以及静态分析来消除违反情况而不耗费大量开销。<br>\n这正是 <a href=\"#Stroustrup15\">C++ 的类型和资源安全性模型</a>中所讨论的主要部分。</p>\n<p><strong>参见</strong>：</p>\n<ul>\n<li>使用 <a href=\"#Rr-raii\">RAII</a> 以避免生存期问题。</li>\n<li>使用 <a href=\"#Rf-unique_ptr\">unique_ptr</a> 以避免生存期问题。</li>\n<li>使用 <a href=\"#Rf-shared_ptr\">shared_ptr</a> 以避免生存期问题。</li>\n<li>当不可能出现  <code>nullptr</code>  时应使用<a href=\"#Rf-ptr-ref\">引用</a>。</li>\n<li>使用 <a href=\"#Rf-nullptr\">not_null</a> 以尽早捕捉到预期外的  <code>nullptr</code> 。</li>\n<li>使用<a href=\"#SS-bounds\">边界剖面配置</a>以避免范围错误。</li>\n</ul>\n<h5 id=\"示例-224\"><a class=\"markdownIt-Anchor\" href=\"#示例-224\">#</a> 示例</h5>\n<pre><code>void f()\n&#123;\n    int x = 0;\n    int* p = &amp;x;\n\n    if (condition()) &#123;\n        int y = 0;\n        p = &amp;y;\n    &#125; // p 失效\n\n    *p = 42;            // 不好，若走了上面的分支则 p 无效\n&#125;\n</code></pre>\n<p>为解决这个问题，要么应当扩展指针打算指代的这个对象的生存期，要么应当缩短指针的生存期（将解引用移动到所指代的对象生存期结束之前进行）。</p>\n<pre><code>void f1()\n&#123;\n    int x = 0;\n    int* p = &amp;x;\n\n    int y = 0;\n    if (condition()) &#123;\n        p = &amp;y;\n    &#125;\n\n    *p = 42;            // OK，p 可指向 x 或 y，而它们都仍在作用域中\n&#125;\n</code></pre>\n<p>不幸的是，大多数无效指针问题都更加难于定位且更加难于解决。</p>\n<h5 id=\"示例-225\"><a class=\"markdownIt-Anchor\" href=\"#示例-225\">#</a> 示例</h5>\n<pre><code>void f(int* p)\n&#123;\n    int x = *p; // 不好：如何确定 p 是否有效？\n&#125;\n</code></pre>\n<p>有大量的这种代码存在。<br>\n它们大多数都能工作（经过了大量的测试），但其各自是很难确定  <code>p</code>  是否可能为  <code>nullptr</code>  的。<br>\n后果就是，这同样是错误的一大来源。<br>\n有许多方案试图解决这个潜在问题：</p>\n<pre><code>void f1(int* p) // 处理 nullptr\n&#123;\n    if (!p) &#123;\n        // 处理 nullptr（分配，返回，抛出，使 p 指向什么，等等\n    &#125;\n    int x = *p;\n&#125;\n</code></pre>\n<p>测试  <code>nullptr</code>  的做法有两个潜在的问题：</p>\n<ul>\n<li>当遇到  <code>nullptr</code>  时应当做什么并不总是明确的</li>\n<li>其测试可能多余并且相对比较昂贵</li>\n<li>这个测试是为了保护某种违例还是所需逻辑的一部分并不明显</li>\n</ul>\n<!-- comment needed for code block after list -->\n<pre><code>void f2(int* p) // 声称 p 不应当为 nullptr\n&#123;\n    Assert(p);\n    int x = *p;\n&#125;\n</code></pre>\n<p>这样，仅当打开了断言检查时才会有所耗费，而且会向编译器 / 分析器提供有用的信息。<br>\n当 C++ 出现契约的直接支持后，还可以做的更好：</p>\n<pre><code>void f3(int* p) // 声称 p 不应当为 nullptr\n    [[expects: p]]\n&#123;\n    int x = *p;\n&#125;\n</code></pre>\n<p>或者，还可以使用  <code>gsl::not_null</code>  来保证  <code>p</code>  不为  <code>nullptr</code> 。</p>\n<pre><code>void f(not_null&lt;int*&gt; p)\n&#123;\n    int x = *p;\n&#125;\n</code></pre>\n<p>这些只是关于  <code>nullptr</code>  的处理办法。<br>\n要知道还有其他出现无效指针的方式。</p>\n<h5 id=\"示例-226\"><a class=\"markdownIt-Anchor\" href=\"#示例-226\">#</a> 示例</h5>\n<pre><code>void f(int* p)  // 老代码，没使用 owner\n&#123;\n    delete p;\n&#125;\n\nvoid g()        // 老代码：使用了裸 new\n&#123;\n    auto q = new int&#123;7&#125;;\n    f(q);\n    int x = *q; // 不好：解引用了无效指针\n&#125;\n</code></pre>\n<h5 id=\"示例-227\"><a class=\"markdownIt-Anchor\" href=\"#示例-227\">#</a> 示例</h5>\n<pre><code>void f()\n&#123;\n    vector&lt;int&gt; v(10);\n    int* p = &amp;v[5];\n    v.push_back(99); // 可能重新分配 v 中的元素\n    int x = *p; // 不好：解引用了潜在的无效指针\n&#125;\n</code></pre>\n<h5 id=\"强制实施-234\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-234\">#</a> 强制实施</h5>\n<p>本条规则属于<a href=\"#SS-lifetime\">生存期安全性剖面配置</a></p>\n<ul>\n<li>当对指向已经超出作用域的对象的指针进行解引用时进行标记</li>\n<li>当对可能已经通过赋值  <code>nullptr</code>  而无效的指针进行解引用时进行标记</li>\n<li>当对可能已经因  <code>delete</code>  而无效的指针进行解引用时进行标记</li>\n<li>当对指向可能已经失效的容器元素的指针进行解引用时进行标记</li>\n</ul>\n<h2 id=\"esstmt-语句\"><a class=\"markdownIt-Anchor\" href=\"#esstmt-语句\">#</a> ES.stmt: 语句</h2>\n<p>语句控制了控制的流向（除了函数调用和异常抛出，它们是表达式）。</p>\n<h3 id=\"a-nameres-switch-ifaes70-面临选择时优先采用-switch-语句而不是-if-语句\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-switch-ifaes70-面临选择时优先采用-switch-语句而不是-if-语句\">#</a> <a name=\"Res-switch-if\"></a>ES.70: 面临选择时，优先采用  <code>switch</code>  语句而不是  <code>if</code>  语句</h3>\n<h5 id=\"理由-244\"><a class=\"markdownIt-Anchor\" href=\"#理由-244\">#</a> 理由</h5>\n<ul>\n<li>可读性。</li>\n<li>效率： <code>switch</code>  与常量进行比较，且通常比一个  <code>if</code> - <code>then</code> - <code>else</code>  链中的一系列测试获得更好的优化。</li>\n<li><code>switch</code>  可以启用某种启发式的一致性检查。例如，是否某个  <code>enum</code>  的所有值都被覆盖了？如果没有的话，是否存在  <code>default</code> ？</li>\n</ul>\n<h5 id=\"示例-228\"><a class=\"markdownIt-Anchor\" href=\"#示例-228\">#</a> 示例</h5>\n<pre><code>void use(int n)\n&#123;\n    switch (n) &#123;   // 好\n    case 0:\n        // ...\n        break;\n    case 7:\n        // ...\n        break;\n    default:\n        // ...\n        break;\n    &#125;\n&#125;\n</code></pre>\n<p>要好于：</p>\n<pre><code>void use2(int n)\n&#123;\n    if (n == 0)   // 不好：以 if-then-else 链和一组常量进行比较\n        // ...\n    else if (n == 7)\n        // ...\n&#125;\n</code></pre>\n<h5 id=\"强制实施-235\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-235\">#</a> 强制实施</h5>\n<p>对以  <code>if</code> - <code>then</code> - <code>else</code>  链条（仅）和常量进行比较的情况进行标记。</p>\n<h3 id=\"a-nameres-for-rangeaes71-面临选择时优先采用范围式-for-语句而不是普通-for-语句\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-for-rangeaes71-面临选择时优先采用范围式-for-语句而不是普通-for-语句\">#</a> <a name=\"Res-for-range\"></a>ES.71: 面临选择时，优先采用范围式  <code>for</code>  语句而不是普通  <code>for</code>  语句</h3>\n<h5 id=\"理由-245\"><a class=\"markdownIt-Anchor\" href=\"#理由-245\">#</a> 理由</h5>\n<p>可读性。避免错误。效率。</p>\n<h5 id=\"示例-229\"><a class=\"markdownIt-Anchor\" href=\"#示例-229\">#</a> 示例</h5>\n<pre><code>for (gsl::index i = 0; i &lt; v.size(); ++i)   // 不好\n    cout &lt;&lt; v[i] &lt;&lt; '\\n';\n\nfor (auto p = v.begin(); p != v.end(); ++p)   // 不好\n    cout &lt;&lt; *p &lt;&lt; '\\n';\n\nfor (auto&amp; x : v)    // OK\n    cout &lt;&lt; x &lt;&lt; '\\n';\n\nfor (gsl::index i = 1; i &lt; v.size(); ++i) // 接触了两个元素：无法作为范围式的 for\n    cout &lt;&lt; v[i] + v[i - 1] &lt;&lt; '\\n';\n\nfor (gsl::index i = 0; i &lt; v.size(); ++i) // 可能具有副作用：无法作为范围式的 for\n    cout &lt;&lt; f(v, &amp;v[i]) &lt;&lt; '\\n';\n\nfor (gsl::index i = 0; i &lt; v.size(); ++i) &#123; // 循环体中混入了循环变量：无法作为范围式 for\n    if (i % 2 != 0)\n        cout &lt;&lt; v[i] &lt;&lt; '\\n'; // 输出奇数元素\n&#125;\n</code></pre>\n<p>人类或优良的静态分析器也许可以确定，其实在  <code>f(v, &amp;v[i])</code>  中的  <code>v</code>  的上并不真的存在副作用，因此这个循环可以被重写。</p>\n<p>在循环体中 “混入循环变量” 的情况通常是最好进行避免的。</p>\n<h5 id=\"注解-226\"><a class=\"markdownIt-Anchor\" href=\"#注解-226\">#</a> 注解</h5>\n<p>不要在范围式  <code>for</code>  循环中使用昂贵的循环变量副本：</p>\n<pre><code>for (string s : vs) // ...\n</code></pre>\n<p>这将会对  <code>vs</code>  中的每个元素复制给  <code>s</code> 。这样好一点：</p>\n<pre><code>for (string&amp; s : vs) // ...\n</code></pre>\n<p>更好的做法是，当循环变量不会被修改或复制时：</p>\n<pre><code>for (const string&amp; s : vs) // ...\n</code></pre>\n<h5 id=\"强制实施-236\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-236\">#</a> 强制实施</h5>\n<p>查看循环，如果一个传统的循环仅会查看序列中的各个元素，而且其对这些元素所做的事中没有发生副作用，则将该循环重写为范围式的  <code>for</code>  循环。</p>\n<h3 id=\"a-nameres-for-whileaes72-当存在显然的循环变量时优先采用-for-语句而不是-while-语句\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-for-whileaes72-当存在显然的循环变量时优先采用-for-语句而不是-while-语句\">#</a> <a name=\"Res-for-while\"></a>ES.72: 当存在显然的循环变量时，优先采用  <code>for</code>  语句而不是  <code>while</code>  语句</h3>\n<h5 id=\"理由-246\"><a class=\"markdownIt-Anchor\" href=\"#理由-246\">#</a> 理由</h5>\n<p>可读性：循环的全部逻辑都 “直观可见”。循环变量的作用域是有限的。</p>\n<h5 id=\"示例-230\"><a class=\"markdownIt-Anchor\" href=\"#示例-230\">#</a> 示例</h5>\n<pre><code>for (gsl::index i = 0; i &lt; vec.size(); i++) &#123;\n    // 干活\n&#125;\n</code></pre>\n<h5 id=\"示例不好-99\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-99\">#</a> 示例，不好</h5>\n<pre><code>int i = 0;\nwhile (i &lt; vec.size()) &#123;\n    // 干活\n    i++;\n&#125;\n</code></pre>\n<h5 id=\"强制实施-237\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-237\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-nameres-while-foraes73-当没有显然的循环变量时优先采用-while-语句而不是-for-语句\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-while-foraes73-当没有显然的循环变量时优先采用-while-语句而不是-for-语句\">#</a> <a name=\"Res-while-for\"></a>ES.73: 当没有显然的循环变量时，优先采用  <code>while</code>  语句而不是  <code>for</code>  语句</h3>\n<h5 id=\"理由-247\"><a class=\"markdownIt-Anchor\" href=\"#理由-247\">#</a> 理由</h5>\n<p>可读性。</p>\n<h5 id=\"示例-231\"><a class=\"markdownIt-Anchor\" href=\"#示例-231\">#</a> 示例</h5>\n<pre><code>int events = 0;\nfor (; wait_for_event(); ++events) &#123;  // 不好，含糊\n    // ...\n&#125;\n</code></pre>\n<p>这个 “事件循环” 会误导人，计数器  <code>events</code>  跟循环条件（ <code>wait_for_event()</code> ）并没有任何关系。<br>\n更好的做法是</p>\n<pre><code>int events = 0;\nwhile (wait_for_event()) &#123;      // 更好\n    ++events;\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"强制实施-238\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-238\">#</a> 强制实施</h5>\n<p>对和  <code>for</code>  的条件不相关的  <code>for</code>  初始化式和  <code>for</code>  增量部分进行标记。</p>\n<h3 id=\"a-nameres-for-initaes74-优先在-for-语句的初始化部分中声明循环变量\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-for-initaes74-优先在-for-语句的初始化部分中声明循环变量\">#</a> <a name=\"Res-for-init\"></a>ES.74: 优先在  <code>for</code>  语句的初始化部分中声明循环变量</h3>\n<p>参见 <a href=\"#Res-cond\">ES.6</a></p>\n<h3 id=\"a-nameres-doaes75-避免使用-do-语句\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-doaes75-避免使用-do-语句\">#</a> <a name=\"Res-do\"></a>ES.75: 避免使用  <code>do</code>  语句</h3>\n<h5 id=\"理由-248\"><a class=\"markdownIt-Anchor\" href=\"#理由-248\">#</a> 理由</h5>\n<p>可读性，避免错误。<br>\n其终止条件处于尾部（而这可能会被忽略），且其条件不会在第一时间进行检查。</p>\n<h5 id=\"示例-232\"><a class=\"markdownIt-Anchor\" href=\"#示例-232\">#</a> 示例</h5>\n<pre><code>int x;\ndo &#123;\n    cin &gt;&gt; x;\n    // ...\n&#125; while (x &lt; 0);\n</code></pre>\n<h5 id=\"注解-227\"><a class=\"markdownIt-Anchor\" href=\"#注解-227\">#</a> 注解</h5>\n<p>确实有一些天才的例子中， <code>do</code>  语句是更简洁的方案，但有问题的更多。</p>\n<h5 id=\"强制实施-239\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-239\">#</a> 强制实施</h5>\n<p>标记  <code>do</code>  语句。</p>\n<h3 id=\"a-nameres-gotoaes76-避免-goto\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-gotoaes76-避免-goto\">#</a> <a name=\"Res-goto\"></a>ES.76: 避免  <code>goto</code></h3>\n<h5 id=\"理由-249\"><a class=\"markdownIt-Anchor\" href=\"#理由-249\">#</a> 理由</h5>\n<p>可读性，避免错误。存在对于人类更好的控制结构； <code>goto</code>  是用于机器生成的代码的。</p>\n<h5 id=\"例外-48\"><a class=\"markdownIt-Anchor\" href=\"#例外-48\">#</a> 例外</h5>\n<p>跳出嵌套循环。<br>\n这种情况下应当总是向前跳出。</p>\n<pre><code>for (int i = 0; i &lt; imax; ++i)\n    for (int j = 0; j &lt; jmax; ++j) &#123;\n        if (a[i][j] &gt; elem_max) goto finished;\n        // ...\n    &#125;\nfinished:\n// ...\n</code></pre>\n<h5 id=\"示例不好-100\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-100\">#</a> 示例，不好</h5>\n<p>有相当数量的代码采用 C 风格的 goto-exit 惯用法：</p>\n<pre><code>void f()\n&#123;\n    // ...\n        goto exit;\n    // ...\n        goto exit;\n    // ...\nexit:\n    // ... 公共的清理代码 ...\n&#125;\n</code></pre>\n<p>这是对析构函数的一种专门模仿。<br>\n应当将资源声明为带有清理的析构函数的包装类。<br>\n如果你由于某种原因无法用析构函数来处理所使用的各个变量的清理工作，<br>\n请考虑用  <code>gsl::finally()</code>  作为  <code>goto exit</code>  的一种简洁且更加可靠的替代方案。</p>\n<h5 id=\"强制实施-240\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-240\">#</a> 强制实施</h5>\n<ul>\n<li>标记  <code>goto</code> 。更好的做法是标记出除了从嵌套内层循环中跳出到紧跟一组嵌套循环之后的语句的  <code>goto</code>  以外的所有  <code>goto</code> 。</li>\n</ul>\n<h3 id=\"a-nameres-continueaes77-尽量减少循环中使用的-break-和-continue\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-continueaes77-尽量减少循环中使用的-break-和-continue\">#</a> <a name=\"Res-continue\"></a>ES.77: 尽量减少循环中使用的  <code>break</code>  和  <code>continue</code></h3>\n<h5 id=\"理由-250\"><a class=\"markdownIt-Anchor\" href=\"#理由-250\">#</a> 理由</h5>\n<p>在不平凡的循环体中，容易忽略掉  <code>break</code>  或  <code>continue</code> 。</p>\n<p>循环中的  <code>break</code>  和  <code>switch</code>  语句中的  <code>break</code>  的含义有很大的区别，<br>\n（而且循环中可以有  <code>switch</code>  语句， <code>switch</code>  的  <code>case</code>  中也可以有循环）。</p>\n<h5 id=\"示例-233\"><a class=\"markdownIt-Anchor\" href=\"#示例-233\">#</a> 示例</h5>\n<pre><code>switch(x) &#123;\ncase 1 :\n    while (/* 某种条件 */) &#123;\n        // ...\n    break;\n    &#125; // 噢！打算 break switch 还是 break while？\ncase 2 :\n    // ...\n    break;\n&#125;\n</code></pre>\n<h5 id=\"替代方案-12\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-12\">#</a> 替代方案</h5>\n<p>通常，需要  <code>break</code>  的循环都是作为一个函数（算法）的良好候选者，其  <code>break</code>  将会变为  <code>return</code> 。</p>\n<pre><code>// 原始代码：break 内部循环\nvoid use1()\n&#123;\n    std::vector&lt;T&gt; vec = &#123;/* 初始化为一些值 */&#125;;\n    T value;\n    for (const T item : vec) &#123;\n        if (/* 某种条件 */) &#123;\n            value = item;\n            break;\n        &#125;\n    &#125;\n    /* 然后对 value 做些事 */\n&#125;\n\n// 这样更好：创建一个函数使其从循环中返回\nT search(const std::vector&lt;T&gt; &amp;vec)\n&#123;\n    for (const T &amp;item : vec) &#123;\n        if (/* 某种条件 */) return item;\n    &#125;\n    return T(); // 默认值\n&#125;\n\nvoid use2()\n&#123;\n    std::vector&lt;T&gt; vec = &#123;/* 初始化为一些值 */&#125;;\n    T value = search(vec);\n    /* 然后对 value 做些事 */\n&#125;\n</code></pre>\n<p>通常，使用  <code>continue</code>  的循环都可以等价且同样简洁地用  <code>if</code>  语句来表达。</p>\n<pre><code>for (int item : vec) &#123; // 不好\n    if (item%2 == 0) continue;\n    if (item == 5) continue;\n    if (item &gt; 10) continue;\n    /* 对 item 做些事 */\n&#125;\n\nfor (int item : vec) &#123; // 好\n    if (item%2 != 0 &amp;&amp; item != 5 &amp;&amp; item &lt;= 10) &#123;\n        /* 对 item 做些事 */\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"注解-228\"><a class=\"markdownIt-Anchor\" href=\"#注解-228\">#</a> 注解</h5>\n<p>如果你确实要打断一个循环，使用  <code>break</code>  通常比使用诸如<a href=\"#Res-loop-counter\">修改循环变量</a>或 <a href=\"#Res-goto\"> <code>goto</code> </a> 等其他方案更好：</p>\n<h5 id=\"强制实施-241\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-241\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-nameres-breakaes78-不要依靠-switch-语句中的隐含直落行为\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-breakaes78-不要依靠-switch-语句中的隐含直落行为\">#</a> <a name=\"Res-break\"></a>ES.78: 不要依靠  <code>switch</code>  语句中的隐含直落行为</h3>\n<h5 id=\"理由-251\"><a class=\"markdownIt-Anchor\" href=\"#理由-251\">#</a> 理由</h5>\n<p>总是以  <code>break</code>  来结束非空的  <code>case</code> 。意外地遗漏  <code>break</code>  是一种相当常见的 BUG。<br>\n蓄意的控制直落（fall through）是维护的噩梦，应该罕见并被明确标示出来。</p>\n<h5 id=\"示例-234\"><a class=\"markdownIt-Anchor\" href=\"#示例-234\">#</a> 示例</h5>\n<pre><code>switch (eventType) &#123;\ncase Information:\n    update_status_bar();\n    break;\ncase Warning:\n    write_event_log();\n    // 不好 - 隐式的控制直落\ncase Error:\n    display_error_window();\n    break;\n&#125;\n</code></pre>\n<p>单个语句带有多个  <code>case</code>  标签是可以的：</p>\n<pre><code>switch (x) &#123;\ncase 'a':\ncase 'b':\ncase 'f':\n    do_something(x);\n    break;\n&#125;\n</code></pre>\n<p>在  <code>case</code>  标签中使用返回语句也是可以的：</p>\n<pre><code>switch (x) &#123;\ncase 'a':\n    return 1;\ncase 'b':\n    return 2;\ncase 'c':\n    return 3;\n&#125;\n</code></pre>\n<h5 id=\"例外-49\"><a class=\"markdownIt-Anchor\" href=\"#例外-49\">#</a> 例外</h5>\n<p>在罕见的直落被视为合适行为的情况中。应当明确标示，并使用  <code>[[fallthrough]]</code>  标注：</p>\n<pre><code>switch (eventType) &#123;\ncase Information:\n    update_status_bar();\n    break;\ncase Warning:\n    write_event_log();\n    [[fallthrough]];\ncase Error:\n    display_error_window();\n    break;\n&#125;\n</code></pre>\n<h5 id=\"注解-229\"><a class=\"markdownIt-Anchor\" href=\"#注解-229\">#</a> 注解</h5>\n<h5 id=\"强制实施-242\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-242\">#</a> 强制实施</h5>\n<p>对所有从非空的  <code>case</code>  隐式发生的直落进行标记。</p>\n<h3 id=\"a-nameres-defaultaes79-default仅用于处理一般情况\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-defaultaes79-default仅用于处理一般情况\">#</a> <a name=\"Res-default\"></a>ES.79:  <code>default</code> （仅）用于处理一般情况</h3>\n<h5 id=\"理由-252\"><a class=\"markdownIt-Anchor\" href=\"#理由-252\">#</a> 理由</h5>\n<p>代码清晰性。<br>\n提升错误检测的机会。</p>\n<h5 id=\"示例-235\"><a class=\"markdownIt-Anchor\" href=\"#示例-235\">#</a> 示例</h5>\n<pre><code>enum E &#123; a, b, c, d &#125;;\n\nvoid f1(E x)\n&#123;\n    switch (x) &#123;\n    case a:\n        do_something();\n        break;\n    case b:\n        do_something_else();\n        break;\n    default:\n        take_the_default_action();\n        break;\n    &#125;\n&#125;\n</code></pre>\n<p>此处很明显有一种默认的动作，而情况  <code>a</code>  和  <code>b</code>  则是特殊情况。</p>\n<h5 id=\"示例-236\"><a class=\"markdownIt-Anchor\" href=\"#示例-236\">#</a> 示例</h5>\n<p>不过当不存在默认动作而只想处理特殊情况时怎么办呢？<br>\n这种情况下，应当使用空的  <code>default</code> ，否则没办法知道你确实处理了所有情况：</p>\n<pre><code>void f2(E x)\n&#123;\n    switch (x) &#123;\n    case a:\n        do_something();\n        break;\n    case b:\n        do_something_else();\n        break;\n    default:\n        // 其他情况无需动作\n        break;\n    &#125;\n&#125;\n</code></pre>\n<p>如果没有  <code>default</code>  的话，维护者以及编译器可能会合理地假定你有意处理所有情况：</p>\n<pre><code>void f2(E x)\n&#123;\n    switch (x) &#123;\n    case a:\n        do_something();\n        break;\n    case b:\n    case c:\n        do_something_else();\n        break;\n    &#125;\n&#125;\n</code></pre>\n<p>你是忘记了情况  <code>d</code>  还是故意遗漏了它？<br>\n当有人向枚举中添加一种情况，而又未能对每个针对这些枚举符的  <code>switch</code>  中添加时，<br>\n容易出现这种遗忘  <code>case</code>  的情况。</p>\n<h5 id=\"强制实施-243\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-243\">#</a> 强制实施</h5>\n<p>针对某个枚举的  <code>switch</code>  语句，若其未能处理其所有枚举符且没有  <code>default</code> ，则对其进行标记。<br>\n这样做对于某些代码库可能会产生大量误报；此时，可以仅标记那些处理了大多数情况而不是所有情况的  <code>switch</code>  语句<br>\n（这正是第一个 C++ 编译器曾经的策略）。</p>\n<h3 id=\"a-nameres-nonameaes84-不要试图声明没有名字的局部变量\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-nonameaes84-不要试图声明没有名字的局部变量\">#</a> <a name=\"Res-noname\"></a>ES.84: 不要试图声明没有名字的局部变量</h3>\n<h5 id=\"理由-253\"><a class=\"markdownIt-Anchor\" href=\"#理由-253\">#</a> 理由</h5>\n<p>没有这种东西。<br>\n我们眼里看起来像是个无名变量的东西，对于编译器来说是一条由一个将会立刻离开作用域的临时对象所组成的语句。</p>\n<h5 id=\"示例不好-101\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-101\">#</a> 示例，不好</h5>\n<pre><code>void f()\n&#123;\n    lock_guard&lt;mutex&gt;&#123;mx&#125;;   // 不好\n    // ...\n&#125;\n</code></pre>\n<p>这里声明了一个无名的  <code>lock_guard</code>  对象，它将在分号处立刻离开作用域。<br>\n这并不是一种少见的错误。<br>\n特别是，这个特别的例子会导致很难发觉的竞争条件。</p>\n<h5 id=\"注解-230\"><a class=\"markdownIt-Anchor\" href=\"#注解-230\">#</a> 注解</h5>\n<p>无名函数实参是没问题的。</p>\n<h5 id=\"强制实施-244\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-244\">#</a> 强制实施</h5>\n<p>标记出仅有临时对象的语句。</p>\n<h3 id=\"a-nameres-emptyaes85-让空语句显著可见\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-emptyaes85-让空语句显著可见\">#</a> <a name=\"Res-empty\"></a>ES.85: 让空语句显著可见</h3>\n<h5 id=\"理由-254\"><a class=\"markdownIt-Anchor\" href=\"#理由-254\">#</a> 理由</h5>\n<p>可读性。</p>\n<h5 id=\"示例-237\"><a class=\"markdownIt-Anchor\" href=\"#示例-237\">#</a> 示例</h5>\n<pre><code>for (i = 0; i &lt; max; ++i);   // 不好: 空语句很容易被忽略\nv[i] = f(v[i]);\n\nfor (auto x : v) &#123;           // 好多了\n    // 空\n&#125;\nv[i] = f(v[i]);\n</code></pre>\n<h5 id=\"强制实施-245\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-245\">#</a> 强制实施</h5>\n<p>对并非块语句且不包含注释的空语句进行标记。</p>\n<h3 id=\"a-nameres-loop-counteraes86-避免在原生的-for-循环中修改循环控制变量\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-loop-counteraes86-避免在原生的-for-循环中修改循环控制变量\">#</a> <a name=\"Res-loop-counter\"></a>ES.86: 避免在原生的  <code>for</code>  循环中修改循环控制变量</h3>\n<h5 id=\"理由-255\"><a class=\"markdownIt-Anchor\" href=\"#理由-255\">#</a> 理由</h5>\n<p>循环控制的第一行应当允许对循环中所发生的事情进行正确的推理。同时在循环的重复表达式和循环体之中修改循环计数器，是发生意外和 BUG 的一种经常性来源。</p>\n<h5 id=\"示例-238\"><a class=\"markdownIt-Anchor\" href=\"#示例-238\">#</a> 示例</h5>\n<pre><code>for (int i = 0; i &lt; 10; ++i) &#123;\n    // 未改动 i -- ok\n&#125;\n\nfor (int i = 0; i &lt; 10; ++i) &#123;\n    //\n    if (/* 某种情况 */) ++i; // 不好\n    //\n&#125;\n\nbool skip = false;\nfor (int i = 0; i &lt; 10; ++i) &#123;\n    if (skip) &#123; skip = false; continue; &#125;\n    //\n    if (/* 某种情况 */) skip = true;  // 有改善: 为两个概念使用了两个变量。\n    //\n&#125;\n</code></pre>\n<h5 id=\"强制实施-246\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-246\">#</a> 强制实施</h5>\n<p>如果变量在循环控制的重复表达式和循环体中都潜在地进行更新（存在非  <code>const</code>  使用），则进行标记。</p>\n<h3 id=\"a-nameres-ifaes87-请勿在条件上添加多余的-或\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-ifaes87-请勿在条件上添加多余的-或\">#</a> <a name=\"Res-if\"></a>ES.87: 请勿在条件上添加多余的  <code>==</code>  或  <code>!=</code></h3>\n<h5 id=\"理由-256\"><a class=\"markdownIt-Anchor\" href=\"#理由-256\">#</a> 理由</h5>\n<p>这样可避免啰嗦，并消除了发生某些错误的机会。<br>\n有助于使代码风格保持一致性和协调性。</p>\n<h5 id=\"示例-239\"><a class=\"markdownIt-Anchor\" href=\"#示例-239\">#</a> 示例</h5>\n<p>根据定义， <code>if</code>  语句， <code>while</code>  语句，以及  <code>for</code>  语句中的条件，选择  <code>true</code>  或  <code>false</code>  的取值。<br>\n数值与  <code>0</code>  相比较，指针值与  <code>nullptr</code>  相比较。</p>\n<pre><code>// 这些都表示“当 p 不是 nullptr 时”\nif (p) &#123; ... &#125;            // 好\nif (p != 0) &#123; ... &#125;       // !=0 是多余的；不好：不要对指针用 0\nif (p != nullptr) &#123; ... &#125; // !=nullptr 是多余的，不建议如此\n</code></pre>\n<p>通常， <code>if (p)</code>  可解读为 “如果  <code>p</code>  有效”，这正是程序员意图的直接表达，<br>\n而  <code>if (p != nullptr)</code>  则只是一种啰嗦的变通写法。</p>\n<h5 id=\"示例-240\"><a class=\"markdownIt-Anchor\" href=\"#示例-240\">#</a> 示例</h5>\n<p>这条规则对于把声明式用作条件时尤其有用</p>\n<pre><code>if (auto pc = dynamic_cast&lt;Circle&gt;(ps)) &#123; ... &#125; // 执行是按照 ps 指向某种 Circle 来进行的，好\n\nif (auto pc = dynamic_cast&lt;Circle&gt;(ps); pc != nullptr) &#123; ... &#125; // 不建议如此\n</code></pre>\n<h5 id=\"示例-241\"><a class=\"markdownIt-Anchor\" href=\"#示例-241\">#</a> 示例</h5>\n<p>要注意，条件中会实施向  <code>bool</code>  的隐式转换。<br>\n例如：</p>\n<pre><code>for (string s; cin &gt;&gt; s; ) v.push_back(s);\n</code></pre>\n<p>这里会执行  <code>istream</code>  的  <code>operator bool()</code> 。</p>\n<h5 id=\"注解-231\"><a class=\"markdownIt-Anchor\" href=\"#注解-231\">#</a> 注解</h5>\n<p>明确地将整数和  <code>0</code>  进行比较通常并非是多余的。<br>\n因为（与指针和布尔值相反），整数通常都具有超过两个的有效值。<br>\n此外  <code>0</code> （零）还经常会用于代表成功。<br>\n因此，最好明确地进行比较。</p>\n<pre><code>void f(int i)\n&#123;\n    if (i)            // 可疑\n    // ...\n    if (i == success) // 可能更好\n    // ...\n&#125;\n</code></pre>\n<p>一定要记住整数可以有超过两个值。</p>\n<h5 id=\"示例不好-102\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-102\">#</a> 示例，不好</h5>\n<p>众所周知，</p>\n<pre><code>if(strcmp(p1, p2)) &#123; ... &#125;   // 这两个 C 风格的字符串相等吗？（错误！）\n</code></pre>\n<p>是一种常见的新手错误。<br>\n如果使用 C 风格的字符串，那么就必须好好了解  <code>&lt;cstring&gt;</code>  中的函数。<br>\n即便冗余地写为</p>\n<pre><code>if(strcmp(p1, p2) != 0) &#123; ... &#125;   // 这两个 C 风格的字符串相等吗？（错误！）\n</code></pre>\n<p>也不会有效果。</p>\n<h5 id=\"注解-232\"><a class=\"markdownIt-Anchor\" href=\"#注解-232\">#</a> 注解</h5>\n<p>表达相反的条件的最简单的方式就是使用一次取反：</p>\n<pre><code>// 这些都表示“当 p 为 nullptr 时”\nif (!p) &#123; ... &#125;           // 好\nif (p == 0) &#123; ... &#125;       // ==0 是多余的；不好：不要对指针用 0\nif (p == nullptr) &#123; ... &#125; // ==nullptr 是多余的，不建议如此\n</code></pre>\n<h5 id=\"强制实施-247\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-247\">#</a> 强制实施</h5>\n<p>容易，仅需检查条件中多余的  <code>!=</code>  和  <code>==</code>  的使用即可。</p>\n<h2 id=\"a-namess-numbersa算术\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-numbersa算术\">#</a> <a name=\"SS-numbers\"></a>算术</h2>\n<h3 id=\"a-nameres-mixaes100-不要进行有符号和无符号混合运算\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-mixaes100-不要进行有符号和无符号混合运算\">#</a> <a name=\"Res-mix\"></a>ES.100: 不要进行有符号和无符号混合运算</h3>\n<h5 id=\"理由-257\"><a class=\"markdownIt-Anchor\" href=\"#理由-257\">#</a> 理由</h5>\n<p>避免错误的结果。</p>\n<h5 id=\"示例-242\"><a class=\"markdownIt-Anchor\" href=\"#示例-242\">#</a> 示例</h5>\n<pre><code>int x = -3;\nunsigned int y = 7;\n\ncout &lt;&lt; x - y &lt;&lt; '\\n';  // 无符号结果，可能是 4294967286\ncout &lt;&lt; x + y &lt;&lt; '\\n';  // 无符号结果：4\ncout &lt;&lt; x * y &lt;&lt; '\\n';  // 无符号结果，可能是 4294967275\n</code></pre>\n<p>在更实际的例子中，这种问题更难于被发现。</p>\n<h5 id=\"注解-233\"><a class=\"markdownIt-Anchor\" href=\"#注解-233\">#</a> 注解</h5>\n<p>不幸的是，C++ 使用有符号整数作为数组下标，而标准库使用无符号整数作为容器下标。<br>\n这妨碍了一致性。使用  <code>gsl::index</code>  来作为下标类型；<a href=\"#Res-subscripts\">参见 ES.107</a>。</p>\n<h5 id=\"强制实施-248\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-248\">#</a> 强制实施</h5>\n<ul>\n<li>编译器已知这种情况，有些时候会给出警告。</li>\n<li>（避免噪声）有符号 / 无符号的混合比较，若其一个实参是  <code>sizeof</code>  或调用容器的  <code>.size()</code>  而另一个是  <code>ptrdiff_t</code> ，则不要进行标记。</li>\n</ul>\n<h3 id=\"a-nameres-unsignedaes101-使用无符号类型进行位操作\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-unsignedaes101-使用无符号类型进行位操作\">#</a> <a name=\"Res-unsigned\"></a>ES.101: 使用无符号类型进行位操作</h3>\n<h5 id=\"理由-258\"><a class=\"markdownIt-Anchor\" href=\"#理由-258\">#</a> 理由</h5>\n<p>无符号类型支持位操作而没有符号位的意外。</p>\n<h5 id=\"示例-243\"><a class=\"markdownIt-Anchor\" href=\"#示例-243\">#</a> 示例</h5>\n<pre><code>unsigned char x = 0b1010'1010;\nunsigned char y = ~x;   // y == 0b0101'0101;\n</code></pre>\n<h5 id=\"注解-234\"><a class=\"markdownIt-Anchor\" href=\"#注解-234\">#</a> 注解</h5>\n<p>无符号类型对于模算术也很有用。<br>\n不过，如果你想要进行模算术时，<br>\n应当按需添加代码注释以注明所依赖的回绕行为，因为这样的<br>\n代码会让许多程序员感觉意外。</p>\n<h5 id=\"强制实施-249\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-249\">#</a> 强制实施</h5>\n<ul>\n<li>一般来说基本不可能，因为标准库也使用了无符号下标。<br>\n???</li>\n</ul>\n<h3 id=\"a-nameres-signedaes102-使用有符号类型进行算术运算\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-signedaes102-使用有符号类型进行算术运算\">#</a> <a name=\"Res-signed\"></a>ES.102: 使用有符号类型进行算术运算</h3>\n<h5 id=\"理由-259\"><a class=\"markdownIt-Anchor\" href=\"#理由-259\">#</a> 理由</h5>\n<p>因为大多数算术都假定是有符号的；<br>\n当  <code>y &gt; x</code>  时， <code>x - y</code>  都会产生负数，除了罕见的情况下你确实需要模算术。</p>\n<h5 id=\"示例-244\"><a class=\"markdownIt-Anchor\" href=\"#示例-244\">#</a> 示例</h5>\n<p>当你不期望时，无符号算术会产生奇怪的结果。<br>\n这在混合有符号和无符号算术时有其如此。</p>\n<pre><code>template&lt;typename T, typename T2&gt;\nT subtract(T x, T2 y)\n&#123;\n    return x - y;\n&#125;\n\nvoid test()\n&#123;\n    int s = 5;\n    unsigned int us = 5;\n    cout &lt;&lt; subtract(s, 7) &lt;&lt; '\\n';       // -2\n    cout &lt;&lt; subtract(us, 7u) &lt;&lt; '\\n';     // 4294967294\n    cout &lt;&lt; subtract(s, 7u) &lt;&lt; '\\n';      // -2\n    cout &lt;&lt; subtract(us, 7) &lt;&lt; '\\n';      // 4294967294\n    cout &lt;&lt; subtract(s, us + 2) &lt;&lt; '\\n';  // -2\n    cout &lt;&lt; subtract(us, s + 2) &lt;&lt; '\\n';  // 4294967294\n&#125;\n</code></pre>\n<p>我们这次非常明确发生了什么。<br>\n但要是你见到  <code>us - (s + 2)</code>  或者  <code>s += 2; ...; us - s</code>  时，你确实能够预计到打印的结果将是  <code>4294967294</code>  吗？</p>\n<h5 id=\"例外-50\"><a class=\"markdownIt-Anchor\" href=\"#例外-50\">#</a> 例外</h5>\n<p>如果你确实需要模算术的话就使用无符号类型 ——<br>\n 根据需要为其添加代码注释以说明其依赖溢出行为，因为这样的<br>\n代码会让许多程序员感觉意外。</p>\n<h5 id=\"示例-245\"><a class=\"markdownIt-Anchor\" href=\"#示例-245\">#</a> 示例</h5>\n<p>标准库使用无符号类型作为下标。<br>\n内建数组则用有符号类型作为下标。<br>\n这不可避免地带来了意外（以及 BUG）。</p>\n<pre><code>int a[10];\nfor (int i = 0; i &lt; 10; ++i) a[i] = i;\nvector&lt;int&gt; v(10);\n// 比较有符号和无符号数；有些编译器会警告，但我们不能警告\nfor (gsl::index i = 0; i &lt; v.size(); ++i) v[i] = i;\n\nint a2[-2];         // 错误：负的大小\n\n// OK，但 int 的数值（4294967294）过大，应当会造成一个异常\nvector&lt;int&gt; v2(-2);\n</code></pre>\n<p>使用  <code>gsl::index</code>  作为下标类型；<a href=\"#Res-subscripts\">参见 ES.107</a>。</p>\n<h5 id=\"强制实施-250\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-250\">#</a> 强制实施</h5>\n<ul>\n<li>对混合有符号和无符号算术进行标记。</li>\n<li>对将无符号算术的结果作为有符号数赋值或打印进行标记。</li>\n<li>对负数字面量（比如  <code>-2</code> ）用作容器下标进行标记。</li>\n<li>（避免噪声）有符号 / 无符号的混合比较，若其一个实参是  <code>sizeof</code>  或调用容器的  <code>.size()</code>  而另一个是  <code>ptrdiff_t</code> ，则不要进行标记。</li>\n</ul>\n<h3 id=\"a-nameres-overflowaes103-避免上溢出\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-overflowaes103-避免上溢出\">#</a> <a name=\"Res-overflow\"></a>ES.103: 避免上溢出</h3>\n<h5 id=\"理由-260\"><a class=\"markdownIt-Anchor\" href=\"#理由-260\">#</a> 理由</h5>\n<p>上溢出通常会让数值算法变得没有意义。<br>\n将值增加超过其最大值将导致内存损坏和未定义的行为。</p>\n<h5 id=\"示例不好-103\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-103\">#</a> 示例，不好</h5>\n<pre><code>int a[10];\na[10] = 7;   // 不好，数组边界上溢出\n\nfor (int n = 0; n &lt;= 10; ++n)\n    a[n] = 9;   // 不好，数组边界上溢出\n</code></pre>\n<h5 id=\"示例不好-104\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-104\">#</a> 示例，不好</h5>\n<pre><code>int n = numeric_limits&lt;int&gt;::max();\nint m = n + 1;   // 不好，数值上溢出\n</code></pre>\n<h5 id=\"示例不好-105\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-105\">#</a> 示例，不好</h5>\n<pre><code>int area(int h, int w) &#123; return h * w; &#125;\n\nauto a = area(10'000'000, 100'000'000);   // 不好，数值上溢出\n</code></pre>\n<h5 id=\"例外-51\"><a class=\"markdownIt-Anchor\" href=\"#例外-51\">#</a> 例外</h5>\n<p>如果你确实需要模算术的话就使用无符号类型。</p>\n<p><strong>替代方案</strong>：对于可以负担一些开销的关键应用，可以使用带有范围检查的整数和 / 或浮点类型。</p>\n<h5 id=\"强制实施-251\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-251\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-nameres-underflowaes104-避免下溢出\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-underflowaes104-避免下溢出\">#</a> <a name=\"Res-underflow\"></a>ES.104: 避免下溢出</h3>\n<h5 id=\"理由-261\"><a class=\"markdownIt-Anchor\" href=\"#理由-261\">#</a> 理由</h5>\n<p>将值减小超过其最小值将导致内存损坏和未定义的行为。</p>\n<h5 id=\"示例不好-106\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-106\">#</a> 示例，不好</h5>\n<pre><code>int a[10];\na[-2] = 7;   // 不好\n\nint n = 101;\nwhile (n--)\n    a[n - 1] = 9;   // 不好（两次）\n</code></pre>\n<h5 id=\"例外-52\"><a class=\"markdownIt-Anchor\" href=\"#例外-52\">#</a> 例外</h5>\n<p>如果你确实需要模算术的话就使用无符号类型。</p>\n<h5 id=\"强制实施-252\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-252\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-nameres-zeroaes105-避免除整数零\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-zeroaes105-避免除整数零\">#</a> <a name=\"Res-zero\"></a>ES.105: 避免除整数零</h3>\n<h5 id=\"理由-262\"><a class=\"markdownIt-Anchor\" href=\"#理由-262\">#</a> 理由</h5>\n<p>其结果是未定义的，很可能导致程序崩溃。</p>\n<h5 id=\"注解-235\"><a class=\"markdownIt-Anchor\" href=\"#注解-235\">#</a> 注解</h5>\n<p>这同样适用于  <code>%</code> 。</p>\n<h5 id=\"示例不好-107\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-107\">#</a> 示例，不好</h5>\n<pre><code>int divide(int a, int b)\n&#123;\n    // 不好, 应当进行检查（比如一条前条件）\n    return a / b;\n&#125;\n</code></pre>\n<h5 id=\"示例好-20\"><a class=\"markdownIt-Anchor\" href=\"#示例好-20\">#</a> 示例，好</h5>\n<pre><code>int divide(int a, int b)\n&#123;\n    // 好, 通过前条件进行处置（并当 C++ 支持契约后可以进行替换）\n    Expects(b != 0);\n    return a / b;\n&#125;\n\ndouble divide(double a, double b)\n&#123;\n    // 好, 通过换为使用 double 来处置\n    return a / b;\n&#125;\n</code></pre>\n<p><strong>替代方案</strong>：对于可以负担一些开销的关键应用，可以使用带有范围检查的整数和 / 或浮点类型。</p>\n<h5 id=\"强制实施-253\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-253\">#</a> 强制实施</h5>\n<ul>\n<li>对以可能为零的整型值的除法进行标记。</li>\n</ul>\n<h3 id=\"a-nameres-nonnegativeaes106-不要试图用-unsigned-来防止负数值\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-nonnegativeaes106-不要试图用-unsigned-来防止负数值\">#</a> <a name=\"Res-nonnegative\"></a>ES.106: 不要试图用  <code>unsigned</code>  来防止负数值</h3>\n<h5 id=\"理由-263\"><a class=\"markdownIt-Anchor\" href=\"#理由-263\">#</a> 理由</h5>\n<p>选用  <code>unsigned</code>  意味着对于包括模算术在内的整数的常规行为的许多改动，<br>\n它将抑制掉与溢出有关的警告，<br>\n并打开了与混合符号相关的错误的大门。<br>\n使用  <code>unsigned</code>  并不会真正消除负数值的可能性。</p>\n<h5 id=\"示例-246\"><a class=\"markdownIt-Anchor\" href=\"#示例-246\">#</a> 示例</h5>\n<pre><code>unsigned int u1 = -2;   // 合法：u1 的值为 4294967294\nint i1 = -2;\nunsigned int u2 = i1;   // 合法：u2 的值为 4294967294\nint i2 = u2;            // 合法：i2 的值为 -2\n</code></pre>\n<p>真实代码中很难找出这样的（完全合法的）语法构造的问题，而它们是许多真实世界错误的来源。<br>\n考虑：</p>\n<pre><code>unsigned area(unsigned height, unsigned width) &#123; return height*width; &#125; // [参见](#Ri-expects)\n// ...\nint height;\ncin &gt;&gt; height;\nauto a = area(height, 2);   // 当输入为 -2 时 a 为 4294967292\n</code></pre>\n<p>记住把  <code>-1</code>  赋值给  <code>unsigned int</code>  会变成最大的  <code>unsigned int</code> 。<br>\n而且，由于无符号算术是模算术，其乘法并不会溢出，而是会发生回绕。</p>\n<h5 id=\"示例-247\"><a class=\"markdownIt-Anchor\" href=\"#示例-247\">#</a> 示例</h5>\n<pre><code>unsigned max = 100000;    // “不小心写错了”，应该写 10'000\nunsigned short x = 100;\nwhile (x &lt; max) x += 100; // 无限循环\n</code></pre>\n<p>要是  <code>x</code>  是个有符号的  <code>short</code>  的话，我们就会得到有关溢出的未定义行为的警告了。</p>\n<h5 id=\"替代方案-13\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-13\">#</a> 替代方案</h5>\n<ul>\n<li>使用有符号整数并检查  <code>x &gt;= 0</code></li>\n<li>使用某个正整数类型</li>\n<li>使用某个整数子值域类型</li>\n<li><code>Assert(-1 &lt; x)</code></li>\n</ul>\n<p>例如</p>\n<pre><code>struct Positive &#123;\n    int val;\n    Positive(int x) :val&#123;x&#125; &#123; Assert(0 &lt; x); &#125;\n    operator int() &#123; return val; &#125;\n&#125;;\n\nint f(Positive arg) &#123; return arg; &#125;\n\nint r1 = f(2);\nint r2 = f(-2);  // 抛出异常\n</code></pre>\n<h5 id=\"注解-236\"><a class=\"markdownIt-Anchor\" href=\"#注解-236\">#</a> 注解</h5>\n<p>???</p>\n<h5 id=\"强制实施-254\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-254\">#</a> 强制实施</h5>\n<p>参见 ES.100 的强制实施。</p>\n<h3 id=\"a-nameres-subscriptsaes107-不要对下标使用-unsigned优先使用-gslindex\"><a class=\"markdownIt-Anchor\" href=\"#a-nameres-subscriptsaes107-不要对下标使用-unsigned优先使用-gslindex\">#</a> <a name=\"Res-subscripts\"></a>ES.107: 不要对下标使用  <code>unsigned</code> ，优先使用  <code>gsl::index</code></h3>\n<h5 id=\"理由-264\"><a class=\"markdownIt-Anchor\" href=\"#理由-264\">#</a> 理由</h5>\n<p>避免有符号和无符号混乱。<br>\n允许更好的优化。<br>\n允许更好的错误检测。<br>\n避免  <code>auto</code>  和  <code>int</code>  有关的陷阱。</p>\n<h5 id=\"示例不好-108\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-108\">#</a> 示例，不好</h5>\n<pre><code>vector&lt;int&gt; vec = /*...*/;\n\nfor (int i = 0; i &lt; vec.size(); i += 2)                    // 可能不够大\n    cout &lt;&lt; vec[i] &lt;&lt; '\\n';\nfor (unsigned i = 0; i &lt; vec.size(); i += 2)               // 有风险的回绕\n    cout &lt;&lt; vec[i] &lt;&lt; '\\n';\nfor (auto i = 0; i &lt; vec.size(); i += 2)                   // 可能不够大\n    cout &lt;&lt; vec[i] &lt;&lt; '\\n';\nfor (vector&lt;int&gt;::size_type i = 0; i &lt; vec.size(); i += 2) // 啰嗦\n    cout &lt;&lt; vec[i] &lt;&lt; '\\n';\nfor (auto i = vec.size()-1; i &gt;= 0; i -= 2)                // BUG\n    cout &lt;&lt; vec[i] &lt;&lt; '\\n';\nfor (int i = vec.size()-1; i &gt;= 0; i -= 2)                 // 可能不够大\n    cout &lt;&lt; vec[i] &lt;&lt; '\\n';\n</code></pre>\n<h5 id=\"示例好-21\"><a class=\"markdownIt-Anchor\" href=\"#示例好-21\">#</a> 示例，好</h5>\n<pre><code>vector&lt;int&gt; vec = /*...*/;\n\nfor (gsl::index i = 0; i &lt; vec.size(); i += 2)             // ok\n    cout &lt;&lt; vec[i] &lt;&lt; '\\n';\nfor (gsl::index i = vec.size()-1; i &gt;= 0; i -= 2)          // ok\n    cout &lt;&lt; vec[i] &lt;&lt; '\\n';\n</code></pre>\n<h5 id=\"注解-237\"><a class=\"markdownIt-Anchor\" href=\"#注解-237\">#</a> 注解</h5>\n<p>内建数组允许有符号的下标。<br>\n标准库容器使用无符号的下标。<br>\n因此没有完美的兼容解决方案（除非将来某一天，标准库容器改为使用有符号下标了）。<br>\n鉴于无符号和混合符号方面的已知问题，最好坚持使用（有符号）并且足够大的整数，而  <code>gsl::index</code>  保证了这点。</p>\n<h5 id=\"示例-248\"><a class=\"markdownIt-Anchor\" href=\"#示例-248\">#</a> 示例</h5>\n<pre><code>template&lt;typename T&gt;\nstruct My_container &#123;\npublic:\n    // ...\n    T&amp; operator[](gsl::index i);    // 不是 unsigned\n    // ...\n&#125;;\n</code></pre>\n<h5 id=\"示例-249\"><a class=\"markdownIt-Anchor\" href=\"#示例-249\">#</a> 示例</h5>\n<pre><code>??? 演示改进后的代码生成和潜在可进行的错误检查 ???\n</code></pre>\n<h5 id=\"替代方案-14\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-14\">#</a> 替代方案</h5>\n<p>可以代之以</p>\n<ul>\n<li>使用算法</li>\n<li>使用基于范围的  <code>for</code></li>\n<li>使用迭代器或指针</li>\n</ul>\n<h5 id=\"强制实施-255\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-255\">#</a> 强制实施</h5>\n<ul>\n<li>非常麻烦，因为标准库容器已经搞错了。</li>\n<li>（避免噪声）有符号 / 无符号的混合比较，若其一个实参是  <code>sizeof</code>  或调用容器的  <code>.size()</code>  而另一个是  <code>ptrdiff_t</code> ，则不要进行标记。</li>\n</ul>\n<h1 id=\"a-names-performanceaper-性能\"><a class=\"markdownIt-Anchor\" href=\"#a-names-performanceaper-性能\">#</a> <a name=\"S-performance\"></a>Per: 性能</h1>\n<p>??? 这一节应该放在主指南中吗？？？</p>\n<p>本章节所包含的规则对于需要高性能和低延迟的人们很有价值。<br>\n就是说，这些规则是有关如何在可预测的短时段中尽可能使用更短时间和更少资源来完成任务的。<br>\n本章节中的规则要比（绝大）多数应用程序所需要的规则更多限制并更有侵入性。<br>\n请勿在一般的代码中盲目地尝试遵循这些规则：要达成低延迟的目标是需要进行一些额外工作的。</p>\n<p>性能规则概览：</p>\n<ul>\n<li><a href=\"#Rper-reason\">Per.1: 请勿进行无理由的优化</a></li>\n<li><a href=\"#Rper-Knuth\">Per.2: 请勿进行不成熟的优化</a></li>\n<li><a href=\"#Rper-critical\">Per.3: 请勿对非性能关键的代码进行优化</a></li>\n<li><a href=\"#Rper-simple\">Per.4: 不能假定复杂代码一定比简单代码更快</a></li>\n<li><a href=\"#Rper-low\">Per.5: 不能假定低级代码一定比高级代码更快</a></li>\n<li><a href=\"#Rper-measure\">Per.6: 请勿不进行测量就作出性能评断</a></li>\n<li><a href=\"#Rper-efficiency\">Per.7: 设计应当允许优化</a></li>\n<li><a href=\"#Rper-type\">Per.10: 依赖静态类型系统</a></li>\n<li><a href=\"#Rper-Comp\">Per.11: 把计算从运行时转移到编译期</a></li>\n<li><a href=\"#Rper-alias\">Per.12: 消除多余的别名</a></li>\n<li><a href=\"#Rper-indirect\">Per.13: 消除多余的间接</a></li>\n<li><a href=\"#Rper-alloc\">Per.14: 最小化分配和回收的次数</a></li>\n<li><a href=\"#Rper-alloc0\">Per.15: 请勿在关键逻辑分支中进行分配</a></li>\n<li><a href=\"#Rper-compact\">Per.16: 使用紧凑的数据结构</a></li>\n<li><a href=\"#Rper-struct\">Per.17: 在时间关键的结构中应当先声明最常用的成员</a></li>\n<li><a href=\"#Rper-space\">Per.18: 空间即时间</a></li>\n<li><a href=\"#Rper-access\">Per.19: 进行可预测的内存访问</a></li>\n<li><a href=\"#Rper-context\">Per.30: 避免在关键路径中进行上下文切换</a></li>\n</ul>\n<h3 id=\"a-namerper-reasonaper1-请勿进行无理由的优化\"><a class=\"markdownIt-Anchor\" href=\"#a-namerper-reasonaper1-请勿进行无理由的优化\">#</a> <a name=\"Rper-reason\"></a>Per.1: 请勿进行无理由的优化</h3>\n<h5 id=\"理由-265\"><a class=\"markdownIt-Anchor\" href=\"#理由-265\">#</a> 理由</h5>\n<p>如果没有必要优化的话，这样做的结果就是更多的错误和更高的维护成本。</p>\n<h5 id=\"注解-238\"><a class=\"markdownIt-Anchor\" href=\"#注解-238\">#</a> 注解</h5>\n<p>一些人作出优化只是出于习惯或者因为感觉这很有趣。</p>\n<p>???</p>\n<h3 id=\"a-namerper-knuthaper2-请勿进行不成熟的优化\"><a class=\"markdownIt-Anchor\" href=\"#a-namerper-knuthaper2-请勿进行不成熟的优化\">#</a> <a name=\"Rper-Knuth\"></a>Per.2: 请勿进行不成熟的优化</h3>\n<h5 id=\"理由-266\"><a class=\"markdownIt-Anchor\" href=\"#理由-266\">#</a> 理由</h5>\n<p>经过精心优化的代码通常比未优化的代码更大而且更难修改。</p>\n<p>???</p>\n<h3 id=\"a-namerper-criticalaper3-请勿对非性能关键的代码进行优化\"><a class=\"markdownIt-Anchor\" href=\"#a-namerper-criticalaper3-请勿对非性能关键的代码进行优化\">#</a> <a name=\"Rper-critical\"></a>Per.3: 请勿对非性能关键的代码进行优化</h3>\n<h5 id=\"理由-267\"><a class=\"markdownIt-Anchor\" href=\"#理由-267\">#</a> 理由</h5>\n<p>对程序中并非性能关键的部分进行的优化，对于系统性能是没有效果的。</p>\n<h5 id=\"注解-239\"><a class=\"markdownIt-Anchor\" href=\"#注解-239\">#</a> 注解</h5>\n<p>如果你的程序要耗费大量时间来等待 Web 或人的操作的话，对内存中的计算进行优化可能是没什么用处的。</p>\n<p>换个角度来说：如果你的程序花费处理时间的 4% 来<br>\n计算 A 而花费 40% 的时间来计算 B，那对 A 的 50% 的改进<br>\n其影响只能和 B 的 5% 的改进相比。（如果你甚至不知道<br>\n A 或 B 到底花费了多少时间，参见 <a href=\"#Rper-reason\">Per.1</a> 和 <a\nhref=\"#Rper-Knuth\">Per.2</a>。）</p>\n<h3 id=\"a-namerper-simpleaper4-不能假定复杂代码一定比简单代码更快\"><a class=\"markdownIt-Anchor\" href=\"#a-namerper-simpleaper4-不能假定复杂代码一定比简单代码更快\">#</a> <a name=\"Rper-simple\"></a>Per.4: 不能假定复杂代码一定比简单代码更快</h3>\n<h5 id=\"理由-268\"><a class=\"markdownIt-Anchor\" href=\"#理由-268\">#</a> 理由</h5>\n<p>简单的代码可能会非常快。优化器在简单代码上有时候会发生奇迹。</p>\n<h5 id=\"示例好-22\"><a class=\"markdownIt-Anchor\" href=\"#示例好-22\">#</a> 示例，好</h5>\n<pre><code>// 清晰表达意图，快速执行\n\nvector&lt;uint8_t&gt; v(100000);\n\nfor (auto&amp; c : v)\n    c = ~c;\n</code></pre>\n<h5 id=\"示例不好-109\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-109\">#</a> 示例，不好</h5>\n<pre><code>// 试图更快，但通常会更慢\n\nvector&lt;uint8_t&gt; v(100000);\n\nfor (size_t i = 0; i &lt; v.size(); i += sizeof(uint64_t)) &#123;\n    uint64_t&amp; quad_word = *reinterpret_cast&lt;uint64_t*&gt;(&amp;v[i]);\n    quad_word = ~quad_word;\n&#125;\n</code></pre>\n<h5 id=\"注解-240\"><a class=\"markdownIt-Anchor\" href=\"#注解-240\">#</a> 注解</h5>\n<p>???</p>\n<p>???</p>\n<h3 id=\"a-namerper-lowaper5-不能假定低级代码一定比高级代码更快\"><a class=\"markdownIt-Anchor\" href=\"#a-namerper-lowaper5-不能假定低级代码一定比高级代码更快\">#</a> <a name=\"Rper-low\"></a>Per.5: 不能假定低级代码一定比高级代码更快</h3>\n<h5 id=\"理由-269\"><a class=\"markdownIt-Anchor\" href=\"#理由-269\">#</a> 理由</h5>\n<p>低级代码有时候会妨碍优化。优化器在高级代码上有时候会发生奇迹。</p>\n<h5 id=\"注解-241\"><a class=\"markdownIt-Anchor\" href=\"#注解-241\">#</a> 注解</h5>\n<p>???</p>\n<p>???</p>\n<h3 id=\"a-namerper-measureaper6-请勿不进行测量就作出性能评断\"><a class=\"markdownIt-Anchor\" href=\"#a-namerper-measureaper6-请勿不进行测量就作出性能评断\">#</a> <a name=\"Rper-measure\"></a>Per.6: 请勿不进行测量就作出性能评断</h3>\n<h5 id=\"理由-270\"><a class=\"markdownIt-Anchor\" href=\"#理由-270\">#</a> 理由</h5>\n<p>性能领域充斥各种错误认识和伪习俗。<br>\n现代的硬件和优化器并不遵循这些幼稚的假设；即便是专家也会经常感觉意外。</p>\n<h5 id=\"注解-242\"><a class=\"markdownIt-Anchor\" href=\"#注解-242\">#</a> 注解</h5>\n<p>要进行高质量的性能测量是很难的，而且需要采用专门的工具。</p>\n<h5 id=\"注解-243\"><a class=\"markdownIt-Anchor\" href=\"#注解-243\">#</a> 注解</h5>\n<p>有些使用了 Unix 的  <code>time</code>  或者标准库的  <code>&lt;chrono&gt;</code>  的简单的微基准测量，有助于打破大多数明显的错误认识。<br>\n如果确实无法精确地测量完整系统的话，至少也要尝试对一些关键操作和算法进行测量。<br>\n性能剖析可以帮你发现系统的哪些部分是性能关键的。<br>\n你很可能会感觉意外。</p>\n<p>???</p>\n<h3 id=\"a-namerper-efficiencyaper7-设计应当允许优化\"><a class=\"markdownIt-Anchor\" href=\"#a-namerper-efficiencyaper7-设计应当允许优化\">#</a> <a name=\"Rper-efficiency\"></a>Per.7: 设计应当允许优化</h3>\n<h5 id=\"理由-271\"><a class=\"markdownIt-Anchor\" href=\"#理由-271\">#</a> 理由</h5>\n<p>因为我们经常需要对最初的设计进行优化。<br>\n因为忽略后续改进的可能性的设计是很难修改的。</p>\n<h5 id=\"示例-250\"><a class=\"markdownIt-Anchor\" href=\"#示例-250\">#</a> 示例</h5>\n<p>来自 C（以及 C++）的标准：</p>\n<pre><code>void qsort (void* base, size_t num, size_t size, int (*compar)(const void*, const void*));\n</code></pre>\n<p>什么情况会需要对内存进行排序呢？<br>\n时即上，我们需要对元素序列进行排序，通常它们存储于容器之中。<br>\n对  <code>qsort</code>  的调用抛弃了许多有用的信息（比如元素的类型），强制用户对其已知的信息<br>\n进行重复（比如元素的大小），并强制用户编写额外的代码（比如用于比较  <code>double</code>  的函数）。<br>\n这蕴含了程序员工作量的增加，易错，并剥夺了编译器为优化所需的信息。</p>\n<pre><code>double data[100];\n// ... 填充 a ...\n\n// 对从地址 data 开始的 100 块 sizeof(double) 大小\n// 的内存，用由 compare_doubles 所定义的顺序进行排序\nqsort(data, 100, sizeof(double), compare_doubles);\n</code></pre>\n<p>从接口设计的观点来看， <code>qsort</code>  抛弃了有用的信息。</p>\n<p>这样做可以更好（C++98）：</p>\n<pre><code>template&lt;typename Iter&gt;\n    void sort(Iter b, Iter e);  // sort [b:e)\n\nsort(data, data + 100);\n</code></pre>\n<p>这里，我们利用了编译器关于数组大小，元素类型，以及如何对  <code>double</code>  进行比较的知识。</p>\n<p>而以 C++20 的话，我们还可以做得更好：</p>\n<pre><code>// sortable 指定了 c 必须是一个\n// 可以用 &lt; 进行比较的元素的随机访问序列\nvoid sort(sortable auto&amp; c);\n\nsort(c);\n</code></pre>\n<p>其中的关键在于传递充分的信息以便能够选择一个好的实现。<br>\n这里给出的几个  <code>sort</code>  接口仍然有一个缺憾：<br>\n它们隐含地依赖于元素类型定义了小于（ <code>&lt;</code> ）运算符。<br>\n为使接口完整，我们需要另一个接受比较准则的版本：</p>\n<pre><code>// 用 r 比较 c 的元素\ntemplate&lt;random_access_range R, class C&gt; requires sortable&lt;R, C&gt;\nvoid sort(R&amp;&amp; r, C c);\n</code></pre>\n<p><code>sort</code>  的标准库规范提供了这两个版本和其他版本。</p>\n<h5 id=\"注解-244\"><a class=\"markdownIt-Anchor\" href=\"#注解-244\">#</a> 注解</h5>\n<p>不成熟的优化被称为<a href=\"#Rper-Knuth\">一切罪恶之源</a>，但这并不是轻视性能的理由。<br>\n考虑如何使设计可以为改进而进行修正绝不是不成熟的，而性能改进则是一种常见的改进要求。<br>\n我们的目标是建立一组习惯，使缺省情况就能得到高效，可维护，且可优化的代码。<br>\n特别是，当你编写并非一次性实现细节的函数时，应当考虑</p>\n<ul>\n<li>信息传递：<br>\n优先采用能够为后续的实现改进带来充分信息的简洁<a href=\"#S-interfaces\">接口</a>。<br>\n要注意信息会通过我们所提供的接口来流入和流出一个实现。</li>\n<li>紧凑的数据：默认情况<a href=\"#Rper-compact\">使用紧凑的数据</a>，比如  <code>std::vector</code> ，并<a href=\"#Rper-access\">系统化地进行访问</a>。<br>\n如果你觉得需要一种有链接的结构的话，应尝试构造接口使这个结构不会被用户所看到。</li>\n<li>函数的参数传递和返回：<br>\n对可改变和不可变的数据加以区分。<br>\n不要把资源管理的负担强加给用户。<br>\n不要把假性的间接强加给用户。<br>\n对通过接口传递信息采用<a href=\"#Rf-conventional\">符合惯例的方式</a>；<br>\n不合惯例的，以及 “优化过的” 数据传递方式可能会严重影响后续的重新实现。</li>\n<li>抽象：<br>\n不要过度泛化；视图提供每一种可能用法（和误用），并把每个设计决策都（通过编译时或运行时间接）<br>\n推迟到后面处理的设计，通常是复杂的，膨胀的，难于理解的混乱体。<br>\n应当从具体的例子进行泛化，泛化时要保持性能。<br>\n不要仅仅基于关于未来需求的推测而进行泛化。<br>\n理想情况是零开销泛化。</li>\n<li>程序库：<br>\n使用带有良好接口的程序库。<br>\n当没有可用的程序库时，就构建自己的，并模仿一个好程序库的接口风格。<br>\n<a href=\"#sl-the-standard-library\">标准库</a>是寻找模仿的一个好的第一来源。</li>\n<li>隔离：<br>\n通过将你所选择的接口提供给你的代码来将其和杂乱和老旧风格的代码之间进行隔离。<br>\n这有时候称为为有用或必须但杂乱的代码 “提供包装”。<br>\n不要让不良设计 “渗入” 你的代码中。</li>\n</ul>\n<h5 id=\"示例-251\"><a class=\"markdownIt-Anchor\" href=\"#示例-251\">#</a> 示例</h5>\n<p>考虑：</p>\n<pre><code>template&lt;class ForwardIterator, class T&gt;\nbool binary_search(ForwardIterator first, ForwardIterator last, const T&amp; val);\n</code></pre>\n<p><code>binary_search(begin(c), end(c), 7)</code>  能够得出  <code>7</code>  是否在  <code>c</code>  之中。<br>\n不过，它无法得出  <code>7</code>  在何处，或者是否有多于一个  <code>7</code> 。</p>\n<p>有时候仅把最小数量的信息传递回来（如这里的  <code>true</code>  或  <code>false</code> ）是足够的，但一个好的接口会<br>\n向调用方传递其所需的信息。因此，标准库还提供了</p>\n<pre><code>template&lt;class ForwardIterator, class T&gt;\nForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T&amp; val);\n</code></pre>\n<p><code>lower_bound</code>  返回第一个匹配元素（如果有）的迭代器，否则返回第一个大于  <code>val</code>  的元素的迭代器，找不到这样的元素时，返回  <code>last</code> 。</p>\n<p>不过  <code>lower_bound</code>  还是无法为所有用法返回足够的信息，因此标准库还提供了</p>\n<pre><code>template&lt;class ForwardIterator, class T&gt;\npair&lt;ForwardIterator, ForwardIterator&gt;\nequal_range(ForwardIterator first, ForwardIterator last, const T&amp; val);\n</code></pre>\n<p><code>equal_range</code>  返回迭代器的  <code>pair</code> ，指定匹配的第一个和最后一个之后的元素。</p>\n<pre><code>auto r = equal_range(begin(c), end(c), 7);\nfor (auto p = r.first; p != r.second; ++p)\n    cout &lt;&lt; *p &lt;&lt; '\\n';\n</code></pre>\n<p>显然，这三个接口都是以相同的基本代码实现的。<br>\n它们不过是将基本的二叉搜索算法表现给用户的三种方式，<br>\n包含从最简单（“让简单的事情简单！”）<br>\n到返回完整但不总是必要的信息（“不要隐藏有用的信息”）。<br>\n自然，构造这样一组接口是需要经验和领域知识的。</p>\n<h5 id=\"注解-245\"><a class=\"markdownIt-Anchor\" href=\"#注解-245\">#</a> 注解</h5>\n<p>接口的构建不要仅匹配你能想到的第一种实现和第一种用例。<br>\n一旦第一个初始实现完成后，应当进行复审；一旦它被部署出去，就很难对错误进行补救了。</p>\n<h5 id=\"注解-246\"><a class=\"markdownIt-Anchor\" href=\"#注解-246\">#</a> 注解</h5>\n<p>对效率的需求并不意味着对<a href=\"#Rper-low\">底层代码</a>的需求。<br>\n高层代码并不必然缓慢或膨胀。</p>\n<h5 id=\"注解-247\"><a class=\"markdownIt-Anchor\" href=\"#注解-247\">#</a> 注解</h5>\n<p>事物都是有成本的。<br>\n不要对成本过于偏执（当代计算机真的非常快），<br>\n但需要对你所使用的东西的成本的数量级有大致的概念。<br>\n例如，应当对<br>\n一次内存访问，<br>\n一次函数调用，<br>\n一次字符串比较，<br>\n一次系统调用，<br>\n一次磁盘访问，<br>\n以及一个通过网络的消息的成本有大致的概念。</p>\n<h5 id=\"注解-248\"><a class=\"markdownIt-Anchor\" href=\"#注解-248\">#</a> 注解</h5>\n<p>如果你只能想到一种实现的话，可能你并没有某种能够设计一个稳定接口的东西。<br>\n有可能它只不过是实现细节 —— 不是每段代码都需要一个稳定接口 —— 停下来想一想。<br>\n一个有用的问题是<br>\n “如果这个操作需要用多个线程实现的话，需要什么样的接口呢？向量化？”</p>\n<h5 id=\"注解-249\"><a class=\"markdownIt-Anchor\" href=\"#注解-249\">#</a> 注解</h5>\n<p>这条规则并不抵触<a href=\"#Rper-Knuth\">不要进行不成熟的优化</a>规则。<br>\n它对其进行了补充，鼓励程序员在有必要的时候，使后续的 —— 适当并且成熟的 —— 优化能够进行。</p>\n<h5 id=\"强制实施-256\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-256\">#</a> 强制实施</h5>\n<p>很麻烦。<br>\n也许查找  <code>void*</code>  函数参数能够找到妨碍后续优化的接口的例子。</p>\n<h3 id=\"a-namerper-typeaper10-依赖静态类型系统\"><a class=\"markdownIt-Anchor\" href=\"#a-namerper-typeaper10-依赖静态类型系统\">#</a> <a name=\"Rper-type\"></a>Per.10: 依赖静态类型系统</h3>\n<h5 id=\"理由-272\"><a class=\"markdownIt-Anchor\" href=\"#理由-272\">#</a> 理由</h5>\n<p>类型违规，弱类型（比如  <code>void*</code> ），以及低级代码（比如把序列当作独立字节进行操作）等会让优化器的工作变得困难很多。简单的代码通常比手工打造的复杂代码能够更好地优化。</p>\n<p>???</p>\n<h3 id=\"a-namerper-compaper11-把计算从运行时转移到编译期\"><a class=\"markdownIt-Anchor\" href=\"#a-namerper-compaper11-把计算从运行时转移到编译期\">#</a> <a name=\"Rper-Comp\"></a>Per.11: 把计算从运行时转移到编译期</h3>\n<h5 id=\"理由-273\"><a class=\"markdownIt-Anchor\" href=\"#理由-273\">#</a> 理由</h5>\n<p>减少代码大小和运行时间。<br>\n通过使用常量来避免数据竞争。<br>\n编译时捕获错误（并因而消除错误处理代码）。</p>\n<h5 id=\"示例-252\"><a class=\"markdownIt-Anchor\" href=\"#示例-252\">#</a> 示例</h5>\n<pre><code>double square(double d) &#123; return d*d; &#125;\nstatic double s2 = square(2);    // 旧式代码：动态初始化\n\nconstexpr double ntimes(double d, int n)   // 假定 0 &lt;= n\n&#123;\n        double m = 1;\n        while (n--) m *= d;\n        return m;\n&#125;\nconstexpr double s3 &#123;ntimes(2, 3)&#125;;  // 现代代码：编译期初始化\n</code></pre>\n<p>像  <code>s2</code>  的初始化这样的代码并不少见，尤其是比  <code>square()</code>  更复杂一些的初始化更是如此。<br>\n不过，与  <code>s3</code>  的初始化相比，它有两个问题：</p>\n<ul>\n<li>我们得忍受运行时的一次函数调用的开销</li>\n<li><code>s2</code>  在初始化开始前可能就被某个别的线程访问了。</li>\n</ul>\n<p>注意：常量是不可能发生数据竞争的。</p>\n<h5 id=\"示例-253\"><a class=\"markdownIt-Anchor\" href=\"#示例-253\">#</a> 示例</h5>\n<p>考虑一种流行的提供包装类的技术，在包装类自身之中存储小型对象，而把大型对象保存到堆上。</p>\n<pre><code>constexpr int on_stack_max = 20;\n\ntemplate&lt;typename T&gt;\nstruct Scoped &#123;     // 在 Scoped 中存储一个 T\n        // ...\n    T obj;\n&#125;;\n\ntemplate&lt;typename T&gt;\nstruct On_heap &#123;    // 在自由存储中存储一个 T\n        // ...\n        T* objp;\n&#125;;\n\ntemplate&lt;typename T&gt;\nusing Handle = typename std::conditional&lt;(sizeof(T) &lt;= on_stack_max),\n                    Scoped&lt;T&gt;,      // 第一种候选\n                    On_heap&lt;T&gt;      // 第二种候选\n               &gt;::type;\n\nvoid f()\n&#123;\n    Handle&lt;double&gt; v1;                   // double 在栈中\n    Handle&lt;std::array&lt;double, 200&gt;&gt; v2;  // array 保存到自由存储里\n    // ...\n&#125;\n</code></pre>\n<p>假定  <code>Scoped</code>  和  <code>On_heap</code>  均提供了兼容的用户接口。<br>\n这里我们在编译时计算出了最优的类型。<br>\n对于选择所要调用的最优函数，也有类似的技术。</p>\n<h5 id=\"注解-250\"><a class=\"markdownIt-Anchor\" href=\"#注解-250\">#</a> 注解</h5>\n<p>理想情况是，<em>不</em>试图在编译期执行所有的代码。<br>\n显然，大多数的运算都依赖于输入，因而它们没办法挪到编译期进行，<br>\n而除了这种逻辑限制外，实际情况是，复杂的编译期运算会严重增加编译时间，<br>\n并使调试变得复杂。<br>\n甚至编译期运算也可能使得代码变慢。<br>\n这种情况确实罕见，但当把一种通用运算分解为一组优化的子运算时，可能会导致指令高速缓存的效率变差。</p>\n<h5 id=\"强制实施-257\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-257\">#</a> 强制实施</h5>\n<ul>\n<li>找出可以（但尚不）是 constexpr 的简单函数。</li>\n<li>找出调用时其全部实参均为常量表达式的函数。</li>\n<li>找出可以为 constexpr 的宏。</li>\n</ul>\n<h3 id=\"a-namerper-aliasaper12-消除多余的别名\"><a class=\"markdownIt-Anchor\" href=\"#a-namerper-aliasaper12-消除多余的别名\">#</a> <a name=\"Rper-alias\"></a>Per.12: 消除多余的别名</h3>\n<p>???</p>\n<h3 id=\"a-namerper-indirectaper13-消除多余的间接\"><a class=\"markdownIt-Anchor\" href=\"#a-namerper-indirectaper13-消除多余的间接\">#</a> <a name=\"Rper-indirect\"></a>Per.13: 消除多余的间接</h3>\n<p>???</p>\n<h3 id=\"a-namerper-allocaper14-最小化分配和回收的次数\"><a class=\"markdownIt-Anchor\" href=\"#a-namerper-allocaper14-最小化分配和回收的次数\">#</a> <a name=\"Rper-alloc\"></a>Per.14: 最小化分配和回收的次数</h3>\n<p>???</p>\n<h3 id=\"a-namerper-alloc0aper15-请勿在关键逻辑分支中进行分配\"><a class=\"markdownIt-Anchor\" href=\"#a-namerper-alloc0aper15-请勿在关键逻辑分支中进行分配\">#</a> <a name=\"Rper-alloc0\"></a>Per.15: 请勿在关键逻辑分支中进行分配</h3>\n<p>???</p>\n<h3 id=\"a-namerper-compactaper16-使用紧凑的数据结构\"><a class=\"markdownIt-Anchor\" href=\"#a-namerper-compactaper16-使用紧凑的数据结构\">#</a> <a name=\"Rper-compact\"></a>Per.16: 使用紧凑的数据结构</h3>\n<h5 id=\"理由-274\"><a class=\"markdownIt-Anchor\" href=\"#理由-274\">#</a> 理由</h5>\n<p>性能通常都是由内存访问次数所决定的。</p>\n<p>???</p>\n<h3 id=\"a-namerper-structaper17-在时间关键的结构中应当先声明最常用的成员\"><a class=\"markdownIt-Anchor\" href=\"#a-namerper-structaper17-在时间关键的结构中应当先声明最常用的成员\">#</a> <a name=\"Rper-struct\"></a>Per.17: 在时间关键的结构中应当先声明最常用的成员</h3>\n<p>???</p>\n<h3 id=\"a-namerper-spaceaper18-空间即时间\"><a class=\"markdownIt-Anchor\" href=\"#a-namerper-spaceaper18-空间即时间\">#</a> <a name=\"Rper-space\"></a>Per.18: 空间即时间</h3>\n<h5 id=\"理由-275\"><a class=\"markdownIt-Anchor\" href=\"#理由-275\">#</a> 理由</h5>\n<p>性能通常都是由内存访问次数所决定的。</p>\n<p>???</p>\n<h3 id=\"a-namerper-accessaper19-进行可预测的内存访问\"><a class=\"markdownIt-Anchor\" href=\"#a-namerper-accessaper19-进行可预测的内存访问\">#</a> <a name=\"Rper-access\"></a>Per.19: 进行可预测的内存访问</h3>\n<h5 id=\"理由-276\"><a class=\"markdownIt-Anchor\" href=\"#理由-276\">#</a> 理由</h5>\n<p>性能对于 Cache 的性能非常敏感，而 Cache 算法则更喜欢对相邻数据进行的（通常是线性的）简单访问行为。</p>\n<h5 id=\"示例-254\"><a class=\"markdownIt-Anchor\" href=\"#示例-254\">#</a> 示例</h5>\n<pre><code>int matrix[rows][cols];\n\n// 不好\nfor (int c = 0; c &lt; cols; ++c)\n    for (int r = 0; r &lt; rows; ++r)\n        sum += matrix[r][c];\n\n// 好\nfor (int r = 0; r &lt; rows; ++r)\n    for (int c = 0; c &lt; cols; ++c)\n        sum += matrix[r][c];\n</code></pre>\n<h3 id=\"a-namerper-contextaper30-避免在关键路径中进行上下文切换\"><a class=\"markdownIt-Anchor\" href=\"#a-namerper-contextaper30-避免在关键路径中进行上下文切换\">#</a> <a name=\"Rper-context\"></a>Per.30: 避免在关键路径中进行上下文切换</h3>\n<p>???</p>\n<h1 id=\"a-names-concurrencyacp-并发与并行\"><a class=\"markdownIt-Anchor\" href=\"#a-names-concurrencyacp-并发与并行\">#</a> <a name=\"S-concurrency\"></a>CP: 并发与并行</h1>\n<p>我们经常想要我们的计算机同时运行许多任务（或者至少表现为同时运行它们）。<br>\n这有许多不同的原因（例如，需要仅用一个处理器等待许多事件，同时处理许多数据流，或者利用大量的硬件设施）<br>\n因此也由许多不同的用以表现并发和并行的基本设施。<br>\n我们这里将说明使用 ISO 标准 C++ 中用以表现基本并发和并行的设施的原则和规则。</p>\n<p>线程是对并发和并行编程支持的机器级别的基础。<br>\n使用线程允许互不相关地运行程序的多个部分，<br>\n同时共享相同的内存。并发编程很麻烦，<br>\n因为在线程之间保护共享的数据说起来容易做起来难。<br>\n使现存的单线程代码可以并发执行，<br>\n可以通过策略性地添加  <code>std::async</code>  或  <code>std::thread</code>  这样简单做到，<br>\n也可能需要进行完全的重写，这依赖于原始代码是否是以线程友好<br>\n的方式编写的。</p>\n<p>本文档中的并发 / 并行规则的设计有三个<br>\n目标：</p>\n<ul>\n<li>有助于编写可以被修改为能够在线程环境中使用<br>\n的代码。</li>\n<li>展示使用标准库所提供的线程原语的简洁，<br>\n安全的方式。</li>\n<li>对当并发和并行无法提供所需要的性能增益时应当如何做<br>\n提供指导。</li>\n</ul>\n<p>同样重要的一点，是要注意 C++ 的并发仍然是未完成的工作。<br>\nC<ins>11 引入了许多核心并发原语，C</ins>14 和 C<ins>17 对它们进行了改进，<br>\n而且在使 C</ins> 编写并发程序更加简单的方面<br>\n仍有许多关注。我们预计这里的一些与程序库相关<br>\n的指导方针会随着时间有大量的改动。</p>\n<p>这一部分需要大量的工作（显然如此）。<br>\n请注意我们的规则是从相对非专家们入手的。<br>\n真正的专家们还请稍等；<br>\n我们欢迎贡献者，<br>\n但请为正在努力使他们的并发程序正确且高效的大多数程序员着想。</p>\n<p>并发和并行规则概览：</p>\n<ul>\n<li><a href=\"#Rconc-multi\">CP.1: 假定你的代码将作为多线程程序的一部分而运行</a></li>\n<li><a href=\"#Rconc-races\">CP.2: 避免数据竞争</a></li>\n<li><a href=\"#Rconc-data\">CP.3: 最小化可写数据的明确共享</a></li>\n<li><a href=\"#Rconc-task\">CP.4: 以任务而不是线程的角度思考</a></li>\n<li><a href=\"#Rconc-volatile\">CP.8: 不要为同步而使用  <code>volatile</code> </a></li>\n<li><a href=\"#Rconc-tools\">CP.9: 只要可行，就使用工具对并发代码进行验证</a></li>\n</ul>\n<p><strong>参见</strong>：</p>\n<ul>\n<li><a href=\"#SScp-con\">CP.con: 并发</a></li>\n<li><a href=\"#SScp-coro\">CP.coro: 协程</a></li>\n<li><a href=\"#SScp-par\">CP.par: 并行</a></li>\n<li><a href=\"#SScp-mess\">CP.mess: 消息传递</a></li>\n<li><a href=\"#SScp-vec\">CP.vec: 向量化</a></li>\n<li><a href=\"#SScp-free\">CP.free: 无锁编程</a></li>\n<li><a href=\"#SScp-etc\">CP.etc: 其他并发规则</a></li>\n</ul>\n<h3 id=\"a-namerconc-multiacp1-假定你的代码将作为多线程程序的一部分而运行\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-multiacp1-假定你的代码将作为多线程程序的一部分而运行\">#</a> <a name=\"Rconc-multi\"></a>CP.1: 假定你的代码将作为多线程程序的一部分而运行</h3>\n<h5 id=\"理由-277\"><a class=\"markdownIt-Anchor\" href=\"#理由-277\">#</a> 理由</h5>\n<p>很难说现在或者未来什么时候会不会需要使用并发。<br>\n代码是会被重用的。<br>\n程序的其他使用了线程的部分可能会使用某个未使用线程的程序库。<br>\n请注意这条规则对于程序库代码来说最紧迫，而对独立的应用程序来说则最不紧迫。<br>\n不过，久而久之，代码片段可能出现在意想不到的地方。</p>\n<h5 id=\"示例不好-110\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-110\">#</a> 示例，不好</h5>\n<pre><code>double cached_computation(int x)\n&#123;\n    // 不好：这些静态变量导致多线程的使用情况中的数据竞争\n    static int cached_x = 0.0;\n    static double cached_result = COMPUTATION_OF_ZERO;\n\n    if (cached_x != x) &#123;\n        cached_x = x;\n        cached_result = computation(x);\n    &#125;\n    return cached_result;\n&#125;\n</code></pre>\n<p>虽然  <code>cached_computation</code>  在单线程环境中可以正确工作，但在多线程环境中，其两个  <code>static</code>  变量将导致数据竞争进而发生未定义的行为。</p>\n<h5 id=\"示例好-23\"><a class=\"markdownIt-Anchor\" href=\"#示例好-23\">#</a> 示例，好</h5>\n<pre><code>struct ComputationCache &#123;\n    int cached_x = 0;\n    double cached_result = COMPUTATION_OF_ZERO;\n\n    double compute(int x) &#123;\n        if (cached_x != x) &#123;\n            cached_x = x;\n            cached_result = computation(x);\n        &#125;\n        return cached_result;\n    &#125;\n&#125;;\n</code></pre>\n<p>这里的缓存作为  <code>ComputationCache</code>  对象的成员数据保存，而非共享的静态状态。<br>\n这项重构本质上是将关注点委派给了调用方：<br>\n单线程程序可能仍会选择采用一个全局的  <code>ComputationCache</code>  对象，<br>\n而多线程程序可能会为每个线程准备一个  <code>ComputationCache</code> ，或者为任意定义的 “上下文” 每个准备一个。<br>\n重构后的函数不再试图管理  <code>cached_x</code>  的分配。<br>\n这方面可以看做是对单一职责原则（SRP）的一次应用。</p>\n<p>在这个特定的例子中，为线程安全性进行的重构同样改进了其在单线程程序中的可用性。<br>\n不难想象，某个单线程程序可能需要在程序的不同部分中使用两个  <code>ComputationCache</code>  实例，<br>\n并且它们并不会覆盖掉互相的缓冲数据。</p>\n<p>还有其他的一些方法，可以为针对标准多线程环境（就是唯一的并发形式是  <code>std::thread</code>  的环境）编写的<br>\n代码添加线程安全性：</p>\n<ul>\n<li>将状态变量标为  <code>thread_local</code>  而非  <code>static</code> 。</li>\n<li>实现并发控制逻辑，例如，用一个  <code>static std::mutex</code>  来保护对这两个  <code>static</code>  变量的访问。</li>\n<li>拒绝在多线程环境中进行构建和 / 或运行。</li>\n<li>提供两个实现，一个用在单线程环境中，另一个用在多线程环境中。</li>\n</ul>\n<h5 id=\"例外-53\"><a class=\"markdownIt-Anchor\" href=\"#例外-53\">#</a> 例外</h5>\n<p>永远不会在多线程环境中执行的代码。</p>\n<p>要小心的是：有许多例子，“认为” 永远不会在多线程程序中执行的代码<br>\n却真的在多线程程序中执行了，通常是在多年以后。<br>\n一般来说，这种程序将导致进行痛苦的移除数据竞争的工作。<br>\n因此，确实有意不在多线程环境中执行的代码，应当清晰地进行标注，而且理想情况下应当利用编译或运行时的强制机制来提早检测到这种使用情况。</p>\n<h3 id=\"a-namerconc-racesacp2-避免数据竞争\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-racesacp2-避免数据竞争\">#</a> <a name=\"Rconc-races\"></a>CP.2: 避免数据竞争</h3>\n<h5 id=\"理由-278\"><a class=\"markdownIt-Anchor\" href=\"#理由-278\">#</a> 理由</h5>\n<p>不这样的话，则任何东西都不保证能工作，而且可能出现微妙的错误。</p>\n<h5 id=\"注解-251\"><a class=\"markdownIt-Anchor\" href=\"#注解-251\">#</a> 注解</h5>\n<p>简而言之，当两个线程并发（未同步）地访问同一个对象，且至少一方为写入方（实施某个非  <code>const</code>  操作）时，就会出现数据竞争。<br>\n有关如何正确使用同步来消除数据竞争的更多信息，请求教于一本有关并发的优秀书籍（参见 <a href=\"#Rconc-literature\">认真学习文献</a>）。</p>\n<h5 id=\"示例不好-111\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-111\">#</a> 示例，不好</h5>\n<p>有大量存在数据竞争的例子，其中的一些现在这个时候就运行在<br>\n产品软件之中。一个非常简单的例子是：</p>\n<pre><code>int get_id()\n&#123;\n  static int id = 1;\n  return id++;\n&#125;\n</code></pre>\n<p>这里的增量操作就是数据竞争的一个例子。这可能以许多方式导致发生错误，<br>\n包括：</p>\n<ul>\n<li>线程 A 加载  <code>id</code>  的值，OS 上下文切换使 A 离开<br>\n一段时间，其中有其他线程创建了上百个 ID。线程 A<br>\n 再次允许执行，而  <code>id</code>  被写回到那个位置，其值为 A<br>\n 所读取的  <code>id</code>  值加一。</li>\n<li>线程 A 和 B 同时加载  <code>id</code>  并进行增量。它们都将获得<br>\n相同的 ID。</li>\n</ul>\n<p>局部静态变量是数据竞争的一种常见来源。</p>\n<h5 id=\"示例不好-112\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-112\">#</a> 示例，不好</h5>\n<pre><code>void f(fstream&amp; fs, regex pattern)\n&#123;\n    array&lt;double, max&gt; buf;\n    int sz = read_vec(fs, buf, max);            // 从 fs 读取到 buf 中\n    gsl::span&lt;double&gt; s &#123;buf&#125;;\n    // ...\n    auto h1 = async([&amp;] &#123; sort(std::execution::par, s); &#125;);     // 产生一个进行排序的任务\n    // ...\n    auto h2 = async([&amp;] &#123; return find_all(buf, sz, pattern); &#125;);   // 产生一个查找匹配的任务\n    // ...\n&#125;\n</code></pre>\n<p>这里，在  <code>buf</code>  的元素上有一个（很讨厌的）数据竞争（ <code>sort</code>  既会读取也会写入）。<br>\n所有的数据竞争都很讨厌。<br>\n我们这里设法在栈上的数据上造成了数据竞争。<br>\n不是所有数据竞争都像这个这样容易找出来的。</p>\n<h5 id=\"示例不好-113\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-113\">#</a> 示例，不好</h5>\n<pre><code>// 未用锁进行控制的代码\n\nunsigned val;\n\nif (val &lt; 5) &#123;\n    // ... 其他线程可能在这里改动 val ...\n    switch (val) &#123;\n    case 0: // ...\n    case 1: // ...\n    case 2: // ...\n    case 3: // ...\n    case 4: // ...\n    &#125;\n&#125;\n</code></pre>\n<p>这里，若编译器不知道  <code>val</code>  可能改变，它最可能将这个  <code>switch</code>  实现为一个有五个项目的跳转表。<br>\n然后，超出  <code>[0..4]</code>  范围的  <code>val</code>  值将会导致跳转到程序中的任何可能位置的地址，从那个位置继续执行。<br>\n真的，当你遇到数据竞争时什么都可能发生。<br>\n实际上可能更为糟糕：通过查看生成的代码，是可以确定这个走偏的跳转针对给定的值将会跳转到哪里的；<br>\n这就是一种安全风险。</p>\n<h5 id=\"强制实施-258\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-258\">#</a> 强制实施</h5>\n<p>有些事是可能做到的，至少要做一些事。<br>\n有一些商用和开源的工具试图处理这种问题，<br>\n但要注意的是任何工具解决方案都有其成本和盲点。<br>\n静态工具通常会有许多漏报，而动态工具则通常有显著的成本。<br>\n我们希望有更好的工具。<br>\n使用多个工具可以找到比单个工具更多的问题。</p>\n<p>还有其他方式可以缓解发生数据竞争的机会：</p>\n<ul>\n<li>避免全局数据</li>\n<li>避免  <code>static</code>  变量</li>\n<li>更多地使用栈上的具体类型（且不要过多地把指针到处传递）</li>\n<li>更多地使用不可变数据（字面量， <code>constexpr</code> ，以及  <code>const</code> ）</li>\n</ul>\n<h3 id=\"a-namerconc-dataacp3-最小化可写数据的明确共享\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-dataacp3-最小化可写数据的明确共享\">#</a> <a name=\"Rconc-data\"></a>CP.3: 最小化可写数据的明确共享</h3>\n<h5 id=\"理由-279\"><a class=\"markdownIt-Anchor\" href=\"#理由-279\">#</a> 理由</h5>\n<p>如果不共享可写数据的话，就不会发生数据竞争。<br>\n越少进行共享，你就越少有机会忘掉对访问进行同步（而发生数据竞争）。<br>\n越少进行共享，你就越少有机会需要等待锁定（并改进性能）。</p>\n<h5 id=\"示例-255\"><a class=\"markdownIt-Anchor\" href=\"#示例-255\">#</a> 示例</h5>\n<pre><code>bool validate(const vector&lt;Reading&gt;&amp;);\nGraph&lt;Temp_node&gt; temperature_gradients(const vector&lt;Reading&gt;&amp;);\nImage altitude_map(const vector&lt;Reading&gt;&amp;);\n// ...\n\nvoid process_readings(const vector&lt;Reading&gt;&amp; surface_readings)\n&#123;\n    auto h1 = async([&amp;] &#123; if (!validate(surface_readings)) throw Invalid_data&#123;&#125;; &#125;);\n    auto h2 = async([&amp;] &#123; return temperature_gradients(surface_readings); &#125;);\n    auto h3 = async([&amp;] &#123; return altitude_map(surface_readings); &#125;);\n    // ...\n    h1.get();\n    auto v2 = h2.get();\n    auto v3 = h3.get();\n    // ...\n&#125;\n</code></pre>\n<p>没有这些  <code>const</code>  的话，我们就必须为潜在的数据竞争而为在  <code>surface_readings</code>  上的所有异步函数调用进行复审。<br>\n使  <code>surface_readings</code>  （对于这个函数）为  <code>const</code>  允许我们仅在函数体代码中进行推理。</p>\n<h5 id=\"注解-252\"><a class=\"markdownIt-Anchor\" href=\"#注解-252\">#</a> 注解</h5>\n<p>不可变数据可以安全并高效地共享。<br>\n无须对其进行锁定：不可能在常量上发生数据竞争。<br>\n另请参见<a href=\"#SScp-mess\"> CP.mess: 消息传递</a>和<a href=\"#Rconc-data-by-value\"> CP.31: 优先采用按值传递</a>。</p>\n<h5 id=\"强制实施-259\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-259\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerconc-taskacp4-以任务而不是线程的角度思考\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-taskacp4-以任务而不是线程的角度思考\">#</a> <a name=\"Rconc-task\"></a>CP.4: 以任务而不是线程的角度思考</h3>\n<h5 id=\"理由-280\"><a class=\"markdownIt-Anchor\" href=\"#理由-280\">#</a> 理由</h5>\n<p><code>thread</code>  是一种实现概念，一种针对机器的思考方式。<br>\n任务则是一种应用概念，有时候你可以使任务和其他任务并发执行。<br>\n应用概念更容易进行推理。</p>\n<h5 id=\"理由-281\"><a class=\"markdownIt-Anchor\" href=\"#理由-281\">#</a> 理由</h5>\n<pre><code>void some_fun(const std::string&amp; msg)\n&#123;\n    std::thread publisher([=] &#123; std::cout &lt;&lt; msg; &#125;);      // 不好: 表达性不足\n                                                           //       且更易错\n    auto pubtask = std::async([=] &#123; std::cout &lt;&lt; msg; &#125;);  // OK\n    // ...\n    publisher.join();\n&#125;\n</code></pre>\n<h5 id=\"注解-253\"><a class=\"markdownIt-Anchor\" href=\"#注解-253\">#</a> 注解</h5>\n<p>除了  <code>async()</code>  之外，标准库中的设施都是底层的，面向机器的，线程和锁层次的设施。<br>\n这是一种必须的基础，但我们不得不尝试提升抽象的层次：为提供生产率，可靠性，以及性能。<br>\n这对于采用更高层次的，更加面向应用的程序库（如果可能就建立在标准库设施上）的强有力的理由。</p>\n<h5 id=\"强制实施-260\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-260\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerconc-volatileacp8-不要为同步而使用-volatile\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-volatileacp8-不要为同步而使用-volatile\">#</a> <a name=\"Rconc-volatile\"></a>CP.8: 不要为同步而使用  <code>volatile</code></h3>\n<h5 id=\"理由-282\"><a class=\"markdownIt-Anchor\" href=\"#理由-282\">#</a> 理由</h5>\n<p>和其他语言不同，C++ 中的  <code>volatile</code>  并不提供原子性，不会在线程之间进行同步，<br>\n而且不会防止指令重排（无论编译器还是硬件）。<br>\n它和并发完全没有关系。</p>\n<h5 id=\"示例不好-114\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-114\">#</a> 示例，不好</h5>\n<pre><code>int free_slots = max_slots; // 当前的对象内存的来源\n\nPool* use()\n&#123;\n    if (int n = free_slots--) return &amp;pool[n];\n&#125;\n</code></pre>\n<p>这里有一个问题：<br>\n这在单线程程序中是完全正确的代码，但若有两个线程执行，<br>\n并且在  <code>free_slots</code>  上发生竞争条件时，两个线程就可能拿到相同的值和  <code>free_slots</code> 。<br>\n这（显然）是不好的数据竞争，受过其他语言训练的人可能会试图这样修正：</p>\n<pre><code>volatile int free_slots = max_slots; // 当前的对象内存的来源\n\nPool* use()\n&#123;\n    if (int n = free_slots--) return &amp;pool[n];\n&#125;\n</code></pre>\n<p>这并没有同步效果：数据竞争仍然存在！</p>\n<p>C++ 对此的机制是  <code>atomic</code>  类型：</p>\n<pre><code>atomic&lt;int&gt; free_slots = max_slots; // 当前的对象内存的来源\n\nPool* use()\n&#123;\n    if (int n = free_slots--) return &amp;pool[n];\n&#125;\n</code></pre>\n<p>现在的  <code>--</code>  操作是原子性的，<br>\n而不是可能被另一个线程介入其独立操作之间的读 - 增量 - 写序列。</p>\n<h5 id=\"替代方案-15\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-15\">#</a> 替代方案</h5>\n<p>在某些其他语言中曾经使用  <code>volatile</code>  的地方使用  <code>atomic</code>  类型。<br>\n为更加复杂的例子使用  <code>mutex</code> 。</p>\n<h5 id=\"另见-2\"><a class=\"markdownIt-Anchor\" href=\"#另见-2\">#</a> 另见</h5>\n<p><a href=\"#Rconc-volatile2\"> <code>volatile</code>  的（罕见）恰当用法</a></p>\n<h3 id=\"a-namerconc-toolsacp9-只要可行就使用工具对并发代码进行验证\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-toolsacp9-只要可行就使用工具对并发代码进行验证\">#</a> <a name=\"Rconc-tools\"></a>CP.9: 只要可行，就使用工具对并发代码进行验证</h3>\n<p>经验表明，让并发代码正确是特别难的，<br>\n而编译期检查、运行时检查和测试在找出并发错误方面，<br>\n并没有如同在顺序代码中找出错误时那么有效。<br>\n一些微妙的并发错误可能会造成显著的不良后果，包括内存破坏，死锁，和安全漏洞等。</p>\n<h5 id=\"示例-256\"><a class=\"markdownIt-Anchor\" href=\"#示例-256\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"注解-254\"><a class=\"markdownIt-Anchor\" href=\"#注解-254\">#</a> 注解</h5>\n<p>线程安全性是一种有挑战性的任务，有经验的程序员通常可以做得更好一些：缓解这些风险的一种重要策略是运用工具。<br>\n现存有不少这样的工具，既有商用的也有开源的，既有研究性的也有产品级的。<br>\n遗憾的是，人们的需求和约束条件之间有巨大的差别，使我们无法给出特定的建议，<br>\n但我们可以提一些：</p>\n<ul>\n<li>\n<p>静态强制实施工具：<span class=\"exturl\" data-url=\"aHR0cDovL2NsYW5nLmxsdm0ub3JnL2RvY3MvVGhyZWFkU2FmZXR5QW5hbHlzaXMuaHRtbA==\">clang</span><br>\n 和一些老版本的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9nY2MuZ251Lm9yZy93aWtpL1RocmVhZFNhZmV0eUFubm90YXRpb24=\">GCC</span><br>\n 都提供了一些针对线程安全性性质的静态代码标注。<br>\n统一地采用这项技术可以将许多种类的线程安全性错误变为编译时的错误。<br>\n这些代码标注一般都是局部的（将某个特定成员变量标记为又一个特定的互斥体进行防护），<br>\n且一般都易于学习使用。但与许多的静态工具一样，它经常会造成漏报；<br>\n这些情况应当被发现但却被其忽略了。</p>\n</li>\n<li>\n<p>动态强制实施工具：Clang 的 <span class=\"exturl\" data-url=\"aHR0cDovL2NsYW5nLmxsdm0ub3JnL2RvY3MvVGhyZWFkU2FuaXRpemVyLmh0bWw=\">Thread Sanitizer</span>（即 TSAN）<br>\n是动态工具的一个强有力的例子：它改变你的程序的构建和执行，向其中添加对内存访问的簿记工作，<br>\n精确地识别你的二进制程序的一次特定执行中发生的数据竞争。<br>\n使用它的代价在内存上（多数情况为五到十倍），也拖慢 CPU（二到二十倍）。<br>\n像这样的动态工具，在集成测试，金丝雀推送，以及在多个线程上操作的单元测试上实施是最好的。<br>\n它是与工作负载相关的：一旦 TSAN 识别了一个问题，那它就是实际发生的数据竞争，<br>\n但它只能识别出一次特定的执行之中发生的竞争。</p>\n</li>\n</ul>\n<h5 id=\"强制实施-261\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-261\">#</a> 强制实施</h5>\n<p>对于特定的应用，应用的构建者来选择哪些支持工具是有价值的。</p>\n<h2 id=\"a-namesscp-conacpcon-并发\"><a class=\"markdownIt-Anchor\" href=\"#a-namesscp-conacpcon-并发\">#</a> <a name=\"SScp-con\"></a>CP.con: 并发</h2>\n<p>这个部分所关注的是相对比较专门的通过共享数据进行多线程通信的用法。</p>\n<ul>\n<li>有关并行算法，参见<a href=\"#SScp-par\">并行</a>。</li>\n<li>有关不使用明确共享的任务间，通信参见<a href=\"#SScp-mess\">消息传递</a>。</li>\n<li>有关向量并行代码，参见<a href=\"#SScp-vec\">向量化</a>。</li>\n<li>有关无锁编程，参见<a href=\"#SScp-free\">无锁</a>。</li>\n</ul>\n<p>并发规则概览：</p>\n<ul>\n<li><a href=\"#Rconc-raii\">CP.20: 使用 RAII，绝不使用普通的  <code>lock()</code> / <code>unlock()</code> </a></li>\n<li><a href=\"#Rconc-lock\">CP.21: 用  <code>std::lock()</code>  或  <code>std::scoped_lock</code>  来获得多个  <code>mutex</code> </a></li>\n<li><a href=\"#Rconc-unknown\">CP.22: 绝不在持有锁的时候调用未知的代码（比如回调）</a></li>\n<li><a href=\"#Rconc-join\">CP.23: 把联结的  <code>thread</code>  看作是有作用域的容器</a></li>\n<li><a href=\"#Rconc-detach\">CP.24: 把  <code>thread</code>  看作是全局的容器</a></li>\n<li><a href=\"#Rconc-joining_thread\">CP.25: 优先采用  <code>gsl::joining_thread</code>  而不是  <code>std::thread</code> </a></li>\n<li><a href=\"#Rconc-detached_thread\">CP.26: 不要  <code>detach()</code>  线程</a></li>\n<li><a href=\"#Rconc-data-by-value\">CP.31: 少量数据在线程之间按值传递，而不是通过引用或指针传递</a></li>\n<li><a href=\"#Rconc-shared\">CP.32: 用  <code>shared_ptr</code>  在无关的  <code>thread</code>  之间共享所有权</a></li>\n<li><a href=\"#Rconc-switch\">CP.40: 最小化上下文切换</a></li>\n<li><a href=\"#Rconc-create\">CP.41: 最小化线程的创建和销毁</a></li>\n<li><a href=\"#Rconc-wait\">CP.42: 不要无条件地  <code>wait</code> </a></li>\n<li><a href=\"#Rconc-time\">CP.43: 最小化临界区的时间耗费</a></li>\n<li><a href=\"#Rconc-name\">CP.44: 记得为  <code>lock_guard</code>  和  <code>unique_lock</code>  命名</a></li>\n<li><a href=\"#Rconc-mutex\">CP.50:  <code>mutex</code>  要和其所护卫的数据一起定义。一旦可能就使用  <code>synchronized_value&lt;T&gt;</code> </a></li>\n<li>??? 何时使用 spinlock</li>\n<li>??? 何时使用  <code>try_lock()</code></li>\n<li>??? 何时应优先使用  <code>lock_guard</code>  而不是  <code>unique_lock</code></li>\n<li>??? 时序多工</li>\n<li>??? 何时 / 如何使用  <code>new thread</code></li>\n</ul>\n<h3 id=\"a-namerconc-raiiacp20-使用-raii绝不使用普通的-lockunlock\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-raiiacp20-使用-raii绝不使用普通的-lockunlock\">#</a> <a name=\"Rconc-raii\"></a>CP.20: 使用 RAII，绝不使用普通的  <code>lock()</code> / <code>unlock()</code></h3>\n<h5 id=\"理由-283\"><a class=\"markdownIt-Anchor\" href=\"#理由-283\">#</a> 理由</h5>\n<p>避免源于未释放的锁定的令人讨厌的错误。</p>\n<h5 id=\"示例不好-115\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-115\">#</a> 示例，不好</h5>\n<pre><code>mutex mtx;\n\nvoid do_stuff()\n&#123;\n    mtx.lock();\n    // ... 做一些事 ...\n    mtx.unlock();\n&#125;\n</code></pre>\n<p>或早或晚都会有人忘记  <code>mtx.unlock()</code> ，在  <code>... 做一些事 ...</code>  中放入一个  <code>return</code> ，抛出异常，或者别的什么。</p>\n<pre><code>mutex mtx;\n\nvoid do_stuff()\n&#123;\n    unique_lock&lt;mutex&gt; lck &#123;mtx&#125;;\n    // ... 做一些事 ...\n&#125;\n</code></pre>\n<h5 id=\"强制实施-262\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-262\">#</a> 强制实施</h5>\n<p>标记对成员  <code>lock()</code>  和  <code>unlock()</code>  的调用。 ???</p>\n<h3 id=\"a-namerconc-lockacp21-用-stdlock-或-stdscoped_lock-来获得多个-mutex\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-lockacp21-用-stdlock-或-stdscoped_lock-来获得多个-mutex\">#</a> <a name=\"Rconc-lock\"></a>CP.21: 用  <code>std::lock()</code>  或  <code>std::scoped_lock</code>  来获得多个  <code>mutex</code></h3>\n<h5 id=\"理由-284\"><a class=\"markdownIt-Anchor\" href=\"#理由-284\">#</a> 理由</h5>\n<p>避免在多个  <code>mutex</code>  上造成死锁。</p>\n<h5 id=\"示例-257\"><a class=\"markdownIt-Anchor\" href=\"#示例-257\">#</a> 示例</h5>\n<p>下面将导致死锁：</p>\n<pre><code>// 线程 1\nlock_guard&lt;mutex&gt; lck1(m1);\nlock_guard&lt;mutex&gt; lck2(m2);\n\n// 线程 2\nlock_guard&lt;mutex&gt; lck2(m2);\nlock_guard&lt;mutex&gt; lck1(m1);\n</code></pre>\n<p>代之以使用  <code>lock()</code> ：</p>\n<pre><code>// 线程 1\nlock(m1, m2);\nlock_guard&lt;mutex&gt; lck1(m1, defer_lock);\nlock_guard&lt;mutex&gt; lck2(m2, defer_lock);\n\n// 线程 2\nlock(m2, m1);\nlock_guard&lt;mutex&gt; lck2(m2, defer_lock);\nlock_guard&lt;mutex&gt; lck1(m1, defer_lock);\n</code></pre>\n<p>或者（这样更佳，但仅为 C++17）：</p>\n<pre><code>// 线程 1\nscoped_lock&lt;mutex, mutex&gt; lck1(m1, m2);\n\n// 线程 2\nscoped_lock&lt;mutex, mutex&gt; lck2(m2, m1);\n</code></pre>\n<p>这样， <code>thread1</code>  和  <code>thread2</code>  的作者们仍然未在  <code>mutex</code>  的顺序上达成一致，但顺序不再是问题了。</p>\n<h5 id=\"注解-255\"><a class=\"markdownIt-Anchor\" href=\"#注解-255\">#</a> 注解</h5>\n<p>在实际代码中， <code>mutex</code>  的命名很少便于程序员记得某种有意的关系和有意的获取顺序。<br>\n在实际代码中， <code>mutex</code>  并不总是便于在连续代码行中依次获取的。</p>\n<h5 id=\"注解-256\"><a class=\"markdownIt-Anchor\" href=\"#注解-256\">#</a> 注解</h5>\n<p>在 C++17 中，可以编写普通的</p>\n<pre><code>lock_guard lck1(m1, adopt_lock);\n</code></pre>\n<p>而让  <code>mutex</code>  类型被推断出来。</p>\n<h5 id=\"强制实施-263\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-263\">#</a> 强制实施</h5>\n<p>检测多个  <code>mutex</code>  的获取。<br>\n这一般来说是无法确定的，但找出常见的简单例子（比如上面这个）则比较容易。</p>\n<h3 id=\"a-namerconc-unknownacp22-绝不在持有锁的时候调用未知的代码比如回调\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-unknownacp22-绝不在持有锁的时候调用未知的代码比如回调\">#</a> <a name=\"Rconc-unknown\"></a>CP.22: 绝不在持有锁的时候调用未知的代码（比如回调）</h3>\n<h5 id=\"理由-285\"><a class=\"markdownIt-Anchor\" href=\"#理由-285\">#</a> 理由</h5>\n<p>如果不了解代码做了什么，就有死锁的风险。</p>\n<h5 id=\"示例-258\"><a class=\"markdownIt-Anchor\" href=\"#示例-258\">#</a> 示例</h5>\n<pre><code>void do_this(Foo* p)\n&#123;\n    lock_guard&lt;mutex&gt; lck &#123;my_mutex&#125;;\n    // ... 做一些事 ...\n    p-&gt;act(my_data);\n    // ...\n&#125;\n</code></pre>\n<p>如果不知道  <code>Foo::act</code>  会干什么（可能它是一个虚函数，调用某个还未编写的某个派生类成员），<br>\n它可能会（递归地）调用  <code>do_this</code>  因而在  <code>my_mutex</code>  上造成死锁。<br>\n可能它会在某个别的  <code>mutex</code>  上锁定而无法在适当的时间内返回，对任何调用了  <code>do_this</code>  的代码造成延迟。</p>\n<h5 id=\"示例-259\"><a class=\"markdownIt-Anchor\" href=\"#示例-259\">#</a> 示例</h5>\n<p>“调用未知代码” 问题的一个常见例子是调用了试图在相同对象上进行锁定访问的函数。<br>\n这种问题通常可以用  <code>recursive_mutex</code>  来解决。例如：</p>\n<pre><code>recursive_mutex my_mutex;\n\ntemplate&lt;typename Action&gt;\nvoid do_something(Action f)\n&#123;\n    unique_lock&lt;recursive_mutex&gt; lck &#123;my_mutex&#125;;\n    // ... 做一些事 ...\n    f(this);    // f 将会对 *this 做一些事\n    // ...\n&#125;\n</code></pre>\n<p>如果如同其很可能做的那样， <code>f()</code>  调用了  <code>*this</code>  的某个操作的话，我们就必须保证在调用之前对象的不变式是满足的。</p>\n<h5 id=\"强制实施-264\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-264\">#</a> 强制实施</h5>\n<ul>\n<li>当持有非递归的  <code>mutex</code>  时调用虚函数则进行标记。</li>\n<li>当持有非递归的  <code>mutex</code>  时调用回调则进行标记。</li>\n</ul>\n<h3 id=\"a-namerconc-joinacp23-把联结的-thread-看作是有作用域的容器\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-joinacp23-把联结的-thread-看作是有作用域的容器\">#</a> <a name=\"Rconc-join\"></a>CP.23: 把联结的  <code>thread</code>  看作是有作用域的容器</h3>\n<h5 id=\"理由-286\"><a class=\"markdownIt-Anchor\" href=\"#理由-286\">#</a> 理由</h5>\n<p>为了维护指针安全性并避免泄漏，需要考虑  <code>thread</code>  所使用的指针。<br>\n如果  <code>thread</code>  联结了，我们可以安全地把指向这个  <code>thread</code>  所在作用域及其外围作用域中的对象的指针传递给它。</p>\n<h5 id=\"示例-260\"><a class=\"markdownIt-Anchor\" href=\"#示例-260\">#</a> 示例</h5>\n<pre><code>void f(int* p)\n&#123;\n    // ...\n    *p = 99;\n    // ...\n&#125;\nint glob = 33;\n\nvoid some_fct(int* p)\n&#123;\n    int x = 77;\n    joining_thread t0(f, &amp;x);           // OK\n    joining_thread t1(f, p);            // OK\n    joining_thread t2(f, &amp;glob);        // OK\n    auto q = make_unique&lt;int&gt;(99);\n    joining_thread t3(f, q.get());      // OK\n    // ...\n&#125;\n</code></pre>\n<p><code>gsl::joining_thread</code>  是一种  <code>std::thread</code> ，其析构函数进行联结且不可被  <code>detached()</code> 。<br>\n这里的 “OK” 表明对象能够在  <code>thread</code>  可以使用指向它的指针时一直处于作用域（“存活”）。<br>\n <code>thread</code>  运行的并发性并不会影响这里的生存期或所有权问题；<br>\n这些  <code>thread</code>  可以仅仅被看成是从  <code>some_fct</code>  中调用的函数对象。</p>\n<h5 id=\"强制实施-265\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-265\">#</a> 强制实施</h5>\n<p>确保  <code>joining_thread</code>  不会  <code>detach()</code> 。<br>\n之后，可以实施（针对局部对象的）常规的生存期和所有权强制实施方案。</p>\n<h3 id=\"a-namerconc-detachacp24-把-thread-看作是全局的容器\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-detachacp24-把-thread-看作是全局的容器\">#</a> <a name=\"Rconc-detach\"></a>CP.24: 把  <code>thread</code>  看作是全局的容器</h3>\n<h5 id=\"理由-287\"><a class=\"markdownIt-Anchor\" href=\"#理由-287\">#</a> 理由</h5>\n<p>为了维护指针安全性并避免泄漏，需要考虑  <code>thread</code>  所使用的指针。<br>\n如果  <code>thread</code>  脱离了，我们只可以安全地把指向静态和自由存储的对象的指针传递给它。</p>\n<h5 id=\"示例-261\"><a class=\"markdownIt-Anchor\" href=\"#示例-261\">#</a> 示例</h5>\n<pre><code>void f(int* p)\n&#123;\n    // ...\n    *p = 99;\n    // ...\n&#125;\n\nint glob = 33;\n\nvoid some_fct(int* p)\n&#123;\n    int x = 77;\n    std::thread t0(f, &amp;x);           // 不好\n    std::thread t1(f, p);            // 不好\n    std::thread t2(f, &amp;glob);        // OK\n    auto q = make_unique&lt;int&gt;(99);\n    std::thread t3(f, q.get());      // 不好\n    // ...\n    t0.detach();\n    t1.detach();\n    t2.detach();\n    t3.detach();\n    // ...\n&#125;\n</code></pre>\n<p>这里的 “OK” 表明对象能够在  <code>thread</code>  可以使用指向它的指针时一直处于作用域（“存活”）。<br>\n“bad” 则表示  <code>thread</code>  可能在对象销毁之后使用指向它的指针。<br>\n <code>thread</code>  运行的并发性并不会影响这里的生存期或所有权问题；<br>\n这些  <code>thread</code>  可以仅仅被看成是从  <code>some_fct</code>  中调用的函数对象。</p>\n<h5 id=\"注解-257\"><a class=\"markdownIt-Anchor\" href=\"#注解-257\">#</a> 注解</h5>\n<p>即便具有静态存储期的对象，在脱离的线程中的使用也会造成问题：<br>\n若是这个线程持续到程序终止，则它的运行可能与具有静态存储期的对象的销毁过程之间并发地发生，<br>\n而这样对这些对象的访问就可能发生竞争。</p>\n<h5 id=\"注解-258\"><a class=\"markdownIt-Anchor\" href=\"#注解-258\">#</a> 注解</h5>\n<p>如果你<a href=\"#Rconc-detached_thread\">不  <code>detach()</code> </a> 并<a href=\"#Rconc-joining_thread\">使用  <code>gsl::joining_tread</code> </a> 的话，本条规则是多余的。<br>\n不过，将代码转化为遵循这些指导方针可能很困难，而对于第三方库来说更是不可能的。<br>\n这些情况下，这条规则对于生存期安全性和类型安全性来说就是必要的了。</p>\n<p>一般来说是无法确定是否对某个  <code>thread</code>  执行了  <code>detach()</code>  的，但简单的常见情况则易于检测出来。<br>\n如果无法证明某个  <code>thread</code>  并没有  <code>detach()</code>  的话，我们只能假定它确实脱离了，且它的存活将超过其构造时所处于的作用域；<br>\n之后，可以实施（针对全局对象的）常规的生存期和所有权强制实施方案。</p>\n<h5 id=\"强制实施-266\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-266\">#</a> 强制实施</h5>\n<p>当试图将局部变量传递给可能  <code>detach()</code>  的线程时进行标记。</p>\n<h3 id=\"a-namerconc-joining_threadacp25-优先采用-gsljoining_thread-而不是-stdthread\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-joining_threadacp25-优先采用-gsljoining_thread-而不是-stdthread\">#</a> <a name=\"Rconc-joining_thread\"></a>CP.25: 优先采用  <code>gsl::joining_thread</code>  而不是  <code>std::thread</code></h3>\n<h5 id=\"理由-288\"><a class=\"markdownIt-Anchor\" href=\"#理由-288\">#</a> 理由</h5>\n<p><code>joining_thread</code>  是一种在其作用域结尾处进行联结的线程。<br>\n脱离的线程很难进行监管。<br>\n确保脱离的线程（和潜在脱离的线程）中没有错误则更加困难。</p>\n<h5 id=\"示例不好-116\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-116\">#</a> 示例，不好</h5>\n<pre><code>void f() &#123; std::cout &lt;&lt; &quot;Hello &quot;; &#125;\n\nstruct F &#123;\n    void operator()() const &#123; std::cout &lt;&lt; &quot;parallel world &quot;; &#125;\n&#125;;\n\nint main()\n&#123;\n    std::thread t1&#123;f&#125;;      // f() 在独立线程中执行\n    std::thread t2&#123;F()&#125;;    // F()() 在独立线程中执行\n&#125;  // 请找出问题\n</code></pre>\n<h5 id=\"示例-262\"><a class=\"markdownIt-Anchor\" href=\"#示例-262\">#</a> 示例</h5>\n<pre><code>void f() &#123; std::cout &lt;&lt; &quot;Hello &quot;; &#125;\n\nstruct F &#123;\n    void operator()() const &#123; std::cout &lt;&lt; &quot;parallel world &quot;; &#125;\n&#125;;\n\nint main()\n&#123;\n    std::thread t1&#123;f&#125;;      // f() 在独立线程中执行\n    std::thread t2&#123;F()&#125;;    // F()() 在独立线程中执行\n\n    t1.join();\n    t2.join();\n&#125;  // 剩下一个糟糕的 BUG\n</code></pre>\n<h5 id=\"注解-259\"><a class=\"markdownIt-Anchor\" href=\"#注解-259\">#</a> 注解</h5>\n<p>使 “不死线程” 成为全局的，将其放入外围作用域中，或者放入自由存储中，而不要  <code>detach()</code>  它们。<br>\n<a href=\"#Rconc-detached_thread\">不要  <code>detach</code> </a>。</p>\n<h5 id=\"注解-260\"><a class=\"markdownIt-Anchor\" href=\"#注解-260\">#</a> 注解</h5>\n<p>因为老代码和第三方库也会使用  <code>std::thread</code> ，本条规则可能很难引入。</p>\n<h5 id=\"理由-289\"><a class=\"markdownIt-Anchor\" href=\"#理由-289\">#</a> 理由</h5>\n<p>标记  <code>std::thread</code>  的使用：</p>\n<ul>\n<li>建议使用  <code>gsl::joining_thread</code>  或 C++20 的  <code>std:jthread</code> .</li>\n<li>建议当其脱离时使其<a href=\"#Rconc-detached_thread\"> “外放所有权”</a> 到某个外围作用域中。</li>\n<li>如果不明确线程是联结还是脱离，则给出警告。</li>\n</ul>\n<h3 id=\"a-namerconc-detached_threadacp26-不要-detach-线程\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-detached_threadacp26-不要-detach-线程\">#</a> <a name=\"Rconc-detached_thread\"></a>CP.26: 不要  <code>detach()</code>  线程</h3>\n<h5 id=\"理由-290\"><a class=\"markdownIt-Anchor\" href=\"#理由-290\">#</a> 理由</h5>\n<p>通常，需要存活超出线程创建的作用域的情况是来源于  <code>thread</code>  的任务所决定的，<br>\n但用  <code>detach</code>  来实现这点将造成更加难于对脱离的线程进行监控和通信。<br>\n特别是，要确保线程按预期完成或者按预期的时间存活变得更加困难（虽然不是不可能）。</p>\n<h5 id=\"示例-263\"><a class=\"markdownIt-Anchor\" href=\"#示例-263\">#</a> 示例</h5>\n<pre><code>void heartbeat();\n\nvoid use()\n&#123;\n    std::thread t(heartbeat);             // 不联结；打算持续运行 heartbeat\n    t.detach();\n    // ...\n&#125;\n</code></pre>\n<p>这是一种合理的线程用法，一般会使用  <code>detach()</code> 。<br>\n但这里有些问题。<br>\n我们怎么监控脱离的线程以查看它是否存活呢？<br>\n心跳里边可能会出错，而在需要心跳的系统中，心跳丢失可能是非常严重的问题。<br>\n因此，我们需要与心跳线程进行通信<br>\n（例如，通过某个消息流，或者使用  <code>condition_variable</code>  的通知事件）。</p>\n<p>一种替代的，而且通常更好的方案是，通过将其放入某个其创建点（或激活点）之外的作用域来控制其生存期。<br>\n例如：</p>\n<pre><code>void heartbeat();\n\ngsl::joining_thread t(heartbeat);             // 打算持续运行 heartbeat\n</code></pre>\n<p>这个心跳，（除非出错或者硬件故障等情况）将在程序运行时一直运行。</p>\n<p>有时候，我们需要将创建点和所有权点分离开：</p>\n<pre><code>void heartbeat();\n\nunique_ptr&lt;gsl::joining_thread&gt; tick_tock &#123;nullptr&#125;;\n\nvoid use()\n&#123;\n    // 打算在 tick_tock 存活期间持续运行 heartbeat\n    tick_tock = make_unique(gsl::joining_thread, heartbeat);\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"强制实施-267\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-267\">#</a> 强制实施</h5>\n<p>标记  <code>detach()</code> 。</p>\n<h3 id=\"a-namerconc-data-by-valueacp31-少量数据在线程之间按值传递而不是通过引用或指针传递\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-data-by-valueacp31-少量数据在线程之间按值传递而不是通过引用或指针传递\">#</a> <a name=\"Rconc-data-by-value\"></a>CP.31: 少量数据在线程之间按值传递，而不是通过引用或指针传递</h3>\n<h5 id=\"理由-291\"><a class=\"markdownIt-Anchor\" href=\"#理由-291\">#</a> 理由</h5>\n<p>对少量数据进行复制和访问要比使用某种锁定机制进行共享更廉价。<br>\n复制天然会带来唯一所有权（简化代码），并消除数据竞争的可能性。</p>\n<h5 id=\"注解-261\"><a class=\"markdownIt-Anchor\" href=\"#注解-261\">#</a> 注解</h5>\n<p>对 “少量” 进行精确的定义是不可能的。</p>\n<h5 id=\"示例-264\"><a class=\"markdownIt-Anchor\" href=\"#示例-264\">#</a> 示例</h5>\n<pre><code>string modify1(string);\nvoid modify2(string&amp;);\n\nvoid fct(string&amp; s)\n&#123;\n    auto res = async(modify1, s);\n    async(modify2, s);\n&#125;\n</code></pre>\n<p><code>modify1</code>  的调用涉及两个  <code>string</code>  值的复制；而  <code>modify2</code>  的调用则不会。<br>\n另一方面， <code>modify1</code>  的实现和我们为单线程代码所编写的完全一样，<br>\n而  <code>modify2</code>  的实现则需要某种形式的锁定以避免数据竞争。<br>\n如果字符串很短（比如 10 个字符），对  <code>modify1</code>  的调用将会出乎意料地快；<br>\n基本上所有的代价都在  <code>thread</code>  的切换上。如果字符串很长（比如 1,000,000 个字符），对其两次复制<br>\n可能并不是一个好主意。</p>\n<p>注意这个论点和  <code>async</code>  并没有任何关系。它同等地适用于任何对采用消息传递<br>\n还是共享内存的考虑之上。</p>\n<h5 id=\"强制实施-268\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-268\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerconc-sharedacp32-用-shared_ptr-在无关的-thread-之间共享所有权\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-sharedacp32-用-shared_ptr-在无关的-thread-之间共享所有权\">#</a> <a name=\"Rconc-shared\"></a>CP.32: 用  <code>shared_ptr</code>  在无关的  <code>thread</code>  之间共享所有权</h3>\n<h5 id=\"理由-292\"><a class=\"markdownIt-Anchor\" href=\"#理由-292\">#</a> 理由</h5>\n<p>如果线程之间是无关的（就是说，互相不知道是否在相同作用域中，或者一个的生存期在另一个之内），<br>\n而它们需要共享需要删除的自由存储内存， <code>shared_ptr</code> （或者等价物）就是唯一的<br>\n可以保证正确删除的安全方式。</p>\n<h5 id=\"示例-265\"><a class=\"markdownIt-Anchor\" href=\"#示例-265\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"注解-262\"><a class=\"markdownIt-Anchor\" href=\"#注解-262\">#</a> 注解</h5>\n<ul>\n<li>可以共享静态对象（比如全局对象），因为它并不像是需要某个线程来负责其删除那样被谁所拥有。</li>\n<li>自由存储上不会被删除的对象可以进行共享。</li>\n<li>由一个线程所拥有的对象可以安全地共享给另一个线程，只要第二个线程存活不会超过这个拥有者线程即可。</li>\n</ul>\n<h5 id=\"强制实施-269\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-269\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerconc-switchacp40-最小化上下文切换\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-switchacp40-最小化上下文切换\">#</a> <a name=\"Rconc-switch\"></a>CP.40: 最小化上下文切换</h3>\n<h5 id=\"理由-293\"><a class=\"markdownIt-Anchor\" href=\"#理由-293\">#</a> 理由</h5>\n<p>上下文切换是昂贵的。</p>\n<h5 id=\"示例-266\"><a class=\"markdownIt-Anchor\" href=\"#示例-266\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"强制实施-270\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-270\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerconc-createacp41-最小化线程的创建和销毁\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-createacp41-最小化线程的创建和销毁\">#</a> <a name=\"Rconc-create\"></a>CP.41: 最小化线程的创建和销毁</h3>\n<h5 id=\"理由-294\"><a class=\"markdownIt-Anchor\" href=\"#理由-294\">#</a> 理由</h5>\n<p>线程创建是昂贵的。</p>\n<h5 id=\"示例-267\"><a class=\"markdownIt-Anchor\" href=\"#示例-267\">#</a> 示例</h5>\n<pre><code>void worker(Message m)\n&#123;\n    // 处理\n&#125;\n\nvoid dispatcher(istream&amp; is)\n&#123;\n    for (Message m; is &gt;&gt; m; )\n        run_list.push_back(new thread(worker, m));\n&#125;\n</code></pre>\n<p>这会为每个消息产生一个线程，而  <code>run_list</code>  则假定在它们完成后对这些任务进行销毁。</p>\n<p>我们可以用一组预先创建的工作线程来处理这些消息：</p>\n<pre><code>Sync_queue&lt;Message&gt; work;\n\nvoid dispatcher(istream&amp; is)\n&#123;\n    for (Message m; is &gt;&gt; m; )\n        work.put(m);\n&#125;\n\nvoid worker()\n&#123;\n    for (Message m; m = work.get(); ) &#123;\n        // 处理\n    &#125;\n&#125;\n\nvoid workers()  // 设立工作线程（这里是 4 个工作线程）\n&#123;\n    joining_thread w1 &#123;worker&#125;;\n    joining_thread w2 &#123;worker&#125;;\n    joining_thread w3 &#123;worker&#125;;\n    joining_thread w4 &#123;worker&#125;;\n&#125;\n</code></pre>\n<h5 id=\"注解-263\"><a class=\"markdownIt-Anchor\" href=\"#注解-263\">#</a> 注解</h5>\n<p>如果你的系统有一个好的线程池的话，就请使用它。<br>\n如果你的系统有一个好的消息队列的话，就请使用它。</p>\n<h5 id=\"强制实施-271\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-271\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerconc-waitacp42-不要无条件地-wait\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-waitacp42-不要无条件地-wait\">#</a> <a name=\"Rconc-wait\"></a>CP.42: 不要无条件地  <code>wait</code></h3>\n<h5 id=\"理由-295\"><a class=\"markdownIt-Anchor\" href=\"#理由-295\">#</a> 理由</h5>\n<p>没有条件的  <code>wait</code>  可能会丢失唤醒，或者唤醒时只会发现无事可做。</p>\n<h5 id=\"示例不好-117\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-117\">#</a> 示例，不好</h5>\n<pre><code>std::condition_variable cv;\nstd::mutex mx;\n\nvoid thread1()\n&#123;\n    while (true) &#123;\n        // 做一些工作 ...\n        std::unique_lock&lt;std::mutex&gt; lock(mx);\n        cv.notify_one();    // 唤醒另一个线程\n    &#125;\n&#125;\n\nvoid thread2()\n&#123;\n    while (true) &#123;\n        std::unique_lock&lt;std::mutex&gt; lock(mx);\n        cv.wait(lock);    // 可能会永远阻塞\n        // 做一些工作 ...\n    &#125;\n&#125;\n</code></pre>\n<p>这里，如果某个其他  <code>thread</code>  消费了  <code>thread1</code>  的通知的话， <code>thread2</code>  将会永远等待下去。</p>\n<h5 id=\"示例-268\"><a class=\"markdownIt-Anchor\" href=\"#示例-268\">#</a> 示例</h5>\n<pre><code>template&lt;typename T&gt;\nclass Sync_queue &#123;\npublic:\n    void put(const T&amp; val);\n    void put(T&amp;&amp; val);\n    void get(T&amp; val);\nprivate:\n    mutex mtx;\n    condition_variable cond;    // 这用于控制访问\n    list&lt;T&gt; q;\n&#125;;\n\ntemplate&lt;typename T&gt;\nvoid Sync_queue&lt;T&gt;::put(const T&amp; val)\n&#123;\n    lock_guard&lt;mutex&gt; lck(mtx);\n    q.push_back(val);\n    cond.notify_one();\n&#125;\n\ntemplate&lt;typename T&gt;\nvoid Sync_queue&lt;T&gt;::get(T&amp; val)\n&#123;\n    unique_lock&lt;mutex&gt; lck(mtx);\n    cond.wait(lck, [this] &#123; return !q.empty(); &#125;);    // 防止假性唤醒\n    val = q.front();\n    q.pop_front();\n&#125;\n</code></pre>\n<p>这样当执行  <code>get()</code>  的线程被唤醒时，如果队列为空（比如因为别的线程在之前已经  <code>get()</code>  过了），<br>\n它将立刻回到睡眠中继续等待。</p>\n<h5 id=\"强制实施-272\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-272\">#</a> 强制实施</h5>\n<p>对所有没有条件的  <code>wait</code>  进行标记。</p>\n<h3 id=\"a-namerconc-timeacp43-最小化临界区的时间耗费\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-timeacp43-最小化临界区的时间耗费\">#</a> <a name=\"Rconc-time\"></a>CP.43: 最小化临界区的时间耗费</h3>\n<h5 id=\"理由-296\"><a class=\"markdownIt-Anchor\" href=\"#理由-296\">#</a> 理由</h5>\n<p>获取  <code>mutex</code>  时耗费的时间越短，其他  <code>thread</code>  不得不等待的机会就会越少，<br>\n而  <code>thread</code>  的挂起和恢复是昂贵的。</p>\n<h5 id=\"示例-269\"><a class=\"markdownIt-Anchor\" href=\"#示例-269\">#</a> 示例</h5>\n<pre><code>void do_something() // 不好\n&#123;\n    unique_lock&lt;mutex&gt; lck(my_lock);\n    do0();  // 预备：不需要锁定\n    do1();  // 事务：需要锁定\n    do2();  // 清理：不需要锁定\n&#125;\n</code></pre>\n<p>这里我们持有的锁定比所需的要长：<br>\n我们不应该在必须锁定之前就获取锁定，而且应当在开始清理之前将其释放掉。<br>\n可以将其重写为：</p>\n<pre><code>void do_something() // 不好\n&#123;\n    do0();  // 预备：不需要锁定\n    my_lock.lock();\n    do1();  // 事务：需要锁定\n    my_lock.unlock();\n    do2();  // 清理：不需要锁定\n&#125;\n</code></pre>\n<p>但这样损害了安全性并且违反了<a href=\"#Rconc-raii\">使用 RAII</a> 规则。<br>\n我们可以为临界区添加语句块：</p>\n<pre><code>void do_something() // OK\n&#123;\n    do0();  // 预备：不需要锁定\n    &#123;\n        unique_lock&lt;mutex&gt; lck(my_lock);\n        do1();  // 事务：需要锁定\n    &#125;\n    do2();  // 清理：不需要锁定\n&#125;\n</code></pre>\n<h5 id=\"强制实施-273\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-273\">#</a> 强制实施</h5>\n<p>一般来说是不可能的。<br>\n对 “裸”  <code>lock()</code>  和  <code>unlock()</code>  进行标记。</p>\n<h3 id=\"a-namerconc-nameacp44-记得为-lock_guard-和-unique_lock-命名\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-nameacp44-记得为-lock_guard-和-unique_lock-命名\">#</a> <a name=\"Rconc-name\"></a>CP.44: 记得为  <code>lock_guard</code>  和  <code>unique_lock</code>  命名</h3>\n<h5 id=\"理由-297\"><a class=\"markdownIt-Anchor\" href=\"#理由-297\">#</a> 理由</h5>\n<p>无名的局部对象时临时对象，会立刻离开作用域。</p>\n<h5 id=\"示例-270\"><a class=\"markdownIt-Anchor\" href=\"#示例-270\">#</a> 示例</h5>\n<pre><code>// 全局互斥体\nmutex m1;\nmutex m2;\n\nvoid f()\n&#123;\n    unique_lock&lt;mutex&gt;(m1); // (A)\n    lock_guard&lt;mutex&gt; &#123;m2&#125;; // (B)\n    // 关键区中的工作\n&#125;\n</code></pre>\n<p>这个貌似足够有效，但其实并非如此。在 (A) 点， <code>m1</code>  是一个<br>\n默认构造的局部  <code>unique_lock</code> ，它隐藏了全局的  <code>::m1</code> （且并未锁定它）。<br>\n在 (B) 点，构造了一个无名  <code>lock_guard</code>  临时对象并锁定了  <code>::m2</code> ，<br>\n但它立即离开作用域并再次解锁了  <code>::m2</code> 。<br>\n函数  <code>f()</code>  的余下部分中并没有锁定任何互斥体。</p>\n<h5 id=\"强制实施-274\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-274\">#</a> 强制实施</h5>\n<p>标记所有的无名  <code>lock_guard</code>  和  <code>unique_lock</code> 。</p>\n<h3 id=\"a-namerconc-mutexacp50-mutex-要和其所保护的数据一起定义只要可能就使用-synchronized_valuet\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-mutexacp50-mutex-要和其所保护的数据一起定义只要可能就使用-synchronized_valuet\">#</a> <a name=\"Rconc-mutex\"></a>CP.50:  <code>mutex</code>  要和其所保护的数据一起定义，只要可能就使用  <code>synchronized_value&lt;T&gt;</code></h3>\n<h5 id=\"理由-298\"><a class=\"markdownIt-Anchor\" href=\"#理由-298\">#</a> 理由</h5>\n<p>对于读者来说，数据应该且如何被保护应当是显而易见的。这可以减少锁定错误的互斥体，或者互斥体未能被锁定的机会。</p>\n<p>使用  <code>synchronized_value&lt;T&gt;</code>  保证了数据都带有互斥体，并且当访问数据时锁定正确的互斥体。<br>\n参见向某个未来的 TS 或 C++ 标准的修订版添加  <code>synchronized_value</code>  <span class=\"exturl\" data-url=\"aHR0cDovL3dnMjEubGluay9wMDI5MA==\">WG21 提案</span>。</p>\n<h5 id=\"示例-271\"><a class=\"markdownIt-Anchor\" href=\"#示例-271\">#</a> 示例</h5>\n<pre><code>struct Record &#123;\n    std::mutex m;   // 访问其他成员之前应当获取这个 mutex\n    // ...\n&#125;;\n\nclass MyClass &#123;\n    struct DataRecord &#123;\n       // ...\n    &#125;;\n    synchronized_value&lt;DataRecord&gt; data; // 用互斥体保护数据\n&#125;;\n</code></pre>\n<h5 id=\"强制实施-275\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-275\">#</a> 强制实施</h5>\n<p>??? 可能吗？</p>\n<h2 id=\"a-namesscp-coroacpcoro-协程\"><a class=\"markdownIt-Anchor\" href=\"#a-namesscp-coroacpcoro-协程\">#</a> <a name=\"SScp-coro\"></a>CP.coro: 协程</h2>\n<p>这一部分关注协程的使用。</p>\n<p>协程规则概览：</p>\n<ul>\n<li><a href=\"#Rcoro-capture\">CP.51: 不要使用作为协程的有俘获 lambda 表达式</a></li>\n<li><a href=\"#Rcoro-locks\">CP.52: 不要在持有锁或其它同步原语时跨越挂起点</a></li>\n<li><a href=\"#Rcoro-reference-parameters\">CP.53: 协程的形参不能按引用传递</a></li>\n</ul>\n<h3 id=\"a-namercoro-captureacp51-不要使用作为协程的有俘获-lambda-表达式\"><a class=\"markdownIt-Anchor\" href=\"#a-namercoro-captureacp51-不要使用作为协程的有俘获-lambda-表达式\">#</a> <a name=\"Rcoro-capture\"></a>CP.51: 不要使用作为协程的有俘获 lambda 表达式</h3>\n<h5 id=\"理由-299\"><a class=\"markdownIt-Anchor\" href=\"#理由-299\">#</a> 理由</h5>\n<p>对于普通 lambda 来说正确的使用模式，对于协程 lambda 来说是高危的。很明显的变量俘获模式将会造成在首个挂起点之后访问已释放的内存，即便是带引用计数的智能指针和可复制类型也是如此。</p>\n<p>lambda 表达式会产生一个带有存储的闭包对象，它通常在运行栈上，并会在某个时刻离开作用域。当闭包对象离开作用域时，它所俘获的也会离开作用域。普通 lambda 的执行在这个时间点都已经完成了，因此这并不是问题。闭包 lambda 则可能会在闭包对象已经销毁之后从挂起中恢复执行，而在这时其所有俘获都将变为 “释放后使用” 的内存访问。</p>\n<h5 id=\"示例不好-118\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-118\">#</a> 示例，不好</h5>\n<pre><code>int value = get_value();\nstd::shared_ptr&lt;Foo&gt; sharedFoo = get_foo();\n&#123;\n  const auto lambda = [value, sharedFoo]() -&gt; std::future&lt;void&gt;\n  &#123;\n    co_await something();\n    // &quot;sharedFoo&quot; 和 &quot;value&quot; 已被销毁\n    // “共享”指针没有带来任何好处\n  &#125;;\n  lambda();\n&#125; // lambda 闭包对象此时已离开作用域\n</code></pre>\n<h5 id=\"示例更好\"><a class=\"markdownIt-Anchor\" href=\"#示例更好\">#</a> 示例，更好</h5>\n<pre><code>int value = get_value();\nstd::shared_ptr&lt;Foo&gt; sharedFoo = get_foo();\n&#123;\n  const auto lambda = [](auto sharedFoo, auto value) -&gt; std::future&lt;void&gt;  // 以按值传参代替作为俘获\n  &#123;\n    co_await something();\n    // sharedFoo 和 value 此时仍然有效\n  &#125;;\n  lambda(sharedFoo, value); \n&#125; // lambda 闭包对象此时已离开作用域\n</code></pre>\n<h5 id=\"示例最佳\"><a class=\"markdownIt-Anchor\" href=\"#示例最佳\">#</a> 示例，最佳</h5>\n<p>使用函数作为协程。</p>\n<pre><code>std::future&lt;void&gt; Class::do_something(int value, std::shared_ptr&lt;Foo&gt; sharedFoo)\n&#123;\n  co_await something();\n  // sharedFoo 和 value 此时仍然有效\n&#125;\n\nvoid SomeOtherFunction()\n&#123;\n  int value = get_value();\n  std::shared_ptr&lt;Foo&gt; sharedFoo = get_foo();\n  do_something(value, sharedFoo); \n&#125;\n</code></pre>\n<h5 id=\"强制实施-276\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-276\">#</a> 强制实施</h5>\n<p>标记作为协程且具有非空俘获列表的 lambda 表达式。</p>\n<h3 id=\"a-namercoro-locksacp52-不要在持有锁或其它同步原语时跨越挂起点\"><a class=\"markdownIt-Anchor\" href=\"#a-namercoro-locksacp52-不要在持有锁或其它同步原语时跨越挂起点\">#</a> <a name=\"Rcoro-locks\"></a>CP.52: 不要在持有锁或其它同步原语时跨越挂起点</h3>\n<h5 id=\"理由-300\"><a class=\"markdownIt-Anchor\" href=\"#理由-300\">#</a> 理由</h5>\n<p>这种模式会导致明显的死锁风险。某些种类的等待允许当前线程在异步操作完成前实施一些额外的工作。如果持有锁的线程实施了需要相同的所的工作，那它就会因为试图获取它已经持有的锁而发生死锁。</p>\n<p>如果协程在某个与获得所的线程不同的另一个线程中完成，那就是未定义行为。即使协程中明确返回其原来的线程，仍然有可能在协程恢复之前抛出异常，并导致其锁定防护对象（lock guard）未能销毁。</p>\n<h5 id=\"示例不好-119\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-119\">#</a> 示例，不好</h5>\n<pre><code>std::mutex g_lock;\n\nstd::future&lt;void&gt; Class::do_something()\n&#123;\n    std::lock_guard&lt;std::mutex&gt; guard(g_lock);\n    co_await something(); // 危险：在持有锁时挂起协程\n    co_await somethingElse();\n&#125;\n</code></pre>\n<h5 id=\"示例好-24\"><a class=\"markdownIt-Anchor\" href=\"#示例好-24\">#</a> 示例，好</h5>\n<pre><code>std::mutex g_lock;\n\nstd::future&lt;void&gt; Class::do_something()\n&#123;\n    &#123;\n        std::lock_guard&lt;std::mutex&gt; guard(g_lock);\n        // 修改被锁保护的数据\n    &#125;\n    co_await something(); // OK：锁已经在协程挂起前被释放\n    co_await somethingElse();\n&#125;\n</code></pre>\n<h5 id=\"注解-264\"><a class=\"markdownIt-Anchor\" href=\"#注解-264\">#</a> 注解</h5>\n<p>这种模式对于性能也不好。每当遇到比如  <code>co_await</code>  这样的挂起点时，都会停止当前函数的执行而去运行别的代码。而在协程恢复之前可能会经过很长时间。这个锁会在整个时间段中持有，并且无法被其他线程获得以进行别的工作。</p>\n<h5 id=\"强制实施-277\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-277\">#</a> 强制实施</h5>\n<p>标记所有未能在协程挂起前销毁的锁定防护。</p>\n<h3 id=\"a-namercoro-reference-parametersacp53-协程的形参不能按引用传递\"><a class=\"markdownIt-Anchor\" href=\"#a-namercoro-reference-parametersacp53-协程的形参不能按引用传递\">#</a> <a name=\"Rcoro-reference-parameters\"></a>CP.53: 协程的形参不能按引用传递</h3>\n<h5 id=\"理由-301\"><a class=\"markdownIt-Anchor\" href=\"#理由-301\">#</a> 理由</h5>\n<p>一旦协程到达其第一个如  <code>co_await</code>  这样的挂起点，其同步执行的部分就会返回。这个位置之后，所有按引用传递的形参都是悬挂引用。此后对它们的任何使用都是未定义行为，可能包括向已释放的内存进行写入。</p>\n<h5 id=\"示例不好-120\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-120\">#</a> 示例，不好</h5>\n<pre><code>std::future&lt;int&gt; Class::do_something(const std::shared_ptr&lt;int&gt;&amp; input)\n&#123;\n    co_await something();\n\n    // 危险：对 input 的引用可能不再有效，可能已经是已释放内存\n    co_return *input + 1;\n&#125;\n</code></pre>\n<h5 id=\"示例好-25\"><a class=\"markdownIt-Anchor\" href=\"#示例好-25\">#</a> 示例，好</h5>\n<pre><code>std::future&lt;int&gt; Class::do_something(std::shared_ptr&lt;int&gt; input)\n&#123;\n    co_await something();\n    co_return *input + 1; // input 是一个副本，且到此处仍有效\n&#125;\n</code></pre>\n<h5 id=\"注解-265\"><a class=\"markdownIt-Anchor\" href=\"#注解-265\">#</a> 注解</h5>\n<p>这个问题并不适用于仅在第一个挂起点之前访问的引用形参。此后对函数的改动中可能会添加或移除挂起点，而这可能会再次引入这一类的缺陷。一些种类的协程，在协程执行第一行代码之前就会有挂起点，这种情况中的引用形参总是不安全的。一直采用按值传递的方式更安全，因为所复制的形参存活于协程的栈帧中，并在整个协程中都可以安全访问。</p>\n<h5 id=\"注解-266\"><a class=\"markdownIt-Anchor\" href=\"#注解-266\">#</a> 注解</h5>\n<p>输出参数也有这种危险。<a href=\"#Rf-out\">F.20: 对于 “输出（out）” 值，采用返回值优先于输出参数</a> 不建议使用输出参数。协程应当完全避免输出参数。</p>\n<h5 id=\"强制实施-278\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-278\">#</a> 强制实施</h5>\n<p>标记协程的所有引用形参。</p>\n<h2 id=\"a-namesscp-paracppar-并行\"><a class=\"markdownIt-Anchor\" href=\"#a-namesscp-paracppar-并行\">#</a> <a name=\"SScp-par\"></a>CP.par: 并行</h2>\n<p>这里的 “并行” 代表的是对许多数据项（或多或少）同时地（“并行进行”）实施某项任务。</p>\n<p>并行规则概览：</p>\n<ul>\n<li>???</li>\n<li>???</li>\n<li>适当的时候，优先采用标准库的并行算法</li>\n<li>使用为并行设计的算法，而不是不必要地依赖于线性求值的算法</li>\n</ul>\n<h2 id=\"a-namesscp-messacpmess-消息传递\"><a class=\"markdownIt-Anchor\" href=\"#a-namesscp-messacpmess-消息传递\">#</a> <a name=\"SScp-mess\"></a>CP.mess: 消息传递</h2>\n<p>标准库的设施是相当底层的，关注于使用  <code>thread</code> ， <code>mutex</code> ， <code>atomic</code>  等类型的贴近硬件的关键编程。<br>\n大多数人都不应该在这种层次上工作：它是易错的，而且开发很慢。<br>\n如果可能的话，应当使用高层次的设施：消息程序库，并行算法，以及向量化。<br>\n这一部分关注如何传递消息，以使程序员不必进行显式的同步。</p>\n<p>消息传递规则概览：</p>\n<ul>\n<li><a href=\"#Rconc-future\">CP.60: 使用  <code>future</code>  从并发任务返回值</a></li>\n<li><a href=\"#Rconc-async\">CP.61: 使用  <code>async()</code>  来产生并发任务</a></li>\n<li>消息队列</li>\n<li>消息程序库</li>\n</ul>\n<p>??? 是否应该有某个 “使用 X 而不是  <code>std::async</code> ”，其中 X 是某种更好说明的线程池？</p>\n<p>??? 在未来的趋势下（甚至是现存的程序库）， <code>std::async</code>  是否还是值得使用的并行设施？当有人想要对比如  <code>std::accumulate</code> （带上额外的累加前条件），或者归并排序进行并行化时，指导方针应该给出什么样的建议呢？</p>\n<h3 id=\"a-namerconc-futureacp60-使用-future-从并发任务返回值\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-futureacp60-使用-future-从并发任务返回值\">#</a> <a name=\"Rconc-future\"></a>CP.60: 使用  <code>future</code>  从并发任务返回值</h3>\n<h5 id=\"理由-302\"><a class=\"markdownIt-Anchor\" href=\"#理由-302\">#</a> 理由</h5>\n<p><code>future</code>  为异步任务保持了常规函数调用的返回语义。<br>\n它没有显式的锁定，而且正确的（值）返回和错误的（异常）返回都能被简单处理。</p>\n<h5 id=\"示例-272\"><a class=\"markdownIt-Anchor\" href=\"#示例-272\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"注解-267\"><a class=\"markdownIt-Anchor\" href=\"#注解-267\">#</a> 注解</h5>\n<p>???</p>\n<h5 id=\"强制实施-279\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-279\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerconc-asyncacp61-使用-async-来产生并发任务\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-asyncacp61-使用-async-来产生并发任务\">#</a> <a name=\"Rconc-async\"></a>CP.61: 使用  <code>async()</code>  来产生并发任务</h3>\n<h5 id=\"理由-303\"><a class=\"markdownIt-Anchor\" href=\"#理由-303\">#</a> 理由</h5>\n<p><a href=\"#Rr-immediate-alloc\">R.12</a> 告诉我们要避免原始所有权指针，与此相似，<br>\n我们也要尽可能避免原始线程和原始承诺（promise）。应使用诸如  <code>std::async</code>  之类的工厂函数，<br>\n它将处理线程的产生和重用，而不会讲原始线程暴露给你自己的代码。</p>\n<h5 id=\"示例-273\"><a class=\"markdownIt-Anchor\" href=\"#示例-273\">#</a> 示例</h5>\n<pre><code>int read_value(const std::string&amp; filename)\n&#123;\n    std::ifstream in(filename);\n    in.exceptions(std::ifstream::failbit);\n    int value;\n    in &gt;&gt; value;\n    return value;\n&#125;\n\nvoid async_example()\n&#123;\n    try &#123;\n        std::future&lt;int&gt; f1 = std::async(read_value, &quot;v1.txt&quot;);\n        std::future&lt;int&gt; f2 = std::async(read_value, &quot;v2.txt&quot;);\n        std::cout &lt;&lt; f1.get() + f2.get() &lt;&lt; '\\n';\n    &#125; catch (std::ios_base::failure &amp; fail) &#123;\n        // 此处处理异常\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"注解-268\"><a class=\"markdownIt-Anchor\" href=\"#注解-268\">#</a> 注解</h5>\n<p>不幸的是， <code>async()</code>  并不完美。比如说，它并不使用线程池，<br>\n这意味着它可能会因为资源耗尽而失败，而不会将你的任务放入队列以便随后执行。<br>\n不过，即便你不能用  <code>std::async</code> ，你也应当优先编写自己的返回<br>\n <code>future</code>  的工厂函数，而非使用原始承诺。</p>\n<h5 id=\"示例不好-121\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-121\">#</a> 示例（不好）</h5>\n<p>这个例子展示了两种方式，都使用了  <code>std::future</code>  却未能避免对原始<br>\n <code>std::thread</code>  的管理。</p>\n<pre><code>void async_example()\n&#123;\n    std::promise&lt;int&gt; p1;\n    std::future&lt;int&gt; f1 = p1.get_future();\n    std::thread t1([p1 = std::move(p1)]() mutable &#123;\n        p1.set_value(read_value(&quot;v1.txt&quot;));\n    &#125;);\n    t1.detach(); // 恶行\n\n    std::packaged_task&lt;int()&gt; pt2(read_value, &quot;v2.txt&quot;);\n    std::future&lt;int&gt; f2 = pt2.get_future();\n    std::thread(std::move(pt2)).detach();\n\n    std::cout &lt;&lt; f1.get() + f2.get() &lt;&lt; '\\n';\n&#125;\n</code></pre>\n<h5 id=\"示例好-26\"><a class=\"markdownIt-Anchor\" href=\"#示例好-26\">#</a> 示例（好）</h5>\n<p>这个例子展示一种方法，可以让你在当  <code>std::async</code>  自身<br>\n在产品中不可接受的情形中，模仿  <code>std::async</code>  所设立的<br>\n一般模式的方法。</p>\n<pre><code>void async_example(WorkQueue&amp; wq)\n&#123;\n    std::future&lt;int&gt; f1 = wq.enqueue([]() &#123;\n        return read_value(&quot;v1.txt&quot;);\n    &#125;);\n    std::future&lt;int&gt; f2 = wq.enqueue([]() &#123;\n        return read_value(&quot;v2.txt&quot;);\n    &#125;);\n    std::cout &lt;&lt; f1.get() + f2.get() &lt;&lt; '\\n';\n&#125;\n</code></pre>\n<p>所有为执行  <code>read_value</code>  的代码而产生的线程都被隐藏到对<br>\n <code>WorkQueue::enqueue</code>  的调用之内。用户代码仅需处理  <code>future</code>  对象，<br>\n无需处理原始  <code>thread</code> ， <code>promise</code>  或  <code>packaged_task</code>  对象。</p>\n<h5 id=\"强制实施-280\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-280\">#</a> 强制实施</h5>\n<p>???</p>\n<h2 id=\"a-namesscp-vecacpvec-向量化\"><a class=\"markdownIt-Anchor\" href=\"#a-namesscp-vecacpvec-向量化\">#</a> <a name=\"SScp-vec\"></a>CP.vec: 向量化</h2>\n<p>向量化是一种在不引入显式同步时并发地执行多个任务的技术。<br>\n它会并行地把某个操作实施与某个数据结构（向量，数组，等等）的各个元素之上。<br>\n向量化引人关注的性质在于它通常不需要对程序进行非局部的改动。<br>\n不过，向量化只对简单的数据结构和特别针对它所构造的算法能够得到最好的工作效果。</p>\n<p>向量化规则概览：</p>\n<ul>\n<li>???</li>\n<li>???</li>\n</ul>\n<h2 id=\"a-namesscp-freeacpfree-无锁编程\"><a class=\"markdownIt-Anchor\" href=\"#a-namesscp-freeacpfree-无锁编程\">#</a> <a name=\"SScp-free\"></a>CP.free: 无锁编程</h2>\n<p>使用  <code>mutex</code>  和  <code>condition_variable</code>  进行同步相对来说很昂贵。<br>\n而且可能导致死锁。<br>\n为了性能并消除死锁的可能性，有时候我们不得不使用麻烦的底层 “无锁” 设施，<br>\n它们依赖于对内存短暂地获得互斥（“原子性”）访问。<br>\n无锁编程也被用于实现如  <code>thread</code>  和  <code>mutex</code>  这样的高层并发机制。</p>\n<p>无锁编程规则概览：</p>\n<ul>\n<li><a href=\"#Rconc-lockfree\">CP.100: 除非绝对必要，请勿使用无锁编程</a></li>\n<li><a href=\"#Rconc-distrust\">CP.101: 不要信任你的硬件 - 编译器组合</a></li>\n<li><a href=\"#Rconc-literature\">CP.102: 仔细研究文献</a></li>\n<li>如何 / 何时使用原子</li>\n<li>避免饥饿</li>\n<li>使用无锁数据结构而不是手工构造的专门的无锁访问</li>\n<li><a href=\"#Rconc-double\">CP.110: 不要为初始化编写你自己的双检查锁定</a></li>\n<li><a href=\"#Rconc-double-pattern\">CP.111: 当确实需要双检查锁定时应当采用惯用的模式</a></li>\n<li>如何 / 何时进行比较并交换（CAS）</li>\n</ul>\n<h3 id=\"a-namerconc-lockfreeacp100-除非绝对必要请勿使用无锁编程\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-lockfreeacp100-除非绝对必要请勿使用无锁编程\">#</a> <a name=\"Rconc-lockfree\"></a>CP.100: 除非绝对必要，请勿使用无锁编程</h3>\n<h5 id=\"理由-304\"><a class=\"markdownIt-Anchor\" href=\"#理由-304\">#</a> 理由</h5>\n<p>无锁编程容易出错，要求专家级的语言特性、机器架构和数据结构知识。</p>\n<h5 id=\"示例不好-122\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-122\">#</a> 示例，不好</h5>\n<pre><code>extern atomic&lt;Link*&gt; head;        // 共享的链表表头\n\nLink* nh = new Link(data, nullptr);    // 为进行插入制作一个连接\nLink* h = head.load();                 // 读取链表中的共享表头\n\ndo &#123;\n    if (h-&gt;data &lt;= data) break;        // 这样的话，就插入到别处\n    nh-&gt;next = h;                      // 下一个元素是之前的表头\n&#125; while (!head.compare_exchange_weak(h, nh));    // 将 nh 写入 head 或 h\n</code></pre>\n<p>请找出这里的 BUG。<br>\n通过测试找到它是非常困难的。<br>\n请阅读有关 ABA 问题的材料。</p>\n<h5 id=\"例外-54\"><a class=\"markdownIt-Anchor\" href=\"#例外-54\">#</a> 例外</h5>\n<p><a href=\"#???\">原子变量</a>可以简单并安全地使用，只要你所用的是顺序一致性内存模型（ <code>memory_order_seq_cst</code> ），而这是默认情况。</p>\n<h5 id=\"注解-269\"><a class=\"markdownIt-Anchor\" href=\"#注解-269\">#</a> 注解</h5>\n<p>高层的并发机制，诸如  <code>thread</code>  和  <code>mutex</code> ，是使用无锁编程来实现的。</p>\n<p><strong>替代方案</strong>：使用由他人实现并作为程序库一部分的无锁数据结构。</p>\n<h3 id=\"a-namerconc-distrustacp101-不要信任你的硬件-编译器组合\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-distrustacp101-不要信任你的硬件-编译器组合\">#</a> <a name=\"Rconc-distrust\"></a>CP.101: 不要信任你的硬件 - 编译器组合</h3>\n<h5 id=\"理由-305\"><a class=\"markdownIt-Anchor\" href=\"#理由-305\">#</a> 理由</h5>\n<p>无锁编程所使用的底层硬件接口，是属于最难正确实现的，<br>\n而且属于最可能会发生最微妙的兼容性问题的领域。<br>\n如果你为了性能而进行无锁编程的话，你应当进行回归检查。</p>\n<h5 id=\"注解-270\"><a class=\"markdownIt-Anchor\" href=\"#注解-270\">#</a> 注解</h5>\n<p>指令重排（静态和动态的）会让我们很难有效在这个层次上进行思考（尤其当你使用宽松的内存模型的时候）。<br>\n经验，（半）形式化的模型以及模型检查可以提供帮助。<br>\n测试 —— 通常需要极端程度 —— 是基础。<br>\n“不要飞得太靠近太阳。”</p>\n<h5 id=\"强制实施-281\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-281\">#</a> 强制实施</h5>\n<p>准备强有力的规则，使得当硬件，操作系统，编译器，和程序库发生任何改变都能重复测试以进行覆盖。</p>\n<h3 id=\"a-namerconc-literatureacp102-仔细研究文献\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-literatureacp102-仔细研究文献\">#</a> <a name=\"Rconc-literature\"></a>CP.102: 仔细研究文献</h3>\n<h5 id=\"理由-306\"><a class=\"markdownIt-Anchor\" href=\"#理由-306\">#</a> 理由</h5>\n<p>除了原子和少数其他的标准模式之外，无锁编程真的是只有专家才懂的议题。<br>\n在发布无锁代码给其他人使用之前，应当先成为一名专家。</p>\n<h5 id=\"参考文献\"><a class=\"markdownIt-Anchor\" href=\"#参考文献\">#</a> 参考文献</h5>\n<ul>\n<li>Anthony Williams: C++ concurrency in action. Manning Publications.</li>\n<li>Boehm, Adve, You Don’t Know Jack About Shared Variables or Memory Models , Communications of the ACM, Feb 2012.</li>\n<li>Boehm, “Threads Basics”, HPL TR 2009-259.</li>\n<li>Adve, Boehm, “Memory Models: A Case for Rethinking Parallel Languages and Hardware”, Communications of the ACM, August 2010.</li>\n<li>Boehm, Adve, “Foundations of the C++ Concurrency Memory Model”, PLDI 08.</li>\n<li>Mark Batty, Scott Owens, Susmit Sarkar, Peter Sewell, and Tjark Weber, “Mathematizing C++ Concurrency”, POPL 2011.</li>\n<li>Damian Dechev, Peter Pirkelbauer, and Bjarne Stroustrup: Understanding and Effectively Preventing the ABA Problem in Descriptor-based Lock-free Designs. 13th IEEE Computer Society ISORC 2010 Symposium. May 2010.</li>\n<li>Damian Dechev and Bjarne Stroustrup: Scalable Non-blocking Concurrent Objects for Mission Critical Code. ACM OOPSLA’09. October 2009</li>\n<li>Damian Dechev, Peter Pirkelbauer, Nicolas Rouquette, and Bjarne Stroustrup: Semantically Enhanced Containers for Concurrent Real-Time Systems. Proc. 16th Annual IEEE International Conference and Workshop on the Engineering of Computer Based Systems (IEEE ECBS). April 2009.</li>\n<li>Maurice Herlihy, Nir Shavit, Victor Luchangco, Michael Spear, “The Art of Multiprocessor Programming”, 2nd ed. September 2020</li>\n</ul>\n<h3 id=\"a-namerconc-doubleacp110-不要为初始化编写你自己的双检查锁定\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-doubleacp110-不要为初始化编写你自己的双检查锁定\">#</a> <a name=\"Rconc-double\"></a>CP.110: 不要为初始化编写你自己的双检查锁定</h3>\n<h5 id=\"理由-307\"><a class=\"markdownIt-Anchor\" href=\"#理由-307\">#</a> 理由</h5>\n<p>从 C<ins>11 开始，静态局部变量是以线程安全的方式初始化的。当和 RAII 模式结合时，静态局部变量可以取代为初始化自己编写双检查锁定的需求。 <code>std::call_once</code>  也可以达成相同的目的。请使用 C</ins>11 的静态局部变量或者  <code>std::call_once</code>  来代替自己为初始化编写的双检查锁定。</p>\n<h5 id=\"示例-274\"><a class=\"markdownIt-Anchor\" href=\"#示例-274\">#</a> 示例</h5>\n<p>使用  <code>std::call_once</code>  的例子。</p>\n<pre><code>void f()\n&#123;\n    static std::once_flag my_once_flag;\n    std::call_once(my_once_flag, []()\n    &#123;\n        // 这个只做一次\n    &#125;);\n    // ...\n&#125;\n</code></pre>\n<p>使用 C++11 的线程安全静态局部变量的例子。</p>\n<pre><code>void f()\n&#123;\n    // 假定编译器遵循 C++11\n    static My_class my_object; // 构造函数仅调用一次\n    // ...\n&#125;\n\nclass My_class\n&#123;\npublic:\n    My_class()\n    &#123;\n        // 这个只做一次\n    &#125;\n&#125;;\n</code></pre>\n<h5 id=\"强制实施-282\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-282\">#</a> 强制实施</h5>\n<p>??? 是否可能检测出这种惯用法？</p>\n<h3 id=\"a-namerconc-double-patternacp111-当确实需要双检查锁定时应当采用惯用的模式\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-double-patternacp111-当确实需要双检查锁定时应当采用惯用的模式\">#</a> <a name=\"Rconc-double-pattern\"></a>CP.111: 当确实需要双检查锁定时应当采用惯用的模式</h3>\n<h5 id=\"理由-308\"><a class=\"markdownIt-Anchor\" href=\"#理由-308\">#</a> 理由</h5>\n<p>双检查锁定是很容易被搞乱的。如果确实需要编写自己的双检查锁定，而不顾规则 <a href=\"#Rconc-double\">CP.110: 不要为初始化编写你自己的双检查锁定</a>和规则 <a href=\"#Rconc-lockfree\">CP.100: 除非绝对必要，请勿使用无锁编程</a>，那么应当采用惯用的模式。</p>\n<p>使用双检查锁定模式而不违反<a href=\"#Rconc-double\"> CP.110: 不要为初始化编写你自己的双检查锁定</a>的情形，出现于当某个非线程安全的动作既困难也罕见，并且存在某个快速且线程安全的测试可以用于保证该动作并不需要实施的情况，但反过来的情况则无法保证。</p>\n<h5 id=\"示例不好-123\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-123\">#</a> 示例，不好</h5>\n<p>使用  <code>volatile</code>  并不能使得第一个检查线程安全，另见<a href=\"#Rconc-volatile2\"> CP.200:  <code>volatile</code>  仅用于和非 C++ 内存进行通信</a></p>\n<pre><code>mutex action_mutex;\nvolatile bool action_needed;\n\nif (action_needed) &#123;\n    std::lock_guard&lt;std::mutex&gt; lock(action_mutex);\n    if (action_needed) &#123;\n        take_action();\n        action_needed = false;\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"示例好-27\"><a class=\"markdownIt-Anchor\" href=\"#示例好-27\">#</a> 示例，好</h5>\n<pre><code>mutex action_mutex;\natomic&lt;bool&gt; action_needed;\n\nif (action_needed) &#123;\n    std::lock_guard&lt;std::mutex&gt; lock(action_mutex);\n    if (action_needed) &#123;\n        take_action();\n        action_needed = false;\n    &#125;\n&#125;\n</code></pre>\n<p>这对于正确调校的内存顺序可能会带来好处，其中的获取加载要比顺序一致性加载更加高效</p>\n<pre><code>mutex action_mutex;\natomic&lt;bool&gt; action_needed;\n\nif (action_needed.load(memory_order_acquire)) &#123;\n    lock_guard&lt;std::mutex&gt; lock(action_mutex);\n    if (action_needed.load(memory_order_relaxed)) &#123;\n        take_action();\n        action_needed.store(false, memory_order_release);\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"强制实施-283\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-283\">#</a> 强制实施</h5>\n<p>??? 是否可能检测出这种惯用法？</p>\n<h2 id=\"a-namesscp-etcacpetc-其他并发规则\"><a class=\"markdownIt-Anchor\" href=\"#a-namesscp-etcacpetc-其他并发规则\">#</a> <a name=\"SScp-etc\"></a>CP.etc: 其他并发规则</h2>\n<p>这些规则不适于简单的分类：</p>\n<ul>\n<li><a href=\"#Rconc-volatile2\">CP.200:  <code>volatile</code>  仅用于和非 C++ 内存进行通信</a></li>\n<li><a href=\"#Rconc-signal\">CP.201: ??? 信号</a></li>\n</ul>\n<h3 id=\"a-namerconc-volatile2acp200-volatile-仅用于和非-c-内存进行通信\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-volatile2acp200-volatile-仅用于和非-c-内存进行通信\">#</a> <a name=\"Rconc-volatile2\"></a>CP.200:  <code>volatile</code>  仅用于和非 C++ 内存进行通信</h3>\n<h5 id=\"理由-309\"><a class=\"markdownIt-Anchor\" href=\"#理由-309\">#</a> 理由</h5>\n<p><code>volatile</code>  用于涉指那些与 “非 C++” 代码之间共享的对象，或者不遵循 C++ 内存模型的硬件。</p>\n<h5 id=\"示例-275\"><a class=\"markdownIt-Anchor\" href=\"#示例-275\">#</a> 示例</h5>\n<pre><code>const volatile long clock;\n</code></pre>\n<p>这说明了一个被某个时钟电路不断更新的寄存器。<br>\n <code>clock</code>  为  <code>volatile</code>  是因为其值将会在没有使用它的 C++ 程序的任何动作下被改变。<br>\n例如，两次读取  <code>clock</code>  经常会产生两个不同的值，因此优化器最好不要将下面代码中的第二个读取操作优化掉：</p>\n<pre><code>long t1 = clock;\n// ... 这里没有对 clock 的使用 ...\nlong t2 = clock;\n</code></pre>\n<p><code>clock</code>  为  <code>const</code>  是因为程序不应当试图写入  <code>clock</code> 。</p>\n<h5 id=\"注解-271\"><a class=\"markdownIt-Anchor\" href=\"#注解-271\">#</a> 注解</h5>\n<p>除非你是在编写直接操作硬件的最底层代码，否则应当把  <code>volatile</code>  当做是某种深奥的功能特性并最好避免使用。</p>\n<h5 id=\"示例-276\"><a class=\"markdownIt-Anchor\" href=\"#示例-276\">#</a> 示例</h5>\n<p>通常 C++ 代码接受的  <code>volatile</code>  内存是由别处所拥有的（硬件或其他语言）：</p>\n<pre><code>int volatile* vi = get_hardware_memory_location();\n    // 注意：我们获得了指向别人的内存的指针\n    // volatile 说明“请特别尊重地对待”\n</code></pre>\n<p>有时候 C++ 代码会分配  <code>volatile</code>  内存，并通过故意地暴露一个指针来将其共享给 “别人”（硬件或其他语言）：</p>\n<pre><code>static volatile long vl;\nplease_use_this(&amp;vl);   // 暴露对这个的一个引用给“别人”（不是 C++）\n</code></pre>\n<h5 id=\"示例不好-124\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-124\">#</a> 示例，不好</h5>\n<p><code>volatile</code>  局部变量几乎都是错误的 —— 既然是短暂的，它们如何才能共享给其他语言或硬件呢？<br>\n因为相同的理由，这几乎同样强有力地适用于成员变量。</p>\n<pre><code>void f()\n&#123;\n    volatile int i = 0; // 不好，volatile 局部变量\n    // etc.\n&#125;\n\nclass My_type &#123;\n    volatile int i = 0; // 可以的，volatile 成员变量\n    // etc.\n&#125;;\n</code></pre>\n<h5 id=\"注解-272\"><a class=\"markdownIt-Anchor\" href=\"#注解-272\">#</a> 注解</h5>\n<p>于其他一些语言不通，C++ 中的  <code>volatile</code>  <a href=\"#Rconc-volatile\">和同步没有任何关系</a>。</p>\n<h5 id=\"强制实施-284\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-284\">#</a> 强制实施</h5>\n<ul>\n<li>对  <code>volatile T</code>  的局部成员变量进行标记；几乎肯定你应当用  <code>atomic&lt;T&gt;</code>  进行代替。</li>\n<li>???</li>\n</ul>\n<h3 id=\"a-namerconc-signalacp201-信号\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconc-signalacp201-信号\">#</a> <a name=\"Rconc-signal\"></a>CP.201: ??? 信号</h3>\n<p>???UNIX 信号处理？？？也许值得提及异步信号安全有多么微弱，以及如何同信号处理器进行通信（也许最好应当 “完全避免”）</p>\n<h1 id=\"a-names-errorsae-错误处理\"><a class=\"markdownIt-Anchor\" href=\"#a-names-errorsae-错误处理\">#</a> <a name=\"S-errors\"></a>E: 错误处理</h1>\n<p>错误处理涉及：</p>\n<ul>\n<li>检测某个错误</li>\n<li>将有关错误的信息传递给某个处理代码</li>\n<li>维持程序的某个有效状态</li>\n<li>避免资源泄漏</li>\n</ul>\n<p>不可能做到从所有的错误中恢复。如果从某个错误进行恢复是不可能的话，以明确定义的方式迅速 “脱离” 则是很重要的。错误处理的策略必须简单，否则就会成为更糟糕错误的来源。未经测试和很少被执行的错误处理代码自身也是许多 BUG 的来源。</p>\n<p>以下规则是设计用以帮助避免几种错误的：</p>\n<ul>\n<li>类型违规（比如对  <code>union</code>  和强制转换的误用）</li>\n<li>资源泄漏（包括内存泄漏）</li>\n<li>边界错误</li>\n<li>生存期错误（比如在对象被  <code>delete</code>  后访问它）</li>\n<li>复杂性错误（可能由于过于复杂的想法表达而导致的逻辑错误）</li>\n<li>接口错误（比如通过接口传递了预期外的值）</li>\n</ul>\n<p>错误处理规则概览：</p>\n<ul>\n<li>\n<p><a href=\"#Re-design\">E.1: 在设计中尽早开发错误处理策略</a></p>\n</li>\n<li>\n<p><a href=\"#Re-throw\">E.2: 通过抛出异常来明示函数无法完成其所赋予的任务</a></p>\n</li>\n<li>\n<p><a href=\"#Re-errors\">E.3: 仅使用异常来进行错误处理</a></p>\n</li>\n<li>\n<p><a href=\"#Re-design-invariants\">E.4: 围绕不变式来设计错误处理策略</a></p>\n</li>\n<li>\n<p><a href=\"#Re-invariant\">E.5: 让构造函数建立不变式，若其无法做到则抛出异常</a></p>\n</li>\n<li>\n<p><a href=\"#Re-raii\">E.6: 使用 RAII 来避免泄漏</a></p>\n</li>\n<li>\n<p><a href=\"#Re-precondition\">E.7: 明示前条件</a></p>\n</li>\n<li>\n<p><a href=\"#Re-postcondition\">E.8: 明示后条件</a></p>\n</li>\n<li>\n<p><a href=\"#Re-noexcept\">E.12: 当函数不可能或不能接受以  <code>throw</code>  来退出时，使用  <code>noexcept</code> </a></p>\n</li>\n<li>\n<p><a href=\"#Re-never-throw\">E.13: 不要在作为某个对象的直接所有者时抛出异常</a></p>\n</li>\n<li>\n<p><a href=\"#Re-exception-types\">E.14: 应当使用为目的所设计的自定义类型（而不是内建类型）作为异常</a></p>\n</li>\n<li>\n<p><a href=\"#Re-exception-ref\">E.15: 按值抛出并按引用捕获类型层次中的异常</a></p>\n</li>\n<li>\n<p><a href=\"#Re-never-fail\">E.16: 析构函数，回收函数， <code>swap</code> ，以及异常类型的复制 / 移动构造决不能失败</a></p>\n</li>\n<li>\n<p><a href=\"#Re-not-always\">E.17: 不要试图在每个函数中捕获每个异常</a></p>\n</li>\n<li>\n<p><a href=\"#Re-catch\">E.18: 最小化对  <code>try</code> / <code>catch</code>  的显式使用</a></p>\n</li>\n<li>\n<p><a href=\"#Re-finally\">E.19: 当没有合适的资源包装时，使用  <code>final_action</code>  对象来表达清理动作</a></p>\n</li>\n<li>\n<p><a href=\"#Re-no-throw-raii\">E.25: 当不能抛出异常时，模拟 RAII 来进行资源管理</a></p>\n</li>\n<li>\n<p><a href=\"#Re-no-throw-crash\">E.26: 当不能抛出异常时，考虑采取快速失败</a></p>\n</li>\n<li>\n<p><a href=\"#Re-no-throw-codes\">E.27: 当不能抛出异常时，系统化地使用错误代码</a></p>\n</li>\n<li>\n<p><a href=\"#Re-no-throw\">E.28: 避免基于全局状态（比如  <code>errno</code> ）的错误处理</a></p>\n</li>\n<li>\n<p><a href=\"#Re-specifications\">E.30: 请勿使用异常说明</a></p>\n</li>\n<li>\n<p><a href=\"#Re_catch\">E.31: 恰当地对  <code>catch</code>  子句排序</a></p>\n</li>\n</ul>\n<h3 id=\"a-namere-designae1-在设计中尽早开发错误处理策略\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-designae1-在设计中尽早开发错误处理策略\">#</a> <a name=\"Re-design\"></a>E.1: 在设计中尽早开发错误处理策略</h3>\n<h5 id=\"理由-310\"><a class=\"markdownIt-Anchor\" href=\"#理由-310\">#</a> 理由</h5>\n<p>在一个系统中改造翻新一种一致且完整的处理错误和资源泄漏的策略是很难的。</p>\n<h3 id=\"a-namere-throwae2-通过抛出异常来明示函数无法完成其所赋予的任务\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-throwae2-通过抛出异常来明示函数无法完成其所赋予的任务\">#</a> <a name=\"Re-throw\"></a>E.2: 通过抛出异常来明示函数无法完成其所赋予的任务</h3>\n<h5 id=\"理由-311\"><a class=\"markdownIt-Anchor\" href=\"#理由-311\">#</a> 理由</h5>\n<p>让错误处理有系统性，强健，而且避免重复。</p>\n<h5 id=\"示例-277\"><a class=\"markdownIt-Anchor\" href=\"#示例-277\">#</a> 示例</h5>\n<pre><code>struct Foo &#123;\n    vector&lt;Thing&gt; v;\n    File_handle f;\n    string s;\n&#125;;\n\nvoid use()\n&#123;\n    Foo bar &#123;&#123; \"&#123;&#123;\" &#125;&#125;Thing&#123;1&#125;, Thing&#123;2&#125;, Thing&#123;monkey&#125;&#125;, &#123;&quot;my_file&quot;, &quot;r&quot;&#125;, &quot;Here we go!&quot;&#125;;\n    // ...\n&#125;\n</code></pre>\n<p>这里， <code>vector</code>  和  <code>string</code>  的构造函数可能无法为其元素分配足够的内存， <code>vector</code>  的构造函数可能无法复制其初始化式列表中的  <code>Thing</code> ，而  <code>File_handle</code>  可能无法打开所需的文件。<br>\n这些情况中，它们都会抛出异常来让  <code>use()</code>  的调用者来处理。<br>\n如果  <code>use()</code>  可以处理这种构造  <code>bar</code>  的故障的话，它可以用  <code>try</code> / <code>catch</code>  来控制。<br>\n这些情况下， <code>Foo</code>  的构造函数都会在把控制传递给试图创建  <code>Foo</code>  的任何代码之前恰当地销毁以及构造的内存。<br>\n注意它并不存在可以包含错误代码的返回值。</p>\n<p><code>File_handle</code>  的构造函数可以这样定义：</p>\n<pre><code>File_handle::File_handle(const string&amp; name, const string&amp; mode)\n    : f&#123;fopen(name.c_str(), mode.c_str())&#125;\n&#123;\n    if (!f)\n        throw runtime_error&#123;&quot;File_handle: could not open &quot; + name + &quot; as &quot; + mode&quot;&#125;\n&#125;\n</code></pre>\n<h5 id=\"注解-273\"><a class=\"markdownIt-Anchor\" href=\"#注解-273\">#</a> 注解</h5>\n<p>人们通常说异常应当用于表明意外的事件和故障。<br>\n不过这里面存在一点循环，“什么是意外的？”<br>\n 例如：</p>\n<ul>\n<li>无法满足的前条件</li>\n<li>无法构造对象的构造函数（无法建立类的<a href=\"#Rc-struct\">不变式</a>）</li>\n<li>越界错误（比如  <code>v[v.size()] = 7</code> ）</li>\n<li>无法获得资源（比如网络未连接）</li>\n</ul>\n<p>相较而言，终止某个普通的循环则不是意外的。<br>\n除非这个循环本应当是无限循环，否则其终止就是正常且符合预期的。</p>\n<h5 id=\"注解-274\"><a class=\"markdownIt-Anchor\" href=\"#注解-274\">#</a> 注解</h5>\n<p>不要用  <code>throw</code>  仅仅作为从函数中返回值的另一种方式。</p>\n<h5 id=\"例外-55\"><a class=\"markdownIt-Anchor\" href=\"#例外-55\">#</a> 例外</h5>\n<p>某些系统，比如在执行开始之前就需要保证以（通常很短的）常量最大时间来执行动作的硬实时系统，这样的系统只有当存在工具可以支持精确地预测从一次  <code>throw</code>  中恢复的最大时间时才能使用异常。</p>\n<p><strong>参见</strong>: <a href=\"#Re-raii\">RAII</a></p>\n<p><strong>参见</strong>: <a href=\"#Sd-noexcept\">讨论</a></p>\n<h5 id=\"注解-275\"><a class=\"markdownIt-Anchor\" href=\"#注解-275\">#</a> 注解</h5>\n<p>在你决定你无法负担或者不喜欢基于异常的错误处理之前，请看一看<a href=\"#Re-no-throw-raii\">替代方案</a>；<br>\n它们各自都有自己的复杂性和问题。<br>\n同样地，只要可能的话，就应该进行测量之后再发表有关效率的言论。</p>\n<h3 id=\"a-namere-errorsae3-仅使用异常来进行错误处理\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-errorsae3-仅使用异常来进行错误处理\">#</a> <a name=\"Re-errors\"></a>E.3: 仅使用异常来进行错误处理</h3>\n<h5 id=\"理由-312\"><a class=\"markdownIt-Anchor\" href=\"#理由-312\">#</a> 理由</h5>\n<p>以保持错误处理和 “常规代码” 互相分离。<br>\nC++ 实现都倾向于基于假定异常的稀有而进行优化。</p>\n<h5 id=\"示例请勿如此-2\"><a class=\"markdownIt-Anchor\" href=\"#示例请勿如此-2\">#</a> 示例，请勿如此</h5>\n<pre><code>// 请勿如此: 异常并未用于错误处理\nint find_index(vector&lt;string&gt;&amp; vec, const string&amp; x)\n&#123;\n    try &#123;\n        for (gsl::index i = 0; i &lt; vec.size(); ++i)\n            if (vec[i] == x) throw i;  // 找到了 x\n    &#125;\n    catch (int i) &#123;\n        return i;\n    &#125;\n    return -1;   // 未找到\n&#125;\n</code></pre>\n<p>这种代码要比显然的替代方式更加复杂，而且极可能运行慢得多。<br>\n在  <code>vector</code>  中寻找一个值是没什么意外情况的。</p>\n<h5 id=\"强制实施-285\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-285\">#</a> 强制实施</h5>\n<p>可能应该是启发式措施。<br>\n查找从  <code>catch</code>  子句 “漏掉” 的异常值。</p>\n<h3 id=\"a-namere-design-invariantsae4-围绕不变式来设计错误处理策略\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-design-invariantsae4-围绕不变式来设计错误处理策略\">#</a> <a name=\"Re-design-invariants\"></a>E.4: 围绕不变式来设计错误处理策略</h3>\n<h5 id=\"理由-313\"><a class=\"markdownIt-Anchor\" href=\"#理由-313\">#</a> 理由</h5>\n<p>要使用一个对象，它必须处于某个（正式或非正式通过不变式所定义的）有效的状态，而要从错误中恢复，每个还未销毁的对象也必须处于有效的状态。</p>\n<h5 id=\"注解-276\"><a class=\"markdownIt-Anchor\" href=\"#注解-276\">#</a> 注解</h5>\n<p><a href=\"#Rc-struct\">不变式</a>是对象的成员的逻辑条件，构造函数必须进行建立，且为公开的成员函数所假定。</p>\n<h5 id=\"强制实施-286\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-286\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namere-invariantae5-让构造函数建立不变式若其无法做到则抛出异常\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-invariantae5-让构造函数建立不变式若其无法做到则抛出异常\">#</a> <a name=\"Re-invariant\"></a>E.5: 让构造函数建立不变式，若其无法做到则抛出异常</h3>\n<h5 id=\"理由-314\"><a class=\"markdownIt-Anchor\" href=\"#理由-314\">#</a> 理由</h5>\n<p>遗留仍未建立不变式的对象将会带来麻烦。<br>\n不是任何成员函数都可以对其进行调用。</p>\n<h5 id=\"示例-278\"><a class=\"markdownIt-Anchor\" href=\"#示例-278\">#</a> 示例</h5>\n<pre><code>class Vector &#123;  // 非常简单的 double 向量\n    // 当 elem != nullptr 时 elem 指向 sz 个 double\npublic:\n    Vector() : elem&#123;nullptr&#125;, sz&#123;0&#125;&#123;&#125;\n    Vector(int s) : elem&#123;new double[s]&#125;, sz&#123;s&#125; &#123; /* 元素的初始化 */ &#125;\n    ~Vector() &#123; delete [] elem; &#125;\n    double&amp; operator[](int s) &#123; return elem[s]; &#125;\n    // ...\nprivate:\n    owner&lt;double*&gt; elem;\n    int sz;\n&#125;;\n</code></pre>\n<p>类不变式 —— 这里以代码注释说明 —— 是由构造函数建立的。<br>\n当  <code>new</code>  无法分配所需的内存时将抛出异常。<br>\n各运算符，尤其是下标运算符，都是依赖于这个不变式的。</p>\n<p><strong>参见</strong>: <a href=\"#Rc-throw\">当构造函数无法构造有效对象时，应当抛出异常</a></p>\n<h5 id=\"强制实施-287\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-287\">#</a> 强制实施</h5>\n<p>对带有  <code>private</code>  状态但没有（公开，受保护或私有的）构造函数的类进行标记。</p>\n<h3 id=\"a-namere-raiiae6-使用-raii-来避免泄漏\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-raiiae6-使用-raii-来避免泄漏\">#</a> <a name=\"Re-raii\"></a>E.6: 使用 RAII 来避免泄漏</h3>\n<h5 id=\"理由-315\"><a class=\"markdownIt-Anchor\" href=\"#理由-315\">#</a> 理由</h5>\n<p>资源泄漏通常是不可接受的。<br>\n手工的资源释放很易出错。<br>\nRAII（Resource Acquisition Is Initialization，资源获取即初始化）是最简单，最系统化的避免泄漏方案。</p>\n<h5 id=\"示例-279\"><a class=\"markdownIt-Anchor\" href=\"#示例-279\">#</a> 示例</h5>\n<pre><code>void f1(int i)   // 不好: 可能会泄漏\n&#123;\n    int* p = new int[12];\n    // ...\n    if (i &lt; 17) throw Bad&#123;&quot;in f()&quot;, i&#125;;\n    // ...\n&#125;\n</code></pre>\n<p>我们可以在抛出异常前小心地释放资源：</p>\n<pre><code>void f2(int i)   // 笨拙且易错: 显式的释放\n&#123;\n    int* p = new int[12];\n    // ...\n    if (i &lt; 17) &#123;\n        delete[] p;\n        throw Bad&#123;&quot;in f()&quot;, i&#125;;\n    &#125;\n    // ...\n&#125;\n</code></pre>\n<p>这样很啰嗦。在更大型的可能带有多个  <code>throw</code>  的代码中，显式的释放将变得重复且易错。</p>\n<pre><code>void f3(int i)   // OK: 通过资源包装来进行资源管理（请见下文）\n&#123;\n    auto p = make_unique&lt;int[]&gt;(12);\n    // ...\n    if (i &lt; 17) throw Bad&#123;&quot;in f()&quot;, i&#125;;\n    // ...\n&#125;\n</code></pre>\n<p>注意即使  <code>throw</code>  是在所调用的函数中暗中发生，这也能正常工作：</p>\n<pre><code>void f4(int i)   // OK: 通过资源包装来进行资源管理（请见下文）\n&#123;\n    auto p = make_unique&lt;int[]&gt;(12);\n    // ...\n    helper(i);   // 可能抛出异常\n    // ...\n&#125;\n</code></pre>\n<p>除非你确实需要指针语义，否则还是应当使用局部的资源对象：</p>\n<pre><code>void f5(int i)   // OK: 通过局部对象来进行资源管理\n&#123;\n    vector&lt;int&gt; v(12);\n    // ...\n    helper(i);   // 可能抛出异常\n    // ...\n&#125;\n</code></pre>\n<p>这即简单又安全，而且通常更加高效。</p>\n<h5 id=\"注解-277\"><a class=\"markdownIt-Anchor\" href=\"#注解-277\">#</a> 注解</h5>\n<p>当没有合适的资源包装，且定义一个适当的 RAII 对象 / 包装由于某种原因不可行时，<br>\n万不得已，可以使用 <a href=\"#Re-finally\"> <code>final_action</code>  对象</a>来表达清理动作。</p>\n<h5 id=\"注解-278\"><a class=\"markdownIt-Anchor\" href=\"#注解-278\">#</a> 注解</h5>\n<p>但是当我们所编写的程序不能使用异常时应当怎么办呢？<br>\n首先应当质疑这项假设；到处都有许多反异常的错误认识。<br>\n据我们所知，只有少量正当理由：</p>\n<ul>\n<li>我们所在的系统太小，支持异常将会吃掉我们的 2K 内存的大部分。</li>\n<li>我们所在的是硬实时系统，而且我们没有工具能保证异常会在所需时间内处理掉。</li>\n<li>我们所在的系统中有成吨的遗留代码以难于理解的方式大量地使用指针<br>\n（尤其是没有可识别的所有权策略），因此异常可能会造成泄露。</li>\n<li>我们的 C++ 异常机制的实现不合理地糟糕<br>\n（很慢，很耗内存，对于动态链接库无法正确工作，等等）。<br>\n请向你的实现的供应商提出意见；如果没有用户提出意见，就不会出现改进。</li>\n<li>如果我们质疑经理的古老智慧的话会被炒鱿鱼。</li>\n</ul>\n<p>以上原因中只有第一条才是基础问题，因此一旦可能的话，还是要用异常来实现 RAII，或者设计你的 RAII 对象永不失败。<br>\n当无法使用异常时，可以模拟 RAII。<br>\n就是说，系统化地在对象构造之后检查其有效性，并且仍然在析构函数中释放所有的资源。<br>\n一种策略是为每个资源包装添加一个  <code>valid()</code>  操作：</p>\n<pre><code>void f()\n&#123;\n    vector&lt;string&gt; vs(100);   // 非 std::vector: 添加了 valid()\n    if (!vs.valid()) &#123;\n        // 处理错误或退出\n    &#125;\n\n    ifstream fs(&quot;foo&quot;);   // 非 std::ifstream: 添加了 valid()\n    if (!fs.valid()) &#123;\n        // 处理错误或退出\n    &#125;\n\n    // ...\n&#125; // 析构函数如常进行清理\n</code></pre>\n<p>显然这样做增加了代码大小，不允许隐式的 “异常”（ <code>valid()</code>  检查）传播，而且  <code>valid()</code>  检查可能被忘掉。<br>\n优先采用异常。</p>\n<p><strong>参见</strong>: <a href=\"#Re-noexcept\"> <code>noexcept</code>  的用法</a></p>\n<h5 id=\"强制实施-288\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-288\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namere-preconditionae7-明示前条件\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-preconditionae7-明示前条件\">#</a> <a name=\"Re-precondition\"></a>E.7: 明示前条件</h3>\n<h5 id=\"理由-316\"><a class=\"markdownIt-Anchor\" href=\"#理由-316\">#</a> 理由</h5>\n<p>避免接口错误。</p>\n<p><strong>参见</strong>: <a href=\"#Ri-pre\">前条件规则</a></p>\n<h3 id=\"a-namere-postconditionae8-明示后条件\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-postconditionae8-明示后条件\">#</a> <a name=\"Re-postcondition\"></a>E.8: 明示后条件</h3>\n<h5 id=\"理由-317\"><a class=\"markdownIt-Anchor\" href=\"#理由-317\">#</a> 理由</h5>\n<p>避免接口错误。</p>\n<p><strong>参见</strong>: <a href=\"#Ri-post\">后条件规则</a></p>\n<h3 id=\"a-namere-noexceptae12-当函数不可能或不能接受以-throw-来退出时使用-noexcept\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-noexceptae12-当函数不可能或不能接受以-throw-来退出时使用-noexcept\">#</a> <a name=\"Re-noexcept\"></a>E.12: 当函数不可能或不能接受以  <code>throw</code>  来退出时，使用  <code>noexcept</code></h3>\n<h5 id=\"理由-318\"><a class=\"markdownIt-Anchor\" href=\"#理由-318\">#</a> 理由</h5>\n<p>使错误处理系统化，强健，且高效。</p>\n<h5 id=\"示例-280\"><a class=\"markdownIt-Anchor\" href=\"#示例-280\">#</a> 示例</h5>\n<pre><code>double compute(double d) noexcept\n&#123;\n    return log(sqrt(d &lt;= 0 ? 1 : d));\n&#125;\n</code></pre>\n<p>这里，我们已知  <code>compute</code>  不会抛出异常，因为它仅由不会抛出异常的操作所组成。<br>\n通过将  <code>compute</code>  声明为  <code>noexcept</code> ，让编译器和人类阅读者获得信息，使其更容易理解和操作  <code>compute</code> 。</p>\n<h5 id=\"注解-279\"><a class=\"markdownIt-Anchor\" href=\"#注解-279\">#</a> 注解</h5>\n<p>许多标准库函数都是  <code>noexcept</code>  的，这包括所有从 C 标准库中 “继承” 来的标准库函数。</p>\n<h5 id=\"示例-281\"><a class=\"markdownIt-Anchor\" href=\"#示例-281\">#</a> 示例</h5>\n<pre><code>vector&lt;double&gt; munge(const vector&lt;double&gt;&amp; v) noexcept\n&#123;\n    vector&lt;double&gt; v2(v.size());\n    // ... 做一些事 ...\n&#125;\n</code></pre>\n<p>这里的  <code>noexcept</code>  表明我不希望或无法处理无法构造局部的  <code>vector</code>  对象的情形。<br>\n也就是说，我认为内存耗尽是一种严重的设计错误（类比于硬件故障），因此我希望当其发生时让程序崩溃。</p>\n<h5 id=\"注解-280\"><a class=\"markdownIt-Anchor\" href=\"#注解-280\">#</a> 注解</h5>\n<p>请勿使用传统的<a href=\"#Re-specifications\">异常说明</a>。</p>\n<h5 id=\"参见-3\"><a class=\"markdownIt-Anchor\" href=\"#参见-3\">#</a> 参见</h5>\n<p><a href=\"#Sd-noexcept\">讨论</a>。</p>\n<h3 id=\"a-namere-never-throwae13-不要在作为某个对象的直接所有者时抛出异常\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-never-throwae13-不要在作为某个对象的直接所有者时抛出异常\">#</a> <a name=\"Re-never-throw\"></a>E.13: 不要在作为某个对象的直接所有者时抛出异常</h3>\n<h5 id=\"理由-319\"><a class=\"markdownIt-Anchor\" href=\"#理由-319\">#</a> 理由</h5>\n<p>这可能导致一次泄漏。</p>\n<h5 id=\"示例-282\"><a class=\"markdownIt-Anchor\" href=\"#示例-282\">#</a> 示例</h5>\n<pre><code>void leak(int x)   // 请勿如此: 可能泄漏\n&#123;\n    auto p = new int&#123;7&#125;;\n    if (x &lt; 0) throw Get_me_out_of_here&#123;&#125;;  // 可能泄漏 *p\n    // ...\n    delete p;   // 可能不会执行到这里\n&#125;\n</code></pre>\n<p>避免这种问题的一种方法是坚持使用资源包装：</p>\n<pre><code>void no_leak(int x)\n&#123;\n    auto p = make_unique&lt;int&gt;(7);\n    if (x &lt; 0) throw Get_me_out_of_here&#123;&#125;;  // 将按需删除 *p\n    // ...\n    // 无须 delete p\n&#125;\n</code></pre>\n<p>另一种（通常更好）的方案是使用一个局部变量来消除指针的显式使用：</p>\n<pre><code>void no_leak_simplified(int x)\n&#123;\n    vector&lt;int&gt; v(7);\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"注解-281\"><a class=\"markdownIt-Anchor\" href=\"#注解-281\">#</a> 注解</h5>\n<p>如果有需要清理的某个局部 “东西”，但其并未表示为带有析构函数的对象，则这样的清理<br>\n也必须在  <code>throw</code>  之前完成。<br>\n有时候，<a href=\"#Re-finally\"> <code>finally()</code> </a> 可以把这种不系统的清理变得更加可管理一些。</p>\n<h3 id=\"a-namere-exception-typesae14-应当使用为目的所设计的自定义类型而不是内建类型作为异常\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-exception-typesae14-应当使用为目的所设计的自定义类型而不是内建类型作为异常\">#</a> <a name=\"Re-exception-types\"></a>E.14: 应当使用为目的所设计的自定义类型（而不是内建类型）作为异常</h3>\n<h5 id=\"理由-320\"><a class=\"markdownIt-Anchor\" href=\"#理由-320\">#</a> 理由</h5>\n<p>自定义类型可以把有关某个错误的信息更好地传递给处理器。<br>\n这些信息可以编码到类型自身中，而类型则不大可能会和其他人的异常造成冲突。</p>\n<h5 id=\"示例-283\"><a class=\"markdownIt-Anchor\" href=\"#示例-283\">#</a> 示例</h5>\n<pre><code>throw 7; // 不好\n\nthrow &quot;something bad&quot;;  // 不好\n\nthrow std::exception(); // 不好 - 未提供信息\n</code></pre>\n<p>从  <code>std::exception</code>  派生，能够获得选择捕获特定异常或者通过  <code>std::exception</code>  进行通盘处理的灵活性：</p>\n<pre><code>class MyException: public std::runtime_error\n&#123;\npublic:\n    MyException(const string&amp; msg) : std::runtime_error(msg) &#123;&#125;\n    // ...\n&#125;;\n\n// ...\n\nthrow MyException(&quot;something bad&quot;);  // 好\n</code></pre>\n<p>异常可以不必派生于  <code>std::exception</code> ：</p>\n<pre><code>class MyCustomError final &#123;&#125;;  // 并未派生于 std::exception\n\n// ...\n\nthrow MyCustomError&#123;&#125;;  // 好 - 处理器必须捕获这个类型（或 ...）\n</code></pre>\n<p>当检测位置没有可以添加的有用信息时，可以使用派生于  <code>exception</code> <br>\n 的库类型作为通用类型：</p>\n<pre><code>throw std::runtime_error&#123;&quot;someting bad&quot;&#125;; // 好\n\n// ...\n\nthrow std::invalid_argument(&quot;i is not even&quot;); // 好\n</code></pre>\n<p>也可以使用  <code>enum</code>  类：</p>\n<pre><code>enum class alert &#123;RED, YELLOW, GREEN&#125;;\n\nthrow alert::RED; // 好\n</code></pre>\n<h5 id=\"强制实施-289\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-289\">#</a> 强制实施</h5>\n<p>识别针对内建类型和  <code>std::exception</code>  的  <code>throw</code> 。</p>\n<h3 id=\"a-namere-exception-refae15-按值抛出并按引用捕获类型层次中的异常\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-exception-refae15-按值抛出并按引用捕获类型层次中的异常\">#</a> <a name=\"Re-exception-ref\"></a>E.15: 按值抛出并按引用捕获类型层次中的异常</h3>\n<h5 id=\"理由-321\"><a class=\"markdownIt-Anchor\" href=\"#理由-321\">#</a> 理由</h5>\n<p>按值（而非指针）抛出并按引用捕获，能避免进行复制，尤其是基类子对象的切片。</p>\n<h5 id=\"示例不好-125\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-125\">#</a> 示例，不好</h5>\n<pre><code>void f()\n&#123;\n    try &#123;\n        // ...\n        throw new widget&#123;&#125;; // 请勿如此：抛出值而不要抛出原始指针\n        // ...\n    &#125;\n    catch (base_class e) &#123;  // 请勿如此: 可能造成切片\n        // ...\n    &#125;\n&#125;\n</code></pre>\n<p>可以代之以引用：</p>\n<pre><code>catch (base_class&amp; e) &#123; /* ... */ &#125;\n</code></pre>\n<p>或者（通常更好的） <code>const</code>  引用：</p>\n<pre><code>catch (const base_class&amp; e) &#123; /* ... */ &#125;\n</code></pre>\n<p>大多数处理器并不会改动异常，一般情况下我们都会<a href=\"#Res-const\">建议使用  <code>const</code> </a>。</p>\n<h5 id=\"注解-282\"><a class=\"markdownIt-Anchor\" href=\"#注解-282\">#</a> 注解</h5>\n<p>对于如一个  <code>enum</code>  值这样的小型值类型来说，按值捕获是合适的。</p>\n<h5 id=\"注解-283\"><a class=\"markdownIt-Anchor\" href=\"#注解-283\">#</a> 注解</h5>\n<p>重新抛出已捕获的异常应当使用  <code>throw;</code>  而非  <code>throw e;</code> 。使用  <code>throw e;</code>  将会抛出  <code>e</code>  的一个新副本（并于异常被  <code>catch (const std::exception&amp; e)</code>  捕获时切片成静态类型  <code>std::exception</code> ），而并非重新抛出原来的  <code>std::runtime_error</code>  类型的异常。（但请关注<a href=\"#Re-not-always\">请勿试图在每个函数中捕获所有的异常</a>，以及<a href=\"#Re-catch\">尽可能减少  <code>try</code> / <code>catch</code>  的显式使用</a>。)</p>\n<h5 id=\"强制实施-290\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-290\">#</a> 强制实施</h5>\n<ul>\n<li>对按值捕获具有虚函数的类型进行标记。</li>\n<li>对抛出原始指针进行标记。</li>\n</ul>\n<h3 id=\"a-namere-never-failae16-析构函数回收函数swap以及异常类型的复制移动构造决不能失败\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-never-failae16-析构函数回收函数swap以及异常类型的复制移动构造决不能失败\">#</a> <a name=\"Re-never-fail\"></a>E.16: 析构函数，回收函数， <code>swap</code> ，以及异常类型的复制 / 移动构造决不能失败</h3>\n<h5 id=\"理由-322\"><a class=\"markdownIt-Anchor\" href=\"#理由-322\">#</a> 理由</h5>\n<p>如果析构函数， <code>swap</code> ，内存回收，或者尝试复制 / 移动异常对象时会失败，就是说如果它会通过异常而退出，或者根本不会实施其所需的动作，我们就将不知道应当如何编写可靠的程序。</p>\n<h5 id=\"示例请勿如此-3\"><a class=\"markdownIt-Anchor\" href=\"#示例请勿如此-3\">#</a> 示例，请勿如此</h5>\n<pre><code>class Connection &#123;\n    // ...\npublic:\n    ~Connection()   // 请勿如此: 非常糟糕的析构函数\n    &#123;\n        if (cannot_disconnect()) throw I_give_up&#123;information&#125;;\n        // ...\n    &#125;\n&#125;;\n</code></pre>\n<h5 id=\"注解-284\"><a class=\"markdownIt-Anchor\" href=\"#注解-284\">#</a> 注解</h5>\n<p>许多人都曾试图编写违反这条规则的可靠代码，比如当网络连接 “拒绝关闭” 的情形。<br>\n尽我们所知，没人曾找到一个做到这点的通用方案。<br>\n虽然偶尔对于非常特殊的例子，你可以通过设置某个状态以便进行将来的清理的方式绕过它。<br>\n比如说，我们可能将一个不打算关闭的 socket 放入一个 “故障 socket” 列表之中，<br>\n让其被某个定期的系统状态清理所检查处理。<br>\n我们见过的每个这种例子都是易错的，专门的，而且通常有 BUG。</p>\n<h5 id=\"注解-285\"><a class=\"markdownIt-Anchor\" href=\"#注解-285\">#</a> 注解</h5>\n<p>标准库假定析构函数，回收函数（比如  <code>operator delete</code> ），和  <code>swap</code>  都不会抛出异常。当它们这样做时，基本的标准库不变式将会被打破。</p>\n<h5 id=\"注解-286\"><a class=\"markdownIt-Anchor\" href=\"#注解-286\">#</a> 注解</h5>\n<ul>\n<li>回收函数，包括  <code>operator delete</code> ，必须为  <code>noexcept</code> 。</li>\n<li><code>swap</code>  函数必须为  <code>noexcept</code> 。</li>\n<li>大多数的析构函数都是缺省隐含为  <code>noexcept</code>  的。</li>\n<li>而且，<a href=\"#Rc-move-noexcept\">应该使移动操作为  <code>noexcept</code> </a>。</li>\n<li>当编写用作异常类型的类型时，确保其复制构造函数不为  <code>noexcept</code> 。一般来说我们没法机制化地强制这一点，因为我们并不了解一个类型是否有意作为一种异常类型。</li>\n<li>尝试避免抛出复制构造函数不为  <code>noexcept</code>  的类型。一般来说我们没法机制化地强制这一点，因为即便  <code>throw std::string(...)</code>  也可能抛异常，虽然实际上并不会。</li>\n</ul>\n<h5 id=\"强制实施-291\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-291\">#</a> 强制实施</h5>\n<ul>\n<li>识别会  <code>throw</code>  的析构函数，回收操作，和  <code>swap</code> 。</li>\n<li>识别不为  <code>noexcept</code>  的这类操作。</li>\n</ul>\n<p><strong>参见</strong>: <a href=\"#Sd-never-fail\">讨论</a></p>\n<h3 id=\"a-namere-not-alwaysae17-不要试图在每个函数中捕获每个异常\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-not-alwaysae17-不要试图在每个函数中捕获每个异常\">#</a> <a name=\"Re-not-always\"></a>E.17: 不要试图在每个函数中捕获每个异常</h3>\n<h5 id=\"理由-323\"><a class=\"markdownIt-Anchor\" href=\"#理由-323\">#</a> 理由</h5>\n<p>如果函数无法对异常进行有意义的恢复动作，其捕获这个异常就导致复杂性和浪费。<br>\n要让异常传播直到遇到一个可以处理它的函数。<br>\n要用 <a href=\"#Re-raii\">RAII</a> 来处理栈回溯路径上的清理操作。</p>\n<h5 id=\"示例请勿如此-4\"><a class=\"markdownIt-Anchor\" href=\"#示例请勿如此-4\">#</a> 示例，请勿如此</h5>\n<pre><code>void f()   // 不好\n&#123;\n    try &#123;\n        // ...\n    &#125;\n    catch (...) &#123;\n        // 不做任何事\n        throw;   // 传播异常\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"强制实施-292\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-292\">#</a> 强制实施</h5>\n<ul>\n<li>标记嵌套的  <code>try</code>  块。</li>\n<li>对带有过高的  <code>try</code>  块 / 函数比率的源代码文件进行标记。 (??? 问题：定义 “过高”)</li>\n</ul>\n<h3 id=\"a-namere-catchae18-最小化对-trycatch-的显式使用\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-catchae18-最小化对-trycatch-的显式使用\">#</a> <a name=\"Re-catch\"></a>E.18: 最小化对  <code>try</code> / <code>catch</code>  的显式使用</h3>\n<h5 id=\"理由-324\"><a class=\"markdownIt-Anchor\" href=\"#理由-324\">#</a> 理由</h5>\n<p><code>try</code> / <code>catch</code>  很啰嗦，而且非平凡的使用是易错的。<br>\n <code>try</code> / <code>catch</code>  可以作为对非系统化和 / 或低级的资源管理或错误处理的一个信号。</p>\n<h5 id=\"示例不好-126\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-126\">#</a> 示例，不好</h5>\n<pre><code>void f(zstring s)\n&#123;\n    Gadget* p;\n    try &#123;\n        p = new Gadget(s);\n        // ...\n        delete p;\n    &#125;\n    catch (Gadget_construction_failure) &#123;\n        delete p;\n        throw;\n    &#125;\n&#125;\n</code></pre>\n<p>这段代码很混乱。<br>\n可能在  <code>try</code>  块中的裸指针上发生泄漏。<br>\n不是所有的异常都被处理了。<br>\n <code>delete</code>  一个构造失败的对象几乎肯定是一个错误。<br>\n更好的是：</p>\n<pre><code>void f2(zstring s)\n&#123;\n    Gadget g &#123;s&#125;;\n&#125;\n</code></pre>\n<h5 id=\"替代方案-16\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-16\">#</a> 替代方案</h5>\n<ul>\n<li>合适的资源包装以及 <a href=\"#Re-raii\">RAII</a></li>\n<li><a href=\"#Re-finally\"> <code>finally</code> </a></li>\n</ul>\n<h5 id=\"强制实施-293\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-293\">#</a> 强制实施</h5>\n<p>??? 很难，需要启发式方法</p>\n<h3 id=\"a-namere-finallyae19-当没有合适的资源包装时使用-final_action-对象来表达清理动作\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-finallyae19-当没有合适的资源包装时使用-final_action-对象来表达清理动作\">#</a> <a name=\"Re-finally\"></a>E.19: 当没有合适的资源包装时，使用  <code>final_action</code>  对象来表达清理动作</h3>\n<h5 id=\"理由-325\"><a class=\"markdownIt-Anchor\" href=\"#理由-325\">#</a> 理由</h5>\n<p><a href=\"#gsl-guidelines-support-library\">GSL</a> 提供的  <code>finally</code>  要比  <code>try</code> / <code>catch</code>  更不啰嗦且难于搞错。</p>\n<h5 id=\"示例-284\"><a class=\"markdownIt-Anchor\" href=\"#示例-284\">#</a> 示例</h5>\n<pre><code>void f(int n)\n&#123;\n    void* p = malloc(n);\n    auto _ = gsl::finally([p] &#123; free(p); &#125;);\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"注解-287\"><a class=\"markdownIt-Anchor\" href=\"#注解-287\">#</a> 注解</h5>\n<p><code>finally</code>  没有  <code>try</code> / <code>catch</code>  那样混乱，但它仍然比较专门化。<br>\n优先采用<a href=\"#Re-raii\">适当的资源管理对象</a>。<br>\n万不得已考虑使用  <code>finally</code> 。</p>\n<h5 id=\"注解-288\"><a class=\"markdownIt-Anchor\" href=\"#注解-288\">#</a> 注解</h5>\n<p>相对于老式的 <a href=\"#Re-no-throw-codes\"> <code>goto exit;</code>  技巧</a>来说，使用  <code>finally</code>  是处理并非系统化的资源管理中的清理工作的<br>\n更加系统化并且相当简洁的方案。</p>\n<h5 id=\"强制实施-294\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-294\">#</a> 强制实施</h5>\n<p>启发式措施：检测  <code>goto exit;</code> 。</p>\n<h3 id=\"a-namere-no-throw-raiiae25-当不能抛出异常时模拟-raii-来进行资源管理\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-no-throw-raiiae25-当不能抛出异常时模拟-raii-来进行资源管理\">#</a> <a name=\"Re-no-throw-raii\"></a>E.25: 当不能抛出异常时，模拟 RAII 来进行资源管理</h3>\n<h5 id=\"理由-326\"><a class=\"markdownIt-Anchor\" href=\"#理由-326\">#</a> 理由</h5>\n<p>即便没有异常，<a href=\"#Re-raii\">RAII</a> 通常仍然是最佳且最系统化的处理资源的方式。</p>\n<h5 id=\"注解-289\"><a class=\"markdownIt-Anchor\" href=\"#注解-289\">#</a> 注解</h5>\n<p>使用异常进行错误处理，是 C++ 中唯一完整且系统化的处理非局部错误的方式。<br>\n特别是，非侵入地对对象构造的失败进行报告需要使用异常。<br>\n以无法被忽略的方式报告错误需要使用异常。<br>\n如果无法使用异常，应当尽你所能模拟它们的使用。</p>\n<p>大量对异常的惧怕是被误导的。<br>\n当用在并非充斥指针和复杂控制结构的代码中的违例情形时，<br>\n异常处理几乎总是（在时间和空间上）可以负担，且几乎总会导致更好的代码。<br>\n当然这假定存在一个优良的异常处理机制实现，而这并非在所有系统上都存在。<br>\n存在另一些情况并不适用于上述问题，但由于其他原因而无法使用异常。<br>\n一个例子是一些硬实时系统：必须在固定的时间之内完成操作并得到错误或正确的响应。<br>\n在没有适当的时间评估工具的条件下，很难对异常作出保证。<br>\n这样的系统（比如飞控系统）通常也会禁止使用动态（堆）内存。</p>\n<p>因此，对于错误处理的主要指导方针还是 “使用异常和 <a href=\"#Re-raii\">RAII</a>。”<br>\n 本节所处理的情况是，要么你没有高效的异常实现，<br>\n或者要面对大量的老式代码<br>\n（比如说，大量的指针，不明确定义的所有权，以及大量的不系统化的基于错误代码检查的错误处理）<br>\n而且向其引入简单且系统化的错误处理的做法不可行。</p>\n<p>在宣称不能使用异常或者抱怨它们成本过高之前，应当考虑一下使用<a href=\"#Re-no-throw-codes\">错误代码</a>的例子。<br>\n请考虑使用错误代码的成本和复杂性。<br>\n如果你担心性能的话，请进行测量。</p>\n<h5 id=\"示例-285\"><a class=\"markdownIt-Anchor\" href=\"#示例-285\">#</a> 示例</h5>\n<p>假定你想要编写</p>\n<pre><code>void func(zstring arg)\n&#123;\n    Gadget g &#123;arg&#125;;\n    // ...\n&#125;\n</code></pre>\n<p>当这个  <code>g</code>  并未正确构造时， <code>func</code>  将以一个异常退出。<br>\n当无法抛出异常时，我们可以通过向  <code>Gadget</code>  添加  <code>valid()</code>  成员函数来模拟 RAII 风格的资源包装：</p>\n<pre><code>error_indicator func(zstring arg)\n&#123;\n    Gadget g &#123;arg&#125;;\n    if (!g.valid()) return gadget_construction_error;\n    // ...\n    return 0;   // 零代表“正常”\n&#125;\n</code></pre>\n<p>显然问题现在变成了调用者必须记得测试其返回值。考虑添加  <code>[[nodiscard]]</code>  以鼓励这样的做法。</p>\n<p><strong>参见</strong>: <a href=\"#Sd-???\">讨论</a></p>\n<h5 id=\"强制实施-295\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-295\">#</a> 强制实施</h5>\n<p>（仅）对于这种想法的特定版本是可能的：比如检查资源包装的构造后进行系统化的  <code>valid()</code>  测试。</p>\n<h3 id=\"a-namere-no-throw-crashae26-当不能抛出异常时考虑采取快速失败\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-no-throw-crashae26-当不能抛出异常时考虑采取快速失败\">#</a> <a name=\"Re-no-throw-crash\"></a>E.26: 当不能抛出异常时，考虑采取快速失败</h3>\n<h5 id=\"理由-327\"><a class=\"markdownIt-Anchor\" href=\"#理由-327\">#</a> 理由</h5>\n<p>如果你无法做好错误恢复的话，至少你可以在发生更多后续的损害之前拜托出来。</p>\n<p><strong>参见</strong>：<a href=\"#Re-no-throw-raii\">模拟 RAII</a></p>\n<h5 id=\"注解-290\"><a class=\"markdownIt-Anchor\" href=\"#注解-290\">#</a> 注解</h5>\n<p>当你无法系统化地进行错误处理时，考虑以 “程序崩溃” 作为对任何无法局部处理的错误的回应。<br>\n就是说，如果你无法在检测到错误的函数的上下文中处理它，则调用  <code>abort()</code> ， <code>quick_exit()</code> ，<br>\n或者相似的某个将触发某种系统重启的函数。</p>\n<p>在具有大量进程和 / 或大量计算机的系统中，你总要预计到并处理这些关键程序崩溃，<br>\n比如说源于硬件故障而引发。<br>\n这种情况下，“程序崩溃” 只不过把错误处理留给了系统的下一个层次。</p>\n<h5 id=\"示例-286\"><a class=\"markdownIt-Anchor\" href=\"#示例-286\">#</a> 示例</h5>\n<pre><code>void f(int n)\n&#123;\n    // ...\n    p = static_cast&lt;X*&gt;(malloc(n * sizeof(X)));\n    if (!p) abort();     // 当内存耗尽时 abort\n    // ...\n&#125;\n</code></pre>\n<p>大多数程序都无法得体地处理内存耗尽。这大略上等价于</p>\n<pre><code>void f(int n)\n&#123;\n    // ...\n    p = new X[n];    // 当内存耗尽时抛出异常（默认情况会调用 terminate）\n    // ...\n&#125;\n</code></pre>\n<p>通常，在退出之前将 “崩溃” 的原因记录日志是个好主意。</p>\n<h5 id=\"强制实施-296\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-296\">#</a> 强制实施</h5>\n<p>很难对付</p>\n<h3 id=\"a-namere-no-throw-codesae27-当不能抛出异常时系统化地使用错误代码\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-no-throw-codesae27-当不能抛出异常时系统化地使用错误代码\">#</a> <a name=\"Re-no-throw-codes\"></a>E.27: 当不能抛出异常时，系统化地使用错误代码</h3>\n<h5 id=\"理由-328\"><a class=\"markdownIt-Anchor\" href=\"#理由-328\">#</a> 理由</h5>\n<p>系统化地使用任何错误处理策略都能最小化忘记处理错误的机会。</p>\n<p><strong>参见</strong>：<a href=\"#Re-no-throw-raii\">模拟 RAII</a></p>\n<h5 id=\"注解-291\"><a class=\"markdownIt-Anchor\" href=\"#注解-291\">#</a> 注解</h5>\n<p>需要处理几个问题：</p>\n<ul>\n<li>如何从函数向外传递错误指示？</li>\n<li>如何在错误退出函数之前释放所有资源？</li>\n<li>使用什么来作为错误指示？</li>\n</ul>\n<p>通常，返回错误指示意味着返回两个值：其结果以及一个错误指示。<br>\n错误指示可以是对象的一部分，例如对象可以带有  <code>valid()</code>  指示，<br>\n也可以返回一对值。</p>\n<h5 id=\"示例-287\"><a class=\"markdownIt-Anchor\" href=\"#示例-287\">#</a> 示例</h5>\n<pre><code>Gadget make_gadget(int n)\n&#123;\n    // ...\n&#125;\n\nvoid user()\n&#123;\n    Gadget g = make_gadget(17);\n    if (!g.valid()) &#123;\n            // 错误处理\n    &#125;\n    // ...\n&#125;\n</code></pre>\n<p>这种方案符合<a href=\"#Re-no-throw-raii\">模拟 RAII 资源管理</a>。<br>\n <code>valid()</code>  函数可以返回一个  <code>error_indicator</code> （比如说  <code>error_indicator</code>  枚举的某个成员）。</p>\n<h5 id=\"示例-288\"><a class=\"markdownIt-Anchor\" href=\"#示例-288\">#</a> 示例</h5>\n<p>要是我们无法或者不想改动  <code>Gadget</code>  类型呢？<br>\n这种情况下，我们只能返回一对值。<br>\n例如：</p>\n<pre><code>std::pair&lt;Gadget, error_indicator&gt; make_gadget(int n)\n&#123;\n    // ...\n&#125;\n\nvoid user()\n&#123;\n    auto r = make_gadget(17);\n    if (!r.second) &#123;\n            // 错误处理\n    &#125;\n    Gadget&amp; g = r.first;\n    // ...\n&#125;\n</code></pre>\n<p>可见， <code>std::pair</code>  是一种可能的返回类型。<br>\n某些人则更喜欢专门的类型。<br>\n例如：</p>\n<pre><code>Gval make_gadget(int n)\n&#123;\n    // ...\n&#125;\n\nvoid user()\n&#123;\n    auto r = make_gadget(17);\n    if (!r.err) &#123;\n            // 错误处理\n    &#125;\n    Gadget&amp; g = r.val;\n    // ...\n&#125;\n</code></pre>\n<p>倾向于专门返回类型的一种原因是为其成员提供命名，而不是使用多少有些隐秘的  <code>first</code>  和  <code>second</code> ,<br>\n 而且可以避免与  <code>std::pair</code>  的其他使用相混淆。</p>\n<h5 id=\"示例-289\"><a class=\"markdownIt-Anchor\" href=\"#示例-289\">#</a> 示例</h5>\n<p>通常，在错误退出之前必须进行清理。<br>\n这样做是很混乱的：</p>\n<pre><code>std::pair&lt;int, error_indicator&gt; user()\n&#123;\n    Gadget g1 = make_gadget(17);\n    if (!g1.valid()) &#123;\n        return &#123;0, g1_error&#125;;\n    &#125;\n\n    Gadget g2 = make_gadget(17);\n    if (!g2.valid()) &#123;\n        cleanup(g1);\n        return &#123;0, g2_error&#125;;\n    &#125;\n\n    // ...\n\n    if (all_foobar(g1, g2)) &#123;\n        cleanup(g2);\n        cleanup(g1);\n        return &#123;0, foobar_error&#125;;\n    &#125;\n\n    // ...\n\n    cleanup(g2);\n    cleanup(g1);\n    return &#123;res, 0&#125;;\n&#125;\n</code></pre>\n<p>模拟 RAII 可能不那么简单，尤其是在带有多个资源和多种可能错误的函数之中。<br>\n一种较为常见的技巧是把清理都集中到函数末尾以避免重复（注意这里本不必为  <code>g2</code>  增加一层作用域，但是编译  <code>goto</code>  版本却需要它）：</p>\n<pre><code>std::pair&lt;int, error_indicator&gt; user()\n&#123;\n    error_indicator err = 0;\n    int res = 0;\n\n    Gadget g1 = make_gadget(17);\n    if (!g1.valid()) &#123;\n        err = g1_error;\n        goto g1_exit;\n    &#125;\n\n    &#123;\n        Gadget g2 = make_gadget(31);\n        if (!g2.valid()) &#123;\n            err = g2_error;\n            goto g2_exit;\n        &#125;\n\n        if (all_foobar(g1, g2)) &#123;\n            err = foobar_error;\n            goto exit;\n        &#125;\n\n        // ...\n\n    g2_exit:\n        if (g2.valid()) cleanup(g2);\n    &#125;\n\ng1_exit:\n    if (g1.valid()) cleanup(g1);\n    return &#123;res,err&#125;;\n&#125;\n</code></pre>\n<p>函数越大，这种技巧就越有吸引力。<br>\n <code>finally</code>  可以<a href=\"#Re-finally\">略微缓解这个问题</a>。<br>\n而且，程序变得越大，系统化地采用一中基于错误指示的错误处理策略就越加困难。</p>\n<p>我们<a href=\"#Re-throw\">优先采用基于异常的错误处理</a>，并建议<a href=\"#Rf-single\">保持函数短小</a>。</p>\n<p><strong>参见</strong>: <a href=\"#Sd-???\">讨论</a></p>\n<p><strong>参见</strong>: <a href=\"#Rf-out-multi\">返回多个值</a></p>\n<h5 id=\"强制实施-297\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-297\">#</a> 强制实施</h5>\n<p>很难对付。</p>\n<h3 id=\"a-namere-no-throwae28-避免基于全局状态比如-errno的错误处理\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-no-throwae28-避免基于全局状态比如-errno的错误处理\">#</a> <a name=\"Re-no-throw\"></a>E.28: 避免基于全局状态（比如  <code>errno</code> ）的错误处理</h3>\n<h5 id=\"理由-329\"><a class=\"markdownIt-Anchor\" href=\"#理由-329\">#</a> 理由</h5>\n<p>全局状态难于管理，且易于忘记检查。<br>\n你上次检查  <code>printf()</code>  的返回值是什么时候了？</p>\n<p><strong>参见</strong>：<a href=\"#Re-no-throw-raii\">模拟 RAII</a></p>\n<h5 id=\"示例不好-127\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-127\">#</a> 示例，不好</h5>\n<pre><code>int last_err;\n\nvoid f(int n)\n&#123;\n    // ...\n    p = static_cast&lt;X*&gt;(malloc(n * sizeof(X)));\n    if (!p) last_err = -1;     // 当内存耗尽时发生的错误\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"注解-292\"><a class=\"markdownIt-Anchor\" href=\"#注解-292\">#</a> 注解</h5>\n<p>C 风格的错误处理就是基于全局变量  <code>errno</code>  的，因此基本上不可能完全避免这种风格。</p>\n<h5 id=\"强制实施-298\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-298\">#</a> 强制实施</h5>\n<p>很难对付。</p>\n<h3 id=\"a-namere-specificationsae30-请勿使用异常说明\"><a class=\"markdownIt-Anchor\" href=\"#a-namere-specificationsae30-请勿使用异常说明\">#</a> <a name=\"Re-specifications\"></a>E.30: 请勿使用异常说明</h3>\n<h5 id=\"理由-330\"><a class=\"markdownIt-Anchor\" href=\"#理由-330\">#</a> 理由</h5>\n<p>异常说明使得错误处理变得脆弱，隐含一些运行时开销，并且已经从 C++ 标准中被删除了。</p>\n<h5 id=\"示例-290\"><a class=\"markdownIt-Anchor\" href=\"#示例-290\">#</a> 示例</h5>\n<pre><code>int use(int arg)\n    throw(X, Y)\n&#123;\n    // ...\n    auto x = f(arg);\n    // ...\n&#125;\n</code></pre>\n<p>当  <code>f()</code>  抛出了不同于  <code>X</code>  和  <code>Y</code>  的异常时将会执行未预期异常处理器，其默认将终止程序。<br>\n这没什么问题，但假定我们检查过着并不会发生而  <code>f</code>  则被改写为抛出某个新异常  <code>Z</code> ，<br>\n这样将导致程序崩溃，除非我们改写  <code>use()</code> （并重新测试所有东西）。<br>\n障碍在于  <code>f()</code>  可能在某个我们无法控制的程序库中，而对于新的异常  <code>use()</code> <br>\n 没办法对其做任何事，或者对其完全不感兴趣。<br>\n我们可以改写  <code>use()</code>  使其传递  <code>Z</code>  出去，但这样的话  <code>use()</code>  的调用方可能也需要被改写。<br>\n如此事态将很快变得无法掌控。<br>\n或者，我们可以在  <code>use()</code>  中添加一个  <code>try</code> - <code>catch</code>  以将  <code>Z</code>  映射为某种可以接受的异常。<br>\n这种方法也会很快变得无法掌控。<br>\n注意，对异常集合的改动通常都发生在系统的最底层<br>\n（比如说，当改换了网络库或者某种中间件时），因此改变将沿着冗长的调用链 “冒泡上浮”。<br>\n在大型代码库中，这将意味着直到最后一个使用方也被改写之前，没人可以更新某个库到新版本。<br>\n如果  <code>use()</code>  是某个库的一部分，则也许不可能对其进行更新，因为其改动可能影响到未知的客户代码。</p>\n<p>而让异常继续传递直到其到达某个潜在可以处理它的函数的策略，已经在多年的实践中得到了证明。</p>\n<h5 id=\"注解-293\"><a class=\"markdownIt-Anchor\" href=\"#注解-293\">#</a> 注解</h5>\n<p>静态强制检查异常说明并不会带来任何好处。<br>\n相关例子请参见 <a href=\"#Stroustrup94\">Stroustrup94</a>。</p>\n<h5 id=\"注解-294\"><a class=\"markdownIt-Anchor\" href=\"#注解-294\">#</a> 注解</h5>\n<p>当不会抛出异常时，请使用 <a href=\"#Re-noexcept\"> <code>noexcept</code> </a>。</p>\n<h5 id=\"强制实施-299\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-299\">#</a> 强制实施</h5>\n<p>标记每个异常说明。</p>\n<h3 id=\"a-namere_catchae31-恰当地对-catch-子句排序\"><a class=\"markdownIt-Anchor\" href=\"#a-namere_catchae31-恰当地对-catch-子句排序\">#</a> <a name=\"Re_catch\"></a>E.31: 恰当地对  <code>catch</code>  子句排序</h3>\n<h5 id=\"理由-331\"><a class=\"markdownIt-Anchor\" href=\"#理由-331\">#</a> 理由</h5>\n<p><code>catch</code>  子句是以其出现顺序依次求值的，而其中一个可能会隐藏掉另一个。</p>\n<h5 id=\"示例不好-128\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-128\">#</a> 示例，不好</h5>\n<pre><code>void f()\n&#123;\n    // ...\n    try &#123;\n            // ...\n    &#125;\n    catch (Base&amp; b) &#123; /* ... */ &#125;\n    catch (Derived&amp; d) &#123; /* ... */ &#125;\n    catch (...) &#123; /* ... */ &#125;\n    catch (std::exception&amp; e) &#123; /* ... */ &#125;\n&#125;\n</code></pre>\n<p>若  <code>Derived</code>  派生自  <code>Base</code>  则  <code>Derived</code>  的处理器永远不会被执行。<br>\n“捕获任何东西” 的处理器保证  <code>std::exception</code>  的处理器永远不会被执行。</p>\n<h5 id=\"强制实施-300\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-300\">#</a> 强制实施</h5>\n<p>标记出所有的 “隐藏处理器”。</p>\n<h1 id=\"a-names-constacon-常量与不可变性\"><a class=\"markdownIt-Anchor\" href=\"#a-names-constacon-常量与不可变性\">#</a> <a name=\"S-const\"></a>Con: 常量与不可变性</h1>\n<p>常量是不会出现竞争条件的。<br>\n当大量的对象不会改变它们的值时，对程序进行推理将变得更容易。<br>\n承诺 “不改动” 作为参数所传递对象的接口，极大地提升了可读性。</p>\n<p>常量规则概览：</p>\n<ul>\n<li><a href=\"#Rconst-immutable\">Con.1: 缺省情况下，对象应当是不可变的</a></li>\n<li><a href=\"#Rconst-fct\">Con.2: 缺省情况下，成员函数应当为  <code>const</code> </a></li>\n<li><a href=\"#Rconst-ref\">Con.3: 缺省情况下，应当传递指向  <code>const</code>  对象的指针或引用</a></li>\n<li><a href=\"#Rconst-const\">Con.4: 构造之后不再改变其值的对象应当以  <code>const</code>  来定义</a></li>\n<li><a href=\"#Rconst-constexpr\">Con.5: 以  <code>constexpr</code>  来定义可以在编译期计算的值</a></li>\n</ul>\n<h3 id=\"a-namerconst-immutableacon1-缺省情况下对象应当是不可变的\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconst-immutableacon1-缺省情况下对象应当是不可变的\">#</a> <a name=\"Rconst-immutable\"></a>Con.1: 缺省情况下，对象应当是不可变的</h3>\n<h5 id=\"理由-332\"><a class=\"markdownIt-Anchor\" href=\"#理由-332\">#</a> 理由</h5>\n<p>不可变对象更易于进行推理，应仅当需要改动对象的值时，才使之为非  <code>const</code>  对象。<br>\n避免出现意外造成的或者很难发觉的值的改变。</p>\n<h5 id=\"示例-291\"><a class=\"markdownIt-Anchor\" href=\"#示例-291\">#</a> 示例</h5>\n<pre><code>for (const int i : c) cout &lt;&lt; i &lt;&lt; '\\n';    // 仅进行读取: const\n\nfor (int i : c) cout &lt;&lt; i &lt;&lt; '\\n';          // 不好: 仅进行读取\n</code></pre>\n<h5 id=\"例外-56\"><a class=\"markdownIt-Anchor\" href=\"#例外-56\">#</a> 例外</h5>\n<p>按值传递的函数参数很少被改动，但也很少被声明为  <code>const</code> 。<br>\n为了避免造成混淆和大量的误报，不要对函数参数实施这条规则。。</p>\n<pre><code>void f(const char* const p); // 迂腐\nvoid g(const int i) &#123; ... &#125;  // 迂腐\n</code></pre>\n<p>注意，函数参数是局部变量，其改动也是局部的。</p>\n<h5 id=\"强制实施-301\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-301\">#</a> 强制实施</h5>\n<ul>\n<li>标记未发生改动的非  <code>const</code>  变量（排除参数以避免误报）</li>\n</ul>\n<h3 id=\"a-namerconst-fctacon2-缺省情况下成员函数应当为-const\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconst-fctacon2-缺省情况下成员函数应当为-const\">#</a> <a name=\"Rconst-fct\"></a>Con.2: 缺省情况下，成员函数应当为  <code>const</code></h3>\n<h5 id=\"理由-333\"><a class=\"markdownIt-Anchor\" href=\"#理由-333\">#</a> 理由</h5>\n<p>除非成员函数会改变对象的可观察状态，否则它应当标记为  <code>const</code> 。<br>\n这样做更精确地描述了设计意图，具有更佳的可读性，编译器可以识别更多的错误，而且有时能够带来更多的优化机会。</p>\n<h5 id=\"示例不好-129\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-129\">#</a> 示例，不好</h5>\n<pre><code>class Point &#123;\n    int x, y;\npublic:\n    int getx() &#123; return x; &#125;    // 不好，应当为 const，它并不改变对象的状态\n    // ...\n&#125;;\n\nvoid f(const Point&amp; pt)\n&#123;\n    int x = pt.getx();          // 错误，无法通过编译，因为 getx 并未标记为 const\n&#125;\n</code></pre>\n<h5 id=\"注解-295\"><a class=\"markdownIt-Anchor\" href=\"#注解-295\">#</a> 注解</h5>\n<p>传递非  <code>const</code>  的指针或引用并非天生就是不好的，<br>\n但应当只有在所调用的函数预计会修改这个对象时才这样做。<br>\n代码的读者必须假定接受 “普通的”  <code>T*</code>  或  <code>T&amp;</code>  的函数都将会修改其所指代的对象。<br>\n如果它现在不会，那它可能以后会，且无需强制要求重新编译。</p>\n<h5 id=\"注解-296\"><a class=\"markdownIt-Anchor\" href=\"#注解-296\">#</a> 注解</h5>\n<p>有些代码和程序库提供的函数是声明为  <code>T*</code> ，<br>\n但这些函数并不会修改这个  <code>T</code> 。<br>\n这对于进行代码现代化转换的人们来说是个问题。<br>\n你可以：</p>\n<ul>\n<li>如果倾向于长期解决方案的话，将程序库更新为  <code>const</code>  正确的；</li>\n<li>“强制掉  <code>const</code> ”（<a href=\"#Res-casts-const\">最好避免这样做</a>）；</li>\n<li>提供包装函数。</li>\n</ul>\n<p>例如：</p>\n<pre><code>void f(int* p);   // 老代码：f() 并不会修改 `*p`\nvoid f(const int* p) &#123; f(const_cast&lt;int*&gt;(p)); &#125; // 包装函数\n</code></pre>\n<p>注意，这种包装函数的方案是一种补丁，只能在无法修改  <code>f()</code>  的声明时才使用它，<br>\n比如当它属于某个你无法修改的程序库时。</p>\n<h5 id=\"注解-297\"><a class=\"markdownIt-Anchor\" href=\"#注解-297\">#</a> 注解</h5>\n<p><code>const</code>  成员函数可以改动  <code>mutable</code>  对象的值，或者通过某个指针成员改动对象的值。<br>\n一种常见用法是来维护一个缓存以避免重复进行复杂的运算。<br>\n例如，这里的  <code>Date</code>  缓存（记住）了其字符串表示，以简化其重复使用：</p>\n<pre><code>class Date &#123;\npublic:\n    // ...\n    const string&amp; string_ref() const\n    &#123;\n        if (string_val == &quot;&quot;) compute_string_rep();\n        return string_val;\n    &#125;\n    // ...\nprivate:\n    void compute_string_rep() const;    // 计算字符串表示并将其存入 string_val\n    mutable string string_val;\n    // ...\n&#125;;\n</code></pre>\n<p>另一种说法是  <code>const</code>  特性不会传递。<br>\n通过  <code>const</code>  成员函数改动  <code>mutable</code>  成员的值和通过非  <code>const</code>  指针来访问的对象的值<br>\n是有可能的。<br>\n由类负责确保这样的改动仅当根据其语义（不变式）对于其用户有意义时<br>\n才会发生。</p>\n<p><strong>参见</strong>：<a href=\"#Ri-pimpl\">PImpl</a></p>\n<h5 id=\"强制实施-302\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-302\">#</a> 强制实施</h5>\n<ul>\n<li>如果未标记为  <code>const</code>  的成员函数并未对任何成员变量实施非  <code>const</code>  操作的话，对其进行标记。</li>\n</ul>\n<h3 id=\"a-namerconst-refacon3-缺省情况下应当传递指向-const-对象的指针或引用\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconst-refacon3-缺省情况下应当传递指向-const-对象的指针或引用\">#</a> <a name=\"Rconst-ref\"></a>Con.3: 缺省情况下，应当传递指向  <code>const</code>  对象的指针或引用</h3>\n<h5 id=\"理由-334\"><a class=\"markdownIt-Anchor\" href=\"#理由-334\">#</a> 理由</h5>\n<p>避免所调用的函数意外地改变了这个值。<br>\n如果被调用的函数不会改动状态的话，对程序的推理将变得容易得多。</p>\n<h5 id=\"示例-292\"><a class=\"markdownIt-Anchor\" href=\"#示例-292\">#</a> 示例</h5>\n<pre><code>void f(char* p);        // f 会不会修改 *p?（假定它会修改）\nvoid g(const char* p);  // g 不会修改 *p\n</code></pre>\n<h5 id=\"注解-298\"><a class=\"markdownIt-Anchor\" href=\"#注解-298\">#</a> 注解</h5>\n<p>传递指向非  <code>const</code>  对象的指针或引用并不是天生就有问题的，<br>\n不过只有当所调用的函数本就有意改动对象时才能这样做。</p>\n<h5 id=\"注解-299\"><a class=\"markdownIt-Anchor\" href=\"#注解-299\">#</a> 注解</h5>\n<p><a href=\"#Res-casts-const\">请勿强制掉  <code>const</code> </a>。</p>\n<h5 id=\"强制实施-303\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-303\">#</a> 强制实施</h5>\n<ul>\n<li>如果函数并未修改以指向非  <code>const</code>  的指针或引用传递的对象，则对其进行标记。</li>\n<li>如果函数（利用强制转换）修改了以指向  <code>const</code>  的指针或引用传递的对象，则对其进行标记。</li>\n</ul>\n<h3 id=\"a-namerconst-constacon4-构造之后不再改变其值的对象应当以-const-来定义\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconst-constacon4-构造之后不再改变其值的对象应当以-const-来定义\">#</a> <a name=\"Rconst-const\"></a>Con.4: 构造之后不再改变其值的对象应当以  <code>const</code>  来定义</h3>\n<h5 id=\"理由-335\"><a class=\"markdownIt-Anchor\" href=\"#理由-335\">#</a> 理由</h5>\n<p>避免意外地改变对象的值。</p>\n<h5 id=\"示例-293\"><a class=\"markdownIt-Anchor\" href=\"#示例-293\">#</a> 示例</h5>\n<pre><code>void f()\n&#123;\n    int x = 7;\n    const int y = 9;\n\n    for (;;) &#123;\n        // ...\n    &#125;\n    // ...\n&#125;\n</code></pre>\n<p>既然  <code>x</code>  并非  <code>const</code> ，我们就必须假定它可能在循环中的某处会被修改。</p>\n<h5 id=\"强制实施-304\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-304\">#</a> 强制实施</h5>\n<ul>\n<li>标记并未被修改的非  <code>const</code>  变量。</li>\n</ul>\n<h3 id=\"a-namerconst-constexpracon5-以-constexpr-来定义可以在编译期计算的值\"><a class=\"markdownIt-Anchor\" href=\"#a-namerconst-constexpracon5-以-constexpr-来定义可以在编译期计算的值\">#</a> <a name=\"Rconst-constexpr\"></a>Con.5: 以  <code>constexpr</code>  来定义可以在编译期计算的值</h3>\n<h5 id=\"理由-336\"><a class=\"markdownIt-Anchor\" href=\"#理由-336\">#</a> 理由</h5>\n<p>更好的性能，更好的编译期检查，受保证的编译期求值，竞争条件可能性为零。</p>\n<h5 id=\"示例-294\"><a class=\"markdownIt-Anchor\" href=\"#示例-294\">#</a> 示例</h5>\n<pre><code>double x = f(2);            // 可能在运行时求值\nconst double y = f(2);      // 可能在运行时求值\nconstexpr double z = f(2);  // 除非 f(2) 可在编译期求值，否则会报错\n</code></pre>\n<h5 id=\"注解-300\"><a class=\"markdownIt-Anchor\" href=\"#注解-300\">#</a> 注解</h5>\n<p>参见 F.4。</p>\n<h5 id=\"强制实施-305\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-305\">#</a> 强制实施</h5>\n<ul>\n<li>对带有常量表达式初始化式的  <code>const</code>  定义进行标记。</li>\n</ul>\n<h1 id=\"a-names-templatesat-模板和泛型编程\"><a class=\"markdownIt-Anchor\" href=\"#a-names-templatesat-模板和泛型编程\">#</a> <a name=\"S-templates\"></a>T: 模板和泛型编程</h1>\n<p>泛型编程是使用以类型、值和算法进行参数化的类型和算法所进行的编程。<br>\n在 C++ 中，泛型编程是以 “模板” 语言机制来提供支持的。</p>\n<p>泛型函数的参数是以针对参数类型及其所涉及的值的规定的集合来刻画的。<br>\n在 C++ 中，这些规定是以被称为概念（concept）的编译期谓词来表达的。</p>\n<p>模板还可用于进行元编程；亦即由编译期代码所组成的程序。</p>\n<p>泛型编程的中心是 “概念”；亦即以编译时谓词表现的对于模板参数的要求。<br>\nC++20 已经将 “概念” 标准化了，不过是在 GCC 6.1 中以一种略有不同的语法首次提供的。</p>\n<p>模板使用的规则概览：</p>\n<ul>\n<li><a href=\"#Rt-raise\">T.1: 用模板来提升代码的抽象层次</a></li>\n<li><a href=\"#Rt-algo\">T.2: 用模板来表达适用于许多参数类型的算法</a></li>\n<li><a href=\"#Rt-cont\">T.3: 用模板来表达容器和范围</a></li>\n<li><a href=\"#Rt-expr\">T.4: 用模板来表达对语法树的操作</a></li>\n<li><a href=\"#Rt-generic-oo\">T.5: 结合泛型和面向对象技术来增强它们的能力，而不是它们的成本</a></li>\n</ul>\n<p>概念使用的规则概览：</p>\n<ul>\n<li><a href=\"#Rt-concepts\">T.10: 为所有模板实参指明概念</a></li>\n<li><a href=\"#Rt-std-concepts\">T.11: 尽可能采用标准概念</a></li>\n<li><a href=\"#Rt-auto\">T.12: 对于局部变量，优先采用概念名而不是  <code>auto</code> </a></li>\n<li><a href=\"#Rt-shorthand\">T.13: 对于简单的单类型参数概念，优先采用简写形式</a></li>\n<li>???</li>\n</ul>\n<p>概念定义的规则概览：</p>\n<ul>\n<li><a href=\"#Rt-low\">T.20: 避免没有有意义的语义的 “概念”</a></li>\n<li><a href=\"#Rt-complete\">T.21: 为概念提出一组完整的操作要求</a></li>\n<li><a href=\"#Rt-axiom\">T.22: 为概念指明公理</a></li>\n<li><a href=\"#Rt-refine\">T.23: 通过添加新的使用模式，从更一般情形的概念中区分出提炼后的概念</a></li>\n<li><a href=\"#Rt-tag\">T.24: 用标签类或特征类来区分仅在语义上存在差别的概念</a></li>\n<li><a href=\"#Rt-not\">T.25: 避免互补性的约束</a></li>\n<li><a href=\"#Rt-use\">T.26: 优先采用使用模式而不是简单的语法来定义概念</a></li>\n<li><a href=\"#Rt-???\">T.30: 节制地采用概念求反（ <code>!C&lt;T&gt;</code> ）来表示微小差异</a></li>\n<li><a href=\"#Rt-???\">T.31: 节制地采用概念析取（disjunction）（ <code>C1&lt;T&gt; || C2&lt;T&gt;</code> ）来表示备选项</a></li>\n<li>???</li>\n</ul>\n<p>模板接口的规则概览：</p>\n<ul>\n<li><a href=\"#Rt-fo\">T.40: 使用函数对象向算法传递操作</a></li>\n<li><a href=\"#Rt-essential\">T.41: 在模板的概念上仅提出基本的性质要求</a></li>\n<li><a href=\"#Rt-alias\">T.42: 使用模板别名来简化写法并隐藏实现细节</a></li>\n<li><a href=\"#Rt-using\">T.43: 优先使用  <code>using</code>  而不是  <code>typedef</code>  来定义别名</a></li>\n<li><a href=\"#Rt-deduce\">T.44: （如果可行）使用函数模板来对类模板的参数类型进行推断</a></li>\n<li><a href=\"#Rt-regular\">T.46: 要求模板参数至少是半正规的</a></li>\n<li><a href=\"#Rt-visible\">T.47: 避免用常用名字命名高度可见的无约束模板</a></li>\n<li><a href=\"#Rt-concept-def\">T.48: 如果你的编译器不支持概念的话，可以用  <code>enable_if</code>  来模拟</a></li>\n<li><a href=\"#Rt-erasure\">T.49: 尽可能避免类型擦除</a></li>\n</ul>\n<p>模板定义的规则概览：</p>\n<ul>\n<li><a href=\"#Rt-depend\">T.60: 最小化模板的上下文依赖性</a></li>\n<li><a href=\"#Rt-scary\">T.61: 请勿对成员进行过度参数化（SCARY）</a></li>\n<li><a href=\"#Rt-nondependent\">T.62: 将无依赖的类模板成员置于一个非模板基类之中</a></li>\n<li><a href=\"#Rt-specialization\">T.64: 用特化来提供类模板的其他实现</a></li>\n<li><a href=\"#Rt-tag-dispatch\">T.65: 用标签分派来提供函数的其他实现</a></li>\n<li><a href=\"#Rt-specialization2\">T.67: 用特化来提供不规则类型的其他实现</a></li>\n<li><a href=\"#Rt-cast\">T.68: 在模板中用  <code>&#123;&#125;</code>  而不是  <code>()</code>  以避免歧义</a></li>\n<li><a href=\"#Rt-customization\">T.69: 在模板中，请勿进行未限定的非成员函数调用，除非有意将之作为定制点</a></li>\n</ul>\n<p>模板和类型层次的规则概览：</p>\n<ul>\n<li><a href=\"#Rt-hier\">T.80: 请勿不成熟地对类层次进行模板化</a></li>\n<li><a href=\"#Rt-array\">T.81: 请勿混合类层次和数组</a> // ??? 放在 “类型层次” 部分</li>\n<li><a href=\"#Rt-linear\">T.82: 当不想要虚函数时，可以将类层次线性化</a></li>\n<li><a href=\"#Rt-virtual\">T.83: 请勿声明虚的成员函数模板</a></li>\n<li><a href=\"#Rt-abi\">T.84: 使用非模板的核心实现来提供 ABI 稳定的接口</a></li>\n<li><a href=\"#Rt-???\">T.??: ???</a></li>\n</ul>\n<p>变参模板的规则概览：</p>\n<ul>\n<li><a href=\"#Rt-variadic\">T.100: 当需要可以接受可变数量的多种类型参数的函数时，使用变参模板</a></li>\n<li><a href=\"#Rt-variadic-pass\">T.101: ??? 如何向变参模板传递参数？？？</a></li>\n<li><a href=\"#Rt-variadic-process\">T.102: ??? 如何处理变参模板的参数？？？</a></li>\n<li><a href=\"#Rt-variadic-not\">T.103: 请勿对同质参数列表使用变参模板</a></li>\n<li><a href=\"#Rt-???\">T.??: ???</a></li>\n</ul>\n<p>元编程的规则概览：</p>\n<ul>\n<li><a href=\"#Rt-metameta\">T.120: 仅当确实需要时才使用模板元编程</a></li>\n<li><a href=\"#Rt-emulate\">T.121: 模板元编程主要用于模拟概念机制</a></li>\n<li><a href=\"#Rt-tmp\">T.122: 用模板（通常为模板别名）来在编译期进行类型运算</a></li>\n<li><a href=\"#Rt-fct\">T.123: 用  <code>constexpr</code>  函数来在编译期进行值运算</a></li>\n<li><a href=\"#Rt-std-tmp\">T.124: 优先使用标准库的模板元编程设施</a></li>\n<li><a href=\"#Rt-lib\">T.125: 当需要标准库之外的模板元编程设施时，使用某个现存程序库</a></li>\n<li><a href=\"#Rt-???\">T.??: ???</a></li>\n</ul>\n<p>其他模板规则概览：</p>\n<ul>\n<li><a href=\"#Rt-name\">T.140: 若操作可被重用，则应为其命名</a></li>\n<li><a href=\"#Rt-lambda\">T.141: 当仅在一个地方需要一个简单的函数对象时，使用无名的 lambda</a></li>\n<li><a href=\"#Rt-var\">T.142: 使用模板变量以简化写法</a></li>\n<li><a href=\"#Rt-nongeneric\">T.143: 请勿编写并非有意非泛型的代码</a></li>\n<li><a href=\"#Rt-specialize-function\">T.144: 请勿特化函数模板</a></li>\n<li><a href=\"#Rt-check-class\">T.150: 用  <code>static_assert</code>  来检查类是否与概念相符</a></li>\n<li><a href=\"#Rt-???\">T.??: ???</a></li>\n</ul>\n<h2 id=\"a-namess-gpatgp-泛型编程\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-gpatgp-泛型编程\">#</a> <a name=\"SS-GP\"></a><span class=\"exturl\" data-url=\"aHR0cDovL1QuZ3A=\">T.gp</span>: 泛型编程</h2>\n<p>泛型编程是利用以类型、值和算法进行了参数化的类型和算法所进行的编程。</p>\n<h3 id=\"a-namert-raiseat1-用模板来提升代码的抽象层次\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-raiseat1-用模板来提升代码的抽象层次\">#</a> <a name=\"Rt-raise\"></a>T.1: 用模板来提升代码的抽象层次</h3>\n<h5 id=\"理由-337\"><a class=\"markdownIt-Anchor\" href=\"#理由-337\">#</a> 理由</h5>\n<p>通用性。重用。效率。鼓励用户类型的定义一致性。</p>\n<h5 id=\"示例不好-130\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-130\">#</a> 示例，不好</h5>\n<p>概念上说，以下要求是错误的，因为我们所要求的  <code>T</code>  不止是如 “可以增量” 或 “可以进行加法” 这样的非常低级的概念：</p>\n<pre><code>template&lt;typename T&gt;\n    requires Incrementable&lt;T&gt;\nT sum1(vector&lt;T&gt;&amp; v, T s)\n&#123;\n    for (auto x : v) s += x;\n    return s;\n&#125;\n\ntemplate&lt;typename T&gt;\n    requires Simple_number&lt;T&gt;\nT sum2(vector&lt;T&gt;&amp; v, T s)\n&#123;\n    for (auto x : v) s = s + x;\n    return s;\n&#125;\n</code></pre>\n<p>由于假设  <code>Incrementable</code>  并不支持  <code>+</code> ，而  <code>Simple_number</code>  也不支持  <code>+=</code> ，我们对  <code>sum1</code>  和  <code>sum2</code>  的实现者过度约束了。<br>\n而且，这种情况下也错过了一次通用化的机会。</p>\n<h5 id=\"示例-295\"><a class=\"markdownIt-Anchor\" href=\"#示例-295\">#</a> 示例</h5>\n<pre><code>template&lt;typename T&gt;\n    requires Arithmetic&lt;T&gt;\nT sum(vector&lt;T&gt;&amp; v, T s)\n&#123;\n    for (auto x : v) s += x;\n    return s;\n&#125;\n</code></pre>\n<p>通过假定  <code>Arithmetic</code>  同时要求  <code>+</code>  和  <code>+=</code> ，我们约束  <code>sum</code>  的使用者来提供完整的算术类型。<br>\n这并非是最小的要求，但它为算法的实现者更多所需的自由度，并确保了任何  <code>Arithmetic</code>  类型<br>\n都可被用于各种各样的算法。</p>\n<p>为达成额外的通用性和可重用性，我们还可以用更通用的  <code>Container</code>  或  <code>Range</code>  概念而不是仅投入到  <code>vector</code>  一个容器上。</p>\n<h5 id=\"注解-301\"><a class=\"markdownIt-Anchor\" href=\"#注解-301\">#</a> 注解</h5>\n<p>如果我们所定义的模板提出的要求，完全是由一个算法的一个实现所要求的操作<br>\n（比如说仅要求  <code>+=</code>  而不同时要求  <code>=</code>  和  <code>+</code> ），而没有别的要求，就会对维护者提出过度的约束。<br>\n我们的目标是最小化模板参数的要求，但一个实现的绝对最小要求很少能作为有意义的概念。</p>\n<h5 id=\"注解-302\"><a class=\"markdownIt-Anchor\" href=\"#注解-302\">#</a> 注解</h5>\n<p>可以用模板来表现几乎任何东西（它是图灵完备的），但（利用模板进行）泛型编程的目标在于，<br>\n使操作和算法对于一组带有相似语义性质的类型有效地进行通用化。</p>\n<h5 id=\"强制实施-306\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-306\">#</a> 强制实施</h5>\n<ul>\n<li>对带有 “过于简单” 的要求（诸如不用概念而直接使用特定的运算符）的算法进行标记。</li>\n<li>不要对 “过于简单” 的概念本身进行标记；它们也许只不过是更有用的概念的构造块。</li>\n</ul>\n<h3 id=\"a-namert-algoat2-用模板来表达适用于许多参数类型的算法\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-algoat2-用模板来表达适用于许多参数类型的算法\">#</a> <a name=\"Rt-algo\"></a>T.2: 用模板来表达适用于许多参数类型的算法</h3>\n<h5 id=\"理由-338\"><a class=\"markdownIt-Anchor\" href=\"#理由-338\">#</a> 理由</h5>\n<p>通用性。最小化源代码数量。互操作性。重用。</p>\n<h5 id=\"示例-296\"><a class=\"markdownIt-Anchor\" href=\"#示例-296\">#</a> 示例</h5>\n<p>这正是 STL 的基础所在。一个  <code>find</code>  算法可以很轻易地同任何输入范围一起工作：</p>\n<pre><code>template&lt;typename Iter, typename Val&gt;\n    // requires Input_iterator&lt;Iter&gt;\n    //       &amp;&amp; Equality_comparable&lt;Value_type&lt;Iter&gt;, Val&gt;\nIter find(Iter b, Iter e, Val v)\n&#123;\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"注解-303\"><a class=\"markdownIt-Anchor\" href=\"#注解-303\">#</a> 注解</h5>\n<p>除非确实需要多于一种模板参数类型，否则请不要使用模板。<br>\n请勿过度抽象。</p>\n<h5 id=\"强制实施-307\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-307\">#</a> 强制实施</h5>\n<p>??? 很难办，可能需要人来进行</p>\n<h3 id=\"a-namert-contat3-用模板来表达容器和范围\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-contat3-用模板来表达容器和范围\">#</a> <a name=\"Rt-cont\"></a>T.3: 用模板来表达容器和范围</h3>\n<h5 id=\"理由-339\"><a class=\"markdownIt-Anchor\" href=\"#理由-339\">#</a> 理由</h5>\n<p>容器需要一种元素类型，而将之表示为一个模板参数则是通用的，可重用的，且类型安全的做法。<br>\n这样也避免了采用脆弱的或者低效的变通手段。约定：这正是 STL 的做法。</p>\n<h5 id=\"示例-297\"><a class=\"markdownIt-Anchor\" href=\"#示例-297\">#</a> 示例</h5>\n<pre><code>template&lt;typename T&gt;\n    // requires Regular&lt;T&gt;\nclass Vector &#123;\n    // ...\n    T* elem;   // 指向 sz 个 T\n    int sz;\n&#125;;\n\nVector&lt;double&gt; v(10);\nv[7] = 9.9;\n</code></pre>\n<h5 id=\"示例不好-131\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-131\">#</a> 示例，不好</h5>\n<pre><code>class Container &#123;\n    // ...\n    void* elem;   // 指向 sz 个某种类型的元素\n    int sz;\n&#125;;\n\nContainer c(10, sizeof(double));\n((double*) c.elem)[7] = 9.9;\n</code></pre>\n<p>这样做无法直接表现出程序员的意图，而且向类型系统和优化器隐藏了程序的结构。</p>\n<p>把  <code>void*</code>  隐藏在宏之中只会掩盖问题，并引入新的发生混乱的机会。</p>\n<p><strong>例外</strong>：当需要 ABI 稳定的接口时，也许你不得不提供一个基本实现，在基于它来呈现（类型安全的）目标。<br>\n参见<a href=\"#Rt-abi\">稳定的基类</a>。</p>\n<h5 id=\"强制实施-308\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-308\">#</a> 强制实施</h5>\n<ul>\n<li>对出现于低级实现代码之外的  <code>void*</code>  和强制转换进行标记。</li>\n</ul>\n<h3 id=\"a-namert-exprat4-用模板来表达对语法树的操作\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-exprat4-用模板来表达对语法树的操作\">#</a> <a name=\"Rt-expr\"></a>T.4: 用模板来表达对语法树的操作</h3>\n<h5 id=\"理由-340\"><a class=\"markdownIt-Anchor\" href=\"#理由-340\">#</a> 理由</h5>\n<p>???</p>\n<h5 id=\"示例-298\"><a class=\"markdownIt-Anchor\" href=\"#示例-298\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<p><strong>例外</strong>: ???</p>\n<h3 id=\"a-namert-generic-ooat5-结合泛型和面向对象技术来增强它们的能力而不是它们的成本\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-generic-ooat5-结合泛型和面向对象技术来增强它们的能力而不是它们的成本\">#</a> <a name=\"Rt-generic-oo\"></a>T.5: 结合泛型和面向对象技术来增强它们的能力，而不是它们的成本</h3>\n<h5 id=\"理由-341\"><a class=\"markdownIt-Anchor\" href=\"#理由-341\">#</a> 理由</h5>\n<p>泛型和面向对象技术是互补的。</p>\n<h5 id=\"示例-299\"><a class=\"markdownIt-Anchor\" href=\"#示例-299\">#</a> 示例</h5>\n<p>静态能够帮助动态：使用静态多态来实现动态多态的接口：</p>\n<pre><code>class Command &#123;\n    // 纯虚函数\n&#125;;\n\n// 实现\ntemplate&lt;/*...*/&gt;\nclass ConcreteCommand : public Command &#123;\n    // 实现虚函数\n&#125;;\n</code></pre>\n<h5 id=\"示例-300\"><a class=\"markdownIt-Anchor\" href=\"#示例-300\">#</a> 示例</h5>\n<p>动态有助于静态：提供通用的，便利的，静态绑定的接口，但内部进行动态派发，这样就可以提供统一的对象布局。<br>\n这样的例子包括如  <code>std::shared_ptr</code>  的删除器的类型擦除。（不过<a href=\"#Rt-erasure\">请勿过度使用类型擦除</a>。）</p>\n<pre><code>#include &lt;memory&gt;\n\nclass Object &#123;\npublic:\n    template&lt;typename T&gt;\n    Object(T&amp;&amp; obj)\n        : concept_(std::make_shared&lt;ConcreteCommand&lt;T&gt;&gt;(std::forward&lt;T&gt;(obj))) &#123;&#125;\n\n    int get_id() const &#123; return concept_-&gt;get_id(); &#125;\n\nprivate:\n    struct Command &#123;\n        virtual ~Command() &#123;&#125;\n        virtual int get_id() const = 0;\n    &#125;;\n\n    template&lt;typename T&gt;\n    struct ConcreteCommand final : Command &#123;\n        ConcreteCommand(T&amp;&amp; obj) noexcept : object_(std::forward&lt;T&gt;(obj)) &#123;&#125;\n        int get_id() const final &#123; return object_.get_id(); &#125;\n\n    private:\n        T object_;\n    &#125;;\n\n    std::shared_ptr&lt;Command&gt; concept_;\n&#125;;\n\nclass Bar &#123;\npublic:\n    int get_id() const &#123; return 1; &#125;\n&#125;;\n\nstruct Foo &#123;\npublic:\n    int get_id() const &#123; return 2; &#125;\n&#125;;\n\nObject o(Bar&#123;&#125;);\nObject o2(Foo&#123;&#125;);\n</code></pre>\n<h5 id=\"注解-304\"><a class=\"markdownIt-Anchor\" href=\"#注解-304\">#</a> 注解</h5>\n<p>类模板之中，非虚函数仅会在被使用时才会实例化 —— 而虚函数则每次都会实例化。<br>\n这会导致代码大小膨胀，而且可能因为实例化从不需要的功能而导致对通用类型的过度约束。<br>\n请避免这样做，虽然标准的刻面类犯过这种错误。</p>\n<h5 id=\"参见-4\"><a class=\"markdownIt-Anchor\" href=\"#参见-4\">#</a> 参见</h5>\n<ul>\n<li>ref ???</li>\n<li>ref ???</li>\n<li>ref ???</li>\n</ul>\n<h5 id=\"强制实施-309\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-309\">#</a> 强制实施</h5>\n<p>参见参考条目以获得更具体的规则。</p>\n<h2 id=\"a-namess-conceptsatconcepts-概念规则\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-conceptsatconcepts-概念规则\">#</a> <a name=\"SS-concepts\"></a>T.concepts: 概念规则</h2>\n<p>概念是一种 C<ins>20 语言设施，用于为模板参数指定要求。<br>\n在考虑泛型编程，以及未来的 C</ins> 程序库（无论标准的还是其他的）的基础时，<br>\n概念都是关键性的。</p>\n<p>本部分假定有概念支持。</p>\n<p>概念使用的规则概览：</p>\n<ul>\n<li><a href=\"#Rt-concepts\">T.10: 为所有模板实参指明概念</a></li>\n<li><a href=\"#Rt-std-concepts\">T.11: 尽可能采用标准概念</a></li>\n<li><a href=\"#Rt-auto\">T.12: 优先采用概念名而不是  <code>auto</code> </a></li>\n<li><a href=\"#Rt-shorthand\">T.13: 对于简单的单类型参数概念，优先采用简写形式</a></li>\n<li>???</li>\n</ul>\n<p>概念定义的规则概览：</p>\n<ul>\n<li><a href=\"#Rt-low\">T.20: 避免没有有意义的语义的 “概念”</a></li>\n<li><a href=\"#Rt-complete\">T.21: 为概念提出一组完整的操作要求</a></li>\n<li><a href=\"#Rt-axiom\">T.22: 为概念指明公理</a></li>\n<li><a href=\"#Rt-refine\">T.23: 通过添加新的使用模式，从更一般情形的概念中区分出提炼后的概念</a></li>\n<li><a href=\"#Rt-tag\">T.24: 用标签类或特征类来区分仅在语义上存在差别的概念</a></li>\n<li><a href=\"#Rt-not\">T.25: 避免互补性的约束</a></li>\n<li><a href=\"#Rt-use\">T.26: 优先采用使用模式而不是简单的语法来定义概念</a></li>\n<li>???</li>\n</ul>\n<h2 id=\"a-namess-concept-useatcon-use-概念的使用\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-concept-useatcon-use-概念的使用\">#</a> <a name=\"SS-concept-use\"></a>T.con-use: 概念的使用</h2>\n<h3 id=\"a-namert-conceptsat10-为所有模板实参指明概念\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-conceptsat10-为所有模板实参指明概念\">#</a> <a name=\"Rt-concepts\"></a>T.10: 为所有模板实参指明概念</h3>\n<h5 id=\"理由-342\"><a class=\"markdownIt-Anchor\" href=\"#理由-342\">#</a> 理由</h5>\n<p>正确性和可读性。<br>\n针对模板参数所假定的含义（包括语法和语义），是模板接口的基础部分。<br>\n使用概念能够显著改善模板的文档和错误处理。<br>\n为模板参数指定概念是一种强力的设计工具。</p>\n<h5 id=\"示例-301\"><a class=\"markdownIt-Anchor\" href=\"#示例-301\">#</a> 示例</h5>\n<pre><code>template&lt;typename Iter, typename Val&gt;\n    requires input_iterator&lt;Iter&gt;\n             &amp;&amp; equality_comparable_with&lt;value_type_t&lt;Iter&gt;, Val&gt;\nIter find(Iter b, Iter e, Val v)\n&#123;\n    // ...\n&#125;\n</code></pre>\n<p>也可以等价地用更为简洁的方式：</p>\n<pre><code>template&lt;input_iterator Iter, typename Val&gt;\n    requires equality_comparable_with&lt;value_type_t&lt;Iter&gt;, Val&gt;\nIter find(Iter b, Iter e, Val v)\n&#123;\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"注解-305\"><a class=\"markdownIt-Anchor\" href=\"#注解-305\">#</a> 注解</h5>\n<p>普通的  <code>typename</code> （或  <code>auto</code> ）是受最少约束的概念。<br>\n应当仅在只能假定 “这是一个类型” 的罕见情况中使用它们。<br>\n通常，这只会在当我们（用模板元编程代码）操作纯粹的表达式树，并推迟进行类型检查时才会需要。</p>\n<p><strong>参考</strong>: TC++PL4</p>\n<h5 id=\"强制实施-310\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-310\">#</a> 强制实施</h5>\n<p>对没有概念的模板类型参数进行标记。</p>\n<h3 id=\"a-namert-std-conceptsat11-尽可能采用标准概念\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-std-conceptsat11-尽可能采用标准概念\">#</a> <a name=\"Rt-std-concepts\"></a>T.11: 尽可能采用标准概念</h3>\n<h5 id=\"理由-343\"><a class=\"markdownIt-Anchor\" href=\"#理由-343\">#</a> 理由</h5>\n<p>“标准” 概念（即由 <a href=\"#gsl-guidelines-support-library\">GSL</a> 和 ISO 标准自身所提供的概念)，<br>\n避免了我们思考自己的概念，它们比我们匆忙中能够想出来的要好得多，而且还提升了互操作性。</p>\n<h5 id=\"注解-306\"><a class=\"markdownIt-Anchor\" href=\"#注解-306\">#</a> 注解</h5>\n<p>如果你不是要创建一个新的泛型程序库的话，大多数所需的概念都已经在标准库中定义过了。</p>\n<h5 id=\"示例-302\"><a class=\"markdownIt-Anchor\" href=\"#示例-302\">#</a> 示例</h5>\n<pre><code>template&lt;typename T&gt;\n    // 请勿定义这个: &lt;iterator&gt; 中已经有 sortable\nconcept Ordered_container = Sequence&lt;T&gt; &amp;&amp; Random_access&lt;Iterator&lt;T&gt;&gt; &amp;&amp; Ordered&lt;Value_type&lt;T&gt;&gt;;\n\nvoid sort(Ordered_container auto&amp; s);\n</code></pre>\n<p>这个  <code>Ordered_container</code>  貌似相当合理，但它和标准库中的  <code>sortable</code>  概念非常相似。<br>\n它是更好？更正确？它真的精确地反映了标准对于  <code>sort</code>  的要求吗？<br>\n直接使用  <code>sortable</code>  则更好而且更简单：</p>\n<pre><code>void sort(sortable auto&amp; s);   // 更好\n</code></pre>\n<h5 id=\"注解-307\"><a class=\"markdownIt-Anchor\" href=\"#注解-307\">#</a> 注解</h5>\n<p>在我们推进一个包含概念的 ISO 标准的过程中，“标准” 概念的集合是不断演进的。</p>\n<h5 id=\"注解-308\"><a class=\"markdownIt-Anchor\" href=\"#注解-308\">#</a> 注解</h5>\n<p>设计一个有用的概念是很有挑战性的。</p>\n<h5 id=\"强制实施-311\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-311\">#</a> 强制实施</h5>\n<p>很难。</p>\n<ul>\n<li>查找无约束的参数，使用 “非常规” 或非标准的概念的模板，以及使用 “自造的” 又没有公理的概念的目标。</li>\n<li>开发一种概念识别工具（例如，参考<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9zbGUyMDEwX3dlYnZlcnNpb24ucGRm\">一种早期实验</span>）。</li>\n</ul>\n<h3 id=\"a-namert-autoat12-对于局部变量优先采用概念名而不是-auto\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-autoat12-对于局部变量优先采用概念名而不是-auto\">#</a> <a name=\"Rt-auto\"></a>T.12: 对于局部变量，优先采用概念名而不是  <code>auto</code></h3>\n<h5 id=\"理由-344\"><a class=\"markdownIt-Anchor\" href=\"#理由-344\">#</a> 理由</h5>\n<p><code>auto</code>  是最弱的概念。概念的名字会比仅用  <code>auto</code>  传达出更多的意义。</p>\n<h5 id=\"示例-303\"><a class=\"markdownIt-Anchor\" href=\"#示例-303\">#</a> 示例</h5>\n<pre><code>vector&lt;string&gt; v&#123; &quot;abc&quot;, &quot;xyz&quot; &#125;;\nauto&amp; x = v.front();        // 不好\nString auto&amp; s = v.front(); // 好（String 是 GSL 的一个概念）\n</code></pre>\n<h5 id=\"强制实施-312\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-312\">#</a> 强制实施</h5>\n<ul>\n<li>???</li>\n</ul>\n<h3 id=\"a-namert-shorthandat13-对于简单的单类型参数概念优先采用简写形式\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-shorthandat13-对于简单的单类型参数概念优先采用简写形式\">#</a> <a name=\"Rt-shorthand\"></a>T.13: 对于简单的单类型参数概念，优先采用简写形式</h3>\n<h5 id=\"理由-345\"><a class=\"markdownIt-Anchor\" href=\"#理由-345\">#</a> 理由</h5>\n<p>可读性。直接表达意图。</p>\n<h5 id=\"示例-304\"><a class=\"markdownIt-Anchor\" href=\"#示例-304\">#</a> 示例</h5>\n<p>这样来表达 “ <code>T</code>  是一种  <code>sortable</code> ”：</p>\n<pre><code>template&lt;typename T&gt;       // 正确但很啰嗦：“参数的类型\n    requires sortable&lt;T&gt;   // 为 T，这是某个 sortable\nvoid sort(T&amp;);             // 类型的名字”\n\ntemplate&lt;sortable T&gt;       // 有改善：“参数的类型\nvoid sort(T&amp;);             // 为 Sortable 的类型 T”\n\nvoid sort(sortable auto&amp;); // 最佳方式：“参数为 sortable”\n</code></pre>\n<p>越简练的版本越符合我们的说话方式。注意许多模板不在需要使用  <code>template</code>  关键字了。</p>\n<h5 id=\"强制实施-313\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-313\">#</a> 强制实施</h5>\n<ul>\n<li>当人们从  <code>&lt;typename T&gt;</code>  and  <code>&lt;class T&gt;</code>  写法进行转换时，使用简短形式是不可行的。</li>\n<li>之后，如果声明中首先引入了一个  <code>typename</code> ，之后又用简单的单类型参数概念对其进行约束的话，就对其进行标记。</li>\n</ul>\n<h2 id=\"a-namess-concepts-defatconceptsdef-概念定义规则\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-concepts-defatconceptsdef-概念定义规则\">#</a> <a name=\"SS-concepts-def\"></a>T.concepts.def: 概念定义规则</h2>\n<p>定义恰当的概念并不简单。<br>\n概念是用于表现应用领域中的基本概念的（正如其名 “概念”）。<br>\n只是把用在某个具体的类或算法的参数上的一组语法约束聚在一起，并不是概念所设计的用法，<br>\n也无法获得这个机制的全部好处。</p>\n<p>显然，定义概念对于那些可以使用某个实现（比如 C++20 或更新版本）的代码是最有用的，<br>\n不过定义概念本身就是一种有益的设计技巧，有助于发现概念上的错误并清理实现中的各种概念。</p>\n<h3 id=\"a-namert-lowat20-避免没有有意义的语义的概念\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-lowat20-避免没有有意义的语义的概念\">#</a> <a name=\"Rt-low\"></a>T.20: 避免没有有意义的语义的 “概念”</h3>\n<h5 id=\"理由-346\"><a class=\"markdownIt-Anchor\" href=\"#理由-346\">#</a> 理由</h5>\n<p>概念是用于表现语义的观念的，比如 “数”，元素的 “范围”，以及 “全序的” 等等。<br>\n简单的约束，比如 “带有  <code>+</code>  运算符” 和 “带有  <code>&gt;</code>  运算符”，是无法独立进行有意义的运用的，<br>\n而仅应当被用作有意义的概念的构造块，而不是在用户代码中使用。</p>\n<h5 id=\"示例不好-132\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-132\">#</a> 示例，不好</h5>\n<pre><code>template&lt;typename T&gt;\n// 不好，不充分\nconcept Addable = requires(T a, T b) &#123; a+b; &#125;;\n\ntemplate&lt;Addable N&gt;\nauto algo(const N&amp; a, const N&amp; b) // 使用两个数值\n&#123;\n    // ...\n    return a + b;\n&#125;\n\nint x = 7;\nint y = 9;\nauto z = algo(x, y);   // z = 16\n\nstring xx = &quot;7&quot;;\nstring yy = &quot;9&quot;;\nauto zz = algo(xx, yy);   // zz = &quot;79&quot;\n</code></pre>\n<p>也许拼接是有意进行的。不过更可能的是一种意外。而对减法进行同等的定义则会导致可接受类型的集合的非常不同。<br>\n这个  <code>Addable</code>  违反了加法应当可交换的数学法则： <code>a+b == b+a</code> 。</p>\n<h5 id=\"注解-309\"><a class=\"markdownIt-Anchor\" href=\"#注解-309\">#</a> 注解</h5>\n<p>给出有意义的语义的能力，在于定义真正的概念的特征，而不是仅给出语法约束。</p>\n<h5 id=\"示例-305\"><a class=\"markdownIt-Anchor\" href=\"#示例-305\">#</a> 示例</h5>\n<pre><code>template&lt;typename T&gt;\n// 假定数值的运算符 +、-、* 和 / 都遵循常规的数学法则\nconcept Number = requires(T a, T b) &#123; a+b; a-b; a*b; a/b; &#125;;\n\ntemplate&lt;Number N&gt;\nauto algo(const N&amp; a, const N&amp; b)\n&#123;\n    // ...\n    return a + b;\n&#125;\n\nint x = 7;\nint y = 9;\nauto z = algo(x, y);   // z = 16\n\nstring xx = &quot;7&quot;;\nstring yy = &quot;9&quot;;\nauto zz = algo(xx, yy);   // 错误：string 不是 Number\n</code></pre>\n<h5 id=\"注解-310\"><a class=\"markdownIt-Anchor\" href=\"#注解-310\">#</a> 注解</h5>\n<p>带有多个操作的概念要远比单个操作的概念更少和类型发生意外匹配的机会。</p>\n<h5 id=\"强制实施-314\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-314\">#</a> 强制实施</h5>\n<ul>\n<li>对在其他  <code>concept</code>  的定义之外使用的但操作  <code>concept</code>  进行标记。</li>\n<li>对表现为模拟单操作  <code>concept</code>  的  <code>enable_if</code>  的使用进行标记。</li>\n</ul>\n<h3 id=\"a-namert-completeat21-为概念提出一组完整的操作要求\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-completeat21-为概念提出一组完整的操作要求\">#</a> <a name=\"Rt-complete\"></a>T.21: 为概念提出一组完整的操作要求</h3>\n<h5 id=\"理由-347\"><a class=\"markdownIt-Anchor\" href=\"#理由-347\">#</a> 理由</h5>\n<p>易于理解。<br>\n提升互操作性。<br>\n帮助实现者和维护者。</p>\n<h5 id=\"注解-311\"><a class=\"markdownIt-Anchor\" href=\"#注解-311\">#</a> 注解</h5>\n<p>这是对一般性规则<a href=\"#Rt-low\">必须让概念有语义上的意义</a>的一个专门的变体。</p>\n<h5 id=\"示例不好-133\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-133\">#</a> 示例，不好</h5>\n<pre><code>template&lt;typename T&gt; concept Subtractable = requires(T a, T b) &#123; a-b; &#125;;\n</code></pre>\n<p>这个是没有语义作用的。<br>\n你至少还需要  <code>+</code>  来让  <code>-</code>  有意义和有用处。</p>\n<p>完整集合的例子有</p>\n<ul>\n<li><code>Arithmetic</code> :  <code>+</code> ,  <code>-</code> ,  <code>*</code> ,  <code>/</code> ,  <code>+=</code> ,  <code>-=</code> ,  <code>*=</code> ,  <code>/=</code></li>\n<li><code>Comparable</code> :  <code>&lt;</code> ,  <code>&gt;</code> ,  <code>&lt;=</code> ,  <code>&gt;=</code> ,  <code>==</code> ,  <code>!=</code></li>\n</ul>\n<h5 id=\"注解-312\"><a class=\"markdownIt-Anchor\" href=\"#注解-312\">#</a> 注解</h5>\n<p>无论我们是否使用了概念的直接语言支持，本条规则都适用。<br>\n这是一种一般性的设计规则，即便对于非模板也同样适用：</p>\n<pre><code>class Minimal &#123;\n    // ...\n&#125;;\n\nbool operator==(const Minimal&amp;, const Minimal&amp;);\nbool operator&lt;(const Minimal&amp;, const Minimal&amp;);\n\nMinimal operator+(const Minimal&amp;, const Minimal&amp;);\n// 没有其他运算符\n\nvoid f(const Minimal&amp; x, const Minimal&amp; y)\n&#123;\n    if (!(x == y)) &#123; /* ... */ &#125;    // OK\n    if (x != y) &#123; /* ... */ &#125;       // 意外！错误\n\n    while (!(x &lt; y)) &#123; /* ... */ &#125;  // OK\n    while (x &gt;= y) &#123; /* ... */ &#125;    // 意外！错误\n\n    x = x + y;          // OK\n    x += y;             // 意外！错误\n&#125;\n</code></pre>\n<p>这是最小化的设计，但会使用户遇到意外或受到限制。<br>\n可能它还会比较低效。</p>\n<p>这条规则支持这样的观点：概念应当反映（数学上）协调的一组操作。</p>\n<h5 id=\"示例-306\"><a class=\"markdownIt-Anchor\" href=\"#示例-306\">#</a> 示例</h5>\n<pre><code>class Convenient &#123;\n    // ...\n&#125;;\n\nbool operator==(const Convenient&amp;, const Convenient&amp;);\nbool operator&lt;(const Convenient&amp;, const Convenient&amp;);\n// ... 其他比较运算符 ...\n\nConvenient operator+(const Convenient&amp;, const Convenient&amp;);\n// ... 其他算术运算符 ...\n\nvoid f(const Convenient&amp; x, const Convenient&amp; y)\n&#123;\n    if (!(x == y)) &#123; /* ... */ &#125;    // OK\n    if (x != y) &#123; /* ... */ &#125;       // OK\n\n    while (!(x &lt; y)) &#123; /* ... */ &#125;  // OK\n    while (x &gt;= y) &#123; /* ... */ &#125;    // OK\n\n    x = x + y;     // OK\n    x += y;        // OK\n&#125;\n</code></pre>\n<p>定义所有的运算符也许很麻烦，但并不困难。<br>\n理想情况下，语言应当默认提供比较运算符以支持这条规则。</p>\n<h5 id=\"强制实施-315\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-315\">#</a> 强制实施</h5>\n<ul>\n<li>如果类所支持的运算符是运算符集合的 “奇异” 子集，比如有  <code>==</code>  但没有  <code>!=</code>  或者有  <code>+</code>  但没有  <code>-</code> ，就对其进行标记。<br>\n确实， <code>std::string</code>  也是 “奇异” 的，但要修改它太晚了。</li>\n</ul>\n<h3 id=\"a-namert-axiomat22-为概念指明公理\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-axiomat22-为概念指明公理\">#</a> <a name=\"Rt-axiom\"></a>T.22: 为概念指明公理</h3>\n<h5 id=\"理由-348\"><a class=\"markdownIt-Anchor\" href=\"#理由-348\">#</a> 理由</h5>\n<p>有意义或有用的概念都有语义上的含义。<br>\n以非正式、半正式或正式的方式表达这些语义可以使概念对于读者更加可理解，而且对其进行表达的工作也能发现一些概念上的错误。<br>\n对语义的说明是一种强大的设计工具。</p>\n<h5 id=\"示例-307\"><a class=\"markdownIt-Anchor\" href=\"#示例-307\">#</a> 示例</h5>\n<pre><code>template&lt;typename T&gt;\n    // 假定数值的运算符 +、-、* 和 / 都遵循常规的数学法则\n    // axiom(T a, T b) &#123; a + b == b + a; a - a == 0; a * (b + c) == a * b + a * c; /*...*/ &#125;\n    concept Number = requires(T a, T b) &#123;\n        &#123;a + b&#125; -&gt; convertible_to&lt;T&gt;;\n        &#123;a - b&#125; -&gt; convertible_to&lt;T&gt;;\n        &#123;a * b&#125; -&gt; convertible_to&lt;T&gt;;\n        &#123;a / b&#125; -&gt; convertible_to&lt;T&gt;;\n    &#125;;\n</code></pre>\n<h5 id=\"注解-313\"><a class=\"markdownIt-Anchor\" href=\"#注解-313\">#</a> 注解</h5>\n<p>这是一种数学意义上的公理：可以假定成立而无需证明。<br>\n通常公理是无法证明的，而即便可以证明，通常也超出了编译器的能力。<br>\n一条公理也许并不是通用的，不过模板作者可以假定其对于其所实际使用的所有输入均成立（类似于一种前条件）。</p>\n<h5 id=\"注解-314\"><a class=\"markdownIt-Anchor\" href=\"#注解-314\">#</a> 注解</h5>\n<p>这种上下文中的公理都是布尔表达式。<br>\n参见 <a href=\"#S-references\">Palo Alto TR</a> 中的例子。<br>\n当前，C++ 并不支持公理（即便 ISO Concepts TS 也不支持），我们不得不长期用代码注释来给出它们。<br>\n语言支持一旦出现，公理前面的  <code>//</code>  就可以删掉了。</p>\n<h5 id=\"注解-315\"><a class=\"markdownIt-Anchor\" href=\"#注解-315\">#</a> 注解</h5>\n<p>GSL 中的概念都具有恰当定义的语义；请参见 Palo Alto TR 和 Ranges TS。</p>\n<h5 id=\"例外-57\"><a class=\"markdownIt-Anchor\" href=\"#例外-57\">#</a> 例外</h5>\n<p>一个处于开发之中的新 “概念” 的早期版本，经常会仅仅定义了一组简单的约束而并没有恰当指定的语义。<br>\n为其寻找正确的语义可能是很费功夫和时间的。<br>\n不过不完整的约束集合仍然是很有用的：</p>\n<pre><code>// 对于一般二叉树的平衡器\ntemplate&lt;typename Node&gt; concept Balancer = requires(Node* p) &#123;\n    add_fixup(p);\n    touch(p);\n    detach(p);\n&#125;;\n</code></pre>\n<p>这样  <code>Balancer</code>  就必须为树的  <code>Node</code>  至少提供这些操作，<br>\n但我们还是无法指定详细的语义，因为一种新种类的平衡树可能需要更多的操作，<br>\n而在设计的早期阶段，很难确定把对于所有节点的精确的一般语义所确定下来。</p>\n<p>不完整的或者没有恰当指定的语义的 “概念” 仍然是很有用的。<br>\n比如说，它可能允许在初始的试验之中进行某些检查。<br>\n不过，请不要把它当作是稳定的。<br>\n它的每个新的用例都可能导致不完整概念的改善。</p>\n<h5 id=\"强制实施-316\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-316\">#</a> 强制实施</h5>\n<ul>\n<li>在概念定义的代码注释中寻找单词 “axiom”。</li>\n</ul>\n<h3 id=\"a-namert-refineat23-通过添加新的使用模式从更一般情形的概念中区分出提炼后的概念\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-refineat23-通过添加新的使用模式从更一般情形的概念中区分出提炼后的概念\">#</a> <a name=\"Rt-refine\"></a>T.23: 通过添加新的使用模式，从更一般情形的概念中区分出提炼后的概念</h3>\n<h5 id=\"理由-349\"><a class=\"markdownIt-Anchor\" href=\"#理由-349\">#</a> 理由</h5>\n<p>否则编译器是无法自动对它们进行区分的。</p>\n<h5 id=\"示例-308\"><a class=\"markdownIt-Anchor\" href=\"#示例-308\">#</a> 示例</h5>\n<pre><code>template&lt;typename I&gt;\n// 注：&lt;iterator&gt; 中定义了 input_iterator\nconcept Input_iter = requires(I iter) &#123; ++iter; &#125;;\n\ntemplate&lt;typename I&gt;\n// 注：&lt;iterator&gt; 中定义了 forward_iterator\nconcept Fwd_iter = Input_iter&lt;I&gt; &amp;&amp; requires(I iter) &#123; iter++; &#125;;\n</code></pre>\n<p>编译器可以基于所要求的操作的集合（这里为前缀  <code>++</code> ）来确定提炼关系。<br>\n这样做减少了这些类型的实现者的负担，<br>\n因为他们不再需要任何特殊的声明来 “打入概念内部” 了。<br>\n如果两个概念具有完全相同的要求的话，它们在逻辑上就是等价的（不存在提炼）。</p>\n<h5 id=\"强制实施-317\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-317\">#</a> 强制实施</h5>\n<ul>\n<li>对与已经出现的另一个概念具有完全相同的要求的概念进行标记（它们中不存在更精炼的概念）。<br>\n为对它们进行区分，参见 <a href=\"#Rt-tag\">T.24</a>。</li>\n</ul>\n<h3 id=\"a-namert-tagat24-用标签类或特征类来区分仅在语义上存在差别的概念\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-tagat24-用标签类或特征类来区分仅在语义上存在差别的概念\">#</a> <a name=\"Rt-tag\"></a>T.24: 用标签类或特征类来区分仅在语义上存在差别的概念</h3>\n<h5 id=\"理由-350\"><a class=\"markdownIt-Anchor\" href=\"#理由-350\">#</a> 理由</h5>\n<p>要求相同的语法但具有不同语义的两个概念之间会造成歧义，除非程序员对它们进行区分。</p>\n<h5 id=\"示例-309\"><a class=\"markdownIt-Anchor\" href=\"#示例-309\">#</a> 示例</h5>\n<pre><code>template&lt;typename I&gt;    // 提供随机访问的迭代器\n// 注：&lt;iterator&gt; 中定义了 random_access_iterator\nconcept RA_iter = ...;\n\ntemplate&lt;typename I&gt;    // 提供对连续数据的随机访问的迭代器\n// 注：&lt;iterator&gt; 中定义了 contiguous_iterator\nconcept Contiguous_iter =\n    RA_iter&lt;I&gt; &amp;&amp; is_contiguous_v&lt;I&gt;;  // 使用 is_contiguous 特征\n</code></pre>\n<p>程序员（在程序库中）必须适当地定义（特征）  <code>is_contiguous</code> 。</p>\n<p>把标签类包装到概念中可以得到这个方案的更简单的表达方式：</p>\n<pre><code>template&lt;typename I&gt; concept Contiguous = is_contiguous_v&lt;I&gt;;\n\ntemplate&lt;typename I&gt;\nconcept Contiguous_iter = RA_iter&lt;I&gt; &amp;&amp; Contiguous&lt;I&gt;;\n</code></pre>\n<p>程序员（在程序库中）必须适当地定义（特征）  <code>is_contiguous</code> 。</p>\n<h5 id=\"注解-316\"><a class=\"markdownIt-Anchor\" href=\"#注解-316\">#</a> 注解</h5>\n<p>特征可以是特征类或者类型特征。<br>\n它们可以是用户定义的，或者标准库中的。<br>\n优先采用标准库中的特征。</p>\n<h5 id=\"强制实施-318\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-318\">#</a> 强制实施</h5>\n<ul>\n<li>编译器会将对相同的概念的有歧义的使用标记出来。</li>\n<li>对相同的概念定义进行标记。</li>\n</ul>\n<h3 id=\"a-namert-notat25-避免互补性的约束\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-notat25-避免互补性的约束\">#</a> <a name=\"Rt-not\"></a>T.25: 避免互补性的约束</h3>\n<h5 id=\"理由-351\"><a class=\"markdownIt-Anchor\" href=\"#理由-351\">#</a> 理由</h5>\n<p>清晰性。可维护性。<br>\n用否定来表达的具有互补要求的函数是很脆弱的。</p>\n<h5 id=\"示例-310\"><a class=\"markdownIt-Anchor\" href=\"#示例-310\">#</a> 示例</h5>\n<p>最初，人们总会试图定义带有互补要求的函数：</p>\n<pre><code>template&lt;typename T&gt;\n    requires !C&lt;T&gt;    // 不好\nvoid f();\n\ntemplate&lt;typename T&gt;\n    requires C&lt;T&gt;\nvoid f();\n</code></pre>\n<p>这样会好得多：</p>\n<pre><code>template&lt;typename T&gt;   // 通用模板\n    void f();\n\ntemplate&lt;typename T&gt;   // 用概念进行特化\n    requires C&lt;T&gt;\nvoid f();\n</code></pre>\n<p>仅当  <code>C&lt;T&gt;</code>  无法满足时，编译器将会选择无约束的模板。<br>\n如果你并不想（或者无法）定义无约束版本的<br>\n <code>f()</code>  的话，你可以删掉它。</p>\n<pre><code>template&lt;typename T&gt;\nvoid f() = delete;\n</code></pre>\n<p>编译器将会选取这个重载，或者给出一个适当的错误。</p>\n<h5 id=\"注解-317\"><a class=\"markdownIt-Anchor\" href=\"#注解-317\">#</a> 注解</h5>\n<p>很不幸，互补约束在  <code>enable_if</code>  代码中很常见：</p>\n<pre><code>template&lt;typename T&gt;\nenable_if&lt;!C&lt;T&gt;, void&gt;   // 不好\nf();\n\ntemplate&lt;typename T&gt;\nenable_if&lt;C&lt;T&gt;, void&gt;\nf();\n</code></pre>\n<h5 id=\"注解-318\"><a class=\"markdownIt-Anchor\" href=\"#注解-318\">#</a> 注解</h5>\n<p>有时候会（不正确地）把对单个要求的互补约束当做是可以接受的。<br>\n不过，对于两个或更多的要求来说，所需要的定义的数量是按指数增长的（2，4，8，16，……）：</p>\n<pre><code>C1&lt;T&gt; &amp;&amp; C2&lt;T&gt;\n!C1&lt;T&gt; &amp;&amp; C2&lt;T&gt;\nC1&lt;T&gt; &amp;&amp; !C2&lt;T&gt;\n!C1&lt;T&gt; &amp;&amp; !C2&lt;T&gt;\n</code></pre>\n<p>这样，犯错的机会也会倍增。</p>\n<h5 id=\"强制实施-319\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-319\">#</a> 强制实施</h5>\n<ul>\n<li>对带有  <code>C&lt;T&gt;</code>  和  <code>!C&lt;T&gt;</code>  约束的函数对进行标记。</li>\n</ul>\n<h3 id=\"a-namert-useat26-优先采用使用模式而不是简单的语法来定义概念\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-useat26-优先采用使用模式而不是简单的语法来定义概念\">#</a> <a name=\"Rt-use\"></a>T.26: 优先采用使用模式而不是简单的语法来定义概念</h3>\n<h5 id=\"理由-352\"><a class=\"markdownIt-Anchor\" href=\"#理由-352\">#</a> 理由</h5>\n<p>其定义更可读，而且更直接地对应于用户需要编写的代码。<br>\n其中同时兼顾了类型转换。你再不需要记住所有的类型特征的名字。</p>\n<h5 id=\"示例-311\"><a class=\"markdownIt-Anchor\" href=\"#示例-311\">#</a> 示例</h5>\n<p>你可能打算这样来定义概念  <code>Equality</code> ：</p>\n<pre><code>template&lt;typename T&gt; concept Equality = has_equal&lt;T&gt; &amp;&amp; has_not_equal&lt;T&gt;;\n</code></pre>\n<p>显然，直接使用标准的  <code>equality_comparable</code>  要更好而且更容易，<br>\n但是 —— 只是一个例子 —— 如果你不得不定义这样的概念的话，应当这样：</p>\n<pre><code>template&lt;typename T&gt; concept Equality = requires(T a, T b) &#123;\n    &#123; a == b &#125; -&gt; std::convertible_to&lt;bool&gt;;\n    &#123; a != b &#125; -&gt; std::convertible_to&lt;bool&gt;;\n    // axiom &#123; !(a == b) == (a != b) &#125;\n    // axiom &#123; a = b; =&gt; a == b &#125;  // =&gt; 的意思是“意味着”\n&#125;;\n</code></pre>\n<p>而不是定义两个无意义的概念  <code>has_equal</code>  和  <code>has_not_equal</code>  仅用于帮助  <code>Equality</code>  的定义。<br>\n“无意义” 的意思是我们无法独立地指定  <code>has_equal</code>  的语义。</p>\n<h5 id=\"强制实施-320\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-320\">#</a> 强制实施</h5>\n<p>???</p>\n<h2 id=\"a-namess-temp-interfacea模板接口\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-temp-interfacea模板接口\">#</a> <a name=\"SS-temp-interface\"></a>模板接口</h2>\n<p>这些年以来，使用模板的编程一直忍受着模板的接口及其实现之间的<br>\n微弱区分性。<br>\n在引入概念之前，这种区分是没有直接的语言支持的。<br>\n不过，模板的接口是一个关键概念 —— 是用户和实现者之间的一种契约 —— 而且应当进行周密的设计。</p>\n<h3 id=\"a-namert-foat40-使用函数对象向算法传递操作\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-foat40-使用函数对象向算法传递操作\">#</a> <a name=\"Rt-fo\"></a>T.40: 使用函数对象向算法传递操作</h3>\n<h5 id=\"理由-353\"><a class=\"markdownIt-Anchor\" href=\"#理由-353\">#</a> 理由</h5>\n<p>函数对象比 “普通” 的函数指针能够向接口传递更多的信息。<br>\n一般来说，传递函数对象比传递函数指针能带来更好的性能。</p>\n<h5 id=\"示例-312\"><a class=\"markdownIt-Anchor\" href=\"#示例-312\">#</a> 示例</h5>\n<pre><code>bool greater(double x, double y) &#123; return x &gt; y; &#125;\nsort(v, greater);                                    // 函数指针：可能较慢\nsort(v, [](double x, double y) &#123; return x &gt; y; &#125;);   // 函数对象\nsort(v, std::greater&#123;&#125;);                             // 函数对象\n\nbool greater_than_7(double x) &#123; return x &gt; 7; &#125;\nauto x = find_if(v, greater_than_7);                 // 函数指针：不灵活\nauto y = find_if(v, [](double x) &#123; return x &gt; 7; &#125;); // 函数对象：携带所需数据\nauto z = find_if(v, Greater_than&lt;double&gt;(7));        // 函数对象：携带所需数据\n</code></pre>\n<p>当然，也可以使用  <code>auto</code>  或概念来使这些函数通用化。例如：</p>\n<pre><code>auto y1 = find_if(v, [](totally_ordered auto x) &#123; return x &gt; 7; &#125;); // 要求一种有序类型\nauto z1 = find_if(v, [](auto x) &#123; return x &gt; 7; &#125;);                 // 期望类型带有 &gt;\n</code></pre>\n<h5 id=\"注解-319\"><a class=\"markdownIt-Anchor\" href=\"#注解-319\">#</a> 注解</h5>\n<p>Lambda 会生成函数对象。</p>\n<h5 id=\"注解-320\"><a class=\"markdownIt-Anchor\" href=\"#注解-320\">#</a> 注解</h5>\n<p>性能表现依赖于编译器和优化器技术。</p>\n<h5 id=\"强制实施-321\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-321\">#</a> 强制实施</h5>\n<ul>\n<li>标记以函数指针作为模板参数。</li>\n<li>标记将函数指针作为模板的参数进行传递（存在误报风险）。</li>\n</ul>\n<h3 id=\"a-namert-essentialat41-在模板的概念上仅提出基本的性质要求\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-essentialat41-在模板的概念上仅提出基本的性质要求\">#</a> <a name=\"Rt-essential\"></a>T.41: 在模板的概念上仅提出基本的性质要求</h3>\n<h5 id=\"理由-354\"><a class=\"markdownIt-Anchor\" href=\"#理由-354\">#</a> 理由</h5>\n<p>保持接口的简单和稳定。</p>\n<h5 id=\"示例-313\"><a class=\"markdownIt-Anchor\" href=\"#示例-313\">#</a> 示例</h5>\n<p>考虑一个带有（过度简化的）简单调试支持的  <code>sort</code> ：</p>\n<pre><code>void sort(sortable auto&amp; s)  // 对序列 s 进行排序\n&#123;\n    if (debug) cerr &lt;&lt; &quot;enter sort( &quot; &lt;&lt; s &lt;&lt;  &quot;)\\n&quot;;\n    // ...\n    if (debug) cerr &lt;&lt; &quot;exit sort( &quot; &lt;&lt; s &lt;&lt;  &quot;)\\n&quot;;\n&#125;\n</code></pre>\n<p>是否该把它重写为：</p>\n<pre><code>template&lt;sortable S&gt;\n    requires Streamable&lt;S&gt;\nvoid sort(S&amp; s)  // 对序列 s 进行排序\n&#123;\n    if (debug) cerr &lt;&lt; &quot;enter sort( &quot; &lt;&lt; s &lt;&lt;  &quot;)\\n&quot;;\n    // ...\n    if (debug) cerr &lt;&lt; &quot;exit sort( &quot; &lt;&lt; s &lt;&lt;  &quot;)\\n&quot;;\n&#125;\n</code></pre>\n<p>毕竟， <code>sortable</code>  里面并没有要求任何  <code>iostream</code>  支持。<br>\n而另一方面，在排序的基本概念中也没有任何东西是有关于调试的。</p>\n<h5 id=\"注解-321\"><a class=\"markdownIt-Anchor\" href=\"#注解-321\">#</a> 注解</h5>\n<p>如果我们要求把用到的所有操作都在要求部分中列出的话，接口就会变得不稳定：<br>\n每当我们改动了调试设施，使用情况数据收集，测试支持，错误报告等等，<br>\n模板的定义就都得进行改动，而模板的所有使用方都不得不进行重新编译。<br>\n这样做很是累赘，而且在某些环境下是不可行的。</p>\n<p>与之相反，如果我们在实现中使用了某个并未被概念检查提供保证的操作的话，<br>\n我们可能会遇到一个延后的编译时错误。</p>\n<p>通过不对模板参数的那些不被认为是基本的性质进行概念检查，<br>\n我们把其检查推迟到了进行实例化的时候。<br>\n我们认为这是值得做出的折衷。</p>\n<p>注意，使用非局部的，非待决的名字（比如  <code>debug</code>  和  <code>cerr</code> ），同样会引入可能导致 “神秘的” 错误的某些上下文依赖。</p>\n<h5 id=\"注解-322\"><a class=\"markdownIt-Anchor\" href=\"#注解-322\">#</a> 注解</h5>\n<p>可能很难确定一个类型的哪些性质是基本的，而哪些不是。</p>\n<h5 id=\"强制实施-322\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-322\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namert-aliasat42-使用模板别名来简化写法并隐藏实现细节\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-aliasat42-使用模板别名来简化写法并隐藏实现细节\">#</a> <a name=\"Rt-alias\"></a>T.42: 使用模板别名来简化写法并隐藏实现细节</h3>\n<h5 id=\"理由-355\"><a class=\"markdownIt-Anchor\" href=\"#理由-355\">#</a> 理由</h5>\n<p>提升可读性。<br>\n隐藏实现。<br>\n注意，模板别名取代了许多用于计算类型的特征。<br>\n它们也可以用于封装一个特征。</p>\n<h5 id=\"示例-314\"><a class=\"markdownIt-Anchor\" href=\"#示例-314\">#</a> 示例</h5>\n<pre><code>template&lt;typename T, size_t N&gt;\nclass Matrix &#123;\n    // ...\n    using Iterator = typename std::vector&lt;T&gt;::iterator;\n    // ...\n&#125;;\n</code></pre>\n<p>这免除了  <code>Matrix</code>  的用户必须了解其元素是存储于  <code>vector</code>  之中，而且也免除了用户重复书写  <code>typename std::vector&lt;T&gt;::</code> 。</p>\n<h5 id=\"示例-315\"><a class=\"markdownIt-Anchor\" href=\"#示例-315\">#</a> 示例</h5>\n<pre><code>template&lt;typename T&gt;\nvoid user(T&amp; c)\n&#123;\n    // ...\n    typename container_traits&lt;T&gt;::value_type x; // 不好，啰嗦\n    // ...\n&#125;\n\ntemplate&lt;typename T&gt;\nusing Value_type = typename container_traits&lt;T&gt;::value_type;\n</code></pre>\n<p>这免除了  <code>Value_type</code>  的用户必须了解用于实现  <code>value_type</code>  的技术。</p>\n<pre><code>template&lt;typename T&gt;\nvoid user2(T&amp; c)\n&#123;\n    // ...\n    Value_type&lt;T&gt; x;\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"注解-323\"><a class=\"markdownIt-Anchor\" href=\"#注解-323\">#</a> 注解</h5>\n<p>一种简洁的常用说法是：“包装特征！”</p>\n<h5 id=\"强制实施-323\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-323\">#</a> 强制实施</h5>\n<ul>\n<li>将  <code>using</code>  声明之外用于消除歧义的  <code>typename</code>  进行标记。</li>\n<li>???</li>\n</ul>\n<h3 id=\"a-namert-usingat43-优先使用-using-而不是-typedef-来定义别名\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-usingat43-优先使用-using-而不是-typedef-来定义别名\">#</a> <a name=\"Rt-using\"></a>T.43: 优先使用  <code>using</code>  而不是  <code>typedef</code>  来定义别名</h3>\n<h5 id=\"理由-356\"><a class=\"markdownIt-Anchor\" href=\"#理由-356\">#</a> 理由</h5>\n<p>提升可读性：使用  <code>using</code>  时，新名字在前面，而不是被嵌在声明中的什么地方。<br>\n通用性： <code>using</code>  可用于模板别名，而  <code>typedef</code>  无法轻易作为模板。<br>\n一致性： <code>using</code>  在语法上和  <code>auto</code>  相似。</p>\n<h5 id=\"示例-316\"><a class=\"markdownIt-Anchor\" href=\"#示例-316\">#</a> 示例</h5>\n<pre><code>typedef int (*PFI)(int);   // OK, 但很别扭\n\nusing PFI2 = int (*)(int);   // OK, 更好\n\ntemplate&lt;typename T&gt;\ntypedef int (*PFT)(T);      // 错误\n\ntemplate&lt;typename T&gt;\nusing PFT2 = int (*)(T);   // OK\n</code></pre>\n<h5 id=\"强制实施-324\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-324\">#</a> 强制实施</h5>\n<ul>\n<li>标记  <code>typedef</code>  的使用。不过这样会出现大量的 “命中” 😦</li>\n</ul>\n<h3 id=\"a-namert-deduceat44-如果可行使用函数模板来对类模板的参数类型进行推断\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-deduceat44-如果可行使用函数模板来对类模板的参数类型进行推断\">#</a> <a name=\"Rt-deduce\"></a>T.44: （如果可行）使用函数模板来对类模板的参数类型进行推断</h3>\n<h5 id=\"理由-357\"><a class=\"markdownIt-Anchor\" href=\"#理由-357\">#</a> 理由</h5>\n<p>显式写出模板参数类型既麻烦又无必要。</p>\n<h5 id=\"示例-317\"><a class=\"markdownIt-Anchor\" href=\"#示例-317\">#</a> 示例</h5>\n<pre><code>tuple&lt;int, string, double&gt; t1 = &#123;1, &quot;Hamlet&quot;, 3.14&#125;;   // 明确类型\nauto t2 = make_tuple(1, &quot;Ophelia&quot;s, 3.14);         // 更好；推断类型\n</code></pre>\n<p>注意这里用  <code>s</code>  后缀来确保字符串是  <code>std::string</code>  而不是 C 风格字符串。</p>\n<h5 id=\"注解-324\"><a class=\"markdownIt-Anchor\" href=\"#注解-324\">#</a> 注解</h5>\n<p>既然你可以轻易写出  <code>make_T</code>  函数，编译器也可以。以后  <code>make_T</code>  函数也许将会变得多余。</p>\n<h5 id=\"例外-58\"><a class=\"markdownIt-Anchor\" href=\"#例外-58\">#</a> 例外</h5>\n<p>有时候没办法对模板参数进行推断，而有时候你则想要明确指定参数：</p>\n<pre><code>vector&lt;double&gt; v = &#123; 1, 2, 3, 7.9, 15.99 &#125;;\nlist&lt;Record*&gt; lst;\n</code></pre>\n<h5 id=\"注解-325\"><a class=\"markdownIt-Anchor\" href=\"#注解-325\">#</a> 注解</h5>\n<p>注意，C++17 强允许模板参数直接从构造函数参数进行推断，而使这条规则变得多余：<br>\n<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcGVuLXN0ZC5vcmcvanRjMS9zYzIyL3dnMjEvZG9jcy9wYXBlcnMvMjAxNi9wMDA5MXIxLmh0bWw=\">构造函数的模板形参推断 (Rev. 3)</span>。<br>\n例如：</p>\n<pre><code>tuple t1 = &#123;1, &quot;Hamlet&quot;s, 3.14&#125;; // 推断为：tuple&lt;int, string, double&gt;\n</code></pre>\n<h5 id=\"强制实施-325\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-325\">#</a> 强制实施</h5>\n<p>当显式指定的类型与所使用的类型精确匹配时进行标记。</p>\n<h3 id=\"a-namert-regularat46-要求模板参数至少是半正规的\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-regularat46-要求模板参数至少是半正规的\">#</a> <a name=\"Rt-regular\"></a>T.46: 要求模板参数至少是半正规的</h3>\n<h5 id=\"理由-358\"><a class=\"markdownIt-Anchor\" href=\"#理由-358\">#</a> 理由</h5>\n<p>可读性。<br>\n避免意外和错误。<br>\n大多数用法都支持这样做。</p>\n<h5 id=\"示例-318\"><a class=\"markdownIt-Anchor\" href=\"#示例-318\">#</a> 示例</h5>\n<pre><code>class X &#123;\npublic:\n    explicit X(int);\n    X(const X&amp;);            // 复制\n    X operator=(const X&amp;);\n    X(X&amp;&amp;) noexcept;        // 移动\n    X&amp; operator=(X&amp;&amp;) noexcept;\n    ~X();\n    // ... 没有别的构造函数了 ...\n&#125;;\n\nX x &#123;1&#125;;              // 没问题\nX y = x;              // 没问题\nstd::vector&lt;X&gt; v(10); // 错误: 没有默认构造函数\n</code></pre>\n<h5 id=\"注解-326\"><a class=\"markdownIt-Anchor\" href=\"#注解-326\">#</a> 注解</h5>\n<p><code>SemiRegular</code>  要求可以默认构造。</p>\n<h5 id=\"强制实施-326\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-326\">#</a> 强制实施</h5>\n<ul>\n<li>对并非至少为  <code>SemiRegular</code>  的类型进行标记。</li>\n</ul>\n<h3 id=\"a-namert-visibleat47-避免用常用名字命名高度可见的无约束模板\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-visibleat47-避免用常用名字命名高度可见的无约束模板\">#</a> <a name=\"Rt-visible\"></a>T.47: 避免用常用名字命名高度可见的无约束模板</h3>\n<h5 id=\"示例-319\"><a class=\"markdownIt-Anchor\" href=\"#示例-319\">#</a> 示例</h5>\n<p>无约束的模板参数和任何东西都能完全匹配，因此这样的模板相对于需要少量转换的更特定类型来说可能更优先。<br>\n而当使用 ADL 时，这一点将会更加麻烦和危险。<br>\n而常用的名字则会让这种问题更易于出现。</p>\n<h5 id=\"示例-320\"><a class=\"markdownIt-Anchor\" href=\"#示例-320\">#</a> 示例</h5>\n<pre><code>namespace Bad &#123;\n    struct S &#123; int m; &#125;;\n    template&lt;typename T1, typename T2&gt;\n    bool operator==(T1, T2) &#123; cout &lt;&lt; &quot;Bad\\n&quot;; return true; &#125;\n&#125;\n\nnamespace T0 &#123;\n    bool operator==(int, Bad::S) &#123; cout &lt;&lt; &quot;T0\\n&quot;; return true; &#125;  // 与 int 比较\n\n    void test()\n    &#123;\n        Bad::S bad&#123; 1 &#125;;\n        vector&lt;int&gt; v(10);\n        bool b = 1 == bad;\n        bool b2 = v.size() == bad;\n    &#125;\n&#125;\n</code></pre>\n<p>这将会打印出  <code>T0</code>  和  <code>Bad</code> 。</p>\n<p>这里  <code>Bad</code>  中的  <code>==</code>  有意设计为造成问题，不过你是否在真实代码中发现过这个问题呢？<br>\n问题在于  <code>v.size()</code>  返回的是  <code>unsigned</code>  整数，因此需要进行转换才能调用局部的  <code>==</code> ；<br>\n而  <code>Bad</code>  中的  <code>=</code>  则不需要任何转换。<br>\n实际的类型，比如标准库的迭代器，也可以被弄成类似的反社会倾向。</p>\n<h5 id=\"注解-327\"><a class=\"markdownIt-Anchor\" href=\"#注解-327\">#</a> 注解</h5>\n<p>如果在相同的命名空间中定义了一个无约束模板类型，<br>\n这个无约束模板是可以通过 ADL 所找到的（如例子中所发生的一样）。<br>\n就是说，它是高度可见的。</p>\n<h5 id=\"注解-328\"><a class=\"markdownIt-Anchor\" href=\"#注解-328\">#</a> 注解</h5>\n<p>这条规则应当是没有必要的，不过委员会在是否将无约束模板从 ADL 中排除上无法达成一致。</p>\n<p>不幸的是，这会导致大量的误报；标准库也大量地违反了这条规则，它将许多无约束模板和类型都放入了单一的命名空间  <code>std</code>  之中。</p>\n<h5 id=\"强制实施-327\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-327\">#</a> 强制实施</h5>\n<p>如果定义模板的命名空间中同样定义了具体的类型，就对其进行标记（可能在我们有概念支持之前都是不可行的）。</p>\n<h3 id=\"a-namert-concept-defat48-如果你的编译器不支持概念的话可以用-enable_if-来模拟\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-concept-defat48-如果你的编译器不支持概念的话可以用-enable_if-来模拟\">#</a> <a name=\"Rt-concept-def\"></a>T.48: 如果你的编译器不支持概念的话，可以用  <code>enable_if</code>  来模拟</h3>\n<h5 id=\"理由-359\"><a class=\"markdownIt-Anchor\" href=\"#理由-359\">#</a> 理由</h5>\n<p>因为这是我们没有直接的概念支持时能够做到的最好的方式。<br>\n <code>enable_if</code>  可被用于有条件地定义函数，以及用于在一组函数中进行选择。</p>\n<h5 id=\"示例-321\"><a class=\"markdownIt-Anchor\" href=\"#示例-321\">#</a> 示例</h5>\n<pre><code>template&lt;typename T&gt;\nenable_if_t&lt;is_integral_v&lt;T&gt;&gt;\nf(T v)\n&#123;\n    // ...\n&#125;\n\n// 等价于：\ntemplate&lt;Integral T&gt;\nvoid f(T v)\n&#123;\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"注解-329\"><a class=\"markdownIt-Anchor\" href=\"#注解-329\">#</a> 注解</h5>\n<p>请当心<a href=\"#Rt-not\">互补约束</a>。<br>\n当用  <code>enable_if</code>  来模拟概念重载时，有时候会迫使我们使用这种易错的设计技巧。</p>\n<h5 id=\"强制实施-328\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-328\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namert-erasureat49-尽可能避免类型擦除\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-erasureat49-尽可能避免类型擦除\">#</a> <a name=\"Rt-erasure\"></a>T.49: 尽可能避免类型擦除</h3>\n<h5 id=\"理由-360\"><a class=\"markdownIt-Anchor\" href=\"#理由-360\">#</a> 理由</h5>\n<p>类型擦除通过在一个独立的编译边界之后隐藏类型信息而招致一层额外的间接。</p>\n<h5 id=\"示例-322\"><a class=\"markdownIt-Anchor\" href=\"#示例-322\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<p><strong>例外</strong>：有时候类型擦除是合适的，比如  <code>std::function</code> 。</p>\n<h5 id=\"强制实施-329\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-329\">#</a> 强制实施</h5>\n<p>???</p>\n<h5 id=\"注解-330\"><a class=\"markdownIt-Anchor\" href=\"#注解-330\">#</a> 注解</h5>\n<h2 id=\"a-namess-temp-defatdef-模板定义\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-temp-defatdef-模板定义\">#</a> <a name=\"SS-temp-def\"></a>T.def: 模板定义</h2>\n<p>模板的定义式（无论是类还是函数）都可能包含任意的代码，因而只有相当范围的 C++ 编程技术才能覆盖这个主题。<br>\n不过，这个部分所关注的是特定于模板的实现的问题。<br>\n特别地说，这里关注的是模板定义式对其上下文之间的依赖。</p>\n<h3 id=\"a-namert-dependat60-最小化模板的上下文依赖性\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-dependat60-最小化模板的上下文依赖性\">#</a> <a name=\"Rt-depend\"></a>T.60: 最小化模板的上下文依赖性</h3>\n<h5 id=\"理由-361\"><a class=\"markdownIt-Anchor\" href=\"#理由-361\">#</a> 理由</h5>\n<p>便于理解。<br>\n最小化源于意外依赖的错误。<br>\n便于创建工具。</p>\n<h5 id=\"示例-323\"><a class=\"markdownIt-Anchor\" href=\"#示例-323\">#</a> 示例</h5>\n<pre><code>template&lt;typename C&gt;\nvoid sort(C&amp; c)\n&#123;\n    std::sort(begin(c), end(c)); // 必要并且有意义的依赖\n&#125;\n\ntemplate&lt;typename Iter&gt;\nIter algo(Iter first, Iter last)\n&#123;\n    for (; first != last; ++first) &#123;\n        auto x = sqrt(*first); // 潜在的意外依赖：哪个 sqrt()？\n        helper(first, x);      // 潜在的意外依赖：\n                               // helper 是基于 first 和 x 所选择的\n        TT var = 7;            // 潜在的意外依赖：哪个 TT？\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"注解-331\"><a class=\"markdownIt-Anchor\" href=\"#注解-331\">#</a> 注解</h5>\n<p>通常模板是放在头文件中的，因此相对于  <code>.cpp</code>  文件之中的函数来说，其上下文依赖更加会受到  <code>#include</code>  的顺序依赖的威胁。</p>\n<h5 id=\"注解-332\"><a class=\"markdownIt-Anchor\" href=\"#注解-332\">#</a> 注解</h5>\n<p>让模板仅对其参数进行操作是一种把依赖减到最少的方式，但通常这是很难做到的。<br>\n比如说，一个算法通常会使用其他的算法，并且调用一些并非仅在参数上做动作的一些操作。<br>\n而且别再让我们从宏开始干活！</p>\n<p><strong>参见</strong>：<a href=\"#Rt-customization\">T.69</a>。</p>\n<h5 id=\"强制实施-330\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-330\">#</a> 强制实施</h5>\n<p>??? 很麻烦</p>\n<h3 id=\"a-namert-scaryat61-请勿对成员进行过度参数化scary\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-scaryat61-请勿对成员进行过度参数化scary\">#</a> <a name=\"Rt-scary\"></a>T.61: 请勿对成员进行过度参数化（SCARY）</h3>\n<h5 id=\"理由-362\"><a class=\"markdownIt-Anchor\" href=\"#理由-362\">#</a> 理由</h5>\n<p>不依赖于模板参数的成员，除非给定某个特定的模板参数，否则也是无法使用的。<br>\n这样会限制其使用，而且通常会增加代码大小。</p>\n<h5 id=\"示例不好-134\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-134\">#</a> 示例，不好</h5>\n<pre><code>template&lt;typename T, typename A = std::allocator&lt;T&gt;&gt;\n    // requires Regular&lt;T&gt; &amp;&amp; Allocator&lt;A&gt;\nclass List &#123;\npublic:\n    struct Link &#123;   // 并未依赖于 A\n        T elem;\n        Link* pre;\n        Link* suc;\n    &#125;;\n\n    using iterator = Link*;\n\n    iterator first() const &#123; return head; &#125;\n\n    // ...\nprivate:\n    Link* head;\n&#125;;\n\nList&lt;int&gt; lst1;\nList&lt;int, My_allocator&gt; lst2;\n</code></pre>\n<p>这看起来没什么问题，但现在  <code>Link</code>  形成依赖于分配器（尽管它不使用分配器）。 这迫使冗余的实例化在某些现实场景中可能造成出奇的高的成本。<br>\n通常，解决方案是使用自己的最小模板参数集使嵌套类非局部化。</p>\n<pre><code>template&lt;typename T&gt;\nstruct Link &#123;\n    T elem;\n    Link* pre;\n    Link* suc;\n&#125;;\n\ntemplate&lt;typename T, typename A = std::allocator&lt;T&gt;&gt;\n    // requires Regular&lt;T&gt; &amp;&amp; Allocator&lt;A&gt;\nclass List2 &#123;\npublic:\n    using iterator = Link&lt;T&gt;*;\n\n    iterator first() const &#123; return head; &#125;\n\n    // ...\nprivate:\n    Link&lt;T&gt;* head;\n&#125;;\n\nList2&lt;int&gt; lst1;\nList2&lt;int, My_allocator&gt; lst2;\n</code></pre>\n<p>人们发现  <code>Link</code>  不再隐藏在列表中很可怕，所以我们命名这个技术为 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcGVuLXN0ZC5vcmcvanRjMS9zYzIyL1dHMjEvZG9jcy9wYXBlcnMvMjAwOS9uMjkxMS5wZGY=\">SCARY</span>。<br>\n引自该学术论文：“首字母缩略词 SCARY 描述了看似错误的赋值和初始化（受冲突的通用参数的约束），<br>\n但实际上使用了正确的实现（由于最小化的依赖而不受冲突的约束）。”</p>\n<h5 id=\"注解-333\"><a class=\"markdownIt-Anchor\" href=\"#注解-333\">#</a> 注解</h5>\n<p>这同样适用于那些并不依赖于其全部模板形参的 lambda 表达式。</p>\n<h5 id=\"强制实施-331\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-331\">#</a> 强制实施</h5>\n<ul>\n<li>对并未依赖于全部模板形参的成员类型进行标记。</li>\n<li>对并未依赖于全部模板形参的成员函数进行标记。</li>\n<li>对并未依赖于全部模板形参的 lambda 表达式或变量模板进行标记。</li>\n</ul>\n<h3 id=\"a-namert-nondependentat62-将无依赖的类模板成员置于一个非模板基类之中\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-nondependentat62-将无依赖的类模板成员置于一个非模板基类之中\">#</a> <a name=\"Rt-nondependent\"></a>T.62: 将无依赖的类模板成员置于一个非模板基类之中</h3>\n<h5 id=\"理由-363\"><a class=\"markdownIt-Anchor\" href=\"#理由-363\">#</a> 理由</h5>\n<p>可以在使用基类成员时不需要指定模板参数，也不需要模板实例化。</p>\n<h5 id=\"示例-324\"><a class=\"markdownIt-Anchor\" href=\"#示例-324\">#</a> 示例</h5>\n<pre><code>template&lt;typename T&gt;\nclass Foo &#123;\npublic:\n    enum &#123; v1, v2 &#125;;\n    // ...\n&#125;;\n</code></pre>\n<p>???</p>\n<pre><code>struct Foo_base &#123;\n    enum &#123; v1, v2 &#125;;\n    // ...\n&#125;;\n\ntemplate&lt;typename T&gt;\nclass Foo : public Foo_base &#123;\npublic:\n    // ...\n&#125;;\n</code></pre>\n<h5 id=\"注解-334\"><a class=\"markdownIt-Anchor\" href=\"#注解-334\">#</a> 注解</h5>\n<p>这条规则的更一般化的版本是，<br>\n“如果类模板的成员依赖于 M 个模板参数中的 N 个，就将它置于只有 N 个参数的基类之中。”<br>\n 当 N == 1 时，可以如同 <a href=\"#Rt-scary\">T.61</a> 一样在一个基类和其外围作用域中的一个类之间进行选择。</p>\n<p>??? 常量的情况如何？类的静态成员呢？</p>\n<h5 id=\"强制实施-332\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-332\">#</a> 强制实施</h5>\n<ul>\n<li>标记？？？</li>\n</ul>\n<h3 id=\"a-namert-specializationat64-用特化来提供类模板的其他实现\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-specializationat64-用特化来提供类模板的其他实现\">#</a> <a name=\"Rt-specialization\"></a>T.64: 用特化来提供类模板的其他实现</h3>\n<h5 id=\"理由-364\"><a class=\"markdownIt-Anchor\" href=\"#理由-364\">#</a> 理由</h5>\n<p>模板定义了通用接口。<br>\n特化是一种为这个接口提供替代实现的强大机制。</p>\n<h5 id=\"示例-325\"><a class=\"markdownIt-Anchor\" href=\"#示例-325\">#</a> 示例</h5>\n<pre><code>??? 字符串的特化 (==)\n\n??? 表示特化？\n</code></pre>\n<h5 id=\"注解-335\"><a class=\"markdownIt-Anchor\" href=\"#注解-335\">#</a> 注解</h5>\n<p>???</p>\n<h5 id=\"强制实施-333\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-333\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namert-tag-dispatchat65-用标签分派来提供函数的其他实现\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-tag-dispatchat65-用标签分派来提供函数的其他实现\">#</a> <a name=\"Rt-tag-dispatch\"></a>T.65: 用标签分派来提供函数的其他实现</h3>\n<h5 id=\"理由-365\"><a class=\"markdownIt-Anchor\" href=\"#理由-365\">#</a> 理由</h5>\n<ul>\n<li>模板定义了通用接口。</li>\n<li>标签派发允许我们基于参数类型的特定性质选择不同的实现。</li>\n<li>性能。</li>\n</ul>\n<h5 id=\"示例-326\"><a class=\"markdownIt-Anchor\" href=\"#示例-326\">#</a> 示例</h5>\n<p>这是  <code>std::copy</code>  的一个简化版本（忽略了非连续序列的可能性）</p>\n<pre><code>struct pod_tag &#123;&#125;;\nstruct non_pod_tag &#123;&#125;;\n\ntemplate&lt;class T&gt; struct copy_trait &#123; using tag = non_pod_tag; &#125;;   // T 不是“朴素数据”\n\ntemplate&lt;&gt; struct copy_trait&lt;int&gt; &#123; using tag = pod_tag; &#125;;         // int 是“朴素数据”\n\ntemplate&lt;class Iter&gt;\nOut copy_helper(Iter first, Iter last, Iter out, pod_tag)\n&#123;\n    // 使用 memmove\n&#125;\n\ntemplate&lt;class Iter&gt;\nOut copy_helper(Iter first, Iter last, Iter out, non_pod_tag)\n&#123;\n    // 使用调用复制构造函数的循环\n&#125;\n\ntemplate&lt;class Iter&gt;\nOut copy(Iter first, Iter last, Iter out)\n&#123;\n    return copy_helper(first, last, out, typename copy_trait&lt;Value_type&lt;Iter&gt;&gt;::tag&#123;&#125;)\n&#125;\n\nvoid use(vector&lt;int&gt;&amp; vi, vector&lt;int&gt;&amp; vi2, vector&lt;string&gt;&amp; vs, vector&lt;string&gt;&amp; vs2)\n&#123;\n    copy(vi.begin(), vi.end(), vi2.begin()); // 使用 memmove\n    copy(vs.begin(), vs.end(), vs2.begin()); // 使用调用复制构造函数的循环\n&#125;\n</code></pre>\n<p>这是一种进行编译时算法选择的通用且有力的技巧。</p>\n<h5 id=\"注解-336\"><a class=\"markdownIt-Anchor\" href=\"#注解-336\">#</a> 注解</h5>\n<p>当可以广泛使用  <code>concept</code>  之后，这样的替代实现就可以直接进行区分了：</p>\n<pre><code>template&lt;class Iter&gt;\n    requires Pod&lt;Value_type&lt;Iter&gt;&gt;\nOut copy_helper(In, first, In last, Out out)\n&#123;\n    // 使用 memmove\n&#125;\n\ntemplate&lt;class Iter&gt;\nOut copy_helper(In, first, In last, Out out)\n&#123;\n    // 使用调用复制构造函数的循环\n&#125;\n</code></pre>\n<h5 id=\"强制实施-334\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-334\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namert-specialization2at67-用特化来提供不规则类型的其他实现\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-specialization2at67-用特化来提供不规则类型的其他实现\">#</a> <a name=\"Rt-specialization2\"></a>T.67: 用特化来提供不规则类型的其他实现</h3>\n<h5 id=\"理由-366\"><a class=\"markdownIt-Anchor\" href=\"#理由-366\">#</a> 理由</h5>\n<p>???</p>\n<h5 id=\"示例-327\"><a class=\"markdownIt-Anchor\" href=\"#示例-327\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"强制实施-335\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-335\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namert-castat68-在模板中用-而不是-以避免歧义\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-castat68-在模板中用-而不是-以避免歧义\">#</a> <a name=\"Rt-cast\"></a>T.68: 在模板中用  <code>&#123;&#125;</code>  而不是  <code>()</code>  以避免歧义</h3>\n<h5 id=\"理由-367\"><a class=\"markdownIt-Anchor\" href=\"#理由-367\">#</a> 理由</h5>\n<p><code>()</code>  会带来文法歧义。</p>\n<h5 id=\"示例-328\"><a class=\"markdownIt-Anchor\" href=\"#示例-328\">#</a> 示例</h5>\n<pre><code>template&lt;typename T, typename U&gt;\nvoid f(T t, U u)\n&#123;\n    T v1(T(u));    // 错误：啊，v1 是函数而不是变量\n    T v2&#123;u&#125;;       // 清晰：显然是变量\n    auto x = T(u); // 不清晰：构造还是强制转换？\n&#125;\n\nf(1, &quot;asdf&quot;); // 不好：从 const char* 强制转换为 int\n</code></pre>\n<h5 id=\"强制实施-336\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-336\">#</a> 强制实施</h5>\n<ul>\n<li>标记  <code>()</code>  初始化式。</li>\n<li>标记函数风格的强制转换。</li>\n</ul>\n<h3 id=\"a-namert-customizationat69-在模板中请勿进行未限定的非成员函数调用除非有意将之作为定制点\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-customizationat69-在模板中请勿进行未限定的非成员函数调用除非有意将之作为定制点\">#</a> <a name=\"Rt-customization\"></a>T.69: 在模板中，请勿进行未限定的非成员函数调用，除非有意将之作为定制点</h3>\n<h5 id=\"理由-368\"><a class=\"markdownIt-Anchor\" href=\"#理由-368\">#</a> 理由</h5>\n<ul>\n<li>仅提供预计之内的灵活性。</li>\n<li>避免源于意外的环境改变的威胁。</li>\n</ul>\n<h5 id=\"示例-329\"><a class=\"markdownIt-Anchor\" href=\"#示例-329\">#</a> 示例</h5>\n<p>主要有三种方法使调用代码对模板进行定制化。</p>\n<pre><code>template&lt;class T&gt;\n    // 调用成员函数\nvoid test1(T t)\n&#123;\n    t.f();    // 要求 T 提供 f()\n&#125;\n\ntemplate&lt;class T&gt;\nvoid test2(T t)\n    // 不带限定地调用非成员函数\n&#123;\n    f(t);     // 要求 f(/*T*/) 在调用方的作用域或者 T 的命名空间中可用\n&#125;\n\ntemplate&lt;class T&gt;\nvoid test3(T t)\n    // 调用一个“特征”\n&#123;\n    test_traits&lt;T&gt;::f(t); // 要求定制化 test_traits&lt;&gt;\n                          // 以获得非默认的函数和类型\n&#125;\n</code></pre>\n<p>特征通常是用以计算一个类型的类型别名，<br>\n用以计算一个值的  <code>constexpr</code>  函数，<br>\n或者针对用户的类型进行特化的传统的特征模板。</p>\n<h5 id=\"注解-337\"><a class=\"markdownIt-Anchor\" href=\"#注解-337\">#</a> 注解</h5>\n<p>当你打算为依赖于某个模板类型参数的值  <code>t</code>  调用自己的辅助函数  <code>helper(t)</code>  时，<br>\n请将函数放入一个  <code>::detail</code>  命名空间中，并把调用限定为  <code>detail::helper(t);</code> 。<br>\n无限定的调用将成为一个定制点，它将会调用处于  <code>t</code>  的类型所在命名空间中的任何  <code>helper</code>  函数；<br>\n这可能会导致诸如<a href=\"#Rt-visible\">意外地调用了无约束函数模板</a>这样的问题。</p>\n<h5 id=\"强制实施-337\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-337\">#</a> 强制实施</h5>\n<ul>\n<li>在模板中，如果非成员函数的无限定调用传递了具有依赖类型的变量，而在该模板的命名空间中存在相同名字的非成员函数，则对其进行标记。</li>\n</ul>\n<h2 id=\"a-namess-temp-hierattemp-hier-模板和类型层次规则\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-temp-hierattemp-hier-模板和类型层次规则\">#</a> <a name=\"SS-temp-hier\"></a>T.temp-hier: 模板和类型层次规则：</h2>\n<p>模板是 C++ 为泛型编程提供支持的基石，而类层次则是 C++ 为面向对象编程提供<br>\n支持的基石。<br>\n这两种语言机制可以有效地组合起来，但必须避免一些设计上的陷阱。</p>\n<h3 id=\"a-namert-hierat80-请勿不成熟地对类层次进行模板化\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-hierat80-请勿不成熟地对类层次进行模板化\">#</a> <a name=\"Rt-hier\"></a>T.80: 请勿不成熟地对类层次进行模板化</h3>\n<h5 id=\"理由-369\"><a class=\"markdownIt-Anchor\" href=\"#理由-369\">#</a> 理由</h5>\n<p>使一个带有许多函数，尤其是有许多虚函数的类层次进行模板化，会导致代码膨胀。</p>\n<h5 id=\"示例不好-135\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-135\">#</a> 示例，不好</h5>\n<pre><code>template&lt;typename T&gt;\nstruct Container &#123;         // 这是一个接口\n    virtual T* get(int i);\n    virtual T* first();\n    virtual T* next();\n    virtual void sort();\n&#125;;\n\ntemplate&lt;typename T&gt;\nclass Vector : public Container&lt;T&gt; &#123;\npublic:\n    // ...\n&#125;;\n\nVector&lt;int&gt; vi;\nVector&lt;string&gt; vs;\n</code></pre>\n<p>把  <code>sort</code>  定义为容器的成员函数可能是一个比较糟糕的主意，不过这样做并不鲜见，而且它是一个展示不应当做的事情的好例子。</p>\n<p>在这之中，编译器不知道  <code>Vector&lt;int&gt;::sort()</code>  是不是会被调用，因此它必须为之生成代码。<br>\n <code>Vector&lt;string&gt;::sort()</code>  也与此相似。<br>\n除非这两个函数被调用，否则这就是代码爆炸。<br>\n不难想象当一个带有几十个成员函数和几十个派生类的类层次被大量实例化时会怎么样。</p>\n<h5 id=\"注解-338\"><a class=\"markdownIt-Anchor\" href=\"#注解-338\">#</a> 注解</h5>\n<p>许多情况下都可以通过不为基类进行参数化而提供一个稳定的接口；<br>\n参见<a href=\"#Rt-abi\"> “稳定的基类”</a> 和 <a href=\"#Rt-generic-oo\">OO 与 GP</a>。</p>\n<h5 id=\"强制实施-338\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-338\">#</a> 强制实施</h5>\n<ul>\n<li>对依赖于模板参数的虚函数进行标记。 ??? 误报</li>\n</ul>\n<h3 id=\"a-namert-arrayat81-请勿混合类层次和数组\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-arrayat81-请勿混合类层次和数组\">#</a> <a name=\"Rt-array\"></a>T.81: 请勿混合类层次和数组</h3>\n<h5 id=\"理由-370\"><a class=\"markdownIt-Anchor\" href=\"#理由-370\">#</a> 理由</h5>\n<p>派生类的数组可以隐式地 “退化” 成指向基类的指针，并带来潜在的灾难性后果。</p>\n<h5 id=\"示例-330\"><a class=\"markdownIt-Anchor\" href=\"#示例-330\">#</a> 示例</h5>\n<p>假定  <code>Apple</code>  和  <code>Pear</code>  是两种  <code>Fruit</code> 。</p>\n<pre><code>void maul(Fruit* p)\n&#123;\n    *p = Pear&#123;&#125;;     // 把一个 Pear 放入 *p\n    p[1] = Pear&#123;&#125;;   // 把一个 Pear 放入 p[1]\n&#125;\n\nApple aa [] = &#123; an_apple, another_apple &#125;;   // aa 包含的是 Apple （显然！）\n\nmaul(aa);\nApple&amp; a0 = &amp;aa[0];   // 是 Pear 吗？\nApple&amp; a1 = &amp;aa[1];   // 是 Pear 吗？\n</code></pre>\n<p><code>aa[0]</code>  可能会变为  <code>Pear</code> （并且没进行过强制转换！）。<br>\n当  <code>sizeof(Apple) != sizeof(Pear)</code>  时，对  <code>aa[1]</code>  的访问就是并未跟数组中的对象的适当起始位置进行对齐的。<br>\n这里出现了类型违例，以及很可能出现的内存损坏。<br>\n决不要写这样的代码。</p>\n<p>注意， <code>maul()</code>  违反了 <a href=\"#Rf-ptr\"> <code>T*</code>  应指向独立对象的规则</a>。</p>\n<p><strong>替代方案</strong>：使用适当的（模板化）容器：</p>\n<pre><code>void maul2(Fruit* p)\n&#123;\n    *p = Pear&#123;&#125;;   // 把一个 Pear 放入 *p\n&#125;\n\nvector&lt;Apple&gt; va = &#123; an_apple, another_apple &#125;;   // va 包含的是 Apple （显然！）\n\nmaul2(va);       // 错误: 无法把 vector&lt;Apple&gt; 转换为 Fruit*\nmaul2(&amp;va[0]);   // 这是你明确要做的\n\nApple&amp; a0 = &amp;va[0];   // 是 Pear 吗？\n</code></pre>\n<p>注意， <code>maul2()</code>  中的赋值违反了<a href=\"#Res-slice\">避免发生切片的规则</a>。</p>\n<h5 id=\"强制实施-339\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-339\">#</a> 强制实施</h5>\n<ul>\n<li>对这种恐怖的东西进行检测！</li>\n</ul>\n<h3 id=\"a-namert-linearat82-当不想要虚函数时可以将类层次线性化\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-linearat82-当不想要虚函数时可以将类层次线性化\">#</a> <a name=\"Rt-linear\"></a>T.82: 当不想要虚函数时，可以将类层次线性化</h3>\n<h5 id=\"理由-371\"><a class=\"markdownIt-Anchor\" href=\"#理由-371\">#</a> 理由</h5>\n<p>???</p>\n<h5 id=\"示例-331\"><a class=\"markdownIt-Anchor\" href=\"#示例-331\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"强制实施-340\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-340\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namert-virtualat83-请勿声明虚的成员函数模板\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-virtualat83-请勿声明虚的成员函数模板\">#</a> <a name=\"Rt-virtual\"></a>T.83: 请勿声明虚的成员函数模板</h3>\n<h5 id=\"理由-372\"><a class=\"markdownIt-Anchor\" href=\"#理由-372\">#</a> 理由</h5>\n<p>C++ 是不支持这样做的。<br>\n如果支持的话，就只能等到连接时才能生成 VTBL 了。<br>\n而且一般来说，各个实现还要搞定动态连接的问题。</p>\n<h5 id=\"示例请勿如此-5\"><a class=\"markdownIt-Anchor\" href=\"#示例请勿如此-5\">#</a> 示例，请勿如此</h5>\n<pre><code>class Shape &#123;\n    // ...\n    template&lt;class T&gt;\n    virtual bool intersect(T* p);   // 错误：模板不能为虚\n&#125;;\n</code></pre>\n<h5 id=\"注解-339\"><a class=\"markdownIt-Anchor\" href=\"#注解-339\">#</a> 注解</h5>\n<p>我们保留这条规则是因为人们总是问这个问题。</p>\n<h5 id=\"替代方案-17\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-17\">#</a> 替代方案</h5>\n<p>双派发或访问器模式，或者计算出所要调用的函数。</p>\n<h5 id=\"强制实施-341\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-341\">#</a> 强制实施</h5>\n<p>编译器会处理这个问题。</p>\n<h3 id=\"a-namert-abiat84-使用非模板的核心实现来提供-abi-稳定的接口\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-abiat84-使用非模板的核心实现来提供-abi-稳定的接口\">#</a> <a name=\"Rt-abi\"></a>T.84: 使用非模板的核心实现来提供 ABI 稳定的接口</h3>\n<h5 id=\"理由-373\"><a class=\"markdownIt-Anchor\" href=\"#理由-373\">#</a> 理由</h5>\n<p>提升代码的稳定性。<br>\n避免代码爆炸。</p>\n<h5 id=\"示例-332\"><a class=\"markdownIt-Anchor\" href=\"#示例-332\">#</a> 示例</h5>\n<p>这个应当是基类：</p>\n<pre><code>struct Link_base &#123;   // 稳定\n    Link_base* suc;\n    Link_base* pre;\n&#125;;\n\ntemplate&lt;typename T&gt;   // 模板化的包装带来了类型安全性\nstruct Link : Link_base &#123;\n    T val;\n&#125;;\n\nstruct List_base &#123;\n    Link_base* first;   // 第一个元素（如果有）\n    int sz;             // 元素数量\n    void add_front(Link_base* p);\n    // ...\n&#125;;\n\ntemplate&lt;typename T&gt;\nclass List : List_base &#123;\npublic:\n    void put_front(const T&amp; e) &#123; add_front(new Link&lt;T&gt;&#123;e&#125;); &#125;   // 隐式强制转换为 Link_base\n    T&amp; front() &#123; static_cast&lt;Link&lt;T&gt;*&gt;(first).val; &#125;   // 显式强制转换回 Link&lt;T&gt;\n    // ...\n&#125;;\n\nList&lt;int&gt; li;\nList&lt;string&gt; ls;\n</code></pre>\n<p>这样的话就只有一份用于对  <code>List</code>  的元素进行入链和解链的操作的代码了。<br>\n而类  <code>Link</code>  和  <code>List</code>  除了进行类型操作之外什么也没做。</p>\n<p>除了使用一个独立的 “base” 类型外，另一种常用的技巧是对  <code>void</code>  或  <code>void*</code>  进行特化，并让针对  <code>T</code>  的通用模板成为在从或向  <code>void</code>  的核心实现进行强制转换的一层类型安全封装。</p>\n<p><strong>替代方案</strong>：使用一个 <a href=\"#Ri-pimpl\">PImpl</a> 实现。</p>\n<h5 id=\"强制实施-342\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-342\">#</a> 强制实施</h5>\n<p>???</p>\n<h2 id=\"a-namess-variadicatvar-变参模板规则\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-variadicatvar-变参模板规则\">#</a> <a name=\"SS-variadic\"></a>T.var: 变参模板规则</h2>\n<p>???</p>\n<h3 id=\"a-namert-variadicat100-当需要可以接受可变数量的多种类型参数的函数时使用变参模板\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-variadicat100-当需要可以接受可变数量的多种类型参数的函数时使用变参模板\">#</a> <a name=\"Rt-variadic\"></a>T.100: 当需要可以接受可变数量的多种类型参数的函数时，使用变参模板</h3>\n<h5 id=\"理由-374\"><a class=\"markdownIt-Anchor\" href=\"#理由-374\">#</a> 理由</h5>\n<p>变参模板是做到这点的最通用的机制，而且既高效又类型安全。请不要使用 C 的变参。</p>\n<h5 id=\"示例-333\"><a class=\"markdownIt-Anchor\" href=\"#示例-333\">#</a> 示例</h5>\n<pre><code>??? printf\n</code></pre>\n<h5 id=\"强制实施-343\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-343\">#</a> 强制实施</h5>\n<ul>\n<li>对用户代码中  <code>va_arg</code>  的使用进行标记。</li>\n</ul>\n<h3 id=\"a-namert-variadic-passat101-如何向变参模板传递参数\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-variadic-passat101-如何向变参模板传递参数\">#</a> <a name=\"Rt-variadic-pass\"></a>T.101: ??? 如何向变参模板传递参数？？？</h3>\n<h5 id=\"理由-375\"><a class=\"markdownIt-Anchor\" href=\"#理由-375\">#</a> 理由</h5>\n<p>???</p>\n<h5 id=\"示例-334\"><a class=\"markdownIt-Anchor\" href=\"#示例-334\">#</a> 示例</h5>\n<pre><code>??? 当心仅能移动参数和引用参数\n</code></pre>\n<h5 id=\"强制实施-344\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-344\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namert-variadic-processat102-如何处理变参模板的参数\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-variadic-processat102-如何处理变参模板的参数\">#</a> <a name=\"Rt-variadic-process\"></a>T.102: 如何处理变参模板的参数</h3>\n<h5 id=\"理由-376\"><a class=\"markdownIt-Anchor\" href=\"#理由-376\">#</a> 理由</h5>\n<p>???</p>\n<h5 id=\"示例-335\"><a class=\"markdownIt-Anchor\" href=\"#示例-335\">#</a> 示例</h5>\n<pre><code>??? 转发参数，类型检查，引用\n</code></pre>\n<h5 id=\"强制实施-345\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-345\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namert-variadic-notat103-请勿对同质参数列表使用变参模板\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-variadic-notat103-请勿对同质参数列表使用变参模板\">#</a> <a name=\"Rt-variadic-not\"></a>T.103: 请勿对同质参数列表使用变参模板</h3>\n<h5 id=\"理由-377\"><a class=\"markdownIt-Anchor\" href=\"#理由-377\">#</a> 理由</h5>\n<p>存在更加正规的给出同质序列的方式，比如使用  <code>initializer_list</code> 。</p>\n<h5 id=\"示例-336\"><a class=\"markdownIt-Anchor\" href=\"#示例-336\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"强制实施-346\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-346\">#</a> 强制实施</h5>\n<p>???</p>\n<h2 id=\"a-namess-metaatmeta-模板元编程tmp\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-metaatmeta-模板元编程tmp\">#</a> <a name=\"SS-meta\"></a>T.meta: 模板元编程（TMP）</h2>\n<p>模板提供了一种编译期编程的通用机制。</p>\n<p>元编程，是其中至少一项输入或者一项输出是类型的编程。<br>\n模板提供了编译期的图灵完备（除了内存消耗外）的鸭子类型系统。<br>\n其语法和所需技巧都相当可怕。</p>\n<h3 id=\"a-namert-metametaat120-仅当确实需要时才使用模板元编程\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-metametaat120-仅当确实需要时才使用模板元编程\">#</a> <a name=\"Rt-metameta\"></a>T.120: 仅当确实需要时才使用模板元编程</h3>\n<h5 id=\"理由-378\"><a class=\"markdownIt-Anchor\" href=\"#理由-378\">#</a> 理由</h5>\n<p>模板元编程很难做对，它会拖慢编译速度，而且通常很难维护。<br>\n不过，现实世界有些例子中模板元编程提供了比其他专家级的汇编代码替代方案还要更好的性能。<br>\n而且，也存在现实世界的例子用模板元编程做到比运行时代码更好地表达基本设计意图的情况。<br>\n例如，当确实需要在编译期进行 AST 操作时，（比如说对矩阵操作进行可选的折叠），C++ 中可能没有其他的实现方式。</p>\n<h5 id=\"示例不好-136\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-136\">#</a> 示例，不好</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"示例不好-137\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-137\">#</a> 示例，不好</h5>\n<pre><code>enable_if\n</code></pre>\n<p>请使用概念来替代它。不过请参见<a href=\"#Rt-emulate\">如何在没有语言支持时模拟概念</a>。</p>\n<h5 id=\"示例-337\"><a class=\"markdownIt-Anchor\" href=\"#示例-337\">#</a> 示例</h5>\n<pre><code>??? 好例子\n</code></pre>\n<p><strong>替代方案</strong>：如果结果是一个值而不是类型，请使用 <a href=\"#Rt-fct\"> <code>constexpr</code>  函数</a>。</p>\n<h5 id=\"注解-340\"><a class=\"markdownIt-Anchor\" href=\"#注解-340\">#</a> 注解</h5>\n<p>当你觉得需要把模板元编程代码隐藏到宏之中时，你可能已经跑得太远了。</p>\n<h3 id=\"a-namert-emulateat121-模板元编程主要用于模拟概念机制\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-emulateat121-模板元编程主要用于模拟概念机制\">#</a> <a name=\"Rt-emulate\"></a>T.121: 模板元编程主要用于模拟概念机制</h3>\n<h5 id=\"理由-379\"><a class=\"markdownIt-Anchor\" href=\"#理由-379\">#</a> 理由</h5>\n<p>不能使用 C++20 时，我们需要用 TMP 来模拟它。<br>\n对概念给出要求的用例（比如基于概念进行重载）是 TMP 的最常见（而且最简单）的用法。</p>\n<h5 id=\"示例-338\"><a class=\"markdownIt-Anchor\" href=\"#示例-338\">#</a> 示例</h5>\n<pre><code>template&lt;typename Iter&gt;\n    /*requires*/ enable_if&lt;random_access_iterator&lt;Iter&gt;, void&gt;\nadvance(Iter p, int n) &#123; p += n; &#125;\n\ntemplate&lt;typename Iter&gt;\n    /*requires*/ enable_if&lt;forward_iterator&lt;Iter&gt;, void&gt;\nadvance(Iter p, int n) &#123; assert(n &gt;= 0); while (n--) ++p;&#125;\n</code></pre>\n<h5 id=\"注解-341\"><a class=\"markdownIt-Anchor\" href=\"#注解-341\">#</a> 注解</h5>\n<p>这种代码使用概念时将更加简单：</p>\n<pre><code>void advance(random_access_iterator auto p, int n) &#123; p += n; &#125;\n\nvoid advance(forward_iterator auto p, int n) &#123; assert(n &gt;= 0); while (n--) ++p;&#125;\n</code></pre>\n<h5 id=\"强制实施-347\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-347\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namert-tmpat122-用模板通常为模板别名来在编译期进行类型运算\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-tmpat122-用模板通常为模板别名来在编译期进行类型运算\">#</a> <a name=\"Rt-tmp\"></a>T.122: 用模板（通常为模板别名）来在编译期进行类型运算</h3>\n<h5 id=\"理由-380\"><a class=\"markdownIt-Anchor\" href=\"#理由-380\">#</a> 理由</h5>\n<p>模板元编程是在编译期进行类型生成的受到直接支持和部分正规化的唯一方式。</p>\n<h5 id=\"注解-342\"><a class=\"markdownIt-Anchor\" href=\"#注解-342\">#</a> 注解</h5>\n<p>“特征（Trait）” 技术基本上在计算类型方面被模板别名所代替，而在计算值方面则被  <code>constexpr</code>  函数所代替。</p>\n<h5 id=\"示例-339\"><a class=\"markdownIt-Anchor\" href=\"#示例-339\">#</a> 示例</h5>\n<pre><code>??? 大型对象 / 小型对象的优化\n</code></pre>\n<h5 id=\"强制实施-348\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-348\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namert-fctat123-用-constexpr-函数来在编译期进行值运算\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-fctat123-用-constexpr-函数来在编译期进行值运算\">#</a> <a name=\"Rt-fct\"></a>T.123: 用  <code>constexpr</code>  函数来在编译期进行值运算</h3>\n<h5 id=\"理由-381\"><a class=\"markdownIt-Anchor\" href=\"#理由-381\">#</a> 理由</h5>\n<p>函数是用于表达计算一个值的最显然和传统的方式。<br>\n通常  <code>constexpr</code>  函数都比其他的替代方式具有更少的编译期开销。</p>\n<h5 id=\"注解-343\"><a class=\"markdownIt-Anchor\" href=\"#注解-343\">#</a> 注解</h5>\n<p>“特征（Trait）” 技术基本上在计算类型方面被模板别名所代替，而在计算值方面则被  <code>constexpr</code>  函数所代替。</p>\n<h5 id=\"示例-340\"><a class=\"markdownIt-Anchor\" href=\"#示例-340\">#</a> 示例</h5>\n<pre><code>template&lt;typename T&gt;\n    // requires Number&lt;T&gt;\nconstexpr T pow(T v, int n)   // 幂/指数\n&#123;\n    T res = 1;\n    while (n--) res *= v;\n    return res;\n&#125;\n\nconstexpr auto f7 = pow(pi, 7);\n</code></pre>\n<h5 id=\"强制实施-349\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-349\">#</a> 强制实施</h5>\n<ul>\n<li>对产生值的模板元程序进行标记。它们应当被替换成  <code>constexpr</code>  函数。</li>\n</ul>\n<h3 id=\"a-namert-std-tmpat124-优先使用标准库的模板元编程设施\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-std-tmpat124-优先使用标准库的模板元编程设施\">#</a> <a name=\"Rt-std-tmp\"></a>T.124: 优先使用标准库的模板元编程设施</h3>\n<h5 id=\"理由-382\"><a class=\"markdownIt-Anchor\" href=\"#理由-382\">#</a> 理由</h5>\n<p>标准中所定义的设施，诸如  <code>conditional</code> ， <code>enable_if</code> ，以及  <code>tuple</code>  等，是可移植的，可以假定为大家所了解。</p>\n<h5 id=\"示例-341\"><a class=\"markdownIt-Anchor\" href=\"#示例-341\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"强制实施-350\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-350\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namert-libat125-当需要标准库之外的模板元编程设施时使用某个现存程序库\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-libat125-当需要标准库之外的模板元编程设施时使用某个现存程序库\">#</a> <a name=\"Rt-lib\"></a>T.125: 当需要标准库之外的模板元编程设施时，使用某个现存程序库</h3>\n<h5 id=\"理由-383\"><a class=\"markdownIt-Anchor\" href=\"#理由-383\">#</a> 理由</h5>\n<p>要搞出高级的 TMP 设施是很难的，而使用一个库则可让你进入某个（有希望收到支持的）社区。<br>\n只有当确实不得不编写自己的 “高级 TMP 支持” 时，才应当这样做。</p>\n<h5 id=\"示例-342\"><a class=\"markdownIt-Anchor\" href=\"#示例-342\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"强制实施-351\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-351\">#</a> 强制实施</h5>\n<p>???</p>\n<h2 id=\"a-namess-temp-othera其他模板规则\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-temp-othera其他模板规则\">#</a> <a name=\"SS-temp-other\"></a>其他模板规则</h2>\n<h3 id=\"a-namert-nameat140-若操作可被重用则应为其命名\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-nameat140-若操作可被重用则应为其命名\">#</a> <a name=\"Rt-name\"></a>T.140: 若操作可被重用，则应为其命名</h3>\n<p>参见 <a href=\"#Rf-name\">F.10</a></p>\n<h3 id=\"a-namert-lambdaat141-当仅在一个地方需要一个简单的函数对象时使用无名的-lambda\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-lambdaat141-当仅在一个地方需要一个简单的函数对象时使用无名的-lambda\">#</a> <a name=\"Rt-lambda\"></a>T.141: 当仅在一个地方需要一个简单的函数对象时，使用无名的 lambda</h3>\n<p>参见 <a href=\"#Rf-lambda\">F.11</a></p>\n<h3 id=\"a-namert-varat142-使用模板变量以简化写法\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-varat142-使用模板变量以简化写法\">#</a> <a name=\"Rt-var\"></a>T.142?: 使用模板变量以简化写法</h3>\n<h5 id=\"理由-384\"><a class=\"markdownIt-Anchor\" href=\"#理由-384\">#</a> 理由</h5>\n<p>改善可读性。</p>\n<h5 id=\"示例-343\"><a class=\"markdownIt-Anchor\" href=\"#示例-343\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"强制实施-352\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-352\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namert-nongenericat143-请勿编写并非有意非泛型的代码\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-nongenericat143-请勿编写并非有意非泛型的代码\">#</a> <a name=\"Rt-nongeneric\"></a>T.143: 请勿编写并非有意非泛型的代码</h3>\n<h5 id=\"理由-385\"><a class=\"markdownIt-Anchor\" href=\"#理由-385\">#</a> 理由</h5>\n<p>一般性。可重用性。请勿无必要地陷入技术细节之中；请使用最广泛可用的设施。</p>\n<h5 id=\"示例-344\"><a class=\"markdownIt-Anchor\" href=\"#示例-344\">#</a> 示例</h5>\n<p>用  <code>!=</code>  而不是  <code>&lt;</code>  来比较迭代器； <code>!=</code>  可以在更多对象上正常工作，因为它并未蕴含有序性。</p>\n<pre><code>for (auto i = first; i &lt; last; ++i) &#123;   // 通用性较差\n    // ...\n&#125;\n\nfor (auto i = first; i != last; ++i) &#123;   // 好; 通用性较强\n    // ...\n&#125;\n</code></pre>\n<p>当然，范围式  <code>for</code>  在符合需求的时候当然是更好的选择。</p>\n<h5 id=\"示例-345\"><a class=\"markdownIt-Anchor\" href=\"#示例-345\">#</a> 示例</h5>\n<p>使用能够提供所需功能的最接近基类的类。</p>\n<pre><code>class Base &#123;\npublic:\n    Bar f();\n    Bar g();\n&#125;;\n\nclass Derived1 : public Base &#123;\npublic:\n    Bar h();\n&#125;;\n\nclass Derived2 : public Dase &#123;\npublic:\n    Bar j();\n&#125;;\n\n// 不好，除非确实有特别的原因来将之仅限制为 Derived1 对象\nvoid my_func(Derived1&amp; param)\n&#123;\n    use(param.f());\n    use(param.g());\n&#125;\n\n// 好，仅使用 Base 的接口，且保证了这个类型\nvoid my_func(Base&amp; param)\n&#123;\n    use(param.f());\n    use(param.g());\n&#125;\n</code></pre>\n<h5 id=\"强制实施-353\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-353\">#</a> 强制实施</h5>\n<ul>\n<li>对使用  <code>&lt;</code>  而不是  <code>!=</code>  的迭代器比较进行标记。</li>\n<li>当存在  <code>x.empty()</code>  或  <code>x.is_empty()</code>  时，对  <code>x.size() == 0</code>  进行标记。 <code>empty()</code>  比  <code>size()</code>  能够对于更多的容器工作，因为某些容器是不知道自己的大小的，甚至概念上就是大小无界的。</li>\n<li>如果函数接受指向更加派生的类型的指针或引用，但仅使用了在某个基类中所声明的函数，则对其进行标记。</li>\n</ul>\n<h3 id=\"a-namert-specialize-functionat144-请勿特化函数模板\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-specialize-functionat144-请勿特化函数模板\">#</a> <a name=\"Rt-specialize-function\"></a>T.144: 请勿特化函数模板</h3>\n<h5 id=\"理由-386\"><a class=\"markdownIt-Anchor\" href=\"#理由-386\">#</a> 理由</h5>\n<p>根据语言规则，函数模板是无法被部分特化的。函数模板可以被完全特化，不过你基本上需要的都是进行重载而不是特化 —— 因为函数模板特化并不参与重载，它们的行为和你想要的可能是不同的。少数情况下，应当通过你可以进行适当特化的类模板来进行真正的特化。</p>\n<h5 id=\"示例-346\"><a class=\"markdownIt-Anchor\" href=\"#示例-346\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<p><strong>例外</strong>：当确实有特化函数模板的恰当理由时，请只编写一个函数模板，并使它委派给一个类模板，然后对这个类模板进行特化（这提供了编写部分特化的能力）。</p>\n<h5 id=\"强制实施-354\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-354\">#</a> 强制实施</h5>\n<ul>\n<li>标记出所有的函数模板特化。代之以函数重载。</li>\n</ul>\n<h3 id=\"a-namert-check-classat150-用-static_assert-来检查类是否与概念相符\"><a class=\"markdownIt-Anchor\" href=\"#a-namert-check-classat150-用-static_assert-来检查类是否与概念相符\">#</a> <a name=\"Rt-check-class\"></a>T.150: 用  <code>static_assert</code>  来检查类是否与概念相符</h3>\n<h5 id=\"理由-387\"><a class=\"markdownIt-Anchor\" href=\"#理由-387\">#</a> 理由</h5>\n<p>当你打算使一个类符合某个概念时，应该提早进行验证以减少麻烦。</p>\n<h5 id=\"示例-347\"><a class=\"markdownIt-Anchor\" href=\"#示例-347\">#</a> 示例</h5>\n<pre><code>class X &#123;\npublic:\n    X() = delete;\n    X(const X&amp;) = default;\n    X(X&amp;&amp;) = default;\n    X&amp; operator=(const X&amp;) = default;\n    // ...\n&#125;;\n</code></pre>\n<p>在别的地方，也许是某个实现文件中，可以让编译器来检查  <code>X</code>  的所需各项性质：</p>\n<pre><code>static_assert(Default_constructible&lt;X&gt;);    // 错误: X 没有默认构造函数\nstatic_assert(Copyable&lt;X&gt;);                 // 错误: 忘记定义 X 的移动构造函数了\n</code></pre>\n<h5 id=\"强制实施-355\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-355\">#</a> 强制实施</h5>\n<p>不可行。</p>\n<h1 id=\"a-names-cplacpl-c-风格的编程\"><a class=\"markdownIt-Anchor\" href=\"#a-names-cplacpl-c-风格的编程\">#</a> <a name=\"S-cpl\"></a>CPL: C 风格的编程</h1>\n<p>C 和 C++ 是联系很紧密的两门语言。<br>\n它们都是源于 1978 年的 “经典 C” 语言的，且从此之后就在 ISO 标准委员会中进行演化。<br>\n为了让它们保持兼容，我们做过许多努力，但它们各自都并非是对方的子集。</p>\n<p>C 规则概览：</p>\n<ul>\n<li><a href=\"#Rcpl-C\">CPL.1: 优先使用 C++ 而不是 C</a></li>\n<li><a href=\"#Rcpl-subset\">CPL.2: 当一定要用 C 时，应使用 C 和 C++ 的公共子集，并将 C 代码以 C++ 来编译</a></li>\n<li><a href=\"#Rcpl-interface\">CPL.3: 当一定要用 C 来作为接口时，应在使用这些接口的调用方代码中使用 C++</a></li>\n</ul>\n<h3 id=\"a-namercpl-cacpl1-优先使用-c-而不是-c\"><a class=\"markdownIt-Anchor\" href=\"#a-namercpl-cacpl1-优先使用-c-而不是-c\">#</a> <a name=\"Rcpl-C\"></a>CPL.1: 优先使用 C++ 而不是 C</h3>\n<h5 id=\"理由-388\"><a class=\"markdownIt-Anchor\" href=\"#理由-388\">#</a> 理由</h5>\n<p>C++ 提供更好的类型检查和更多的语法支持。<br>\n它能为高层的编程提供更好的支持，而且通常会产生更快速的代码。</p>\n<h5 id=\"示例-348\"><a class=\"markdownIt-Anchor\" href=\"#示例-348\">#</a> 示例</h5>\n<pre><code>char ch = 7;\nvoid* pv = &amp;ch;\nint* pi = pv;   // 非 C++\n*pi = 999;      // 覆盖了 &amp;ch 附近的 sizeof(int) 个字节\n</code></pre>\n<p>针对在 C 中从  <code>void*</code>  或向它进行的隐式强制转换的相关规则比较麻烦而且并未强制实施。<br>\n特别是，这个例子违反了禁止把类型转换为具有更严格对齐的类型的规则。</p>\n<h5 id=\"强制实施-356\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-356\">#</a> 强制实施</h5>\n<p>使用 C++ 编译器。</p>\n<h3 id=\"a-namercpl-subsetacpl2-当一定要用-c-时应使用-c-和-c-的公共子集并将-c-代码以-c-来编译\"><a class=\"markdownIt-Anchor\" href=\"#a-namercpl-subsetacpl2-当一定要用-c-时应使用-c-和-c-的公共子集并将-c-代码以-c-来编译\">#</a> <a name=\"Rcpl-subset\"></a>CPL.2: 当一定要用 C 时，应使用 C 和 C++ 的公共子集，并将 C 代码以 C++ 来编译</h3>\n<h5 id=\"理由-389\"><a class=\"markdownIt-Anchor\" href=\"#理由-389\">#</a> 理由</h5>\n<p>它们的子集语言，C 和 C++ 编译器都可以编译，而当作为 C++ 编译时，比 “纯 C” 进行更好的类型检查。</p>\n<h5 id=\"示例-349\"><a class=\"markdownIt-Anchor\" href=\"#示例-349\">#</a> 示例</h5>\n<pre><code>int* p1 = malloc(10 * sizeof(int));                      // 非 C++\nint* p2 = static_cast&lt;int*&gt;(malloc(10 * sizeof(int)));   // 非 C, C 风格的 C++\nint* p3 = new int[10];                                   // 非 C\nint* p4 = (int*) malloc(10 * sizeof(int));               // C 和 C++ 均可\n</code></pre>\n<h5 id=\"强制实施-357\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-357\">#</a> 强制实施</h5>\n<ul>\n<li>\n<p>当使用某种将代码作为 C 来编译的构建模式时进行标记。</p>\n<ul>\n<li>C++ 将会确保代码是合法的 C++ 代码，除非使用了 C 扩展的编译器选项。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"a-namercpl-interfaceacpl3-当一定要用-c-来作为接口时应在使用这些接口的代码中使用-c\"><a class=\"markdownIt-Anchor\" href=\"#a-namercpl-interfaceacpl3-当一定要用-c-来作为接口时应在使用这些接口的代码中使用-c\">#</a> <a name=\"Rcpl-interface\"></a>CPL.3: 当一定要用 C 来作为接口时，应在使用这些接口的代码中使用 C++</h3>\n<h5 id=\"理由-390\"><a class=\"markdownIt-Anchor\" href=\"#理由-390\">#</a> 理由</h5>\n<p>C++ 比 C 的表达能力更强，而且为许多种类的编程都提供了更好的支持。</p>\n<h5 id=\"示例-350\"><a class=\"markdownIt-Anchor\" href=\"#示例-350\">#</a> 示例</h5>\n<p>例如，为使用第三方 C 程序库或者 C 系统接口，可以使用 C 和 C++ 的公共子集来定义其底层接口，以获得更好的类型检查。<br>\n尽可能将底层接口封装到一个遵循了 C++ 指导方针的接口之中（以获得更好的抽象、内存安全性和资源安全性），并在 C++ 代码中使用这个 C++ 接口。</p>\n<h5 id=\"示例-351\"><a class=\"markdownIt-Anchor\" href=\"#示例-351\">#</a> 示例</h5>\n<p>在 C++ 中可以调用 C：</p>\n<pre><code>// C 中:\ndouble sqrt(double);\n\n// C++ 中:\nextern &quot;C&quot; double sqrt(double);\n\nsqrt(2);\n</code></pre>\n<h5 id=\"示例-352\"><a class=\"markdownIt-Anchor\" href=\"#示例-352\">#</a> 示例</h5>\n<p>在 C 中可以调用 C++：</p>\n<pre><code>// C 中:\nX call_f(struct Y*, int);\n\n// C++ 中:\nextern &quot;C&quot; X call_f(Y* p, int i)\n&#123;\n    return p-&gt;f(i);   // 可能是虚函数调用\n&#125;\n</code></pre>\n<h5 id=\"强制实施-358\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-358\">#</a> 强制实施</h5>\n<p>不需要做什么。</p>\n<h1 id=\"a-names-sourceasf-源文件\"><a class=\"markdownIt-Anchor\" href=\"#a-names-sourceasf-源文件\">#</a> <a name=\"S-source\"></a>SF: 源文件</h1>\n<p>区分声明（用作接口）和定义（用作实现）。<br>\n用头文件来表达接口并强调逻辑结构。</p>\n<p>源文件规则概览：</p>\n<ul>\n<li>\n<p><a href=\"#Rs-file-suffix\">SF.1: 如果你的项目还未采用别的约定的话，应当为代码文件使用后缀  <code>.cpp</code> ，而对接口文件使用后缀  <code>.h</code> </a></p>\n</li>\n<li>\n<p><a href=\"#Rs-inline\">SF.2: 头文件不能含有对象定义或非内联的函数定义</a></p>\n</li>\n<li>\n<p><a href=\"#Rs-declaration-header\">SF.3: 对在多个源文件中使用的任何声明，都应使用头文件</a></p>\n</li>\n<li>\n<p><a href=\"#Rs-include-order\">SF.4: 在文件中的其他所有声明之前包含头文件</a></p>\n</li>\n<li>\n<p><a href=\"#Rs-consistency\">SF.5:  <code>.cpp</code>  文件必须包含定义了它的接口的一个或多个头文件</a></p>\n</li>\n<li>\n<p><a href=\"#Rs-using\">SF.6:  <code>using namespace</code>  指令，（仅）可以为迁移而使用，可以为基础程序库使用（比如  <code>std</code> ），或者在局部作用域中使用</a></p>\n</li>\n<li>\n<p><a href=\"#Rs-using-directive\">SF.7: 请勿在头文件中的全局作用域使用  <code>using namespace</code>  指令</a></p>\n</li>\n<li>\n<p><a href=\"#Rs-guards\">SF.8: 为所有的头文件使用  <code>#include</code>  防卫宏</a></p>\n</li>\n<li>\n<p><a href=\"#Rs-cycles\">SF.9: 避免源文件的循环依赖</a></p>\n</li>\n<li>\n<p><a href=\"#Rs-implicit\">SF.10: 避免依赖于隐含地  <code>#include</code>  进来的名字</a></p>\n</li>\n<li>\n<p><a href=\"#Rs-contained\">SF.11: 头文件应当是自包含的</a></p>\n</li>\n<li>\n<p><a href=\"#Rs-incform\">SF.12: 对相对于包含文件的文件优先采用引号形式的  <code>#include</code> ，其他情况下采用角括号形式</a></p>\n</li>\n<li>\n<p><a href=\"#Rs-namespace\">SF.20: 用  <code>namespace</code>  表示逻辑结构</a></p>\n</li>\n<li>\n<p><a href=\"#Rs-unnamed\">SF.21: 请勿在头文件中使用无名（匿名）命名空间</a></p>\n</li>\n<li>\n<p><a href=\"#Rs-unnamed2\">SF.22: 为所有的内部 / 不导出的实体使用无名（匿名）命名空间</a></p>\n</li>\n</ul>\n<h3 id=\"a-namers-file-suffixasf1-如果你的项目还未采用别的约定的话应当为代码文件使用后缀-cpp而对接口文件使用后缀-h\"><a class=\"markdownIt-Anchor\" href=\"#a-namers-file-suffixasf1-如果你的项目还未采用别的约定的话应当为代码文件使用后缀-cpp而对接口文件使用后缀-h\">#</a> <a name=\"Rs-file-suffix\"></a>SF.1: 如果你的项目还未采用别的约定的话，应当为代码文件使用后缀  <code>.cpp</code> ，而对接口文件使用后缀  <code>.h</code></h3>\n<p>参见 <a href=\"#Rl-file-suffix\">NL.27</a></p>\n<h3 id=\"a-namers-inlineasf2-头文件不能含有对象定义或非内联的函数定义\"><a class=\"markdownIt-Anchor\" href=\"#a-namers-inlineasf2-头文件不能含有对象定义或非内联的函数定义\">#</a> <a name=\"Rs-inline\"></a>SF.2: 头文件不能含有对象定义或非内联的函数定义</h3>\n<h5 id=\"理由-391\"><a class=\"markdownIt-Anchor\" href=\"#理由-391\">#</a> 理由</h5>\n<p>对受制于唯一定义规则的实体的包含将导致连接错误。</p>\n<h5 id=\"示例-353\"><a class=\"markdownIt-Anchor\" href=\"#示例-353\">#</a> 示例</h5>\n<pre><code>// file.h:\nnamespace Foo &#123;\n    int x = 7;\n    int xx() &#123; return x+x; &#125;\n&#125;\n\n// file1.cpp:\n#include &lt;file.h&gt;\n// ... 更多代码 ...\n\n // file2.cpp:\n#include &lt;file.h&gt;\n// ... 更多代码 ...\n</code></pre>\n<p>当连接  <code>file1.cpp</code>  和  <code>file2.cpp</code>  时将出现两个连接器错误。</p>\n<p><strong>其他形式</strong>：头文件必须仅包含：</p>\n<ul>\n<li><code>#include</code>  其他的头文件（可能包括包含防卫宏）</li>\n<li>模板</li>\n<li>类定义</li>\n<li>函数声明</li>\n<li><code>extern</code>  声明</li>\n<li><code>inline</code>  函数定义</li>\n<li><code>constexpr</code>  定义</li>\n<li><code>const</code>  定义</li>\n<li><code>using</code>  别名定义</li>\n<li>???</li>\n</ul>\n<h5 id=\"强制实施-359\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-359\">#</a> 强制实施</h5>\n<p>根据以上白名单来检查。</p>\n<h3 id=\"a-namers-declaration-headerasf3-对在多个源文件中使用的任何声明都应使用头文件\"><a class=\"markdownIt-Anchor\" href=\"#a-namers-declaration-headerasf3-对在多个源文件中使用的任何声明都应使用头文件\">#</a> <a name=\"Rs-declaration-header\"></a>SF.3: 对在多个源文件中使用的任何声明，都应使用头文件</h3>\n<h5 id=\"理由-392\"><a class=\"markdownIt-Anchor\" href=\"#理由-392\">#</a> 理由</h5>\n<p>可维护性。可读性。</p>\n<h5 id=\"示例不好-138\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-138\">#</a> 示例，不好</h5>\n<pre><code>// bar.cpp:\nvoid bar() &#123; cout &lt;&lt; &quot;bar\\n&quot;; &#125;\n\n// foo.cpp:\nextern void bar();\nvoid foo() &#123; bar(); &#125;\n</code></pre>\n<p><code>bar</code>  的维护者在需要改变  <code>bar</code>  的类型时，无法找到其全部声明。<br>\n <code>bar</code>  的使用者不知道他所使用的接口是否完整和正确。顶多会从连接器获得一些（延迟的）错误消息。</p>\n<h5 id=\"强制实施-360\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-360\">#</a> 强制实施</h5>\n<ul>\n<li>对并未放入  <code>.h</code>  而在其他源文件中的实体声明进行标记。</li>\n</ul>\n<h3 id=\"a-namers-include-orderasf4-在文件中的其他所有声明之前包含头文件\"><a class=\"markdownIt-Anchor\" href=\"#a-namers-include-orderasf4-在文件中的其他所有声明之前包含头文件\">#</a> <a name=\"Rs-include-order\"></a>SF.4: 在文件中的其他所有声明之前包含头文件</h3>\n<h5 id=\"理由-393\"><a class=\"markdownIt-Anchor\" href=\"#理由-393\">#</a> 理由</h5>\n<p>最小化上下文的依赖并增加可读性。</p>\n<h5 id=\"示例-354\"><a class=\"markdownIt-Anchor\" href=\"#示例-354\">#</a> 示例</h5>\n<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;string&gt;\n\n// ... 我自己的代码 ...\n</code></pre>\n<h5 id=\"示例不好-139\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-139\">#</a> 示例，不好</h5>\n<pre><code>#include &lt;vector&gt;\n\n// ... 我自己的代码 ...\n\n#include &lt;algorithm&gt;\n#include &lt;string&gt;\n</code></pre>\n<h5 id=\"注解-344\"><a class=\"markdownIt-Anchor\" href=\"#注解-344\">#</a> 注解</h5>\n<p>这对于  <code>.h</code>  和  <code>.cpp</code>  文件都同样适用。</p>\n<h5 id=\"注解-345\"><a class=\"markdownIt-Anchor\" href=\"#注解-345\">#</a> 注解</h5>\n<p>有一种论点是通过在打算保护的代码的<em>后面</em>再  <code>#include</code>  头文件，以此将代码同头文件中的声明式和宏等之间进行隔离<br>\n（如上面例子中标为 “不好” 之处）。<br>\n不过，</p>\n<ul>\n<li>这只能对单个文件（在单个层次上）工作：如果采用这个技巧的头文件被别的头文件所包含，这个威胁就会再次出现。</li>\n<li>命名空间（一个 “实现命名空间”）可以针对许多的上下文依赖进行保护。</li>\n<li>完全的保护和灵活性需要模块。</li>\n</ul>\n<p><strong>参见</strong>：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcGVuLXN0ZC5vcmcvanRjMS9zYzIyL3dnMjEvZG9jcy9wYXBlcnMvMjAxNi9uNDU5Mi5wZGY=\">工作草案，C++ 的模块扩展</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcGVuLXN0ZC5vcmcvanRjMS9zYzIyL3dnMjEvZG9jcy9wYXBlcnMvMjAxNi9wMDE0MXIwLnBkZg==\">模块，组件化及其迁移</span></li>\n</ul>\n<h5 id=\"强制实施-361\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-361\">#</a> 强制实施</h5>\n<p>容易。</p>\n<h3 id=\"a-namers-consistencyasf5-cpp-文件必须包含定义了它的接口的一个或多个头文件\"><a class=\"markdownIt-Anchor\" href=\"#a-namers-consistencyasf5-cpp-文件必须包含定义了它的接口的一个或多个头文件\">#</a> <a name=\"Rs-consistency\"></a>SF.5:  <code>.cpp</code>  文件必须包含定义了它的接口的一个或多个头文件</h3>\n<h5 id=\"理由-394\"><a class=\"markdownIt-Anchor\" href=\"#理由-394\">#</a> 理由</h5>\n<p>这使得编译器可以提早进行一致性检查。</p>\n<h5 id=\"示例不好-140\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-140\">#</a> 示例，不好</h5>\n<pre><code>// foo.h:\nvoid foo(int);\nint bar(long);\nint foobar(int);\n\n// foo.cpp:\nvoid foo(int) &#123; /* ... */ &#125;\nint bar(double) &#123; /* ... */ &#125;\ndouble foobar(int);\n</code></pre>\n<p>这个错误直到调用了  <code>bar</code>  或  <code>foobar</code>  的程序的连接时才会被发现。</p>\n<h5 id=\"示例-355\"><a class=\"markdownIt-Anchor\" href=\"#示例-355\">#</a> 示例</h5>\n<pre><code>// foo.h:\nvoid foo(int);\nint bar(long);\nint foobar(int);\n\n// foo.cpp:\n#include &quot;foo.h&quot;\n\nvoid foo(int) &#123; /* ... */ &#125;\nint bar(double) &#123; /* ... */ &#125;\ndouble foobar(int);   // 错误: 错误的返回类型\n</code></pre>\n<p><code>foobar</code>  的返回类型错误在编译  <code>foo.cpp</code>  时立即就被发现了。<br>\n对  <code>bar</code>  的参数类型错误在连接时之前无法被发现，因为可能会有重载发生，但系统性地使用  <code>.h</code>  文件能够增加时其被程序员更早发现的可能性。</p>\n<h5 id=\"强制实施-362\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-362\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namers-usingasf6-using-namespace-指令仅可以为迁移而使用可以为基础程序库使用比如-std或者在局部作用域中使用\"><a class=\"markdownIt-Anchor\" href=\"#a-namers-usingasf6-using-namespace-指令仅可以为迁移而使用可以为基础程序库使用比如-std或者在局部作用域中使用\">#</a> <a name=\"Rs-using\"></a>SF.6:  <code>using namespace</code>  指令，（仅）可以为迁移而使用，可以为基础程序库使用（比如  <code>std</code> ），或者在局部作用域中使用</h3>\n<h5 id=\"理由-395\"><a class=\"markdownIt-Anchor\" href=\"#理由-395\">#</a> 理由</h5>\n<p><code>using namespace</code>  可能造成名字冲突，因而应当节制使用。<br>\n然而，将用户代码中的每个命名空间中的名字都进行限定并不总是能够做到（比如在转换过程中）<br>\n而且有时候命名空间非常基础，并且在代码库中广为使用，坚持进行限定将使其既啰嗦又分散注意力。</p>\n<h5 id=\"示例-356\"><a class=\"markdownIt-Anchor\" href=\"#示例-356\">#</a> 示例</h5>\n<pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\n// ...\n</code></pre>\n<p>显然地，大量使用了标准库，而且貌似没使用别的程序库，因此要求每一处带有使用  <code>std::</code> <br>\n 会使人分散注意力。</p>\n<h5 id=\"示例-357\"><a class=\"markdownIt-Anchor\" href=\"#示例-357\">#</a> 示例</h5>\n<p>使用  <code>using namespace std;</code>  导致程序员可能面临与标准库中的名字造成名字冲突</p>\n<pre><code>#include &lt;cmath&gt;\nusing namespace std;\n\nint g(int x)\n&#123;\n    int sqrt = 7;\n    // ...\n    return sqrt(x); // 错误\n&#125;\n</code></pre>\n<p>不过，不大可能导致并非错误的名字解析，<br>\n假定使用  <code>using namespace std</code>  的人们都了解  <code>std</code>  以及这种风险。</p>\n<h5 id=\"注解-346\"><a class=\"markdownIt-Anchor\" href=\"#注解-346\">#</a> 注解</h5>\n<p><code>.cpp</code>  文件也是一种形式的局部作用域。<br>\n包含一条  <code>using namespace X</code>  的 N 行的  <code>.cpp</code>  文件中发生名字冲突的机会，<br>\n和包含一条  <code>using namespace X</code>  的 N 行的函数，<br>\n以及每个都包含一条  <code>using namespace X</code>  的总行数为 N 行的 M 个函数，没有多少差别。</p>\n<h5 id=\"注解-347\"><a class=\"markdownIt-Anchor\" href=\"#注解-347\">#</a> 注解</h5>\n<p><a href=\"#Rs-using-directive\">请勿在头文件全局作用域中使用  <code>using namespace</code> </a>。</p>\n<h5 id=\"强制实施-363\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-363\">#</a> 强制实施</h5>\n<p>对于单个源文件中，对不同命名空间的多个  <code>using namespace</code>  指令进行标记。</p>\n<h3 id=\"a-namers-using-directiveasf7-请勿在头文件中的全局作用域使用-using-namespace\"><a class=\"markdownIt-Anchor\" href=\"#a-namers-using-directiveasf7-请勿在头文件中的全局作用域使用-using-namespace\">#</a> <a name=\"Rs-using-directive\"></a>SF.7: 请勿在头文件中的全局作用域使用  <code>using namespace</code></h3>\n<h5 id=\"理由-396\"><a class=\"markdownIt-Anchor\" href=\"#理由-396\">#</a> 理由</h5>\n<p>这样做使  <code>#include</code>  一方无法有效地进行区分并使用其他方式。这还可能使所  <code>#include</code>  的头文件之间出现顺序依赖，它们以不同次序包含时可能具有不同的意义。</p>\n<h5 id=\"示例-358\"><a class=\"markdownIt-Anchor\" href=\"#示例-358\">#</a> 示例</h5>\n<pre><code>// bad.h\n#include &lt;iostream&gt;\nusing namespace std; // bad\n\n// user.cpp\n#include &quot;bad.h&quot;\n\nbool copy(/*... some parameters ...*/);    // some function that happens to be named copy\n\nint main()\n&#123;\n    copy(/*...*/);    // now overloads local ::copy and std::copy, could be ambiguous\n&#125;\n</code></pre>\n<h5 id=\"注解-348\"><a class=\"markdownIt-Anchor\" href=\"#注解-348\">#</a> 注解</h5>\n<p>一个例外是  <code>using namespace std::literals;</code> 。若要在头文件中使用<br>\n字符串字面量，则必须如此，而且根据<span class=\"exturl\" data-url=\"aHR0cDovL2VlbC5pcy9jKytkcmFmdC9vdmVyLmxpdGVyYWw=\">规则</span> —— 用户必须以<br>\n <code>operator&quot;&quot;_x</code>  来命名他们自己的 UDL—— 它们并不会与标准库相冲突。</p>\n<h5 id=\"强制实施-364\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-364\">#</a> 强制实施</h5>\n<p>标记头文件的全局作用域中的  <code>using namespace</code> 。</p>\n<h3 id=\"a-namers-guardsasf8-为所有的头文件使用-include-防卫宏\"><a class=\"markdownIt-Anchor\" href=\"#a-namers-guardsasf8-为所有的头文件使用-include-防卫宏\">#</a> <a name=\"Rs-guards\"></a>SF.8: 为所有的头文件使用  <code>#include</code>  防卫宏</h3>\n<h5 id=\"理由-397\"><a class=\"markdownIt-Anchor\" href=\"#理由-397\">#</a> 理由</h5>\n<p>避免文件被多次  <code>#include</code> 。</p>\n<p>为避免包含防卫宏的冲突，不要仅使用文件名来命名防卫宏。<br>\n确保还要包含一个关键词和好的区分词，比如头文件所属的程序库<br>\n或组件的名字。</p>\n<h5 id=\"示例-359\"><a class=\"markdownIt-Anchor\" href=\"#示例-359\">#</a> 示例</h5>\n<pre><code>// file foobar.h:\n#ifndef LIBRARY_FOOBAR_H\n#define LIBRARY_FOOBAR_H\n// ... 声明 ...\n#endif // LIBRARY_FOOBAR_H\n</code></pre>\n<h5 id=\"强制实施-365\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-365\">#</a> 强制实施</h5>\n<p>标记没有  <code>#include</code>  防卫的  <code>.h</code>  文件。</p>\n<h5 id=\"注解-349\"><a class=\"markdownIt-Anchor\" href=\"#注解-349\">#</a> 注解</h5>\n<p>一些实现提供了如  <code>#pragma once</code>  这样的厂商扩展作为包含防卫宏的替代。<br>\n这并非标准且不可移植。它向程序中注入了宿主机器的文件系统的语义，<br>\n而且把你锁定到某个特定厂商。<br>\n我们的建议是编写 ISO C++：参见<a href=\"#Rp-Cplusplus\">规则 P.2</a>。</p>\n<h3 id=\"a-namers-cyclesasf9-避免源文件的循环依赖\"><a class=\"markdownIt-Anchor\" href=\"#a-namers-cyclesasf9-避免源文件的循环依赖\">#</a> <a name=\"Rs-cycles\"></a>SF.9: 避免源文件的循环依赖</h3>\n<h5 id=\"理由-398\"><a class=\"markdownIt-Anchor\" href=\"#理由-398\">#</a> 理由</h5>\n<p>循环会使理解变得困难，并拖慢编译速度。<br>\n它们还会使（当其可用时）向利用语言支持的模块进行转换工作变得复杂。</p>\n<h5 id=\"注解-350\"><a class=\"markdownIt-Anchor\" href=\"#注解-350\">#</a> 注解</h5>\n<p>要消除循环依赖；请勿仅仅用  <code>#include</code>  防卫宏来试图打破它们。</p>\n<h5 id=\"示例不好-141\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-141\">#</a> 示例，不好</h5>\n<pre><code>// file1.h:\n#include &quot;file2.h&quot;\n\n// file2.h:\n#include &quot;file3.h&quot;\n\n// file3.h:\n#include &quot;file1.h&quot;\n</code></pre>\n<h5 id=\"强制实施-366\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-366\">#</a> 强制实施</h5>\n<p>对任何循环依赖进行标记。</p>\n<h3 id=\"a-namers-implicitasf10-避免依赖于隐含地-include-进来的名字\"><a class=\"markdownIt-Anchor\" href=\"#a-namers-implicitasf10-避免依赖于隐含地-include-进来的名字\">#</a> <a name=\"Rs-implicit\"></a>SF.10: 避免依赖于隐含地  <code>#include</code>  进来的名字</h3>\n<h5 id=\"理由-399\"><a class=\"markdownIt-Anchor\" href=\"#理由-399\">#</a> 理由</h5>\n<p>避免意外。<br>\n避免当  <code>#include</code>  的头文件改变时改变一条  <code>#include</code> 。<br>\n避免意外地变为依赖于所包含的头文件中的实现细节和逻辑上独立的实体。</p>\n<h5 id=\"示例不好-142\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-142\">#</a> 示例，不好</h5>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid use()\n&#123;\n    string s;\n    cin &gt;&gt; s;               // 好\n    getline(cin, s);        // 错误：getline() 未定义\n    if (s == &quot;surprise&quot;) &#123;  // 错误：== 未定义\n        // ...\n    &#125;\n&#125;\n</code></pre>\n<p><code>&lt;iostream&gt;</code>  暴露了  <code>std::string</code>  的定义（“为什么？” 是一个有趣的问题），<br>\n但其并不必然是通过传递包含整个  <code>&lt;string&gt;</code>  头文件而做到这一点的，<br>\n这带来了常见的新手问题 “为什么  <code>getline(cin,s);</code>  不成？”，<br>\n甚至偶尔出现的 “ <code>string</code>  无法用  <code>==</code>  来比较”。</p>\n<p>其解决方案是明确地  <code>#include &lt;string&gt;</code> ：</p>\n<h5 id=\"示例好-28\"><a class=\"markdownIt-Anchor\" href=\"#示例好-28\">#</a> 示例，好</h5>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nvoid use()\n&#123;\n    string s;\n    cin &gt;&gt; s;               // 好\n    getline(cin, s);        // 好\n    if (s == &quot;surprise&quot;) &#123;  // 好\n        // ...\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"注解-351\"><a class=\"markdownIt-Anchor\" href=\"#注解-351\">#</a> 注解</h5>\n<p>一些头文件正是用于从一些头文件中合并一组声明。<br>\n例如：</p>\n<pre><code>// basic_std_lib.h:\n\n#include &lt;string&gt;\n#include &lt;map&gt;\n#include &lt;iostream&gt;\n#include &lt;random&gt;\n#include &lt;vector&gt;\n</code></pre>\n<p>用户只用一条  <code>#include</code>  就可以获得整组的声明了：</p>\n<pre><code>#include &quot;basic_std_lib.h&quot;\n</code></pre>\n<p>本条反对隐式包含的规则并不防止这种特意的聚集包含。</p>\n<h5 id=\"强制实施-367\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-367\">#</a> 强制实施</h5>\n<p>强制实施将需要一些有关头文件中哪些是 “导出” 给用户所用而哪些是用于实现的知识。<br>\n在我们能用到模块之前没有真正的好方案。</p>\n<h3 id=\"a-namers-containedasf11-头文件应当是自包含的\"><a class=\"markdownIt-Anchor\" href=\"#a-namers-containedasf11-头文件应当是自包含的\">#</a> <a name=\"Rs-contained\"></a>SF.11: 头文件应当是自包含的</h3>\n<h5 id=\"理由-400\"><a class=\"markdownIt-Anchor\" href=\"#理由-400\">#</a> 理由</h5>\n<p>易用性，头文件应当易于使用，且单独包含即可正常工作。<br>\n头文件应当对其所提供的功能进行封装。<br>\n避免让头文件的使用方来管理它的依赖项。</p>\n<h5 id=\"示例-360\"><a class=\"markdownIt-Anchor\" href=\"#示例-360\">#</a> 示例</h5>\n<pre><code>#include &quot;helpers.h&quot;\n// helpers.h 依赖于 std::string 并已包含了 &lt;string&gt;\n</code></pre>\n<h5 id=\"注解-352\"><a class=\"markdownIt-Anchor\" href=\"#注解-352\">#</a> 注解</h5>\n<p>不遵守这条规则将导致头文件的使用方难于诊断所出现的错误。</p>\n<h5 id=\"注解-353\"><a class=\"markdownIt-Anchor\" href=\"#注解-353\">#</a> 注解</h5>\n<p>头文件应当包含其所有依赖项。请小心使用相对路径，各 C++ 实现对于它们的含义是有分歧的。</p>\n<h5 id=\"强制实施-368\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-368\">#</a> 强制实施</h5>\n<p>以一项测试来验证头文件自身可通过编译，或者一个仅包含了该头文件的 cpp 文件可通过编译。</p>\n<h3 id=\"a-namers-incformasf12-对相对于包含文件的文件优先采用引号形式的-include其他情况下采用角括号形式\"><a class=\"markdownIt-Anchor\" href=\"#a-namers-incformasf12-对相对于包含文件的文件优先采用引号形式的-include其他情况下采用角括号形式\">#</a> <a name=\"Rs-incform\"></a>SF.12: 对相对于包含文件的文件优先采用引号形式的  <code>#include</code> ，其他情况下采用角括号形式</h3>\n<h5 id=\"理由-401\"><a class=\"markdownIt-Anchor\" href=\"#理由-401\">#</a> 理由</h5>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2VlbC5pcy9jKytkcmFmdC9jcHAuaW5jbHVkZQ==\">标准</span> 向编译器提供了对于实现<br>\n使用角括号（ <code>&lt;&gt;</code> ）或引号（ <code>&quot;&quot;</code> ）语法的  <code>#include</code>  的两种形式的灵活性。<br>\n各厂商利用了这点并采用了不同的搜索算法和指定包含路径的方法。</p>\n<p>无论如何，指导方针是使用引号形式来（从同一个组件或项目中）包含那些存在于某个相对于含有这条  <code>#include</code>  语句的文件的相对路径中的文件，其他情况尽可能使用角括号形式。这样做鼓励明确表现出文件与包含它的文件之间的局部性，或当需要某种不同的搜索算法的情形。这样一眼就可以很容易明白头文件是从某个局部相对文件包含的，还是某个标准库头文件或别的搜索路径（比如另一个程序库或一组常用包含路径）中的某个头文件。</p>\n<h5 id=\"示例-361\"><a class=\"markdownIt-Anchor\" href=\"#示例-361\">#</a> 示例</h5>\n<pre><code>// foo.cpp:\n#include &lt;string&gt;                // 来自标准程序库，要求使用 &lt;&gt; 形式\n#include &lt;some_library/common.h&gt; // 从另一个程序库中包含的，并非出于局部相对位置的文件；使用 &lt;&gt; 形式\n#include &quot;foo.h&quot;                 // 处于同一项目中局部相对于 foo.cpp 的文件，使用 &quot;&quot; 形式\n#include &quot;foo_utils/utils.h&quot;     // 处于同一项目中局部相对于 foo.cpp 的文件，使用 &quot;&quot; 形式\n#include &lt;component_b/bar.h&gt;     // 通过搜索路径定位到的处于同一项目中的文件，使用 &lt;&gt; 形式\n</code></pre>\n<h5 id=\"注解-354\"><a class=\"markdownIt-Anchor\" href=\"#注解-354\">#</a> 注解</h5>\n<p>不遵守这条可能会导致很难诊断的错误：由于包含时指定的错误的范围而选择了错误的文件。<br>\n例如，通常  <code>#include &quot;&quot;</code>  的搜索算法首先搜索存在于某个局部相对路径中的文件，因此使用这种形式来指代某个并非位于局部相对路径的文件，就一位置一旦在局部相对路径中出现了一个这样的文件（比如进行包含的文件被移动到了别的位置），它就会在原来所包含的文件之前被找到，并使包含文件集合以一种预料之外的方式被改变。</p>\n<p>程序库作者们应当把它们的头文件放到一个文件夹中，然后让其客户使用相对路径来包含这些文件： <code>#include &lt;some_library/common.h&gt;</code> 。</p>\n<h5 id=\"强制实施-369\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-369\">#</a> 强制实施</h5>\n<p>检测按  <code>&quot;&quot;</code>  引用的头文件是否可以按  <code>&lt;&gt;</code>  引用。</p>\n<h3 id=\"a-namers-namespaceasf20-用-namespace-表示逻辑结构\"><a class=\"markdownIt-Anchor\" href=\"#a-namers-namespaceasf20-用-namespace-表示逻辑结构\">#</a> <a name=\"Rs-namespace\"></a>SF.20: 用  <code>namespace</code>  表示逻辑结构</h3>\n<h5 id=\"理由-402\"><a class=\"markdownIt-Anchor\" href=\"#理由-402\">#</a> 理由</h5>\n<p>???</p>\n<h5 id=\"示例-362\"><a class=\"markdownIt-Anchor\" href=\"#示例-362\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"强制实施-370\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-370\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namers-unnamedasf21-请勿在头文件中使用无名匿名命名空间\"><a class=\"markdownIt-Anchor\" href=\"#a-namers-unnamedasf21-请勿在头文件中使用无名匿名命名空间\">#</a> <a name=\"Rs-unnamed\"></a>SF.21: 请勿在头文件中使用无名（匿名）命名空间</h3>\n<h5 id=\"理由-403\"><a class=\"markdownIt-Anchor\" href=\"#理由-403\">#</a> 理由</h5>\n<p>在头文件中使用无名命名空间差不多都是一个 BUG。</p>\n<h5 id=\"示例-363\"><a class=\"markdownIt-Anchor\" href=\"#示例-363\">#</a> 示例</h5>\n<pre><code>// 文件 foo.h:\nnamespace\n&#123;\n    const double x = 1.234;  // 不好\n\n    double foo(double y)     // 不好\n    &#123;\n        return y + x;\n    &#125;\n&#125;\n\nnamespace Foo\n&#123;\n    const double x = 1.234; // 好\n\n    inline double foo(double y)        // 好\n    &#123;\n        return y + x;\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"强制实施-371\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-371\">#</a> 强制实施</h5>\n<ul>\n<li>对头文件中所使用的任何匿名命名空间进行标记。</li>\n</ul>\n<h3 id=\"a-namers-unnamed2asf22-为所有的内部不导出的实体使用无名匿名命名空间\"><a class=\"markdownIt-Anchor\" href=\"#a-namers-unnamed2asf22-为所有的内部不导出的实体使用无名匿名命名空间\">#</a> <a name=\"Rs-unnamed2\"></a>SF.22: 为所有的内部 / 不导出的实体使用无名（匿名）命名空间</h3>\n<h5 id=\"理由-404\"><a class=\"markdownIt-Anchor\" href=\"#理由-404\">#</a> 理由</h5>\n<p>外部实体无法依赖于嵌套的无名命名空间中的实体。<br>\n考虑将实现源文件中的所有定义都放入无名命名空间中，除非它定义的是一个 “外部 / 导出” 实体。</p>\n<h5 id=\"示例不好-143\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-143\">#</a> 示例；不好</h5>\n<pre><code>static int f();\nint g();\nstatic bool h();\nint k();\n</code></pre>\n<h5 id=\"示例好-29\"><a class=\"markdownIt-Anchor\" href=\"#示例好-29\">#</a> 示例；好</h5>\n<pre><code>namespace &#123;\n    int f();\n    bool h();\n&#125;\nint g();\nint k();\n</code></pre>\n<h5 id=\"示例-364\"><a class=\"markdownIt-Anchor\" href=\"#示例-364\">#</a> 示例</h5>\n<p>API 类及其成员不能放在无名命名空间中；而在实现源文件中所定义的任何的 “辅助” 类或函数则应当放在无名命名空间作用域之中。</p>\n<pre><code>???\n</code></pre>\n<h5 id=\"强制实施-372\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-372\">#</a> 强制实施</h5>\n<ul>\n<li>???</li>\n</ul>\n<h1 id=\"a-names-stdlibasl-标准库\"><a class=\"markdownIt-Anchor\" href=\"#a-names-stdlibasl-标准库\">#</a> <a name=\"S-stdlib\"></a>SL: 标准库</h1>\n<p>如果只使用纯语言本身的话，任何开发任务都会变得很麻烦（无论以何种语言）。<br>\n如果使用了某个合适的程序库的话，则任何开发任务都会变得相当简单。</p>\n<p>这些年来标准库一直在持续增长。<br>\n现在它在标准中的描述已经比语言功能特性的描述更大了。<br>\n因此，可能指导方针的库部分的规模最终将会增长等于甚至超过其他的所有部分。</p>\n<p>&lt;&lt;??? 我们需要另一个层次的规则编号？？？&gt;&gt;</p>\n<p>C++ 标准库组件概览：</p>\n<ul>\n<li><a href=\"#SS-con\">SL.con: 容器</a></li>\n<li><a href=\"#SS-string\">SL.str: 字符串</a></li>\n<li><a href=\"#SS-io\">SL.io: I/O 流（iostream）</a></li>\n<li><a href=\"#SS-regex\">SL.regex: 正则表达式</a></li>\n<li><a href=\"#SS-chrono\">SL.chrono: 时间</a></li>\n<li><a href=\"#SS-clib\">SL.C: C 标准库</a></li>\n</ul>\n<p>标准库规则概览：</p>\n<ul>\n<li><a href=\"#Rsl-lib\">SL.1: 尽可能使用程序库</a></li>\n<li><a href=\"#Rsl-sl\">SL.2: 优先使用标准库而不是其他程序库</a></li>\n<li><a href=\"#sl-std\">SL.3: 请勿向命名空间  <code>std</code>  中添加非标准实体</a></li>\n<li><a href=\"#sl-safe\">SL.4: 以类型安全的方式使用标准库</a></li>\n<li>???</li>\n</ul>\n<h3 id=\"a-namersl-libasl1-尽可能使用程序库\"><a class=\"markdownIt-Anchor\" href=\"#a-namersl-libasl1-尽可能使用程序库\">#</a> <a name=\"Rsl-lib\"></a>SL.1:  尽可能使用程序库</h3>\n<h5 id=\"理由-405\"><a class=\"markdownIt-Anchor\" href=\"#理由-405\">#</a> 理由</h5>\n<p>节约时间。避免重复发明轮子。<br>\n避免重复他人的工作。<br>\n如果其他人的工作有了改进，则可以从中获得好处。<br>\n当你进行了改进之后可以帮助其他人。</p>\n<h3 id=\"a-namersl-slasl2-优先使用标准库而不是其他程序库\"><a class=\"markdownIt-Anchor\" href=\"#a-namersl-slasl2-优先使用标准库而不是其他程序库\">#</a> <a name=\"Rsl-sl\"></a>SL.2: 优先使用标准库而不是其他程序库</h3>\n<h5 id=\"理由-406\"><a class=\"markdownIt-Anchor\" href=\"#理由-406\">#</a> 理由</h5>\n<p>了解标准库的人更多。<br>\n相对于你自己的代码或者大多数其他程序库来说，标准库更加倾向于稳定，进行了良好维护，而且广泛可用。</p>\n<h3 id=\"a-namesl-stdasl3-请勿向命名空间-std-中添加非标准实体\"><a class=\"markdownIt-Anchor\" href=\"#a-namesl-stdasl3-请勿向命名空间-std-中添加非标准实体\">#</a> <a name=\"sl-std\"></a>SL.3: 请勿向命名空间  <code>std</code>  中添加非标准实体</h3>\n<h5 id=\"理由-407\"><a class=\"markdownIt-Anchor\" href=\"#理由-407\">#</a> 理由</h5>\n<p>向  <code>std</code>  中添加东西可能会改变本来是遵循标准的代码的含义。<br>\n添加到  <code>std</code>  的东西可能会与未来版本的标准产生冲突。</p>\n<h5 id=\"示例-365\"><a class=\"markdownIt-Anchor\" href=\"#示例-365\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"强制实施-373\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-373\">#</a> 强制实施</h5>\n<p>有可能，但很麻烦而且在一些平台上很可能导致一些问题。</p>\n<h3 id=\"a-namesl-safeasl4-以类型安全的方式使用标准库\"><a class=\"markdownIt-Anchor\" href=\"#a-namesl-safeasl4-以类型安全的方式使用标准库\">#</a> <a name=\"sl-safe\"></a>SL.4: 以类型安全的方式使用标准库</h3>\n<h5 id=\"理由-408\"><a class=\"markdownIt-Anchor\" href=\"#理由-408\">#</a> 理由</h5>\n<p>因为，很显然，违反这条规则将导致未定义的行为，内存损坏，以及其他所有种类的糟糕的错误。</p>\n<h5 id=\"注解-355\"><a class=\"markdownIt-Anchor\" href=\"#注解-355\">#</a> 注解</h5>\n<p>本条规则是半哲学性的元规则，需要许多具体规则予以支持。<br>\n我们需要将之作为对于更加专门的规则的总括。</p>\n<p>更加专门的规则概览：</p>\n<ul>\n<li><a href=\"#sl-safe\">SL.4: 以类型安全的方式使用标准库</a></li>\n</ul>\n<h2 id=\"a-namess-conaslcon-容器\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-conaslcon-容器\">#</a> <a name=\"SS-con\"></a>SL.con: 容器</h2>\n<p>???</p>\n<p>容器规则概览：</p>\n<ul>\n<li><a href=\"#Rsl-arrays\">SL.con.1: 优先采用 STL 的  <code>array</code>  或  <code>vector</code>  而不是 C 数组</a></li>\n<li><a href=\"#Rsl-vector\">SL.con.2: 除非有理由使用别的容器，否则默认情况应优先采用 STL 的  <code>vector</code> </a></li>\n<li><a href=\"#Rsl-bounds\">SL.con.3: 避免边界错误</a></li>\n<li><a href=\"#Rsl-copy\">SL.con.4: 请勿对非可平凡复制的实参使用  <code>memset</code>  或  <code>memcpy</code> </a></li>\n</ul>\n<h3 id=\"a-namersl-arraysaslcon1-优先采用-stl-的-array-或-vector-而不是-c-数组\"><a class=\"markdownIt-Anchor\" href=\"#a-namersl-arraysaslcon1-优先采用-stl-的-array-或-vector-而不是-c-数组\">#</a> <a name=\"Rsl-arrays\"></a>SL.con.1: 优先采用 STL 的  <code>array</code>  或  <code>vector</code>  而不是 C 数组</h3>\n<h5 id=\"理由-409\"><a class=\"markdownIt-Anchor\" href=\"#理由-409\">#</a> 理由</h5>\n<p>C 数组不那么安全，而且相对于  <code>array</code>  和  <code>vector</code>  也没有什么优势。<br>\n对于定长数组，应使用  <code>std::array</code> ，它传递给函数时并不会退变为指针并丢失其大小信息。<br>\n而且，和内建数组一样，栈上分配的  <code>std::array</code>  会在栈上保存它的各个元素。<br>\n对于变长数组，应使用  <code>std::vector</code> ，它还可以改变大小并处理内存分配。</p>\n<h5 id=\"示例-366\"><a class=\"markdownIt-Anchor\" href=\"#示例-366\">#</a> 示例</h5>\n<pre><code>int v[SIZE];                        // 不好\n\nstd::array&lt;int, SIZE&gt; w;            // ok\n</code></pre>\n<h5 id=\"示例-367\"><a class=\"markdownIt-Anchor\" href=\"#示例-367\">#</a> 示例</h5>\n<pre><code>int* v = new int[initial_size];     // 不好，有所有权的原生指针\ndelete[] v;                         // 不好，手工 delete\n\nstd::vector&lt;int&gt; w(initial_size);   // ok\n</code></pre>\n<h5 id=\"注解-356\"><a class=\"markdownIt-Anchor\" href=\"#注解-356\">#</a> 注解</h5>\n<p>在不拥有而引用容器中的元素时使用  <code>gsl::span</code> 。</p>\n<h5 id=\"注解-357\"><a class=\"markdownIt-Anchor\" href=\"#注解-357\">#</a> 注解</h5>\n<p>在栈上分配的固定大小的数组和把元素都放在自由存储上的  <code>vector</code>  之间比较性能是没什么意义的。<br>\n你同样也可以在栈上的  <code>std::array</code>  和通过指针访问  <code>malloc()</code>  的结果之间进行这样的比较。<br>\n对于大多数代码来说，即便是栈上分配和自由存储分配之间的差异也没那么重要，但  <code>vector</code>  带来的便利和安全性却是重要的。<br>\n如果有人编写的代码中这种差异确实重要，那么他显然可以在  <code>array</code>  和  <code>vector</code>  之间做出选择。</p>\n<h5 id=\"强制实施-374\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-374\">#</a> 强制实施</h5>\n<ul>\n<li>如果 C 数组的声明所在的函数或类也声明了 STL 的某个容器（这是为了避免在老式的非 STL 代码中的大量警告噪音），则对其进行标记。修正：最少要把 C 数组改成  <code>std::array</code> 。</li>\n</ul>\n<h3 id=\"a-namersl-vectoraslcon2-除非有理由使用别的容器否则默认情况应优先采用-stl-的-vector\"><a class=\"markdownIt-Anchor\" href=\"#a-namersl-vectoraslcon2-除非有理由使用别的容器否则默认情况应优先采用-stl-的-vector\">#</a> <a name=\"Rsl-vector\"></a>SL.con.2: 除非有理由使用别的容器，否则默认情况应优先采用 STL 的  <code>vector</code></h3>\n<h5 id=\"理由-410\"><a class=\"markdownIt-Anchor\" href=\"#理由-410\">#</a> 理由</h5>\n<p><code>vector</code>  和  <code>array</code>  是仅有的能够提供以下各项优势的标准容器：</p>\n<ul>\n<li>最快的通用访问（随机访问，还包括对于向量化友好性）；</li>\n<li>最快的默认访问模式（从头到尾或从尾到头方式是对预读器友好的）；</li>\n<li>最少的空间耗费（连续布局中没有每个元素的开销，而且是 cache 友好的）。</li>\n</ul>\n<p>通常你都需要对容器进行元素的添加和删除，因此默认应当采用  <code>vector</code> ；如果并不需要改动容器的大小的话，则应采用  <code>array</code> 。</p>\n<p>即便其他容器貌似更加合适，比如  <code>map</code>  的 O (log N) 查找性能，或者  <code>list</code>  的中部高效插入，对于几个 KB 以内大小的容器来说， <code>vector</code>  仍然经常性能更好。</p>\n<h5 id=\"注解-358\"><a class=\"markdownIt-Anchor\" href=\"#注解-358\">#</a> 注解</h5>\n<p><code>string</code>  不应当用作独立字符的容器。 <code>string</code>  是文本字符串；如果需要字符的容器的话，应当采用  <code>vector&lt;/*char_type*/&gt;</code>  或者  <code>array&lt;/*char_type*/&gt;</code> 。</p>\n<h5 id=\"例外-59\"><a class=\"markdownIt-Anchor\" href=\"#例外-59\">#</a> 例外</h5>\n<p>如果你有正当的理由来使用别的容器的话，就请使用它。例如：</p>\n<ul>\n<li>\n<p>若  <code>vector</code>  满足你的需求，但你并不需要容器大小可变，则应当代之以  <code>array</code> 。</p>\n</li>\n<li>\n<p>若你需要支持字典式查找的容器并保证 O (K) 或 O (log N) 的查找效率，而且容器将会比较大（超过几个 KB），你需要经常进行插入使得维护有序的  <code>vector</code>  的开销不大可行，则请代之以使用  <code>unordered_map</code>  或者  <code>map</code> 。</p>\n</li>\n</ul>\n<h5 id=\"注解-359\"><a class=\"markdownIt-Anchor\" href=\"#注解-359\">#</a> 注解</h5>\n<p>使用  <code>()</code>  初始化来将  <code>vector</code>  初始化为具有特定数量的元素。<br>\n使用  <code>&#123;&#125;</code>  初始化来以一个元素列表来对  <code>vector</code>  进行初始化。</p>\n<pre><code>vector&lt;int&gt; v1(20);  // v1 具有 20 个值为 0 的元素（vector&lt;int&gt;&#123;&#125;）\nvector&lt;int&gt; v2 &#123;20&#125;; // v2 具有 1 个值为 20 的元素\n</code></pre>\n<p><a href=\"#Res-list\">优先采用  <code>&#123;&#125;</code>  初始化式语法</a>。</p>\n<h5 id=\"强制实施-375\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-375\">#</a> 强制实施</h5>\n<ul>\n<li>如果  <code>vector</code>  构造之后大小不会改变（比如因为它是  <code>const</code>  或者因为没有对它调用过非  <code>const</code>  函数），则对其进行标记。修正：代之以使用  <code>array</code> 。</li>\n</ul>\n<h3 id=\"a-namersl-boundsaslcon3-避免边界错误\"><a class=\"markdownIt-Anchor\" href=\"#a-namersl-boundsaslcon3-避免边界错误\">#</a> <a name=\"Rsl-bounds\"></a>SL.con.3: 避免边界错误</h3>\n<h5 id=\"理由-411\"><a class=\"markdownIt-Anchor\" href=\"#理由-411\">#</a> 理由</h5>\n<p>越过已分配的元素的范围进行读写，通常都会导致糟糕的错误，不正确的结果，程序崩溃，以及安全漏洞。</p>\n<h5 id=\"注解-360\"><a class=\"markdownIt-Anchor\" href=\"#注解-360\">#</a> 注解</h5>\n<p>应用于一组元素的范围的标准库函数，都有（或应当有）接受  <code>span</code>  的边界安全重载。<br>\n如  <code>vector</code>  这样的标准类型，在边界剖面配置下（以某种不兼容的方式，如添加契约）可以被修改为实施边界检查，或者使用  <code>at()</code> 。</p>\n<p>理想情况下，边界内保证应当可以被静态强制实行。<br>\n例如：</p>\n<ul>\n<li>基于范围的  <code>for</code>  的循环不会越过其所针对的容器的范围</li>\n<li><code>v.begin(),v.end()</code>  可以很容易确定边界安全性</li>\n</ul>\n<p>这种循环和任何的等价的无检查或不安全的循环一样高效。</p>\n<p>通常，可以用一个简单的预先检查来消除检查每个索引的需要。<br>\n例如</p>\n<ul>\n<li>对于  <code>v.begin(),v.begin()+i</code> ， <code>i</code>  可以很容易针对  <code>v.size()</code>  检查</li>\n</ul>\n<p>这种循环比每次都待检查元素访问要快得多。</p>\n<h5 id=\"示例不好-144\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-144\">#</a> 示例，不好</h5>\n<pre><code>void f()\n&#123;\n    array&lt;int, 10&gt; a, b;\n    memset(a.data(), 0, 10);         // 不好，且包含长度错误（length = 10 * sizeof(int)）\n    memcmp(a.data(), b.data(), 10);  // 不好，且包含长度错误（length = 10 * sizeof(int)）\n&#125;\n</code></pre>\n<p>而且， <code>std::array&lt;&gt;::fill()</code>  或  <code>std::fill()</code> ，甚或是空的初始化式，都是比  <code>memset()</code>  更好的候选。</p>\n<h5 id=\"示例好-30\"><a class=\"markdownIt-Anchor\" href=\"#示例好-30\">#</a> 示例，好</h5>\n<pre><code>void f()\n&#123;\n    array&lt;int, 10&gt; a, b, c&#123;&#125;;       // c 被初始化为零\n    a.fill(0);\n    fill(b.begin(), b.end(), 0);    // std::fill()\n    fill(b, 0);                     // std::ranges::fill()\n\n    if ( a == b ) &#123;\n      // ...\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"example\"><a class=\"markdownIt-Anchor\" href=\"#example\">#</a> Example</h5>\n<p>如果代码使用的是未修改的标准库，仍然有一些变通方案来以边界安全的方式使用  <code>std::array</code>  和  <code>std::vector</code> 。代码中可以调用各个类的  <code>.at()</code>  成员函数，这将抛出  <code>std::out_of_range</code>  异常。或者，代码中可以调用  <code>at()</code>  自由函数，这将在边界违例时导致快速失败（或者某个自定义动作）。</p>\n<pre><code>void f(std::vector&lt;int&gt;&amp; v, std::array&lt;int, 12&gt; a, int i)\n&#123;\n    v[0] = a[0];        // 不好\n    v.at(0) = a[0];     // OK（替代方案 1）\n    at(v, 0) = a[0];    // OK（替代方案 2）\n\n    v.at(0) = a[i];     // 不好\n    v.at(0) = a.at(i);  // OK（替代方案 1）\n    v.at(0) = at(a, i); // OK（替代方案 2）\n&#125;\n</code></pre>\n<h5 id=\"强制实施-376\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-376\">#</a> 强制实施</h5>\n<ul>\n<li>对于没有边界检查的标准库函数的任何调用都给出诊断消息。<br>\n??? 在这里添加一组禁用函数的连接列表</li>\n</ul>\n<p>本条规则属于<a href=\"#SS-bounds\">边界剖面配置</a>。</p>\n<h3 id=\"a-namersl-copyaslcon4-请勿对非可平凡复制的实参使用-memset-或-memcpy\"><a class=\"markdownIt-Anchor\" href=\"#a-namersl-copyaslcon4-请勿对非可平凡复制的实参使用-memset-或-memcpy\">#</a> <a name=\"Rsl-copy\"></a>SL.con.4: 请勿对非可平凡复制的实参使用  <code>memset</code>  或  <code>memcpy</code></h3>\n<h5 id=\"理由-412\"><a class=\"markdownIt-Anchor\" href=\"#理由-412\">#</a> 理由</h5>\n<p>这样做会破坏对象语义（例如，其会覆写掉  <code>vptr</code> ）。</p>\n<h5 id=\"注解-361\"><a class=\"markdownIt-Anchor\" href=\"#注解-361\">#</a> 注解</h5>\n<p><code>(w)memset</code> ， <code>(w)memcpy</code> ， <code>(w)memmove</code> ，以及  <code>(w)memcmp</code>  与此相似。</p>\n<h5 id=\"示例-368\"><a class=\"markdownIt-Anchor\" href=\"#示例-368\">#</a> 示例</h5>\n<pre><code>struct base &#123;\n    virtual void update() = 0;\n&#125;;\n\nstruct derived : public base &#123;\n    void update() override &#123;&#125;\n&#125;;\n\n\nvoid f (derived&amp; a, derived&amp; b) // 虚表再见！\n&#123;\n    memset(&amp;a, 0, sizeof(derived));\n    memcpy(&amp;a, &amp;b, sizeof(derived));\n    memcmp(&amp;a, &amp;b, sizeof(derived));\n&#125;\n</code></pre>\n<p>应当代之以定义适当的默认初始化，复制，以及比较函数</p>\n<pre><code>void g(derived&amp; a, derived&amp; b)\n&#123;\n    a = &#123;&#125;;    // 默认初始化\n    b = a;     // 复制\n    if (a == b) do_something(a,b);\n&#125;\n</code></pre>\n<h5 id=\"强制实施-377\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-377\">#</a> 强制实施</h5>\n<ul>\n<li>对在不可平凡复制的类型使用这些函数进行标记</li>\n</ul>\n<p><strong>TODO 注释</strong>:</p>\n<ul>\n<li>对于标准库的影响需要和 WG21 之间进行紧密的协调，即便不需要标准化也应当至少保证兼容性。</li>\n<li>我们正在考虑为标准库（尤其是 C 标准库）中如  <code>memcmp</code>  这样的函数指定边界安全的重载，并在 GSL 中提供它们。</li>\n<li>对于标准中没有进行完全的边界检查的现存函数和如  <code>vector</code>  这样的类型来说，我们的目标是在启用了边界剖面配置的代码中调用时，这些功能应当进行边界检查，而从遗留代码中调用时则没有检查，可能需要利用契约来实现（正由几个 WG21 成员进行提案工作）。</li>\n</ul>\n<h2 id=\"a-namess-stringaslstr-字符串\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-stringaslstr-字符串\">#</a> <a name=\"SS-string\"></a>SL.str: 字符串</h2>\n<p>文本处理是一个大的主题。<br>\n <code>std::string</code>  无法全部覆盖这些。<br>\n这一部分主要尝试澄清  <code>std::string</code>  和  <code>char*</code> 、 <code>zstring</code> 、 <code>string_view</code>  和  <code>gsl::span&lt;char&gt;</code>  之间的关系。<br>\n有关非 ASCII 字符集和编码的重要问题（比如  <code>wchar_t</code> ，Unicode，以及 UTF-8 等）将在别处讨论。</p>\n<p><strong>参见</strong>：<a href=\"#SS-regex\">正则表达式</a></p>\n<p>在这里，我们用 “字符序列” 或 “字符串” 来代表（终将）作为文本来读取的字符序列。<br>\nWe don’t consider ???</p>\n<p>字符串概览：</p>\n<ul>\n<li>\n<p><a href=\"#Rstr-string\">SL.str.1: 使用  <code>std::string</code>  以拥有字符序列</a></p>\n</li>\n<li>\n<p><a href=\"#Rstr-view\">SL.str.2: 使用  <code>std::string_view</code>  或  <code>gsl::span&lt;char&gt;</code>  以指代字符序列</a></p>\n</li>\n<li>\n<p><a href=\"#Rstr-zstring\">SL.str.3: 使用  <code>zstring</code>  或  <code>czstring</code>  以指代 C 风格、以零结尾的字符序列</a></p>\n</li>\n<li>\n<p><a href=\"#Rstr-char*\">SL.str.4: 使用  <code>char*</code>  以指代单个字符</a></p>\n</li>\n<li>\n<p><a href=\"#Rstr-byte\">SL.str.5: 使用  <code>std::byte</code>  以指代并不必须表示字符的字节值</a></p>\n</li>\n<li>\n<p><a href=\"#Rstr-locale\">SL.str.10: 当需要实施相关于文化地域的操作时，使用  <code>std::string</code> </a></p>\n</li>\n<li>\n<p><a href=\"#Rstr-span\">SL.str.11: 当需要改动字符串时，使用  <code>gsl::span&lt;char&gt;</code>  而不是  <code>std::string_view</code> </a></p>\n</li>\n<li>\n<p><a href=\"#Rstr-s\">SL.str.12: 为作为标准库的  <code>string</code>  类型的字符串字面量使用后缀  <code>s</code> </a></p>\n</li>\n</ul>\n<p><strong>参见</strong>：</p>\n<ul>\n<li><a href=\"#Rf-range\">F.24 span</a></li>\n<li><a href=\"#Rf-zstring\">F.25 zstring</a></li>\n</ul>\n<h3 id=\"a-namerstr-stringaslstr1-使用-stdstring-以拥有字符序列\"><a class=\"markdownIt-Anchor\" href=\"#a-namerstr-stringaslstr1-使用-stdstring-以拥有字符序列\">#</a> <a name=\"Rstr-string\"></a>SL.str.1: 使用  <code>std::string</code>  以拥有字符序列</h3>\n<h5 id=\"理由-413\"><a class=\"markdownIt-Anchor\" href=\"#理由-413\">#</a> 理由</h5>\n<p><code>string</code>  能够正确处理资源分配，所有权，复制，渐进扩容，并提供许多有用的操作。</p>\n<h5 id=\"示例-369\"><a class=\"markdownIt-Anchor\" href=\"#示例-369\">#</a> 示例</h5>\n<pre><code>vector&lt;string&gt; read_until(const string&amp; terminator)\n&#123;\n    vector&lt;string&gt; res;\n    for (string s; cin &gt;&gt; s &amp;&amp; s != terminator; ) // 读取一个单词\n        res.push_back(s);\n    return res;\n&#125;\n</code></pre>\n<p>注意已经为  <code>string</code>  提供了  <code>&gt;&gt;</code>  和  <code>!=</code> （作为有用操作的例子），并且没有显示的内存分配，<br>\n回收，或者范围检查（ <code>string</code>  会处理这些）。</p>\n<p>C++17 中，我们可以使用  <code>string_view</code>  而不是  <code>const string&amp;</code>  作为参数，以允许调用方更大的灵活性：</p>\n<pre><code>vector&lt;string&gt; read_until(string_view terminator)   // C++17\n&#123;\n    vector&lt;string&gt; res;\n    for (string s; cin &gt;&gt; s &amp;&amp; s != terminator; ) // 读取一个单词\n        res.push_back(s);\n    return res;\n&#125;\n</code></pre>\n<h5 id=\"示例不好-145\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-145\">#</a> 示例，不好</h5>\n<p>不要使用 C 风格的字符串来进行需要不单纯的内存管理的操作：</p>\n<pre><code>char* cat(const char* s1, const char* s2)   // 当心！\n    // return s1 + '.' + s2\n&#123;\n    int l1 = strlen(s1);\n    int l2 = strlen(s2);\n    char* p = (char*)malloc(l1 + l2 + 2);\n    strcpy(p, s1, l1);\n    p[l1] = '.';\n    strcpy(p + l1 + 1, s2, l2);\n    p[l1 + l2 + 1] = 0;\n    return p;\n&#125;\n</code></pre>\n<p>我们搞对了吗？<br>\n调用者能记得要对返回的指针调用  <code>free()</code>  吗？<br>\n这段代码能通过安全性评审吗？</p>\n<h5 id=\"注解-362\"><a class=\"markdownIt-Anchor\" href=\"#注解-362\">#</a> 注解</h5>\n<p>没有测量就不要假设  <code>string</code>  比底层技术慢，要记得并非所有代码都是性能攸关的。<br>\n<a href=\"#Rper-Knuth\">请勿进行不成熟的优化</a></p>\n<h5 id=\"强制实施-378\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-378\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerstr-viewaslstr2-使用-stdstring_view-或-gslspanchar-以指代字符序列\"><a class=\"markdownIt-Anchor\" href=\"#a-namerstr-viewaslstr2-使用-stdstring_view-或-gslspanchar-以指代字符序列\">#</a> <a name=\"Rstr-view\"></a>SL.str.2: 使用  <code>std::string_view</code>  或  <code>gsl::span&lt;char&gt;</code>  以指代字符序列</h3>\n<h5 id=\"理由-414\"><a class=\"markdownIt-Anchor\" href=\"#理由-414\">#</a> 理由</h5>\n<p><code>std::string_view</code>  或  <code>gsl::span&lt;char&gt;</code>  提供了简易且（潜在）安全的对字符序列的访问，并与序列的<br>\n分配和存储方式无关。</p>\n<h5 id=\"示例-370\"><a class=\"markdownIt-Anchor\" href=\"#示例-370\">#</a> 示例</h5>\n<pre><code>vector&lt;string&gt; read_until(string_view terminator);\n\nvoid user(zstring p, const string&amp; s, string_view ss)\n&#123;\n    auto v1 = read_until(p);\n    auto v2 = read_until(s);\n    auto v3 = read_until(ss);\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"注解-363\"><a class=\"markdownIt-Anchor\" href=\"#注解-363\">#</a> 注解</h5>\n<p><code>std::string_view</code> （C++17）是只读的。</p>\n<h5 id=\"强制实施-379\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-379\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerstr-zstringaslstr3-使用-zstring-或-czstring-以指代-c-风格-以零结尾的字符序列\"><a class=\"markdownIt-Anchor\" href=\"#a-namerstr-zstringaslstr3-使用-zstring-或-czstring-以指代-c-风格-以零结尾的字符序列\">#</a> <a name=\"Rstr-zstring\"></a>SL.str.3: 使用  <code>zstring</code>  或  <code>czstring</code>  以指代 C 风格、以零结尾的字符序列</h3>\n<h5 id=\"理由-415\"><a class=\"markdownIt-Anchor\" href=\"#理由-415\">#</a> 理由</h5>\n<p>可读性。<br>\n明确意图。<br>\n普通的  <code>char*</code>  可以是指向单个字符的指针，指向字符数组的指针，指向 C 风格（零结尾）字符串的指针，甚或是指向小整数的指针。<br>\n对这些情况加以区分能够避免误解和 BUG。</p>\n<h5 id=\"示例-371\"><a class=\"markdownIt-Anchor\" href=\"#示例-371\">#</a> 示例</h5>\n<pre><code>void f1(const char* s); // s 可能是个字符串\n</code></pre>\n<p>我们所知的只不过是它可能是 nullptr 或者指向至少一个字符</p>\n<pre><code>void f1(zstring s);     // s 是 C 风格字符串或者 nullptr\nvoid f1(czstring s);    // s 是 C 风格字符串常量或者 nullptr\nvoid f1(std::byte* s);  // s 是某个字节的指针（C++17）\n</code></pre>\n<h5 id=\"注解-364\"><a class=\"markdownIt-Anchor\" href=\"#注解-364\">#</a> 注解</h5>\n<p>除非确实有理由，否则不要把 C 风格的字符串转换为  <code>string</code> 。</p>\n<h5 id=\"注解-365\"><a class=\"markdownIt-Anchor\" href=\"#注解-365\">#</a> 注解</h5>\n<p>与其他的 “普通指针” 一样， <code>zstring</code>  不能表达所有权。</p>\n<h5 id=\"注解-366\"><a class=\"markdownIt-Anchor\" href=\"#注解-366\">#</a> 注解</h5>\n<p>已经存在了上亿行的 C++ 代码，它们大多使用  <code>char*</code>  和  <code>const char*</code>  却并不注明其意图。<br>\n各种不同的方式都在使用它们，包括以之表示所有权，以及（代替  <code>void*</code> ）作为通用的内存指针。<br>\n很难区分这些用法，因此这条指导方针很难被遵守。<br>\n而这是 C 和 C++ 程序中的最主要的 BUG 来源之一，因此一旦可行就遵守这条指导方针是值得的。</p>\n<h5 id=\"强制实施-380\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-380\">#</a> 强制实施</h5>\n<ul>\n<li>标记在  <code>char*</code>  上使用的  <code>[]</code></li>\n<li>标记在  <code>char*</code>  上使用的  <code>delete</code></li>\n<li>标记在  <code>char*</code>  上使用的  <code>free()</code></li>\n</ul>\n<h3 id=\"a-namerstr-charaslstr4-使用-char-以指代单个字符\"><a class=\"markdownIt-Anchor\" href=\"#a-namerstr-charaslstr4-使用-char-以指代单个字符\">#</a> <a name=\"Rstr-char*\"></a>SL.str.4: 使用  <code>char*</code>  以指代单个字符</h3>\n<h5 id=\"示例-372\"><a class=\"markdownIt-Anchor\" href=\"#示例-372\">#</a> 示例</h5>\n<p>现存代码中对  <code>char*</code>  的各种不同用法，是一种主要的错误来源。</p>\n<h5 id=\"示例不好-146\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-146\">#</a> 示例，不好</h5>\n<pre><code>char arr[] = &#123;'a', 'b', 'c'&#125;;\n\nvoid print(const char* p)\n&#123;\n    cout &lt;&lt; p &lt;&lt; '\\n';\n&#125;\n\nvoid use()\n&#123;\n    print(arr);   // 运行时错误；可能非常糟糕\n&#125;\n</code></pre>\n<p>数组  <code>arr</code>  并非 C 风格字符串，因为它不是零结尾的。</p>\n<h5 id=\"替代方案-18\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-18\">#</a> 替代方案</h5>\n<p>参见 <a href=\"#Rstr-zstring\"> <code>zstring</code> </a>，<a href=\"#Rstr-string\"> <code>string</code> </a>，以及 <a href=\"#Rstr-view\"> <code>string_view</code> </a>。</p>\n<h5 id=\"强制实施-381\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-381\">#</a> 强制实施</h5>\n<ul>\n<li>标记在  <code>char*</code>  上使用的  <code>[]</code></li>\n</ul>\n<h3 id=\"a-namerstr-byteaslstr5-使用-stdbyte-以指代并不必须表示字符的字节值\"><a class=\"markdownIt-Anchor\" href=\"#a-namerstr-byteaslstr5-使用-stdbyte-以指代并不必须表示字符的字节值\">#</a> <a name=\"Rstr-byte\"></a>SL.str.5: 使用  <code>std::byte</code>  以指代并不必须表示字符的字节值</h3>\n<h5 id=\"理由-416\"><a class=\"markdownIt-Anchor\" href=\"#理由-416\">#</a> 理由</h5>\n<p>用  <code>char*</code>  来表示指向不一定是字符的东西的指针会造成混乱，<br>\n并会妨碍有价值的优化。</p>\n<h5 id=\"示例-373\"><a class=\"markdownIt-Anchor\" href=\"#示例-373\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"注解-367\"><a class=\"markdownIt-Anchor\" href=\"#注解-367\">#</a> 注解</h5>\n<p>C++17</p>\n<h5 id=\"强制实施-382\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-382\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerstr-localeaslstr10-当需要实施相关于文化地域的操作时使用-stdstring\"><a class=\"markdownIt-Anchor\" href=\"#a-namerstr-localeaslstr10-当需要实施相关于文化地域的操作时使用-stdstring\">#</a> <a name=\"Rstr-locale\"></a>SL.str.10: 当需要实施相关于文化地域的操作时，使用  <code>std::string</code></h3>\n<h5 id=\"理由-417\"><a class=\"markdownIt-Anchor\" href=\"#理由-417\">#</a> 理由</h5>\n<p><code>std::string</code>  支持标准库的 <a href=\"#Rstr-locale\"> <code>locale</code>  功能</a></p>\n<h5 id=\"示例-374\"><a class=\"markdownIt-Anchor\" href=\"#示例-374\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"注解-368\"><a class=\"markdownIt-Anchor\" href=\"#注解-368\">#</a> 注解</h5>\n<p>???</p>\n<h5 id=\"强制实施-383\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-383\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerstr-spanaslstr11-当需要改动字符串时使用-gslspanchar-而不是-stdstring_view\"><a class=\"markdownIt-Anchor\" href=\"#a-namerstr-spanaslstr11-当需要改动字符串时使用-gslspanchar-而不是-stdstring_view\">#</a> <a name=\"Rstr-span\"></a>SL.str.11: 当需要改动字符串时，使用  <code>gsl::span&lt;char&gt;</code>  而不是  <code>std::string_view</code></h3>\n<h5 id=\"理由-418\"><a class=\"markdownIt-Anchor\" href=\"#理由-418\">#</a> 理由</h5>\n<p><code>std::string_view</code>  是只读的。</p>\n<h5 id=\"示例-375\"><a class=\"markdownIt-Anchor\" href=\"#示例-375\">#</a> 示例</h5>\n<p>???</p>\n<h5 id=\"注解-369\"><a class=\"markdownIt-Anchor\" href=\"#注解-369\">#</a> 注解</h5>\n<p>???</p>\n<h5 id=\"强制实施-384\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-384\">#</a> 强制实施</h5>\n<p>编译器会标记出试图写入  <code>string_view</code>  的地方。</p>\n<h3 id=\"a-namerstr-saslstr12-为作为标准库的-string-类型的字符串字面量使用后缀-s\"><a class=\"markdownIt-Anchor\" href=\"#a-namerstr-saslstr12-为作为标准库的-string-类型的字符串字面量使用后缀-s\">#</a> <a name=\"Rstr-s\"></a>SL.str.12: 为作为标准库的  <code>string</code>  类型的字符串字面量使用后缀  <code>s</code></h3>\n<h5 id=\"理由-419\"><a class=\"markdownIt-Anchor\" href=\"#理由-419\">#</a> 理由</h5>\n<p>直接表达想法能够最小化犯错机会。</p>\n<h5 id=\"示例-376\"><a class=\"markdownIt-Anchor\" href=\"#示例-376\">#</a> 示例</h5>\n<pre><code>auto pp1 = make_pair(&quot;Tokyo&quot;, 9.00);         // &#123;C 风格字符串,double&#125; 有意如此？\npair&lt;string, double&gt; pp2 = &#123;&quot;Tokyo&quot;, 9.00&#125;;  // 稍微啰嗦\nauto pp3 = make_pair(&quot;Tokyo&quot;s, 9.00);        // &#123;std::string,double&#125;    // C++14\npair pp4 = &#123;&quot;Tokyo&quot;s, 9.00&#125;;                 // &#123;std::string,double&#125;    // C++17\n</code></pre>\n<h5 id=\"强制实施-385\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-385\">#</a> 强制实施</h5>\n<p>???</p>\n<h2 id=\"a-namess-ioaslio-io-流iostream\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-ioaslio-io-流iostream\">#</a> <a name=\"SS-io\"></a><span class=\"exturl\" data-url=\"aHR0cDovL1NMLmlv\">SL.io</span>: I/O 流（iostream）</h2>\n<p><code>iostream</code>  是一种类型安全的，可扩展的，带格式的和无格式的流式 I/O 的 I/O 程序库。<br>\n它支持多种（且用户可扩展的）缓冲策略以及多种文化地域。<br>\n它可以用于进行便利的 I/O，内存读写（字符串流），<br>\n以及用户定义的扩展，诸如跨网络的流（asio：尚未标准化）。</p>\n<p>I/O 流规则概览：</p>\n<ul>\n<li><a href=\"#Rio-low\">SL.io.1: 仅在必要时才使用字符层面的输入</a></li>\n<li><a href=\"#Rio-validate\">SL.io.2: 当进行读取时，总要考虑非法输入</a></li>\n<li><a href=\"#Rio-streams\">SL.io.3: 优先使用 iostream 进行 I/O</a></li>\n<li><a href=\"#Rio-sync\">SL.io.10: 除非你使用了  <code>printf</code>  族函数，否则要调用  <code>ios_base::sync_with_stdio(false)</code> </a></li>\n<li><a href=\"#Rio-endl\">SL.io.50: 避免使用  <code>endl</code> </a></li>\n<li><a href=\"#???\">???</a></li>\n</ul>\n<h3 id=\"a-namerio-lowaslio1-仅在必要时才使用字符层面的输入\"><a class=\"markdownIt-Anchor\" href=\"#a-namerio-lowaslio1-仅在必要时才使用字符层面的输入\">#</a> <a name=\"Rio-low\"></a>SL.io.1: 仅在必要时才使用字符层面的输入</h3>\n<h5 id=\"理由-420\"><a class=\"markdownIt-Anchor\" href=\"#理由-420\">#</a> 理由</h5>\n<p>除非你确实仅处理单个的字符，否则使用字符级的输入将导致用户代码实施潜在易错的<br>\n且潜在低效的从字符进行标记组合的工作。</p>\n<h5 id=\"示例-377\"><a class=\"markdownIt-Anchor\" href=\"#示例-377\">#</a> 示例</h5>\n<pre><code>char c;\nchar buf[128];\nint i = 0;\nwhile (cin.get(c) &amp;&amp; !isspace(c) &amp;&amp; i &lt; 128)\n    buf[i++] = c;\nif (i == 128) &#123;\n    // ... 处理过长的字符串 ....\n&#125;\n</code></pre>\n<p>更好的做法（简单得多而且可能更快）：</p>\n<pre><code>string s;\ns.reserve(128);\ncin&gt;&gt;s;\n</code></pre>\n<p>而且额能并不需要  <code>reserve(128)</code> 。</p>\n<h5 id=\"强制实施-386\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-386\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerio-validateaslio2-当进行读取时总要考虑非法输入\"><a class=\"markdownIt-Anchor\" href=\"#a-namerio-validateaslio2-当进行读取时总要考虑非法输入\">#</a> <a name=\"Rio-validate\"></a>SL.io.2: 当进行读取时，总要考虑非法输入</h3>\n<h5 id=\"理由-421\"><a class=\"markdownIt-Anchor\" href=\"#理由-421\">#</a> 理由</h5>\n<p>错误通常最好尽快处理。<br>\n如果输入无效，所有的函数都必须编写为对付不良的数据（而这并不现实）。</p>\n<h5 id=\"示例-378\"><a class=\"markdownIt-Anchor\" href=\"#示例-378\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"强制实施-387\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-387\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerio-streamsaslio3-优先使用-iostream-进行-io\"><a class=\"markdownIt-Anchor\" href=\"#a-namerio-streamsaslio3-优先使用-iostream-进行-io\">#</a> <a name=\"Rio-streams\"></a>SL.io.3: 优先使用 iostream 进行 I/O</h3>\n<h5 id=\"理由-422\"><a class=\"markdownIt-Anchor\" href=\"#理由-422\">#</a> 理由</h5>\n<p><code>iosteam</code>  安全，灵活，并且可扩展。</p>\n<h5 id=\"示例-379\"><a class=\"markdownIt-Anchor\" href=\"#示例-379\">#</a> 示例</h5>\n<pre><code>// 写出一个复数：\ncomplex&lt;double&gt; z&#123; 3,4 &#125;;\ncout &lt;&lt; z &lt;&lt; '\\n';\n</code></pre>\n<p><code>complex</code>  是一个用户定义的类型，而其 I/O 的定义无需改动  <code>iostream</code>  库。</p>\n<h5 id=\"示例-380\"><a class=\"markdownIt-Anchor\" href=\"#示例-380\">#</a> 示例</h5>\n<pre><code>// 读取一系列复数：\nfor (complex&lt;double&gt; z; cin&gt;&gt;z)\n    v.push_back(z);\n</code></pre>\n<h5 id=\"例外-60\"><a class=\"markdownIt-Anchor\" href=\"#例外-60\">#</a> 例外</h5>\n<p>??? 性能？？？</p>\n<h5 id=\"讨论iostream-vs-printf-家族\"><a class=\"markdownIt-Anchor\" href=\"#讨论iostream-vs-printf-家族\">#</a> 讨论： <code>iostream</code>  vs.  <code>printf()</code>  家族</h5>\n<p>人们通常说（并且通常是正确的） <code>printf</code>  家族比  <code>iostream</code>  有两个优势：<br>\n格式化的灵活性和性能。<br>\n这需要与  <code>iostream</code>  在处理用户定义类型方面的扩展性，针对安全性的违反方面的韧性，<br>\n隐含的内存管理，以及  <code>locale</code>  处理等优势之间进行权衡。</p>\n<p>如果需要 I/O 性能的话，你几乎总能做到比  <code>printf()</code>  更好。</p>\n<p><code>gets()</code> ，使用  <code>%s</code>  的  <code>scanf()</code> ，和使用  <code>%s</code>  的  <code>printf()</code>  在安全性方面冒风险（容易遭受缓冲区溢出问题而且通常很易错）。<br>\nC11 定义了一些 “可选扩展”，它们对其实参进行一些额外检查。<br>\n如果您的 C 程序库中包含  <code>gets_s()</code> 、 <code>scanf_s()</code>  和  <code>printf_s()</code> ，它们也许是更安全的替代方案，但仍然并非是类型安全的。</p>\n<h5 id=\"强制实施-388\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-388\">#</a> 强制实施</h5>\n<p>可选地标记  <code>&lt;cstdio&gt;</code>  和  <code>&lt;stdio.h&gt;</code> 。</p>\n<h3 id=\"a-namerio-syncaslio10-除非你使用了-printf-族函数否则要调用-ios_basesync_with_stdiofalse\"><a class=\"markdownIt-Anchor\" href=\"#a-namerio-syncaslio10-除非你使用了-printf-族函数否则要调用-ios_basesync_with_stdiofalse\">#</a> <a name=\"Rio-sync\"></a>SL.io.10: 除非你使用了  <code>printf</code>  族函数，否则要调用  <code>ios_base::sync_with_stdio(false)</code></h3>\n<h5 id=\"理由-423\"><a class=\"markdownIt-Anchor\" href=\"#理由-423\">#</a> 理由</h5>\n<p><code>iostreams</code>  和  <code>printf</code>  风格的 I/O 之间的同步是由代价的。<br>\n <code>cin</code>  和  <code>cout</code>  默认是与  <code>printf</code>  相同步的。</p>\n<h5 id=\"示例-381\"><a class=\"markdownIt-Anchor\" href=\"#示例-381\">#</a> 示例</h5>\n<pre><code>int main()\n&#123;\n    ios_base::sync_with_stdio(false);\n    // ... 使用 iostreams ...\n&#125;\n</code></pre>\n<h5 id=\"强制实施-389\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-389\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerio-endlaslio50-避免使用-endl\"><a class=\"markdownIt-Anchor\" href=\"#a-namerio-endlaslio50-避免使用-endl\">#</a> <a name=\"Rio-endl\"></a>SL.io.50: 避免使用  <code>endl</code></h3>\n<h5 id=\"理由-424\"><a class=\"markdownIt-Anchor\" href=\"#理由-424\">#</a> 理由</h5>\n<p><code>endl</code>  操纵符大致相当于  <code>'\\n'</code>  和  <code>&quot;\\n&quot;</code> ；<br>\n其最常用的情况只不过会以添加多余的  <code>flush()</code>  的方式拖慢程序。<br>\n与  <code>printf</code>  式输出相比，这种拖慢程度是比较显著的。</p>\n<h5 id=\"示例-382\"><a class=\"markdownIt-Anchor\" href=\"#示例-382\">#</a> 示例</h5>\n<pre><code>cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;    // 两次输出操作和一次 flush\ncout &lt;&lt; &quot;hello, World!\\n&quot;;          // 一次输出操作且没有 flush\n</code></pre>\n<h5 id=\"注解-370\"><a class=\"markdownIt-Anchor\" href=\"#注解-370\">#</a> 注解</h5>\n<p>对于  <code>cin</code> / <code>cout</code> （或同等设备）的交互来说，没什么原因必须进行冲洗；它们是自动进行的。<br>\n对于向文件写入来说，也很少需要  <code>flush</code> 。</p>\n<h5 id=\"注解-371\"><a class=\"markdownIt-Anchor\" href=\"#注解-371\">#</a> 注解</h5>\n<p>对于字符串流（指  <code>ostringstream</code> ），插入一个  <code>endl</code>  完全等价于<br>\n插入一个  <code>'\\n'</code>  字符，但正是这种情况下， <code>endl</code>  可能会明显比较慢。</p>\n<p><code>endl</code>  <em>并不</em>关注产生平台专有的行结尾序列（比如 Windows 上的  <code>&quot;\\r\\n&quot;</code> ）。<br>\n因此，字符串流的  <code>s &lt;&lt; endl</code>  只会插入<em>单个</em>  <code>'\\n'</code>  字符。</p>\n<h5 id=\"注解-372\"><a class=\"markdownIt-Anchor\" href=\"#注解-372\">#</a> 注解</h5>\n<p>除了（偶尔会比较重要的）性能问题外，<br>\n从  <code>&quot;\\\\n&quot;</code>  和  <code>endl</code>  之间进行选择基本上完全是审美问题。</p>\n<h2 id=\"a-namess-regexaslregex-正则表达式\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-regexaslregex-正则表达式\">#</a> <a name=\"SS-regex\"></a>SL.regex: 正则表达式</h2>\n<p><code>&lt;regex&gt;</code>  是标准 C++ 的正则表达式库。<br>\n它支持许多正则表达式的模式约定。</p>\n<h2 id=\"a-namess-chronoaslchrono-时间\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-chronoaslchrono-时间\">#</a> <a name=\"SS-chrono\"></a>SL.chrono: 时间</h2>\n<p><code>&lt;chrono&gt;</code> （在命名空间  <code>std::chrono</code>  中定义）提供了  <code>time_point</code>  和  <code>duration</code> ，并同时提供了<br>\n用于以各种不同单位输出时间的函数。<br>\n它还提供了用于注册  <code>time_point</code>  的时钟。</p>\n<h2 id=\"a-namess-clibaslc-c-标准库\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-clibaslc-c-标准库\">#</a> <a name=\"SS-clib\"></a>SL.C: C 标准库</h2>\n<p>???</p>\n<p>C 标准库规则概览：</p>\n<ul>\n<li><a href=\"#Rclib-jmp\">SL.C.1: 请勿使用 setjmp/longjmp</a></li>\n<li><a href=\"#???\">???</a></li>\n<li><a href=\"#???\">???</a></li>\n</ul>\n<h3 id=\"a-namerclib-jmpaslc1-请勿使用-setjmplongjmp\"><a class=\"markdownIt-Anchor\" href=\"#a-namerclib-jmpaslc1-请勿使用-setjmplongjmp\">#</a> <a name=\"Rclib-jmp\"></a>SL.C.1: 请勿使用 setjmp/longjmp</h3>\n<h5 id=\"理由-425\"><a class=\"markdownIt-Anchor\" href=\"#理由-425\">#</a> 理由</h5>\n<p><code>longjmp</code>  会忽略析构函数，由此使得依赖于 RAII 的所有资源管理策略全部失效。</p>\n<h5 id=\"强制实施-390\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-390\">#</a> 强制实施</h5>\n<p>标记出现的所有  <code>longjmp</code>  和  <code>setjmp</code></p>\n<h1 id=\"a-names-aaa-架构设计的观念\"><a class=\"markdownIt-Anchor\" href=\"#a-names-aaa-架构设计的观念\">#</a> <a name=\"S-A\"></a>A: 架构设计的观念</h1>\n<p>本部分包括有关高层次的架构性观念和程序库的观念。</p>\n<p>架构性规则概览：</p>\n<ul>\n<li><a href=\"#Ra-stable\">A.1: 分离稳定的代码和不稳定的代码</a></li>\n<li><a href=\"#Ra-lib\">A.2: 将潜在可复用的部分作为程序库</a></li>\n<li><a href=\"#Ra-dag\">A.4: 程序库之间不能有循环依赖</a></li>\n<li><a href=\"#???\">???</a></li>\n<li><a href=\"#???\">???</a></li>\n<li><a href=\"#???\">???</a></li>\n<li><a href=\"#???\">???</a></li>\n<li><a href=\"#???\">???</a></li>\n<li><a href=\"#???\">???</a></li>\n</ul>\n<h3 id=\"a-namera-stableaa1-分离稳定的代码和不稳定的代码\"><a class=\"markdownIt-Anchor\" href=\"#a-namera-stableaa1-分离稳定的代码和不稳定的代码\">#</a> <a name=\"Ra-stable\"></a>A.1: 分离稳定的代码和不稳定的代码</h3>\n<p>对较不稳定的代码进行隔离，有助于其单元测试，接口改进，重构，以及最终弃用。</p>\n<h3 id=\"a-namera-libaa2-将潜在可复用的部分作为程序库\"><a class=\"markdownIt-Anchor\" href=\"#a-namera-libaa2-将潜在可复用的部分作为程序库\">#</a> <a name=\"Ra-lib\"></a>A.2: 将潜在可复用的部分作为程序库</h3>\n<h5 id=\"理由-426\"><a class=\"markdownIt-Anchor\" href=\"#理由-426\">#</a> 理由</h5>\n<h5 id=\"注解-373\"><a class=\"markdownIt-Anchor\" href=\"#注解-373\">#</a> 注解</h5>\n<p>程序库是一些共同进行维护，文档化，并发布的声明式和定义式的集合体。<br>\n程序库可以是一组头文件（“仅有头文件的程序库”），或者一组头文件加上一组目标文件构成。<br>\n你可以静态或动态地将程序库连接到程序中，或者你还可以  <code>#included</code>  仅头文件的库。</p>\n<h3 id=\"a-namera-dagaa4-程序库之间不能有循环依赖\"><a class=\"markdownIt-Anchor\" href=\"#a-namera-dagaa4-程序库之间不能有循环依赖\">#</a> <a name=\"Ra-dag\"></a>A.4: 程序库之间不能有循环依赖</h3>\n<h5 id=\"理由-427\"><a class=\"markdownIt-Anchor\" href=\"#理由-427\">#</a> 理由</h5>\n<ul>\n<li>循环依赖导致构建过程变得复杂。</li>\n<li>循环依赖难于理解，可能会引入不确定性（未定义行为）。</li>\n</ul>\n<h5 id=\"注解-374\"><a class=\"markdownIt-Anchor\" href=\"#注解-374\">#</a> 注解</h5>\n<p>一个程序库可以在它的组件的定义之间包含循环引用。<br>\n例如：</p>\n<pre><code>???\n</code></pre>\n<p>不过，程序库不能对依赖于它的其他程序库产生依赖。</p>\n<h1 id=\"a-names-notanr-伪规则和错误的看法\"><a class=\"markdownIt-Anchor\" href=\"#a-names-notanr-伪规则和错误的看法\">#</a> <a name=\"S-not\"></a>NR: 伪规则和错误的看法</h1>\n<p>本部分包含一些在不少地方流行的规则和指导方针，但是我们慎重地建议不要采纳它们。<br>\n我们完全了解这些规则曾经在某些时间和场合是有意义的，而且我们自己也曾经采用过它们。<br>\n不过，在我们所推荐并以各项指导方针所支持的编程风格的情况中，这些 “伪规则” 是有害的。</p>\n<p>即便是今天，仍有一些情况下这些规则是有意义的。<br>\n比如说，缺少合适的工具支持会导致异常在硬实时系统中的不适用，<br>\n但请不要盲目地信任 “通俗智慧”（比如有关 “效率” 的未经数据支持的观点）；<br>\n这种 “智慧” 也许是基于几十年前的信息，或者是来自于与 C++ 有非常不同性质的语言的经验<br>\n（比如 C 或者 Java）。</p>\n<p>对于这些伪规则的替代方案的正面观点都在各个规则的 “替代方案” 部分中给出。</p>\n<p>伪规则概览：</p>\n<ul>\n<li><a href=\"#Rnr-top\">NR.1: 请勿坚持认为声明都应当放在函数的最上面</a></li>\n<li><a href=\"#Rnr-single-return\">NR.2: 请勿坚持使函数中只保留一个  <code>return</code>  语句</a></li>\n<li><a href=\"#Rnr-no-exceptions\">NR.3: 请勿避免使用异常</a></li>\n<li><a href=\"#Rnr-lots-of-files\">NR.4: 请勿坚持把每个类定义放在其自己的源文件中</a></li>\n<li><a href=\"#Rnr-two-phase-init\">NR.5: 请勿采用两阶段初始化</a></li>\n<li><a href=\"#Rnr-goto-exit\">NR.6: 请勿把所有清理操作放在函数末尾并使用  <code>goto exit</code> </a></li>\n<li><a href=\"#Rnr-protected-data\">NR.7: 请勿使所有数据成员  <code>protected</code> </a></li>\n<li>???</li>\n</ul>\n<h3 id=\"a-namernr-topanr1-请勿坚持认为声明都应当放在函数的最上面\"><a class=\"markdownIt-Anchor\" href=\"#a-namernr-topanr1-请勿坚持认为声明都应当放在函数的最上面\">#</a> <a name=\"Rnr-top\"></a>NR.1: 请勿坚持认为声明都应当放在函数的最上面</h3>\n<h5 id=\"理由-428\"><a class=\"markdownIt-Anchor\" href=\"#理由-428\">#</a> 理由</h5>\n<p>“所有声明都在开头” 的规则，是来自不允许在语句之后对变量和常量进行初始化的老编程语言的遗产。<br>\n这样做会导致更长的程序，以及更多由于未初始化的或者错误初始化的变量所导致的错误。</p>\n<h5 id=\"示例不好-147\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-147\">#</a> 示例，不好</h5>\n<pre><code>int use(int x)\n&#123;\n    int i;\n    char c;\n    double d;\n\n    // ... 做一些事 ...\n\n    if (x &lt; i) &#123;\n        // ...\n        i = f(x, d);\n    &#125;\n    if (i &lt; x) &#123;\n        // ...\n        i = g(x, c);\n    &#125;\n    return i;\n&#125;\n</code></pre>\n<p>未初始化变量和其使用点的距离越长，出现 BUG 的机会就越大。<br>\n幸运的是，编译器可以发现许多 “设值前使用” 的错误。<br>\n不幸的是，编译器无法捕捉到所有这样的错误，而且一些 BUG 并不都像这个小例子中的这样容易发现。</p>\n<h5 id=\"替代方案-19\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-19\">#</a> 替代方案</h5>\n<ul>\n<li><a href=\"#Res-always\">坚持为对象进行初始化</a>。</li>\n<li><a href=\"#Res-introduce\">ES.21: 不要在确实需要使用变量（或常量）之前就引入它</a>。</li>\n</ul>\n<h3 id=\"a-namernr-single-returnanr2-请勿坚持使函数中只保留一个-return-语句\"><a class=\"markdownIt-Anchor\" href=\"#a-namernr-single-returnanr2-请勿坚持使函数中只保留一个-return-语句\">#</a> <a name=\"Rnr-single-return\"></a>NR.2: 请勿坚持使函数中只保留一个  <code>return</code>  语句</h3>\n<h5 id=\"理由-429\"><a class=\"markdownIt-Anchor\" href=\"#理由-429\">#</a> 理由</h5>\n<p>单返回规则会导致不必要地复杂的代码，并引入多余的状态变量。<br>\n特别是，单返回规则导致更难在函数开头集中进行错误检查。</p>\n<h5 id=\"示例-383\"><a class=\"markdownIt-Anchor\" href=\"#示例-383\">#</a> 示例</h5>\n<pre><code>template&lt;class T&gt;\n//  requires Number&lt;T&gt;\nstring sign(T x)\n&#123;\n    if (x &lt; 0)\n        return &quot;negative&quot;;\n    if (x &gt; 0)\n        return &quot;positive&quot;;\n    return &quot;zero&quot;;\n&#125;\n</code></pre>\n<p>为仅使用一个返回语句，我们得做类似这样的事：</p>\n<pre><code>template&lt;class T&gt;\n//  requires Number&lt;T&gt;\nstring sign(T x)        // 不好\n&#123;\n    string res;\n    if (x &lt; 0)\n        res = &quot;negative&quot;;\n    else if (x &gt; 0)\n        res = &quot;positive&quot;;\n    else\n        res = &quot;zero&quot;;\n    return res;\n&#125;\n</code></pre>\n<p>这不仅更长，而且很可能效率更差。<br>\n越长越复杂的函数，对其进行变通就越是痛苦。<br>\n当然许多简单的函数因为它们本来就简单的逻辑都天然就只有一个  <code>return</code> 。</p>\n<h5 id=\"示例-384\"><a class=\"markdownIt-Anchor\" href=\"#示例-384\">#</a> 示例</h5>\n<pre><code>int index(const char* p)\n&#123;\n    if (!p) return -1;  // 错误指标：替代方案是 &quot;throw nullptr_error&#123;&#125;&quot;\n    // ... 进行查找以找出 p 的索引\n    return i;\n&#125;\n</code></pre>\n<p>如果我们采纳这条规则的话，得做类似这样的事：</p>\n<pre><code>int index2(const char* p)\n&#123;\n    int i;\n    if (!p)\n        i = -1;  // 错误指标\n    else &#123;\n        // ... 进行查找以找出 p 的索引\n    &#125;\n    return i;\n&#125;\n</code></pre>\n<p>注意我们（故意地）违反了禁止未初始化变量的规则，因为这种风格通常都会导致这样。<br>\n而且，这种风格也会倾向于采用 <a href=\"#Rnr-goto-exit\">goto exit</a> 伪规则。</p>\n<h5 id=\"替代方案-20\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-20\">#</a> 替代方案</h5>\n<ul>\n<li>保持函数短小简单。</li>\n<li>随意使用多个  <code>return</code>  语句（以及抛出异常）。</li>\n</ul>\n<h3 id=\"a-namernr-no-exceptionsanr3-请勿避免使用异常\"><a class=\"markdownIt-Anchor\" href=\"#a-namernr-no-exceptionsanr3-请勿避免使用异常\">#</a> <a name=\"Rnr-no-exceptions\"></a>NR.3: 请勿避免使用异常</h3>\n<h5 id=\"理由-430\"><a class=\"markdownIt-Anchor\" href=\"#理由-430\">#</a> 理由</h5>\n<p>一般有四种主要的不用异常的理由：</p>\n<ul>\n<li>异常是低效的</li>\n<li>异常会导致泄漏和错误</li>\n<li>异常的性能无法预测</li>\n<li>异常处理的运行时支持耗费过多空间</li>\n</ul>\n<p>我们没有能够满足所有人的解决这个问题的办法。<br>\n无论如何，针对异常的讨论已经持续了四十多年了。<br>\n一些语言没有异常就无法使用，而另一些并不支持异常。<br>\n这在使用和不使用异常的方面都造成了强大的传统，并导致激烈的争论。</p>\n<p>不过，我们可以简要说明，为什么我们认为对于通用编程以及这里的指导方针的情况来说，<br>\n异常是最佳的候选方案。<br>\n简单的论据，无论支持还是反对，都是缺乏说服力的。<br>\n确实存在一些特殊的应用，其中异常就是不合适的。<br>\n（例如，硬实时系统，且缺乏可靠的对于异常处理的耗费进行估计的支持）。</p>\n<p>我们依次来考虑针对异常的主要反对观点：</p>\n<ul>\n<li>异常是低效的：<br>\n和什么相比？<br>\n当进行比较时，请确保处理了同样的错误集合，并且它们都进行了等价的处理。<br>\n尤其是，不要对一个见到异常就立刻终止的程序和一个在记录错误日志之前<br>\n小心地进行资源清理的程序之间进行比较。<br>\n确实，某些系统的异常处理实现很糟糕；有时候，这样的实现迫使我们使用<br>\n其他错误处理方案，但这并不是异常的基本问题。<br>\n当使用某个有效的论据时 —— 无论什么样的上下文 —— 请小心你能拿出确实提供了所讨论的问题的<br>\n内部情况的健全的数据。</li>\n<li>异常会导致泄漏和错误。<br>\n不会。<br>\n如果你的程序时一大堆乱糟糟的指针而没有总体的资源管理策略，<br>\n那么无论你干什么都会有问题。<br>\n如果你的系统是由上百万行这样的代码构成的，<br>\n那你可能是无法使用异常的，<br>\n不过这是一个有关过度和放纵的使用指针的问题，而不是异常的问题。<br>\n我们的观点是，你需要用 RAII 来让基于异常的错误处理变得简单且安全 —— 比其他方案都要更简单和安全。</li>\n<li>异常的性能无法预测。<br>\n如果你是在硬实时系统上，而你必须确保一个任务要在给定的时间内完成，<br>\n你需要一些工具来支撑这样的保证。<br>\n就我们所知，还没有出现这样的工具（至少对大多数程序员没有）。</li>\n<li>异常处理的运行时支持耗费过多空间<br>\n小型（通常为嵌入式）系统中可能如此。<br>\n不过在放弃异常之前，请考虑采用统一的利用错误码的错误处理将耗费的空间有多少，<br>\n以及错误未被捕获将造成的损失由多少。</li>\n</ul>\n<p>许多（可能是大多数）的和异常有关的问题都源自于需要和杂乱的老代码进行交互的历史性原因。</p>\n<p>而支持使用异常的基本论点是：</p>\n<ul>\n<li>它们把错误返回和普通返回进行了清晰的区分</li>\n<li>它们无法被忘记或忽略</li>\n<li>它们可以系统化地使用</li>\n</ul>\n<p>请记住</p>\n<ul>\n<li>异常是用于报告错误的（C++ 中；其他语言可能有异常的不同用法）。</li>\n<li>异常不是用于可以局部处理的错误的。</li>\n<li>不要试图在每个函数中捕获每一种异常（这样做是冗长的，臃肿的，而且会导致代码缓慢）。</li>\n<li>异常不是用于那些当发生无法恢复的错误之后需要立即终止模块或系统的错误的。</li>\n</ul>\n<h5 id=\"示例-385\"><a class=\"markdownIt-Anchor\" href=\"#示例-385\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"替代方案-21\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-21\">#</a> 替代方案</h5>\n<ul>\n<li><a href=\"#Re-raii\">RAII</a></li>\n<li>契约 / 断言：使用 GSL 的  <code>Expects</code>  和  <code>Ensures</code> （直到对契约的语言支持可以使用）</li>\n</ul>\n<h3 id=\"a-namernr-lots-of-filesanr4-请勿坚持把每个类定义放在其自己的源文件中\"><a class=\"markdownIt-Anchor\" href=\"#a-namernr-lots-of-filesanr4-请勿坚持把每个类定义放在其自己的源文件中\">#</a> <a name=\"Rnr-lots-of-files\"></a>NR.4: 请勿坚持把每个类定义放在其自己的源文件中</h3>\n<h5 id=\"理由-431\"><a class=\"markdownIt-Anchor\" href=\"#理由-431\">#</a> 理由</h5>\n<p>将每个类都放进其自己的文件所导致的文件数量难于管理，并会拖慢编译过程。<br>\n单个的类很少是一种良好的维护和发布的逻辑单位。</p>\n<h5 id=\"示例-386\"><a class=\"markdownIt-Anchor\" href=\"#示例-386\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"替代方案-22\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-22\">#</a> 替代方案</h5>\n<ul>\n<li>使用命名空间来包含逻辑上聚合的类和函数。</li>\n</ul>\n<h3 id=\"a-namernr-two-phase-initanr5-请勿采用两阶段初始化\"><a class=\"markdownIt-Anchor\" href=\"#a-namernr-two-phase-initanr5-请勿采用两阶段初始化\">#</a> <a name=\"Rnr-two-phase-init\"></a>NR.5: 请勿采用两阶段初始化</h3>\n<h5 id=\"理由-432\"><a class=\"markdownIt-Anchor\" href=\"#理由-432\">#</a> 理由</h5>\n<p>将初始化拆分为两步会导致不变式的弱化，<br>\n更复杂的代码（必须处理半构造对象），<br>\n以及错误（当未能一致地正确处理半构造对象时）。</p>\n<h5 id=\"示例不好-148\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-148\">#</a> 示例，不好</h5>\n<pre><code>// 老式传统风格：有许多问题\n\nclass Picture\n&#123;\n    int mx;\n    int my;\n    int * data;\npublic:\n    // 主要问题：构造函数未进行完全构造\n    Picture(int x, int y)\n    &#123;\n        mx = x;         // 也不好：在构造函数体中而非\n                        // 成员初始化式中进行赋值\n        my = y;\n        data = nullptr; // 也不好：在构造函数中而非\n                        // 成员初始化式中进行常量初始化\n    &#125;\n\n    ~Picture()\n    &#123;\n        Cleanup();\n    &#125;\n\n    // ...\n\n    // 不好：两阶段初始化\n    bool Init()\n    &#123;\n        // 不变式检查\n        if (mx &lt;= 0 || my &lt;= 0) &#123;\n            return false;\n        &#125;\n        if (data) &#123;\n            return false;\n        &#125;\n        data = (int*) malloc(mx*my*sizeof(int));   // 也不好：拥有原始指针，还用了 malloc\n        return data != nullptr;\n    &#125;\n\n    // 也不好：没有理由让清理操作作为单独的函数\n    void Cleanup()\n    &#123;\n        if (data) free(data);\n        data = nullptr;\n    &#125;\n&#125;;\n\nPicture picture(100, 0); // 此时 picture 尚未就绪可用\n// 这里将失败\nif (!picture.Init()) &#123;\n    puts(&quot;Error, invalid picture&quot;);\n&#125;\n// 现在有一个无效的 picture 对象实例。\n</code></pre>\n<h5 id=\"示例好-31\"><a class=\"markdownIt-Anchor\" href=\"#示例好-31\">#</a> 示例，好</h5>\n<pre><code>class Picture\n&#123;\n    int mx;\n    int my;\n    vector&lt;int&gt; data;\n\n    static int check_size(int size)\n    &#123;\n        // 不变式检查\n        Expects(size &gt; 0);\n        return size;\n    &#125;\n\npublic:\n    // 更好的方式是以一个 2D 的 Size 类作为单个形参\n    Picture(int x, int y)\n        : mx(check_size(x))\n        , my(check_size(y))\n        // 现在已知 x 和 y 为有效的大小\n        , data(mx * my) // 出错时将抛出 std::bad_alloc\n    &#123;\n        // 图片就绪可用\n    &#125;\n\n    // 编译器生成的析构函数会完成工作。（另见 C.21）\n\n    // ...\n&#125;;\n\nPicture picture1(100, 100);\n// picture1 已就绪可用……\n\n// y 并非有效大小值，\n// 缺省的契约违规行为将会调用 std::terminate\nPicture picture2(100, 0);\n// 不会抵达这里……\n</code></pre>\n<h5 id=\"替代方案-23\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-23\">#</a> 替代方案</h5>\n<ul>\n<li>始终在构造函数中建立类不变式。</li>\n<li>不要在需要对象之前就定义它。</li>\n</ul>\n<h3 id=\"a-namernr-goto-exitanr6-请勿把所有清理操作放在函数末尾并使用-goto-exit\"><a class=\"markdownIt-Anchor\" href=\"#a-namernr-goto-exitanr6-请勿把所有清理操作放在函数末尾并使用-goto-exit\">#</a> <a name=\"Rnr-goto-exit\"></a>NR.6: 请勿把所有清理操作放在函数末尾并使用  <code>goto exit</code></h3>\n<h5 id=\"理由-433\"><a class=\"markdownIt-Anchor\" href=\"#理由-433\">#</a> 理由</h5>\n<p><code>goto</code>  是易错的。<br>\n这种技巧是进行 RAII 式的资源和错误处理的前异常时代的技巧。</p>\n<h5 id=\"示例不好-149\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-149\">#</a> 示例，不好</h5>\n<pre><code>void do_something(int n)\n&#123;\n    if (n &lt; 100) goto exit;\n    // ...\n    int* p = (int*) malloc(n);\n    // ...\n    if (some_error) goto_exit;\n    // ...\nexit:\n    free(p);\n&#125;\n</code></pre>\n<p>请找出其中的 BUG。</p>\n<h5 id=\"替代方案-24\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-24\">#</a> 替代方案</h5>\n<ul>\n<li>使用异常和 <a href=\"#Re-raii\">RAII</a></li>\n<li>对于非 RAII 资源，使用 <a href=\"#Re-finally\"> <code>finally</code> </a>。</li>\n</ul>\n<h3 id=\"a-namernr-protected-dataanr7-请勿使所有数据成员-protected\"><a class=\"markdownIt-Anchor\" href=\"#a-namernr-protected-dataanr7-请勿使所有数据成员-protected\">#</a> <a name=\"Rnr-protected-data\"></a>NR.7: 请勿使所有数据成员  <code>protected</code></h3>\n<h5 id=\"理由-434\"><a class=\"markdownIt-Anchor\" href=\"#理由-434\">#</a> 理由</h5>\n<p><code>protected</code>  数据是一种错误来源。<br>\n <code>protected</code>  数据可以被各种地方的无界限数量的代码所操纵。<br>\n <code>protected</code>  数据是在类层次中等价于全局对象的东西。</p>\n<h5 id=\"示例-387\"><a class=\"markdownIt-Anchor\" href=\"#示例-387\">#</a> 示例</h5>\n<pre><code>???\n</code></pre>\n<h5 id=\"替代方案-25\"><a class=\"markdownIt-Anchor\" href=\"#替代方案-25\">#</a> 替代方案</h5>\n<ul>\n<li><a href=\"#Rh-protected\">使成员数据  <code>public</code>  或者（更好地） <code>private</code> </a>。</li>\n</ul>\n<h1 id=\"a-names-referencesarf-参考材料\"><a class=\"markdownIt-Anchor\" href=\"#a-names-referencesarf-参考材料\">#</a> <a name=\"S-references\"></a>RF: 参考材料</h1>\n<p>已经为 C++，尤其是对 C++ 的使用编写过了许多的编码标准、规则和指导方针。<br>\n它们中许多都</p>\n<ul>\n<li>关注的是低级问题，比如标识符的拼写</li>\n<li>是由 C++ 的新手编写的</li>\n<li>将 “禁止程序员作出不常见行为” 作为其首要目标</li>\n<li>将维持许多编译器的可移植性作为目标（有些已经是 10 年前的了）</li>\n<li>是为了维持好几十年的代码库而编写的</li>\n<li>是仅关注单一的应用领域的</li>\n<li>只会产生反效果</li>\n<li>被忽略了（程序员为了完成工作不得不忽略它们）</li>\n</ul>\n<p>不良的编码标准要比没有编码标准还要差。<br>\n不过一组恰当的指导方针比没有标准要好得多：“形式即解放。”</p>\n<p>我们为什么不能有一种允许所有我们想要的同时又禁止所有我们不期望的东西的语言（“完美的语言”）呢？<br>\n本质上说，这是由于可负担的语言（及其工具链）同时也要为那些需求与你不同的人提供服务，并且要为你今后比今天更多的需求提供服务。<br>\n而且，你的需求会随时间而改变，而为此你则需要采用一种通用语言。<br>\n今日貌似理想的语言在未来可能会变得过于受限了。</p>\n<p>编码指导方针可以使语言能够适应于特定的需求。<br>\n因此，并不存在适用于每个人的单一编码风格。<br>\n我们预计不同的组织会提供更具限制性和更严格的编码风格附加规定。</p>\n<p>参考材料部分：</p>\n<ul>\n<li><a href=\"#SS-rules\">RF.rules: 编码规则</a></li>\n<li><a href=\"#SS-books\">RF.books: 带有编码指导方针的书籍</a></li>\n<li><a href=\"#SS-Cplusplus\">RF.C++: C++ 编程 (C<ins>11/C</ins>14/C++17)</a></li>\n<li><a href=\"#SS-web\">RF.web: 网站</a></li>\n<li><a href=\"#SS-vid\">RS.video: 有关 “当代 C++” 的视频</a></li>\n<li><a href=\"#SS-man\">RF.man: 手册</a></li>\n<li><a href=\"#SS-core\">RF.core: 核心指导方针相关材料</a></li>\n</ul>\n<h2 id=\"a-namess-rulesarfrules-编码规则\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-rulesarfrules-编码规则\">#</a> <a name=\"SS-rules\"></a>RF.rules: 编码规则</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYXV0b3Nhci5vcmcvZmlsZWFkbWluL3VzZXJfdXBsb2FkL3N0YW5kYXJkcy9hZGFwdGl2ZS8xNy0xMC9BVVRPU0FSX1JTX0NQUDE0R3VpZGVsaW5lcy5wZGY=\">AUTOSAR Guidelines for the use of the C++14 language in critical and safety-related systems v17.10</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ib29zdC5vcmcvZGV2ZWxvcG1lbnQvcmVxdWlyZW1lbnRzLmh0bWw=\">Boost Library Requirements and Guidelines</span>.<br>\n???.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Jsb29tYmVyZy9iZGUvd2lraS9Db2RpbmdTdGFuZGFyZHMucGRm\">Bloomberg: BDE C++ Coding</span>.<br>\n 着重强调了代码的组织和布局。</li>\n<li>Facebook: ???</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9nY2MuZ251Lm9yZy9jb2Rpbmdjb252ZW50aW9ucy5odG1s\">GCC Coding Conventions</span>.<br>\nC++03 以及（相当）一部分向后兼容。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL3N0eWxlZ3VpZGUvY3BwZ3VpZGUuaHRtbA==\">Google C++ Style Guide</span>.<br>\n 面向 C++17 和（同样）较老的代码库。Google 的专家们现在正展开活跃的合作，以改进这里的各项指导方针，有希望能够合并这些成果，以使它们能够成为他们也同样推荐采纳的一组现代的通用指导方针。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9KU0YtQVYtcnVsZXMucGRm\">JSF++: JOINT STRIKE FIGHTER AIR VEHICLE C++ CODING STANDARDS</span>.<br>\n 文档编号 2RDU00001 Rev C. December 2005.<br>\n 针对飞行控制软件。<br>\n针对硬实时。<br>\n这意味着它需要非常多的限制（“程序如果发生故障就会有人挂掉”）。<br>\n例如，飞机起飞后禁止进行任何自由存储的分配和回收（禁止内存溢出并禁止发生碎片化）。<br>\n禁止使用异常（因为没有可用工具可以保证异常能够在固定的短时间段内被处理）。<br>\n所使用的程序库必须是已被证明可以用于关键任务应用的。<br>\n它和这个指导方针集合的相似性并不让人惊讶，因为 Bjarne Stroustrup 正是 JSF++ 的作者之一。<br>\n建议采纳，但请注意其非常特定的关注领域。</li>\n<li>[MISRA C++ 2008: Guidelines for the use of the C++ language in critical systems] (<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWlzcmEub3JnLnVrL0J1eW9ubGluZS90YWJpZC81OC9EZWZhdWx0LmFzcHg=\">https://www.misra.org.uk/Buyonline/tabid/58/Default.aspx</span>)。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9maXJlZm94LXNvdXJjZS1kb2NzLm1vemlsbGEub3JnL2NvZGUtcXVhbGl0eS9jb2Rpbmctc3R5bGUvdXNpbmdfY3h4X2luX2ZpcmVmb3hfY29kZS5odG1s\">Using C++ in Mozilla Code</span>.<br>\n 如其名称所示，它关注于跨许多（老）编译器的兼容性。<br>\n因此，它是很具有限制性的。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2dlb3NvZnQubm8vZGV2ZWxvcG1lbnQvY3Bwc3R5bGUuaHRtbA==\">Geosoft.no: C++ Programming Style Guidelines</span>.<br>\n???.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5wb3NzaWJpbGl0eS5jb20vQ3BwL0NwcENvZGluZ1N0YW5kYXJkLmh0bWw=\">Possibility.com: C++ Coding Standard</span>.<br>\n???.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLnNlaS5jbXUuZWR1L2NvbmZsdWVuY2UveC9XbnctQlE=\">SEI CERT: Secure C++ Coding Standard</span>.<br>\n 针对安全关键代码所编写的一组非常好的规则（还带有示例和原理说明）。<br>\n它们的许多规则都广泛适用。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jb2RpbmdzdGFuZGFyZC5jb20v\">High Integrity C++ Coding Standard</span>.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29kaW5nU3RhbmRhcmRzLmh0bWw=\">llvm</span>.<br>\n 有些简略，基于 C++14，而且是（有理由地）针对其应用领域的。</li>\n<li>???</li>\n</ul>\n<h2 id=\"a-namess-booksarfbooks-带有编码指导方针的书籍\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-booksarfbooks-带有编码指导方针的书籍\">#</a> <a name=\"SS-books\"></a>RF.books: 带有编码指导方针的书籍</h2>\n<ul>\n<li><a href=\"#Meyers96\">Meyers96</a> Scott Meyers: <em>More Effective C++</em>. Addison-Wesley 1996.</li>\n<li><a href=\"#Meyers97\">Meyers97</a> Scott Meyers: <em>Effective C++, Second Edition</em>. Addison-Wesley 1997.</li>\n<li><a href=\"#Meyers01\">Meyers01</a> Scott Meyers: <em>Effective STL</em>. Addison-Wesley 2001.</li>\n<li><a href=\"#Meyers05\">Meyers05</a> Scott Meyers: <em>Effective C++, Third Edition</em>. Addison-Wesley 2005.</li>\n<li><a href=\"#Meyers15\">Meyers15</a> Scott Meyers: <em>Effective Modern C++</em>. O’Reilly 2015.</li>\n<li><a href=\"#SuttAlex05\">SuttAlex05</a> Sutter and Alexandrescu: <em>C++ Coding Standards</em>. Addison-Wesley 2005. 与其说是一组规则，不如说是一组元规则。前 C++11 时代。</li>\n<li><a href=\"#Stroustrup05\">Stroustrup05</a> Bjarne Stroustrup: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9TRUxMcmF0aW9uYWxlLnBkZg==\">A rationale for semantically enhanced library languages</span>.<br>\nLCSD05. October 2005.</li>\n<li><a href=\"#Stroustrup05\">Stroustrup14</a> Stroustrup: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9Ub3VyLmh0bWw=\">A Tour of C++</span>.<br>\nAddison Wesley 2014.<br>\n 每章的结尾都有一个包含一组建议的忠告部分。</li>\n<li><a href=\"#Stroustrup13\">Stroustrup13</a> Stroustrup: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS80dGguaHRtbA==\">The C++ Programming Language (4th Edition)</span>.<br>\nAddison Wesley 2013.<br>\n 每章的结尾都有一个包含一组建议的忠告部分。</li>\n<li>Stroustrup: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9Qcm9ncmFtbWluZy9QUFAtc3R5bGUucGRm\">Style Guide</span><br>\nfor <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9wcm9ncmFtbWluZy5odG1s\">Programming: Principles and Practice using C++</span>.<br>\n 大多是一些低级的命名和代码布局规则。<br>\n主要作为教学工具。</li>\n</ul>\n<h2 id=\"a-namess-cplusplusarfc-c-编程-c11c14\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-cplusplusarfc-c-编程-c11c14\">#</a> <a name=\"SS-Cplusplus\"></a>RF.C++: C++ 编程 (C<ins>11/C</ins>14)</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS80dGguaHRtbA==\">TC++PL4</span>:<br>\n 面向有经验的程序员的，对 C++ 语言和标准库的全面彻底的描述。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9Ub3VyLmh0bWw=\">Tour++</span>:<br>\n 面向有经验的程序员的，对 C++ 语言和标准库的简介。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9wcm9ncmFtbWluZy5odG1s\">Programming: Principles and Practice using C++</span>:<br>\n 面向初学者和新手们的教材。</li>\n</ul>\n<h2 id=\"a-namess-webarfweb-网站\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-webarfweb-网站\">#</a> <a name=\"SS-web\"></a><span class=\"exturl\" data-url=\"aHR0cDovL1JGLndlYg==\">RF.web</span>: 网站</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pc29jcHAub3Jn\">isocpp.org</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbQ==\">Bjarne Stroustrup 的个人主页</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcGVuLXN0ZC5vcmcvanRjMS9zYzIyL3dnMjEv\">WG21</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ib29zdC5vcmc=\">Boost</span><a name=\"Boost\"></a></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVuc291cmNlLmFkb2JlLmNvbS8=\">Adobe open source</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3BvY29wcm9qZWN0Lm9yZy8=\">Poco libraries</span></li>\n<li>Sutter’s Mill?</li>\n<li>???</li>\n</ul>\n<h2 id=\"a-namess-vidarsvideo-有关当代-c的视频\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-vidarsvideo-有关当代-c的视频\">#</a> <a name=\"SS-vid\"></a>RS.video: 有关 “当代 C++” 的视频</h2>\n<ul>\n<li>Bjarne Stroustrup: <span class=\"exturl\" data-url=\"aHR0cDovL2NoYW5uZWw5Lm1zZG4uY29tL0V2ZW50cy9Hb2luZ05hdGl2ZS9Hb2luZ05hdGl2ZS0yMDEyL0tleW5vdGUtQmphcm5lLVN0cm91c3RydXAtQ3BwMTEtU3R5bGU=\">C++11?Style</span>. 2012.</li>\n<li>Bjarne Stroustrup: <a href=\"http://channel9.msdn.com/Events/GoingNative/2013/Opening-Keynote-Bjarne-Stroustrup\">The Essence of C++: With Examples in C<ins>84, C</ins>98, C<ins>11, and?C</ins>14</a>. 2013</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pc29jcHAub3JnL2Jsb2cvMjAxNC8xMS9jcHBjb24tdmlkZW9zLWM5\">CppCon '14</span> 的全部演讲</li>\n<li>Bjarne Stroustrup: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj04NnhXVmI0WEl5RQ==\">The essence of C++</span> 在爱丁堡大学。2014</li>\n<li>Bjarne Stroustrup: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1fd3pjN2EzTWNPcw==\">The Evolution of C++ Past, Present and Future</span>. CppCon 2016 keynote.</li>\n<li>Bjarne Stroustrup: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1uZXNDYW9jTmp0UQ==\">Make Simple Tasks Simple!</span>. CppCon 2014 keynote.</li>\n<li>Bjarne Stroustrup: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj0xT0V1OUM1MUsyQQ==\">Writing Good C++14</span>. CppCon 2015 keynote about the Core Guidelines.</li>\n<li>Herb Sutter: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1oRXg1RE5MV0dnQQ==\">Writing Good C++14… By Default</span>. CppCon 2015 keynote about the Core Guidelines.</li>\n<li>CppCon 15</li>\n<li>??? C++ Next</li>\n<li>??? Meting C++</li>\n<li>??? more ???</li>\n</ul>\n<h2 id=\"a-namess-manarfman-手册\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-manarfman-手册\">#</a> <a name=\"SS-man\"></a>RF.man: 手册</h2>\n<ul>\n<li>ISO C++ Standard C++11.</li>\n<li>ISO C++ Standard C++14.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcGVuLXN0ZC5vcmcvanRjMS9zYzIyL3dnMjEvZG9jcy9wYXBlcnMvMjAxNi9uNDYwNi5wZGY=\">ISO C++ Standard C++17</span>. 委员会草案。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcGVuLXN0ZC5vcmcvanRjMS9zYzIyL3dnMjEvZG9jcy9wYXBlcnMvMjAxMi9uMzM1MS5wZGY=\">Palo Alto “Concepts” TR</span>.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcGVuLXN0ZC5vcmcvanRjMS9zYzIyL3dnMjEvZG9jcy9wYXBlcnMvMjAxNS9uNDU1My5wZGY=\">ISO C++ Concepts TS</span>.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcGVuLXN0ZC5vcmcvanRjMS9zYzIyL3dnMjEvZG9jcy9wYXBlcnMvMjAxNi9uNDU2OS5wZGY=\">WG21 Ranges report</span>. 草案。</li>\n</ul>\n<h2 id=\"a-namess-corearfcore-核心指导方针相关材料\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-corearfcore-核心指导方针相关材料\">#</a> <a name=\"SS-core\"></a>RF.core: 核心指导方针相关材料</h2>\n<p>这个部分包含一些用于展示核心指导方针及其背后的思想的有用材料：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2lzb2NwcC9DcHBDb3JlR3VpZGVsaW5lcy90cmVlL21hc3Rlci9kb2Nz\">Our documents directory</span></li>\n<li>Stroustrup, Sutter, and Dos Reis: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9yZXNvdXJjZS1tb2RlbC5wZGY=\">A brief introduction to C++’s model for type- and resource-safety</span>. A paper with lots of examples.</li>\n<li>Sergey Zubkov: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1EeUx3ZGxfNnZtVQ==\">a Core Guidelines talk</span><br>\nand here are the <span class=\"exturl\" data-url=\"aHR0cDovLzIwMTcuY3BwY29uZi5ydS90YWxrcy9zZXJnZXktenVia292\">slides</span>. In Russian. 2017.</li>\n<li>Neil MacIntosh: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1fR2hObkN1YUVqbw==\">The Guideline Support Library: One Year Later</span>. CppCon 2016.</li>\n<li>Bjarne Stroustrup: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj0xT0V1OUM1MUsyQQ==\">Writing Good C++14</span>. CppCon 2015 keynote.</li>\n<li>Herb Sutter: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1oRXg1RE5MV0dnQQ==\">Writing Good C++14… By Default</span>. CppCon 2015 keynote.</li>\n<li>Peter Sommerlad: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1mUTkyNnY0WnpBTQ==\">C++ Core Guidelines - Modernize your C++ Code Base</span>. ACCU 2017.</li>\n<li>Bjarne Stroustrup: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj0wMXpJOWtWNGg4Yw==\">No Littering!</span>. Bay Area ACCU 2016.<br>\nIt gives some idea of the ambition level for the Core uidelines.</li>\n</ul>\n<p>CppCon 的展示的幻灯片是可以获得的（其链接，还有上传的视频）。</p>\n<p>极大欢迎对于这个列表的贡献。</p>\n<h2 id=\"a-namess-acka鸣谢\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-acka鸣谢\">#</a> <a name=\"SS-ack\"></a>鸣谢</h2>\n<p>感谢对规则、建议、支持信息和参考材料等等作出了各种贡献的许多人：</p>\n<ul>\n<li>Peter Juhl</li>\n<li>Neil MacIntosh</li>\n<li>Axel Naumann</li>\n<li>Andrew Pardoe</li>\n<li>Gabriel Dos Reis</li>\n<li>Zhuang, Jiangang (Jeff)</li>\n<li>Sergey Zubkov</li>\n</ul>\n<p>请查看 github 的贡献者列表。</p>\n<h1 id=\"a-names-profileapro-剖面配置\"><a class=\"markdownIt-Anchor\" href=\"#a-names-profileapro-剖面配置\">#</a> <a name=\"S-profile\"></a>Pro: 剖面配置</h1>\n<p>理想情况，我们应当遵循所有这些指导方针。<br>\n这样能够得到最简洁，最规范，最少易错性，而且通常是最快的代码。<br>\n不幸的是这通常是不可能的，因为我们不得不让代码适合于大型的代码库并使用一些现存的程序库。<br>\n常常是，这样的代码已经编写好几十年了，并且并不遵循这些指导方针。<br>\n我们必须以<a href=\"#S-modernizing\">渐次采纳</a>为目标。</p>\n<p>无论采用何种渐次采纳的策略，我们都应当能够首先采用一些相关指导方针的集合来<br>\n处理某些问题的集合，遗留其他的以后处理。<br>\n当发现某些而不是全部的指导方针对于代码库有关时，以及当在某个专门化的应用领域<br>\n采用一组专门化的指导方针的集合时，会出现类似的 “相关指导方针” 的主意。<br>\n我们称这样的相关指导方针的集合为一个 “剖面配置”。<br>\n我们对这种指导方针集合的目标是其内聚性，它们一起可以有助于我们达成某个特定的目标，如 “消除范围错误”<br>\n 或 “静态类型安全性”。<br>\n每个剖面配置都被设计用于消除一个类别的错误。<br>\n而 “随意” 实施一些独立的规则，相对于提供确定的改善来说，更像是对代码库的破坏。</p>\n<p>“剖面配置” 是确定的并且可移植实施的规则（限制）子集，它们是专门设计以达成某项特定保证的。<br>\n“确定性” 意味着它们仅需要进行局部分析，并且可以在一台计算机中进行实现（虽然并不比如此）。<br>\n“可移植实施性” 表明它们和语言规则相似，因而程序员们可以期望不同实施工具对于相同的代码给出相同的答案。</p>\n<p>编写成在这样的语言剖面配置下仍免于警告的代码，可以认为是遵循这个剖面配置的。<br>\n而遵从的代码则可以认为对于该剖面配置的目标安全属性来说是安全的。<br>\n遵从的代码不会成为这种性质的错误的根本原因，<br>\n虽然程序中可能从其他的代码引入这样的错误。<br>\n剖面配置还可能会引入一些额外的库类型，以简化遵从性并鼓励编写正确的代码。</p>\n<p>剖面配置概览：</p>\n<ul>\n<li><a href=\"#SS-type\">Pro.type: 类型安全性</a></li>\n<li><a href=\"#SS-bounds\">Pro.bounds: 边界安全性</a></li>\n<li><a href=\"#SS-lifetime\">Pro.lifetime: 生存期安全性</a></li>\n</ul>\n<p>未来，我们打算定义更多的剖面配置，并向现有剖面配置中添加更多的检查。<br>\n候选者有：</p>\n<ul>\n<li>窄化算术提升和转换（可能会成为一个单独的安全算术剖面配置的一部分）</li>\n<li>从负浮点数向无符号整型类型进行算术强制转换（同上）</li>\n<li>经选择的未定义行为：从 Gabriel Dos Reis 为 WG21 研究小组开发的 UB 列表入手</li>\n<li>经选择的未指明行为：处理可移植性问题。</li>\n<li><code>const</code>  违反：大多数情况已经由编译器完成，但我们可以捕捉不适当的强制转换和  <code>const</code>  的不当使用。</li>\n</ul>\n<p>剖面配置的开启是由实现所定义的；典型情况下，是在分析工具之中进行的设置。</p>\n<p>要抑制对某个剖面配置检查，可以在语言构造上放一个  <code>suppress</code>  标注。例如：</p>\n<pre><code>[[suppress(bounds)]] char* raw_find(char* p, int n, char x)    // 在 p[0]..p[n - 1] 中寻找 x\n&#123;\n    // ...\n&#125;\n</code></pre>\n<p>这样  <code>raw_find()</code>  就可以在内存中到处爬了。<br>\n显然，进行抑制应当是非常罕见的。</p>\n<h2 id=\"a-namess-typeaprosafety-类型安全性剖面配置\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-typeaprosafety-类型安全性剖面配置\">#</a> <a name=\"SS-type\"></a>Pro.safety: 类型安全性剖面配置</h2>\n<p>这个剖面配置将能够简化正确使用类型的代码编写，并避免因疏忽产生类型双关。<br>\n它是关注于移除各种主要的类型违例的因素（包括对强制转换和联合的不安全使用）而达成这点的。</p>\n<p>针对本部分的目的而言，<br>\n类型安全性被定义为这样的性质：对变量的使用不会不遵守其所定义的类型的规则。<br>\n通过类型  <code>T</code>  所访问的内存，不应该是某个实际上包含了无关类型  <code>U</code>  的对象的有效内存。<br>\n注意，当和<a href=\"#SS-bounds\">边界安全性</a>、<a href=\"#SS-lifetime\">生存期安全性</a>组合起来时，安全性才是完整的。</p>\n<p>这个剖面配置的实现应当在源代码中识别出下列模式，将之作为不符合并给出诊断信息。</p>\n<p>类型安全性剖面配置概览：</p>\n<ul>\n<li>\n<p><a name=\"Pro-type-avoidcasts\"></a>Type.1: <a href=\"#Res-casts\">避免强制转换</a>：</p>\n<ol>\n<li><a name=\"Pro-type-reinterpretcast\"></a>请勿使用  <code>reinterpret_cast</code> ；此为<a href=\"#Res-casts\">避免强制转换</a>和<a href=\"#Res-casts-named\">优先使用具名的强制转换</a>的严格的版本。</li>\n<li><a name=\"Pro-type-arithmeticcast\"></a>请勿在算术类型上使用  <code>static_cast</code> ；此为<a href=\"#Res-casts\">避免强制转换</a>和<a href=\"#Res-casts-named\">优先使用具名的强制转换</a>的严格的版本。</li>\n<li><a name=\"Pro-type-identitycast\"></a>当源指针类型和目标类型相同时，请勿进行指针强制转换；此为<a href=\"#Res-casts\">避免强制转换</a>的严格的版本。</li>\n<li><a name=\"Pro-type-implicitpointercast\"></a>当指针转换可以隐式转换时，请勿使用指针强制转换；此为<a href=\"#Res-casts\">避免强制转换</a>的严格的版本。</li>\n</ol>\n</li>\n<li>\n<p><a name=\"Pro-type-downcast\"></a>Type.2: 请勿使用  <code>static_cast</code>  进行向下强制转换：<br>\n<a href=\"#Rh-dynamic_cast\">代之以使用  <code>dynamic_cast</code> </a>。</p>\n</li>\n<li>\n<p><a name=\"Pro-type-constcast\"></a>Type.3: 请勿使用  <code>const_cast</code>  强制掉  <code>const</code> （亦即不要这样做）：<br>\n<a href=\"#Res-casts-const\">不要强制掉  <code>const</code> </a>。</p>\n</li>\n<li>\n<p><a name=\"Pro-type-cstylecast\"></a>Type.4: 请勿使用  C 风格的强制转换  <code>(T)expression</code>  和函数式风格强制转换  <code>T(expression)</code> ：<br>\n优先使用<a href=\"#Res-construct\">构造语法</a>，<a href=\"#Res-casts-named\">具名的强制转换</a>，或  <code>T&#123;expression&#125;</code> 。</p>\n</li>\n<li>\n<p><a name=\"Pro-type-init\"></a>Type.5: 请勿在初始化之前使用变量：<br>\n<a href=\"#Res-always\">坚持进行初始化</a>。</p>\n</li>\n<li>\n<p><a name=\"Pro-type-memberinit\"></a>Type.6: 坚持初始化成员变量：<br>\n<a href=\"#Res-always\">坚持进行初始化</a>，<br>\n可以采用<a href=\"#Rc-default0\">默认构造函数</a>或者<br>\n<a href=\"#Rc-in-class-initializer\">默认成员初始化式</a>。</p>\n</li>\n<li>\n<p><a name=\"Pro-type-union\"></a>Type.7: 避免裸 union：<br>\n<a href=\"#Ru-naked\">代之以使用  <code>variant</code> </a>。</p>\n</li>\n<li>\n<p><a name=\"Pro-type-varargs\"></a>Type.8: 避免 varargs：<br>\n<a href=\"#F-varargs\">不要使用  <code>va_arg</code>  参数</a>。</p>\n</li>\n</ul>\n<h5 id=\"影响\"><a class=\"markdownIt-Anchor\" href=\"#影响\">#</a> 影响</h5>\n<p>在类型安全性剖面配置下，你可以相信每个操作都将在有效的对象上进行。<br>\n可能抛出异常以报告无法（在编译时）被静态地检测到的错误。<br>\n要注意的是，这种类型安全性仅当我们同样具有<a href=\"#SS-bounds\">边界安全性</a>和<a href=\"#SS-lifetime\">生存期安全性</a>时才是完整的。<br>\n而没有这些保证的话，一个内存区域可能以与其所存储的单个或多个对象，或对象的一部分无关的方式被访问。</p>\n<h2 id=\"a-namess-boundsaprobounds-边界安全性剖面配置\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-boundsaprobounds-边界安全性剖面配置\">#</a> <a name=\"SS-bounds\"></a>Pro.bounds: 边界安全性剖面配置</h2>\n<p>这个剖面配置将能简化对于在分配的内存块的边界之中进行操作的编码工作。<br>\n它是通过关注于移除边界违例的主要根源 —— 即指针算术和数组索引 —— 而做到这点的。<br>\n这个剖面配置的核心功能之一就是限制指针只能指向单个对象而不是数组。</p>\n<p>我们将边界安全性定义为这样一种性质：程序不通过一个对象来对分配给这个对象的内存范围之外的内存进行访问。<br>\n仅当边界安全性与<a href=\"#SS-type\">类型安全性</a>和<a href=\"#SS-lifetime\">生存期安全性</a>组合起来时才是完整的，<br>\n它们还会包含其他允许发生边界违例的不安全操作。</p>\n<p>边界安全性剖面配置概览：</p>\n<ul>\n<li><a name=\"Pro-bounds-arithmetic\"></a>Bounds.1: 请勿使用指针算术。请使用  <code>span</code>  代替：<br>\n<a href=\"#Ri-array\">（仅）传递单个对象的指针</a>，并<a href=\"#Res-ptr\">保持指针算术的简单性</a>。</li>\n<li><a name=\"Pro-bounds-arrayindex\"></a>Bounds.2: 仅使用常量表达式对数组进行索引操作：<br>\n<a href=\"#Ri-array\">（仅）传递单个对象的指针</a>，并<a href=\"#Res-ptr\">保持指针算术的简单性</a>。</li>\n<li><a name=\"Pro-bounds-decay\"></a>Bounds.3: 避免数组向指针的退化：<br>\n<a href=\"#Ri-array\">（仅）传递单个对象的指针</a>，并<a href=\"#Res-ptr\">保持指针算术的简单性</a>。</li>\n<li><a name=\"Pro-bounds-stdlib\"></a>Bounds.4: 请勿使用不进行边界检查的标准库函数和类型：<br>\n<a href=\"#Rsl-bounds\">以类型安全的方式使用标准库</a></li>\n</ul>\n<h5 id=\"影响-2\"><a class=\"markdownIt-Anchor\" href=\"#影响-2\">#</a> 影响</h5>\n<p>边界安全性意味着，当访问对象（尤其是数组）时不会越过对象的内存分配范围。<br>\n这消除了一大类的隐伏且难于发现的错误，包括（不）著名的 “缓冲区溢出” 错误。<br>\n这避免了安全漏洞，以及（当越界写入时发生）内存损坏错误的大量来源。<br>\n即使越界访问 “只是读取操作”，它也可能导致不变式的违反（当所访问的不是预期的类型时）<br>\n和 “神秘的值”。</p>\n<h2 id=\"a-namess-lifetimeaprolifetime-生存期安全性剖面配置\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-lifetimeaprolifetime-生存期安全性剖面配置\">#</a> <a name=\"SS-lifetime\"></a>Pro.lifetime: 生存期安全性剖面配置</h2>\n<p>通过已经不指向任何东西的指针进行访问，是错误的一种主要来源，<br>\n而且在许多传统的 C 或 C++ 风格的编程中这很难避免。<br>\n例如，指针可能未初始化，值为  <code>nullptr</code> ，指向越过指针范围，或者指向已删除的对象。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2lzb2NwcC9DcHBDb3JlR3VpZGVsaW5lcy9ibG9iL21hc3Rlci9kb2NzL0xpZmV0aW1lLnBkZg==\">参见此处的设计说明书的当前版本</span></p>\n<p>生存期安全性剖面配置概览：</p>\n<ul>\n<li><a name=\"Pro-lifetime-invalid-deref\"></a>Lifetime.1: 不要解引用无效指针：<br>\n<a href=\"#Res-deref\">检测或避免</a>。</li>\n</ul>\n<h5 id=\"影响-3\"><a class=\"markdownIt-Anchor\" href=\"#影响-3\">#</a> 影响</h5>\n<p>一旦强制实施了编码风格规则，静态分析，以及程序库支持的组合方案之后，本剖面配置将能</p>\n<ul>\n<li>消除 C++ 中的恶劣错误的一种主要来源</li>\n<li>消除潜在安全漏洞的一种主要来源</li>\n<li>通过消除多余的 “偏执” 检查而改善性能</li>\n<li>提升代码正确性的信心</li>\n<li>通过强制遵循一种关键的 C++ 语言规则而避免未定义的行为</li>\n</ul>\n<h1 id=\"a-names-gslagsl-指导方针支持库\"><a class=\"markdownIt-Anchor\" href=\"#a-names-gslagsl-指导方针支持库\">#</a> <a name=\"S-gsl\"></a>GSL: 指导方针支持库</h1>\n<p>GSL 是一个小型的程序库，其中的设施被设计用于支持本指导方针。<br>\n不使用这些设施的话，这些指导方针不得不变得对语言细节过于限制。</p>\n<p>核心指导方针支持库是定义在  <code>gsl</code>  命名空间中的，其中的名字可能是对标准库和其他著名程序库的名字的别名。通过  <code>gsl</code>  命名空间进行的（编译期）间接，使我们可以进行试验，以及对这些支持设施提供局部变体。</p>\n<p>GSL 只有头文件，可以在 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9HU0w=\">GSL: 指导方针支持库</span>找到。<br>\n支持库中的设施被设计为极为轻量化（零开销），它们相比于传统方案并不会带来任何开销。<br>\n当需要时，它们还可以用其他功能 “工具化”（比如一些检查）来帮助进行诸如调试等任务。</p>\n<p>各指导方针中，除了使用 GSL 中的类型之外，还使用了标准程序库（如 C++17）中的类型。<br>\n例如，我们假定有一个  <code>variant</code>  类型，但它当前尚未在 GSL 中。<br>\n总之，请使用<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcGVuLXN0ZC5vcmcvanRjMS9zYzIyL3dnMjEvZG9jcy9wYXBlcnMvMjAxNi9wMDA4OHIzLmh0bWw=\">通过表决进入 C++17 的版本</span>。</p>\n<p>由于诸如当前 C++ 版本的限制等技术原因，您所使用的程序库中可能不支持下面列出的某些 GSL 类型。<br>\n请查阅您的 GSL 文档以获得更多信息。</p>\n<p>对于以下的每个 GSL 类型，我们都为该类型给出了不变式。只要用户代码仅使用类型所提供的成员或自由函数（就是说，用户代码不会以违反任何其他指南规则的方式，绕过类型的接口来改动对象的值或位），该不变式均有效。</p>\n<p>GSL 组件概览：</p>\n<ul>\n<li><a href=\"#SS-views\">GSL.view: 视图</a></li>\n<li><a href=\"#SS-ownership\">GSL.owner</a></li>\n<li><a href=\"#SS-assertions\">GSL.assert: 断言</a></li>\n<li><a href=\"#SS-utilities\">GSL.util: 工具</a></li>\n<li><a href=\"#SS-gsl-concepts\">GSL.concept: 概念</a></li>\n</ul>\n<p>我们计划提供一个 “ISO C++ 标准风格的” 半正式的 GSL 规范。</p>\n<p>我们依赖于 ISO C++ 标准库，并希望 GSL 的一些部分能够被吸收到标准库之中。</p>\n<h2 id=\"a-namess-viewsagslview-视图\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-viewsagslview-视图\">#</a> <a name=\"SS-views\"></a>GSL.view: 视图</h2>\n<p>这些类型使用户可以区分带有和没有所有权的指针，并区分指向单个对象的指针和指向序列的第一个元素的指针。</p>\n<p>“视图” 都不是所有者。</p>\n<p>引用都不是所有者（参见 <a href=\"#Rr-ref\">R.4</a>）。注意：有许多机会能让引用存活超过其所指代的对象，如按引用返回局部变量，持有 vector 的某个元素的引用然后进行  <code>push_back</code> ，绑定到   <code>std::max(x, y + 1)</code> ，等等。生存期安全性剖面配置的目标就是处理这些事情，但即便如此  <code>owner&lt;T&amp;&gt;</code>  也没有意义且不建议使用。</p>\n<p>它们的名字基本上遵循 ISO 标准库风格（小写字母和下划线）：</p>\n<ul>\n<li><code>T*</code>       //  <code>T*</code>  不是所有者，可能为 null；假定为指向单个元素。</li>\n<li><code>T&amp;</code>       //  <code>T&amp;</code>  不是所有者，不可能为 “null 引用”；引用总是绑定到对象上。</li>\n</ul>\n<p>“原生指针” 写法（如  <code>int*</code> ）假定为具有其最常见的含义；亦即指向一个对象的指针，但并不拥有它。<br>\n所有者应当被转换为资源包装（如  <code>unique_ptr</code>  或  <code>vector&lt;T&gt;</code> ），或标为  <code>owner&lt;T*&gt;</code> 。</p>\n<ul>\n<li><code>owner&lt;T*&gt;</code>    //  <code>T*</code> ，拥有所指向 / 指代的对象；可能为  <code>nullptr</code> 。</li>\n</ul>\n<p><code>owner</code>  用于对代码中有所有权的指针进行标记，它们无法更改为使用适当的资源包装。<br>\n其原因可能包括：</p>\n<ul>\n<li>转换的成本。</li>\n<li>需要为某个 ABI 使用指针。</li>\n<li>这个指针时某种资源包装的实现的一部分。</li>\n</ul>\n<p><code>owner&lt;T&gt;</code>  和  <code>T</code>  的某种资源包装的区别在于它仍然需要明确进行  <code>delete</code> 。</p>\n<p><code>owner&lt;T&gt;</code>  假定为指代自由存储（堆）上的某个对象。</p>\n<p>当某个东西不应当为  <code>nullptr</code>  时，可以这样做：</p>\n<ul>\n<li>\n<p><code>not_null&lt;T&gt;</code>    //  <code>T</code>  通常是某个指针类型（例如  <code>not_null&lt;int*&gt;</code>  和  <code>not_null&lt;owner&lt;Foo*&gt;&gt;</code> ），且不能为  <code>nullptr</code> 。<br>\n <code>T</code>  可以是  <code>==nullptr</code>  有意义的任何类型。</p>\n</li>\n<li>\n<p><code>span&lt;T&gt;</code>        //  <code>[p:p+n)</code> ，构造函数接受  <code>&#123;p, q&#125;</code>  和  <code>&#123;p, n&#125;</code> ； <code>T</code>  为指针类型</p>\n</li>\n<li>\n<p><code>span_p&lt;T&gt;</code>      //  <code>&#123;p, predicate&#125;</code>   <code>[p:q)</code> ，其中  <code>q</code>  为首个使  <code>predicate(*p)</code>  为真的元素</p>\n</li>\n</ul>\n<p><code>span&lt;T&gt;</code>  指代零或更多可改动的  <code>T</code> ，除非  <code>T</code>  为  <code>const</code>  类型。对  <code>span</code>  元素的所有访问，尤其是通过  <code>operator[]</code>  进行的访问，默认保证进行边界检查。</p>\n<blockquote>\n<p>注：有提案将 GSL 的  <code>span</code> （起初叫做  <code>array_view</code> ）加入 C++ 标准库且已被采纳（名字和接口有改动），唯一不同是  <code>std::span</code>  不提供边界检查保证。因此，GSL 修改了  <code>span</code>  的名字和接口以跟踪  <code>std::span</code> ，并应当与  <code>std::span</code>  完全相同，而其仅有差别应当为，GSL 的  <code>span</code>  默认是完全边界安全的。如果边界检查影响其接口，那么应当通过 ISO C++ 委员会带回改动的提案，以保持  <code>gsl::span</code>  和  <code>std::span</code>  接口兼容。如果  <code>std::span</code>  未来的演化添加了边界检查，则  <code>gsl::span</code>  即可移除。</p>\n</blockquote>\n<p>“指针算术” 最好在  <code>span</code>  之内进行。<br>\n指向多个  <code>char</code>  但并非 C 风格字符串的  <code>char*</code> （比如指向某个输入缓冲区的指针）应当表示为一个  <code>span</code> 。</p>\n<ul>\n<li><code>zstring</code>     //  <code>char*</code> ，假定为 C 风格字符串；亦即以零结尾的  <code>char</code>  的序列或者是  <code>nullptr</code></li>\n<li><code>czstring</code>    //  <code>const char*</code> ，假定为 C 风格字符串；亦即以零结尾的  <code>const</code>   <code>char</code>  的序列或者是  <code>nullptr</code></li>\n</ul>\n<p>逻辑上来说，最后两种别名是没有必要的，但我们并不总是依照逻辑的，它们可以在指向单个  <code>char</code>  的指针和指向 C 风格字符串的指针之间明确地进行区分。<br>\n并未假定为零结尾的字符序列应当是  <code>span&lt;char&gt;</code> ，或当因 ABI 问题而不可能时是  <code>char*</code> ，而不是  <code>zstring</code> 。</p>\n<p>对于不能为  <code>nullptr</code>  的 C 风格字符串，应使用  <code>not_null&lt;zstring&gt;</code> 。 ??? 我们需要为  <code>not_null&lt;zstring&gt;</code>  命名吗？还是说它的难看是有用的？</p>\n<h2 id=\"a-namess-ownershipagslowner-所有权指针\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-ownershipagslowner-所有权指针\">#</a> <a name=\"SS-ownership\"></a>GSL.owner: 所有权指针</h2>\n<ul>\n<li><code>unique_ptr&lt;T&gt;</code>      // 唯一所有权： <code>std::unique_ptr&lt;T&gt;</code></li>\n<li><code>shared_ptr&lt;T&gt;</code>      // 共享所有权： <code>std::shared_ptr&lt;T&gt;</code> （引用计数指针）</li>\n<li><code>stack_array&lt;T&gt;</code>     // 栈分配数组。元素的数量在构造时确定并固定下来。其元素可改变，除非  <code>T</code>  为  <code>const</code>  类型。</li>\n<li><code>dyn_array&lt;T&gt;</code>       // ??? 有必要吗？？？堆分配数组。元素的数量在构造时确定并固定下来。<br>\n其元素可改变，除非  <code>T</code>  为  <code>const</code>  类型。基本上这是一个进行分配并拥有其元素的  <code>span</code> 。</li>\n</ul>\n<h2 id=\"a-namess-assertionsagslassert-断言\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-assertionsagslassert-断言\">#</a> <a name=\"SS-assertions\"></a>GSL.assert: 断言</h2>\n<ul>\n<li><code>Expects</code>      // 前条件断言。当前放置于函数体内。今后应当移动到声明中。<br>\n//  <code>Expects(p)</code>  当不满足  <code>p == true</code>  时会终止程序<br>\n //  <code>Expects</code>  处于一组选项的控制之下（强制，错误消息，对终止程序的替代）</li>\n<li><code>Ensures</code>      // 后条件断言。当前放置于函数体内。今后应当移动到声明中。</li>\n</ul>\n<p>现在这些断言还是宏（天呐！）而且必须（只）被用在函数定义式之内。<br>\n等待标准委员会对于契约和断言语法的确定。<br>\n参见使用属性语法的<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcGVuLXN0ZC5vcmcvanRjMS9zYzIyL3dnMjEvZG9jcy9wYXBlcnMvMjAxNi9wMDM4MHIxLnBkZg==\">契约提案</span>，<br>\n比如说， <code>Expects(p)</code>  将变为  <code>[[expects: p]]</code> 。</p>\n<h2 id=\"a-namess-utilitiesagslutil-工具\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-utilitiesagslutil-工具\">#</a> <a name=\"SS-utilities\"></a>GSL.util: 工具</h2>\n<ul>\n<li><code>finally</code>         //  <code>finally(f)</code>  创建一个  <code>final_action&#123;f&#125;</code> ，其析构函数将执行  <code>f</code></li>\n<li><code>narrow_cast</code>     //  <code>narrow_cast&lt;T&gt;(x)</code>  就是  <code>static_cast&lt;T&gt;(x)</code></li>\n<li><code>narrow</code>          //  <code>narrow&lt;T&gt;(x)</code>  在满足无符号提升下的  <code>static_cast&lt;T&gt;(x) == x</code>  时为  <code>static_cast&lt;T&gt;(x)</code> ，否则抛出  <code>narrowing_error</code> （例如， <code>narrow&lt;unsigned&gt;(-42)</code>  会抛出异常）</li>\n<li><code>[[implicit]]</code>    // 放在单参数构造函数上的 “记号”，以明确说明它们并非显式构造函数。</li>\n<li><code>move_owner</code>      //  <code>p = move_owner(q)</code>  含义为  <code>p = q</code>  但？？？</li>\n<li><code>joining_thread</code>  // RAII 风格版本的进行联结的  <code>std::thread</code></li>\n<li><code>index</code>           // 用于进行所有的容器和数组索引的类型（当前是  <code>ptrdiff_t</code>  的别名）</li>\n</ul>\n<h2 id=\"a-namess-gsl-conceptsagslconcept-概念\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-gsl-conceptsagslconcept-概念\">#</a> <a name=\"SS-gsl-concepts\"></a>GSL.concept: 概念</h2>\n<p>这些概念（类型谓词）借用于<br>\n Andrew Sutton 的 Origin 程序库，<br>\nRange 提案，<br>\n以及 ISO WG21 的 Palo Alto TR。<br>\n其中许多都与已在 C<ins>20 中成为 ISO C</ins> 标准的概念十分相似。</p>\n<ul>\n<li><code>String</code></li>\n<li><code>Number</code></li>\n<li><code>Boolean</code></li>\n<li><code>Range</code>               // C++20 中为  <code>std::ranges::range</code></li>\n<li><code>Sortable</code>            // C++20 中为  <code>std::sortable</code></li>\n<li><code>EqualityComparable</code>  // C++20 中为  <code>std::equality_comparable</code></li>\n<li><code>Convertible</code>         // C++20 中为  <code>std::convertible_to</code></li>\n<li><code>Common</code>              // C++20 中为  <code>std::common_with</code></li>\n<li><code>Integral</code>            // C++20 中为  <code>std::integral</code></li>\n<li><code>SignedIntegral</code>      // C++20 中为  <code>std::signed_integral</code></li>\n<li><code>SemiRegular</code>         // C++20 中为  <code>std::semiregular</code></li>\n<li><code>Regular</code>             // C++20 中为  <code>std::regular</code></li>\n<li><code>TotallyOrdered</code>      // C++20 中为  <code>std::totally_ordered</code></li>\n<li><code>Function</code>            // C++20 中为  <code>std::invocable</code></li>\n<li><code>RegularFunction</code>     // C++20 中为  <code>std::regular_invocable</code></li>\n<li><code>Predicate</code>           // C++20 中为  <code>std::predicate</code></li>\n<li><code>Relation</code>            // C++20 中为  <code>std::relation</code></li>\n<li>…</li>\n</ul>\n<h3 id=\"a-namess-gsl-smartptrconceptsagslptr-智能指针概念\"><a class=\"markdownIt-Anchor\" href=\"#a-namess-gsl-smartptrconceptsagslptr-智能指针概念\">#</a> <a name=\"SS-gsl-smartptrconcepts\"></a>GSL.ptr: 智能指针概念</h3>\n<ul>\n<li><code>Pointer</code>   // 带有  <code>*</code> ， <code>-&gt;</code> ， <code>==</code> ，以及默认构造的类型（默认构造被假定为设值为唯一的 “null” 值）</li>\n<li><code>Unique_pointer</code>   // 符合  <code>Pointer</code>  的类型，可移动但不可复制</li>\n<li><code>Shared_pointer</code>    // 符合  <code>Pointer</code>  的类型，可复制</li>\n</ul>\n<h1 id=\"a-names-naminganl-命名和代码布局建议\"><a class=\"markdownIt-Anchor\" href=\"#a-names-naminganl-命名和代码布局建议\">#</a> <a name=\"S-naming\"></a>NL: 命名和代码布局建议</h1>\n<p>维持一致的命名和代码布局是很有用的。<br>\n即便不为其他原因，也可以减少 “我的代码风格比你的好” 这类的纷争。<br>\n然而，人们使用许多许多的不同代码风格，并狂热地坚持它们（的优缺点）。<br>\n而且，大多数的现实项目都包含来自于许多来源的代码，因而通常不可能把所有的代码都标准化为某个单一的代码风格。<br>\n经过许多的用户请求给予指导后，我们给出一组规则，当你没有更好的选择时可以使用它们，但真正的目标在于一致性，而不是任何一组特定的规则。<br>\nIDE 和工具可以提供辅助（当然也可能造成妨碍）。</p>\n<p>命名和代码布局规则：</p>\n<ul>\n<li><a href=\"#Rl-comments\">NL.1: 不要在代码注释中说明可以由代码来清晰表达的东西</a></li>\n<li><a href=\"#Rl-comments-intent\">NL.2: 在代码注释中说明意图</a></li>\n<li><a href=\"#Rl-comments-crisp\">NL.3: 保持代码注释简明干脆</a></li>\n<li><a href=\"#Rl-indent\">NL.4: 保持一种统一的缩进风格</a></li>\n<li><a href=\"#Rl-name-type\">NL.5: 避免在名字中编码类型信息</a></li>\n<li><a href=\"#Rl-name-length\">NL.7: 使名字的长度大约正比于其作用域的长度</a></li>\n<li><a href=\"#Rl-name\">NL.8: 使用一种统一的命名风格</a></li>\n<li><a href=\"#Rl-all-caps\">NL.9: 将  <code>ALL_CAPS</code> （全大写）仅用于宏的名字</a></li>\n<li><a href=\"#Rl-camel\">NL.10: 优先采用  <code>underscore_style</code> （下划线风格）的名字</a></li>\n<li><a href=\"#Rl-literals\">NL.11: 使字面量可阅读</a></li>\n<li><a href=\"#Rl-space\">NL.15: 节制地使用空格</a></li>\n<li><a href=\"#Rl-order\">NL.16: 使用一种常规的类成员声明次序</a></li>\n<li><a href=\"#Rl-knr\">NL.17: 使用从 K&amp;R 衍生出的代码布局</a></li>\n<li><a href=\"#Rl-ptr\">NL.18: 使用 C++ 风格的声明符布局</a></li>\n<li><a href=\"#Rl-misread\">NL.19: 避免使用容易误读的名字</a></li>\n<li><a href=\"#Rl-stmt\">NL.20: 不要把两个语句放在同一行中</a></li>\n<li><a href=\"#Rl-dcl\">NL.21: 每个声明式（仅）声明一个名字</a></li>\n<li><a href=\"#Rl-void\">NL.25: 请勿将  <code>void</code>  用作参数类型</a></li>\n<li><a href=\"#Rl-const\">NL.26: 采用符合惯例的  <code>const</code>  写法</a></li>\n<li><a href=\"#Rl-file-suffix\">NL.27: 为代码文件使用后缀  <code>.cpp</code> ，而对接口文件使用后缀  <code>.h</code> </a></li>\n</ul>\n<p>这些问题的大部分都是审美问题，程序员都有很强的个人倾向。<br>\nIDE 也都会提供某些默认方案和一组替代方案。<br>\n这些规则是作为缺省建议的，如果没有别的理由，请采用它们。</p>\n<p>我们收到一些意见称命名和代码布局非常个人化和任意性，我们不应该试图为之 “立法”。<br>\n我们并不是在 “立法”（参见前一个段落）。<br>\n不过，我们也收到了大量的针对某些命名和代码布局约定的请求，要求当没有外来限制的时候应当采用它们。</p>\n<p>更专门和详细的规则更加易于强制实施。</p>\n<p>这些规则恐怕会和 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9Qcm9ncmFtbWluZy9QUFAtc3R5bGUucGRm\">PPP Style Guide</span> 中的建议有很强的相似性，<br>\n它是为支持 Stroustrup 的 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9wcm9ncmFtbWluZy5odG1s\">Programming: Principles and Practice using C++</span> 而编制的。</p>\n<h3 id=\"a-namerl-commentsanl1-不要在代码注释中说明可以由代码来清晰表达的东西\"><a class=\"markdownIt-Anchor\" href=\"#a-namerl-commentsanl1-不要在代码注释中说明可以由代码来清晰表达的东西\">#</a> <a name=\"Rl-comments\"></a>NL.1: 不要在代码注释中说明可以由代码来清晰表达的东西</h3>\n<h5 id=\"理由-435\"><a class=\"markdownIt-Anchor\" href=\"#理由-435\">#</a> 理由</h5>\n<p>编译器不会读注释。<br>\n注释没有代码那么精确。<br>\n注释不会像代码那样进行一致地更新。</p>\n<h5 id=\"示例不好-150\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-150\">#</a> 示例，不好</h5>\n<pre><code>auto x = m * v1 + vv;   // 将 m 乘以 v1 并将其结果加上 vv\n</code></pre>\n<h5 id=\"强制实施-391\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-391\">#</a> 强制实施</h5>\n<p>构建一个 AI 程序来解释口语英文文字，看看它所说的是否可以用 C++ 来更好地表达。</p>\n<h3 id=\"a-namerl-comments-intentanl2-在代码注释中说明意图\"><a class=\"markdownIt-Anchor\" href=\"#a-namerl-comments-intentanl2-在代码注释中说明意图\">#</a> <a name=\"Rl-comments-intent\"></a>NL.2: 在代码注释中说明意图</h3>\n<h5 id=\"理由-436\"><a class=\"markdownIt-Anchor\" href=\"#理由-436\">#</a> 理由</h5>\n<p>代码表示的是做了什么，而不是想要做成什么。通常来说意图比实现能够更清晰简明地进行说明。</p>\n<h5 id=\"示例-388\"><a class=\"markdownIt-Anchor\" href=\"#示例-388\">#</a> 示例</h5>\n<pre><code>void stable_sort(Sortable&amp; c)\n    // 对 c 根据由 &lt; 决定的顺序进行排序，保持相等元素（由 == 定义）的\n    // 原始相对顺序\n&#123;\n    // ... 相当多的不平常的代码行 ...\n&#125;\n</code></pre>\n<h5 id=\"注解-375\"><a class=\"markdownIt-Anchor\" href=\"#注解-375\">#</a> 注解</h5>\n<p>如果代码注释和代码有冲突，则它们都可能是错的。</p>\n<h3 id=\"a-namerl-comments-crispanl3-保持代码注释简明干脆\"><a class=\"markdownIt-Anchor\" href=\"#a-namerl-comments-crispanl3-保持代码注释简明干脆\">#</a> <a name=\"Rl-comments-crisp\"></a>NL.3: 保持代码注释简明干脆</h3>\n<h5 id=\"理由-437\"><a class=\"markdownIt-Anchor\" href=\"#理由-437\">#</a> 理由</h5>\n<p>冗长啰嗦会拖慢理解速度，而且到处散布在代码文件里也会让代码难于阅读。</p>\n<h5 id=\"注解-376\"><a class=\"markdownIt-Anchor\" href=\"#注解-376\">#</a> 注解</h5>\n<p>使用明白易懂的英文。<br>\n也许我可以流利使用丹麦语，但大多数程序员不行；我的代码的维护者也不行。<br>\n避免使用网络用语，注意你的文法，标点，以及大小写。<br>\n目标是专业性，而不是 “够酷”。</p>\n<h5 id=\"强制实施-392\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-392\">#</a> 强制实施</h5>\n<p>不可能。</p>\n<h3 id=\"a-namerl-indentanl4-保持一种统一的缩进风格\"><a class=\"markdownIt-Anchor\" href=\"#a-namerl-indentanl4-保持一种统一的缩进风格\">#</a> <a name=\"Rl-indent\"></a>NL.4: 保持一种统一的缩进风格</h3>\n<h5 id=\"理由-438\"><a class=\"markdownIt-Anchor\" href=\"#理由-438\">#</a> 理由</h5>\n<p>可读性。避免 “微妙的错误”。</p>\n<h5 id=\"示例不好-151\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-151\">#</a> 示例，不好</h5>\n<pre><code>int i;\nfor (i = 0; i &lt; max; ++i); // 可能出现的 BUG\nif (i == j)\n    return i;\n</code></pre>\n<h5 id=\"注解-377\"><a class=\"markdownIt-Anchor\" href=\"#注解-377\">#</a> 注解</h5>\n<p>总是把  <code>if (...)</code> ， <code>for (...)</code> ，以及  <code>while (...)</code>  之后的语句进行缩进是一个好主意：</p>\n<pre><code>if (i &lt; 0) error(&quot;negative argument&quot;);\n\nif (i &lt; 0)\n    error(&quot;negative argument&quot;);\n</code></pre>\n<h5 id=\"强制实施-393\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-393\">#</a> 强制实施</h5>\n<p>使用一种工具。</p>\n<h3 id=\"a-namerl-name-typeanl5-避免在名字中编码类型信息\"><a class=\"markdownIt-Anchor\" href=\"#a-namerl-name-typeanl5-避免在名字中编码类型信息\">#</a> <a name=\"Rl-name-type\"></a>NL.5: 避免在名字中编码类型信息</h3>\n<h5 id=\"原理\"><a class=\"markdownIt-Anchor\" href=\"#原理\">#</a> 原理</h5>\n<p>当名字反映类型而不是功能时，它将变得难于为提供其功能而改变其所使用的类型。<br>\n而且，当改变变量的类型时，使用它的代码也得修改。<br>\n最小化无意进行的转换。</p>\n<h5 id=\"示例不好-152\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-152\">#</a> 示例，不好</h5>\n<pre><code>void print_int(int i);\nvoid print_string(const char*);\n\nprint_int(1);          // 重复，人工进行类型匹配\nprint_string(&quot;xyzzy&quot;); // 重复，人工进行类型匹配\n</code></pre>\n<h5 id=\"示例好-32\"><a class=\"markdownIt-Anchor\" href=\"#示例好-32\">#</a> 示例，好</h5>\n<pre><code>void print(int i);\nvoid print(string_view);    // 对任意字符串式的序列都能工作\n\nprint(1);              // 简洁，自动类型匹配\nprint(&quot;xyzzy&quot;);        // 简洁，自动类型匹配\n</code></pre>\n<h5 id=\"注解-378\"><a class=\"markdownIt-Anchor\" href=\"#注解-378\">#</a> 注解</h5>\n<p>带有类型编码的名字要么啰嗦要么难懂。</p>\n<pre><code>printS  // 打印一个 std::string\nprints  // 打印一个 C 风格字符串\nprinti  // 打印一个 int\n</code></pre>\n<p>在无类型语言中曾经采用过像匈牙利记法这样的技巧来在名字中编码类型，但在像 C++ 这样的强静态类型语言中，这通常是不必要而且实际上是有害的，因为这些标注会过时（这些累赘和注释类似，而且和它们一样会烂掉），而且它们干扰了语言的恰当用法（应当代之以使用相同的名字和重载决议）。</p>\n<h5 id=\"注解-379\"><a class=\"markdownIt-Anchor\" href=\"#注解-379\">#</a> 注解</h5>\n<p>一些代码风格会使用非常一般性的（而不是特定于类型的）前缀来代表变量的一般用法。</p>\n<pre><code>auto p = new User();\nauto p = make_unique&lt;User&gt;();\n// 注：&quot;p&quot; 并非是说“User 类型的原始指针”，\n//     而只是一般性的“这是一次间接访问”\n\nauto cntHits = calc_total_of_hits(/*...*/);\n// 注：&quot;cnt&quot; 并非用于编码某个类型，\n//     而只是一般性的“这是某种东西的一个计数”\n</code></pre>\n<p>这样做是没有害处的，且并不属于本条指导方针，因为其并未编码类型信息。</p>\n<h5 id=\"注解-380\"><a class=\"markdownIt-Anchor\" href=\"#注解-380\">#</a> 注解</h5>\n<p>一些代码风格会对成员和局部变量，以及全局变量之间进行区分。</p>\n<pre><code>struct S &#123;\n    int m_;\n    S(int m) : m_&#123;abs(m)&#125; &#123; &#125;\n&#125;;\n</code></pre>\n<p>这样做是没有害处的，且并不属于本条指导方针，因为其并未编码类型信息。</p>\n<h5 id=\"注解-381\"><a class=\"markdownIt-Anchor\" href=\"#注解-381\">#</a> 注解</h5>\n<p>像 C++ 这样，一些代码风格对类型和非类型之间进行区分。<br>\n例如，对类型名字首字母大写，而函数和变量名字则不这样做。</p>\n<pre><code>typename&lt;typename T&gt;\nclass HashTable &#123;   // 将 string 映射为 T\n    // ...\n&#125;;\n\nHashTable&lt;int&gt; index;\n</code></pre>\n<p>这样做是没有害处的，且并不属于本条指导方针，因为其并未编码类型信息。</p>\n<h3 id=\"a-namerl-name-lengthanl7-使名字的长度大约正比于其作用域的长度\"><a class=\"markdownIt-Anchor\" href=\"#a-namerl-name-lengthanl7-使名字的长度大约正比于其作用域的长度\">#</a> <a name=\"Rl-name-length\"></a>NL.7: 使名字的长度大约正比于其作用域的长度</h3>\n<p><strong>原理</strong>：作用域越大，搞混的机会和意外的名字冲突的机会就越大。</p>\n<h5 id=\"示例-389\"><a class=\"markdownIt-Anchor\" href=\"#示例-389\">#</a> 示例</h5>\n<pre><code>double sqrt(double x);   // 返回 x 的平方根；x 必须是非负数\n\nint length(const char* p);  // 返回零结尾的 C 风格字符串的字符数量\n\nint length_of_string(const char zero_terminated_array_of_char[])    // 不好: 啰嗦\n\nint g;      // 不好: 全局变量具有密秘的名字\n\nint open;   // 不好: 全局变量使用短小且常用的名字\n</code></pre>\n<p>为指针使用  <code>p</code> ，以及为浮点变量使用  <code>x</code>  是符合惯例的，在受限的作用域中不会造成混乱。</p>\n<h5 id=\"强制实施-394\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-394\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerl-nameanl8-使用一种统一的命名风格\"><a class=\"markdownIt-Anchor\" href=\"#a-namerl-nameanl8-使用一种统一的命名风格\">#</a> <a name=\"Rl-name\"></a>NL.8: 使用一种统一的命名风格</h3>\n<p><strong>原理</strong>：命名和命名风格的一致性会提高可读性。</p>\n<h5 id=\"注解-382\"><a class=\"markdownIt-Anchor\" href=\"#注解-382\">#</a> 注解</h5>\n<p>命名风格有好多，当你使用多个程序库时，你无法遵循所有它们不同的命名约定。<br>\n应当选用一种 “自有风格”，但保持 “导入” 的程序为其原有风格不变。</p>\n<h5 id=\"示例-390\"><a class=\"markdownIt-Anchor\" href=\"#示例-390\">#</a> 示例</h5>\n<p>ISO 标准仅使用小写字母和数字，并用下划线进行词的连接。</p>\n<ul>\n<li><code>int</code></li>\n<li><code>vector</code></li>\n<li><code>my_map</code></li>\n</ul>\n<p>避免使用双下划线  <code>__</code> 。</p>\n<h5 id=\"示例-391\"><a class=\"markdownIt-Anchor\" href=\"#示例-391\">#</a> 示例</h5>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9Qcm9ncmFtbWluZy9QUFAtc3R5bGUucGRm\">Stroustrup</span>：<br>\n采用 ISO 标准，但在自己的类型和概念上采用大写字母：</p>\n<ul>\n<li><code>int</code></li>\n<li><code>vector</code></li>\n<li><code>My_map</code></li>\n</ul>\n<h5 id=\"示例-392\"><a class=\"markdownIt-Anchor\" href=\"#示例-392\">#</a> 示例</h5>\n<p>CamelCase：多词标识符的每个词首字母大写：</p>\n<ul>\n<li><code>int</code></li>\n<li><code>vector</code></li>\n<li><code>MyMap</code></li>\n<li><code>myMap</code></li>\n</ul>\n<p>一些命名约定会将首字母大写，而另一些不会。</p>\n<h5 id=\"注解-383\"><a class=\"markdownIt-Anchor\" href=\"#注解-383\">#</a> 注解</h5>\n<p>应当试图在对缩略词的使用和标识符长度上保持一致风格。</p>\n<pre><code>int mtbf &#123;12&#125;;\nint mean_time_between_failures &#123;12&#125;; // 你自己决定\n</code></pre>\n<h5 id=\"强制实施-395\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-395\">#</a> 强制实施</h5>\n<p>除使用具有不同命名约定的程序库之外应当是可能做到的。</p>\n<h3 id=\"a-namerl-all-capsanl9-将-all_caps全大写仅用于宏的名字\"><a class=\"markdownIt-Anchor\" href=\"#a-namerl-all-capsanl9-将-all_caps全大写仅用于宏的名字\">#</a> <a name=\"Rl-all-caps\"></a>NL.9: 将  <code>ALL_CAPS</code> （全大写）仅用于宏的名字</h3>\n<h5 id=\"理由-439\"><a class=\"markdownIt-Anchor\" href=\"#理由-439\">#</a> 理由</h5>\n<p>避免在宏和遵循作用域和类型规则的名字之间造成混乱。</p>\n<h5 id=\"示例-393\"><a class=\"markdownIt-Anchor\" href=\"#示例-393\">#</a> 示例</h5>\n<pre><code>void f()\n&#123;\n    const int SIZE&#123;1000&#125;;  // 不好，应代之以 'size'\n    int v[SIZE];\n&#125;\n</code></pre>\n<h5 id=\"注解-384\"><a class=\"markdownIt-Anchor\" href=\"#注解-384\">#</a> 注解</h5>\n<p>这条规则适用于非宏的符号常量：</p>\n<pre><code>enum bad &#123; BAD, WORSE, HORRIBLE &#125;; // 不好\n</code></pre>\n<h5 id=\"强制实施-396\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-396\">#</a> 强制实施</h5>\n<ul>\n<li>对带有小写字母的宏进行标记</li>\n<li>对  <code>ALL_CAPS</code>  非宏名字进行标记</li>\n</ul>\n<h3 id=\"a-namerl-camelanl10-优先采用-underscore_style下划线风格的名字\"><a class=\"markdownIt-Anchor\" href=\"#a-namerl-camelanl10-优先采用-underscore_style下划线风格的名字\">#</a> <a name=\"Rl-camel\"></a>NL.10: 优先采用  <code>underscore_style</code> （下划线风格）的名字</h3>\n<h5 id=\"理由-440\"><a class=\"markdownIt-Anchor\" href=\"#理由-440\">#</a> 理由</h5>\n<p>用下划线来分隔名字的各部分就是 C 和 C++ 的原始风格，并被用于 C++ 标准库中。</p>\n<h5 id=\"注解-385\"><a class=\"markdownIt-Anchor\" href=\"#注解-385\">#</a> 注解</h5>\n<p>这条规则仅作为当你有选择权时的缺省方案。<br>\n通常你是没有什么选择权的，而只能遵循某个已经设立的风格以维持<a href=\"#Rl-name\">一致性</a>。<br>\n对一致性的需要优先于个人喜好。</p>\n<p>这个推荐适用于<a href=\"#S-naming\">当你没有约束条件或者没有更好的想法时</a>的情况。<br>\n经过很多要求给予指导后，添加这个规则。</p>\n<h5 id=\"示例-394\"><a class=\"markdownIt-Anchor\" href=\"#示例-394\">#</a> 示例</h5>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9Qcm9ncmFtbWluZy9QUFAtc3R5bGUucGRm\">Stroustrup</span>：<br>\n采用 ISO 标准，但在自己的类型和概念上采用大写字母：</p>\n<ul>\n<li><code>int</code></li>\n<li><code>vector</code></li>\n<li><code>My_map</code></li>\n</ul>\n<h5 id=\"强制实施-397\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-397\">#</a> 强制实施</h5>\n<p>不可能。</p>\n<h3 id=\"a-namerl-literalsanl11-使字面量可阅读\"><a class=\"markdownIt-Anchor\" href=\"#a-namerl-literalsanl11-使字面量可阅读\">#</a> <a name=\"Rl-literals\"></a>NL.11: 使字面量可阅读</h3>\n<h5 id=\"理由-441\"><a class=\"markdownIt-Anchor\" href=\"#理由-441\">#</a> 理由</h5>\n<p>可读性。</p>\n<h5 id=\"示例-395\"><a class=\"markdownIt-Anchor\" href=\"#示例-395\">#</a> 示例</h5>\n<p>用数字分隔符来避免长串的数字</p>\n<pre><code>auto c = 299'792'458; // m/s2\nauto q2 = 0b0000'1111'0000'0000;\nauto ss_number = 123'456'7890;\n</code></pre>\n<h5 id=\"示例-396\"><a class=\"markdownIt-Anchor\" href=\"#示例-396\">#</a> 示例</h5>\n<p>需要清晰性时使用字面量后缀</p>\n<pre><code>auto hello = &quot;Hello!&quot;s; // std::string\nauto world = &quot;world&quot;;   // C 风格字符串\nauto interval = 100ms;  // 使用 &lt;chrono&gt;\n</code></pre>\n<h5 id=\"注解-386\"><a class=\"markdownIt-Anchor\" href=\"#注解-386\">#</a> 注解</h5>\n<p>不能在代码中到处当做<a href=\"#Res-magic\"> “魔法常量”</a> 一样乱用字面量，<br>\n但当定义它们时使它们更可读仍是个好主意。<br>\n在较长的整数串中很容易出现拼写错误。</p>\n<h5 id=\"强制实施-398\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-398\">#</a> 强制实施</h5>\n<p>标记长数字串。麻烦的是 “长” 的定义；也许应当是 7。</p>\n<h3 id=\"a-namerl-spaceanl15-节制地使用空格\"><a class=\"markdownIt-Anchor\" href=\"#a-namerl-spaceanl15-节制地使用空格\">#</a> <a name=\"Rl-space\"></a>NL.15: 节制地使用空格</h3>\n<h5 id=\"理由-442\"><a class=\"markdownIt-Anchor\" href=\"#理由-442\">#</a> 理由</h5>\n<p>太多的空格会让文本更大更分散。</p>\n<h5 id=\"示例不好-153\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-153\">#</a> 示例，不好</h5>\n<pre><code>#include &lt; map &gt;\n\nint main(int argc, char * argv [ ])\n&#123;\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"示例-397\"><a class=\"markdownIt-Anchor\" href=\"#示例-397\">#</a> 示例</h5>\n<pre><code>#include &lt;map&gt;\n\nint main(int argc, char* argv[])\n&#123;\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"注解-387\"><a class=\"markdownIt-Anchor\" href=\"#注解-387\">#</a> 注解</h5>\n<p>一些 IDE 有其自己的看法，并会添加分散的空格。</p>\n<p>这个推荐适用于<a href=\"#S-naming\">当你没有约束条件或者没有更好的想法时</a>的情况。<br>\n经过很多要求给予指导后，添加这个规则。</p>\n<h5 id=\"注解-388\"><a class=\"markdownIt-Anchor\" href=\"#注解-388\">#</a> 注解</h5>\n<p>我们将恰当放置的空白评价为能够明显有助于可读性。但请勿过度。</p>\n<h3 id=\"a-namerl-orderanl16-使用一种常规的类成员声明次序\"><a class=\"markdownIt-Anchor\" href=\"#a-namerl-orderanl16-使用一种常规的类成员声明次序\">#</a> <a name=\"Rl-order\"></a>NL.16: 使用一种常规的类成员声明次序</h3>\n<h5 id=\"理由-443\"><a class=\"markdownIt-Anchor\" href=\"#理由-443\">#</a> 理由</h5>\n<p>一种常规的成员次序会提高可读性。</p>\n<p>以如下次序声明类</p>\n<ul>\n<li>类型：类，枚举，别名（ <code>using</code> ）</li>\n<li>构造函数，赋值，析构函数</li>\n<li>函数</li>\n<li>数据</li>\n</ul>\n<p>采用先是  <code>public</code> ，然后是  <code>protected</code> ，之后是  <code>private</code>  的次序。</p>\n<p>这个推荐适用于<a href=\"#S-naming\">当你没有约束条件或者没有更好的想法时</a>的情况。<br>\n经过很多要求给予指导后，添加这个规则。</p>\n<h5 id=\"示例-398\"><a class=\"markdownIt-Anchor\" href=\"#示例-398\">#</a> 示例</h5>\n<pre><code>class X &#123;\npublic:\n    // 接口\nprotected:\n    // 供派生类实现使用的不带检查的函数\nprivate:\n    // 实现细节\n&#125;;\n</code></pre>\n<h5 id=\"示例-399\"><a class=\"markdownIt-Anchor\" href=\"#示例-399\">#</a> 示例</h5>\n<p>有时候，成员的默认顺序，与将公开接口从实现细节中分离出来的需求之间有冲突。<br>\n这种情况下，私有类型和函数可以和私有数据放在一起。</p>\n<pre><code>class X &#123;\npublic:\n    // 接口\nprotected:\n    // 供派生类实现使用的不带检查的函数\nprivate:\n    // 实现细节（类型，函数和数据）\n&#125;;\n</code></pre>\n<h5 id=\"示例不好-154\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-154\">#</a> 示例，不好</h5>\n<p>避免让具有某一种访问（如  <code>public</code> ）的多个声明块被具有不同访问（如  <code>private</code> ）的其他声明块分隔开。</p>\n<pre><code>class X &#123;\npublic:\n    void f();\npublic:\n    int g();\n    // ...\n&#125;;\n</code></pre>\n<p>用宏来声明成员组的做法通常会导致违反所有的次序规则。<br>\n不过，宏的使用掩盖了其所表达的东西。</p>\n<h5 id=\"强制实施-399\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-399\">#</a> 强制实施</h5>\n<p>对背离上述建议次序的代码进行标记。将会有大量的老代码不符合这条规则。</p>\n<h3 id=\"a-namerl-knranl17-使用从-kr-衍生出的代码布局\"><a class=\"markdownIt-Anchor\" href=\"#a-namerl-knranl17-使用从-kr-衍生出的代码布局\">#</a> <a name=\"Rl-knr\"></a>NL.17: 使用从 K&amp;R 衍生出的代码布局</h3>\n<h5 id=\"理由-444\"><a class=\"markdownIt-Anchor\" href=\"#理由-444\">#</a> 理由</h5>\n<p>这正是 C 和 C++ 的原始代码布局。它很好地保持了纵向空间。它对不同语言构造（如函数和类）进行了很好的区分。</p>\n<h5 id=\"注解-389\"><a class=\"markdownIt-Anchor\" href=\"#注解-389\">#</a> 注解</h5>\n<p>在 C++ 的语境中，这种风格通常被称为 “Stroustrup”。</p>\n<p>这个推荐适用于<a href=\"#S-naming\">当你没有约束条件或者没有更好的想法时</a>的情况。<br>\n经过很多要求给予指导后，添加这个规则。</p>\n<h5 id=\"示例-400\"><a class=\"markdownIt-Anchor\" href=\"#示例-400\">#</a> 示例</h5>\n<pre><code>struct Cable &#123;\n    int x;\n    // ...\n&#125;;\n\ndouble foo(int x)\n&#123;\n    if (0 &lt; x) &#123;\n        // ...\n    &#125;\n\n    switch (x) &#123;\n    case 0:\n        // ...\n        break;\n    case amazing:\n        // ...\n        break;\n    default:\n        // ...\n        break;\n    &#125;\n\n    if (0 &lt; x)\n        ++x;\n\n    if (x &lt; 0)\n        something();\n    else\n        something_else();\n\n    return some_value;\n&#125;\n</code></pre>\n<p>注意  <code>if</code>  和  <code>(</code>  之间有一个空格</p>\n<h5 id=\"注解-390\"><a class=\"markdownIt-Anchor\" href=\"#注解-390\">#</a> 注解</h5>\n<p>每个语句， <code>if</code>  的分支，以及  <code>for</code>  的代码体都使用单独的代码行。</p>\n<h5 id=\"注解-391\"><a class=\"markdownIt-Anchor\" href=\"#注解-391\">#</a> 注解</h5>\n<p><code>class</code>  和  <code>struct</code>  的  <code>&#123;</code>  <em>并不</em>在单独的代码行上，但函数的  <code>&#123;</code>  在单独的代码行上。</p>\n<h5 id=\"注解-392\"><a class=\"markdownIt-Anchor\" href=\"#注解-392\">#</a> 注解</h5>\n<p>对你自定义的类型的名字进行首字母大写，以将其与标准库类型相区分。</p>\n<h5 id=\"注解-393\"><a class=\"markdownIt-Anchor\" href=\"#注解-393\">#</a> 注解</h5>\n<p>不要对函数名大写。</p>\n<h5 id=\"强制实施-400\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-400\">#</a> 强制实施</h5>\n<p>如果想要强制实施的话，请使用某个 IDE 进行格式化。</p>\n<h3 id=\"a-namerl-ptranl18-使用-c-风格的声明符布局\"><a class=\"markdownIt-Anchor\" href=\"#a-namerl-ptranl18-使用-c-风格的声明符布局\">#</a> <a name=\"Rl-ptr\"></a>NL.18: 使用 C++ 风格的声明符布局</h3>\n<h5 id=\"理由-445\"><a class=\"markdownIt-Anchor\" href=\"#理由-445\">#</a> 理由</h5>\n<p>C 风格的布局强调其在表达式中的用法和文法，而 C++ 风格强调的是类型。<br>\n对表达式用法的说辞并不适用于引用。</p>\n<h5 id=\"示例-401\"><a class=\"markdownIt-Anchor\" href=\"#示例-401\">#</a> 示例</h5>\n<pre><code>T&amp; operator[](size_t);   // OK\nT &amp;operator[](size_t);   // 奇怪\nT &amp; operator[](size_t);   // 不确定\n</code></pre>\n<h5 id=\"注解-394\"><a class=\"markdownIt-Anchor\" href=\"#注解-394\">#</a> 注解</h5>\n<p>这个推荐适用于<a href=\"#S-naming\">当你没有约束条件或者没有更好的想法时</a>的情况。<br>\n经过很多要求给予指导后，添加这个规则。</p>\n<h5 id=\"强制实施-401\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-401\">#</a> 强制实施</h5>\n<p>由于历史原因而不可能。</p>\n<h3 id=\"a-namerl-misreadanl19-避免使用容易误读的名字\"><a class=\"markdownIt-Anchor\" href=\"#a-namerl-misreadanl19-避免使用容易误读的名字\">#</a> <a name=\"Rl-misread\"></a>NL.19: 避免使用容易误读的名字</h3>\n<h5 id=\"理由-446\"><a class=\"markdownIt-Anchor\" href=\"#理由-446\">#</a> 理由</h5>\n<p>可读性。<br>\n并非每个人都有能将字符轻易区分开的屏幕和打印机。<br>\n我们很容易搞混拼写相似和略微拼错的单词。</p>\n<h5 id=\"示例-402\"><a class=\"markdownIt-Anchor\" href=\"#示例-402\">#</a> 示例</h5>\n<pre><code>int oO01lL = 6; // 不好\n\nint splunk = 7;\nint splonk = 8; // 不好：splunk 和 splonk 很容易搞混\n</code></pre>\n<h5 id=\"强制实施-402\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-402\">#</a> 强制实施</h5>\n<p>???</p>\n<h3 id=\"a-namerl-stmtanl20-不要把两个语句放在同一行中\"><a class=\"markdownIt-Anchor\" href=\"#a-namerl-stmtanl20-不要把两个语句放在同一行中\">#</a> <a name=\"Rl-stmt\"></a>NL.20: 不要把两个语句放在同一行中</h3>\n<h5 id=\"理由-447\"><a class=\"markdownIt-Anchor\" href=\"#理由-447\">#</a> 理由</h5>\n<p>可读性。<br>\n当一行里有多个语句时，相当容易忽视某个语句。</p>\n<h5 id=\"示例-403\"><a class=\"markdownIt-Anchor\" href=\"#示例-403\">#</a> 示例</h5>\n<pre><code>int x = 7; char* p = 29;    // 请勿如此\nint x = 7; f(x);  ++x;      // 请勿如此\n</code></pre>\n<h5 id=\"强制实施-403\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-403\">#</a> 强制实施</h5>\n<p>容易。</p>\n<h3 id=\"a-namerl-dclanl21-每个声明式仅声明一个名字\"><a class=\"markdownIt-Anchor\" href=\"#a-namerl-dclanl21-每个声明式仅声明一个名字\">#</a> <a name=\"Rl-dcl\"></a>NL.21: 每个声明式（仅）声明一个名字</h3>\n<h5 id=\"理由-448\"><a class=\"markdownIt-Anchor\" href=\"#理由-448\">#</a> 理由</h5>\n<p>可读性。<br>\n最小化声明符语法造成的混乱。</p>\n<h5 id=\"注解-395\"><a class=\"markdownIt-Anchor\" href=\"#注解-395\">#</a> 注解</h5>\n<p>相关细节，参见 <a href=\"#Res-name-one\">ES.10</a>、</p>\n<h3 id=\"a-namerl-voidanl25-请勿将-void-用作参数类型\"><a class=\"markdownIt-Anchor\" href=\"#a-namerl-voidanl25-请勿将-void-用作参数类型\">#</a> <a name=\"Rl-void\"></a>NL.25: 请勿将  <code>void</code>  用作参数类型</h3>\n<h5 id=\"理由-449\"><a class=\"markdownIt-Anchor\" href=\"#理由-449\">#</a> 理由</h5>\n<p>这很啰嗦，而且仅在考虑 C 兼容性是才有必要。</p>\n<h5 id=\"示例-404\"><a class=\"markdownIt-Anchor\" href=\"#示例-404\">#</a> 示例</h5>\n<pre><code>void f(void);   // 不好\n\nvoid g();       // 好多了\n</code></pre>\n<h5 id=\"注解-396\"><a class=\"markdownIt-Anchor\" href=\"#注解-396\">#</a> 注解</h5>\n<p>即便是 Dennis Ritchie 自己都认为  <code>void f(void)</code>  很讨厌。<br>\n你可以反驳称，在 C 中当函数原型很少见时禁止这样的代码：</p>\n<pre><code>int f();\nf(1, 2, &quot;weird but valid C89&quot;);   // 希望 f() 被定义为 int f(a, b, c) char* c; &#123; /* ... */ &#125;\n</code></pre>\n<p>可能造成很大的问题，但这并不适于 21 世纪和 C++。</p>\n<h3 id=\"a-namerl-constanl26-采用符合惯例的-const-写法\"><a class=\"markdownIt-Anchor\" href=\"#a-namerl-constanl26-采用符合惯例的-const-写法\">#</a> <a name=\"Rl-const\"></a>NL.26: 采用符合惯例的  <code>const</code>  写法</h3>\n<h5 id=\"理由-450\"><a class=\"markdownIt-Anchor\" href=\"#理由-450\">#</a> 理由</h5>\n<p>更多程序员更加熟悉惯例写法。<br>\n大型代码库中的一致性。</p>\n<h5 id=\"示例-405\"><a class=\"markdownIt-Anchor\" href=\"#示例-405\">#</a> 示例</h5>\n<pre><code>const int x = 7;    // OK\nint const y = 9;    // 不好\n\nconst int *const p = nullptr;   // OK, 指向常量 int 的常量指针\nint const *const p = nullptr;   // 不好，指向常量 int 的常量指针\n</code></pre>\n<h5 id=\"注解-397\"><a class=\"markdownIt-Anchor\" href=\"#注解-397\">#</a> 注解</h5>\n<p>我们知道你可能会说 “不好” 的例子比标有 “OK” 的更符合逻辑，<br>\n但它们会让更多人搞混，尤其是那些依赖于采用了远为常用，符合惯例的 OK 风格的教学材料的新手们。</p>\n<p>一如往常，请记住这些命名和代码布局规则的目标在于一致性，而审美则会有广泛的变化。</p>\n<p>这个推荐适用于<a href=\"#S-naming\">当你没有约束条件或者没有更好的想法时</a>的情况。<br>\n经过很多要求给予指导后，添加这个规则。</p>\n<h5 id=\"强制实施-404\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-404\">#</a> 强制实施</h5>\n<p>标记用作类型的后缀的  <code>const</code> 。</p>\n<h3 id=\"a-namerl-file-suffixanl27-为代码文件使用后缀-cpp而对接口文件使用后缀-h\"><a class=\"markdownIt-Anchor\" href=\"#a-namerl-file-suffixanl27-为代码文件使用后缀-cpp而对接口文件使用后缀-h\">#</a> <a name=\"Rl-file-suffix\"></a>NL.27: 为代码文件使用后缀  <code>.cpp</code> ，而对接口文件使用后缀  <code>.h</code></h3>\n<h5 id=\"理由-451\"><a class=\"markdownIt-Anchor\" href=\"#理由-451\">#</a> 理由</h5>\n<p>这是一条历史悠久的约定。<br>\n不过一致性更加重要，因此如果你的项目用了别的约定的话，应当遵守它。</p>\n<h5 id=\"注解-398\"><a class=\"markdownIt-Anchor\" href=\"#注解-398\">#</a> 注解</h5>\n<p>这项约定反应了一种常见使用模式：<br>\n头文件更容易和 C 语言共享使用，并可以作为 C++ 和 C 编译，它们通常用  <code>.h</code>  后缀，<br>\n并且对于有意要和 C 共用的头文件来说，让所有头文件都使用  <code>.h</code>  而不是别的扩展名要更加容易。<br>\n另一方面，实现文件则很少会和 C 共用，通常应当和  <code>.c</code>  文件相区别，<br>\n因此一般最好为所有的 C++ 实现文件用别的扩展名（如  <code>.cpp</code> ）来命名。</p>\n<p>特定的名字  <code>.h</code>  和  <code>.cpp</code>  并不是必要的（只是作为缺省建议），其他的名字也被广泛采用。<br>\n例子包括  <code>.hh</code> ， <code>.C</code> ，和  <code>.cxx</code>  等。请以类似方式使用这些名字。<br>\n本文档中我们把  <code>.h</code>  和  <code>.cpp</code>  作为头文件和实现文件的简便提法，<br>\n虽然实际上的扩展名可能是不同的。</p>\n<p>也许你的 IDE（如果你使用的话）对后缀有较强的倾向。</p>\n<h5 id=\"示例-406\"><a class=\"markdownIt-Anchor\" href=\"#示例-406\">#</a> 示例</h5>\n<pre><code>// foo.h:\nextern int a;   // 声明\nextern void foo();\n\n// foo.cpp:\nint a;   // 定义\nvoid foo() &#123; ++a; &#125;\n</code></pre>\n<p><code>foo.h</code>  提供了  <code>foo.cpp</code>  的接口。最好避免全局变量。</p>\n<h5 id=\"示例不好-155\"><a class=\"markdownIt-Anchor\" href=\"#示例不好-155\">#</a> 示例，不好</h5>\n<pre><code>// foo.h:\nint a;   // 定义\nvoid foo() &#123; ++a; &#125;\n</code></pre>\n<p>一个程序中两次  <code>#include &lt;foo.h&gt;</code>  将导致因为对唯一定义规则的两次违反而出现一个连接错误。</p>\n<h5 id=\"强制实施-405\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-405\">#</a> 强制实施</h5>\n<ul>\n<li>对不符合约定的文件名进行标记。</li>\n<li>检查  <code>.h</code>  和  <code>.cpp</code> （或等价文件）遵循下列各规则。</li>\n</ul>\n<h1 id=\"a-names-faqafaq-常见问题及其回答\"><a class=\"markdownIt-Anchor\" href=\"#a-names-faqafaq-常见问题及其回答\">#</a> <a name=\"S-faq\"></a>FAQ: 常见问题及其回答</h1>\n<p>本节中包括了对关于这些指导方针的常见问题的回答。</p>\n<h3 id=\"a-namefaq-aimsafaq1-这些指导方针的想要达成什么目标\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-aimsafaq1-这些指导方针的想要达成什么目标\">#</a> <a name=\"Faq-aims\"></a>FAQ.1: 这些指导方针的想要达成什么目标？</h3>\n<p>请参见<a href=\"#S-abstract\">本页面开头</a>。这是一个开源项目，旨在为采用当今的 C++ 标准来编写 C++ 代码而维护的一组现代的权威指导方针。这些指导方针的设计是现代的，尽可能使机器可实施的，并且是为贡献和分支保持开放，以使各种组织机构可以便于将它们整合到其自己组织的编码指导方针之中。</p>\n<h3 id=\"a-namefaq-announcedafaq2-这项工作是何时何地首次公开的\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-announcedafaq2-这项工作是何时何地首次公开的\">#</a> <a name=\"Faq-announced\"></a>FAQ.2: 这项工作是何时何地首次公开的？</h3>\n<p>是在 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9pc29jcHAub3JnL2Jsb2cvMjAxNS8wOS9zdHJvdXN0cnVwLWNwcGNvbjE1LWtleW5vdGU=\">Bjarne Stroustrup 在他为 CppCon 2015 的开场主旨演讲，“Writing Good C++14”</span>。另请参见<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pc29jcHAub3JnL2Jsb2cvMjAxNS8wOS9iamFybmUtc3Ryb3VzdHJ1cC1hbm5vdW5jZXMtY3BwLWNvcmUtZ3VpZGVsaW5lcw==\">相应的 isocpp.org 博客条目</span>，关于类型和内存安全性指导方针的原理请参见 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9pc29jcHAub3JnL2Jsb2cvMjAxNS8wOS9zdXR0ZXItY3BwY29uMTUtZGF5MnBsZW5hcnk=\">Herb Sutter 的后续 CppCon 2015 演讲，“Writing Good C++14 … By Default”</span>。</p>\n<h3 id=\"a-namefaq-maintainersafaq3-谁是这些指导方针的作者和维护者\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-maintainersafaq3-谁是这些指导方针的作者和维护者\">#</a> <a name=\"Faq-maintainers\"></a>FAQ.3: 谁是这些指导方针的作者和维护者？</h3>\n<p>最初的主要作者和维护者是 Bjarne Stroustrup 和 Herb Sutter，而迄今为止的指导方针则是由来自 CERN，Microsoft，Morgan Stanley，以及许多其他组织机构的专家所贡献的。指导方针发布时，其正处于 “0.6” 状态，我们欢迎人们进行贡献。正如 Stroustrup 在其声明中所说：“我们需要帮助！”</p>\n<h3 id=\"a-namefaq-contributeafaq4-我如何进行贡献呢\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-contributeafaq4-我如何进行贡献呢\">#</a> <a name=\"Faq-contribute\"></a>FAQ.4: 我如何进行贡献呢？</h3>\n<p>参见 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2lzb2NwcC9DcHBDb3JlR3VpZGVsaW5lcy9ibG9iL21hc3Rlci9DT05UUklCVVRJTkcubWQ=\">CONTRIBUTING.md</span>。我们感激志愿者的帮助！</p>\n<h3 id=\"a-namefaq-maintainerafaq5-怎样成为一名编辑或维护者\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-maintainerafaq5-怎样成为一名编辑或维护者\">#</a> <a name=\"Faq-maintainer\"></a>FAQ.5: 怎样成为一名编辑或维护者？</h3>\n<p>通过先进行大量贡献并使你的贡献被认可具有一致的质量。参见 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2lzb2NwcC9DcHBDb3JlR3VpZGVsaW5lcy9ibG9iL21hc3Rlci9DT05UUklCVVRJTkcubWQ=\">CONTRIBUTING.md</span>。我们感激志愿者的帮助！</p>\n<h3 id=\"a-namefaq-isoafaq6-这些指导方针被-iso-c-标准委员会采纳了吗它们是否代表委员会的一致意见\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-isoafaq6-这些指导方针被-iso-c-标准委员会采纳了吗它们是否代表委员会的一致意见\">#</a> <a name=\"Faq-iso\"></a>FAQ.6: 这些指导方针被 ISO C++ 标准委员会采纳了吗？它们是否代表委员会的一致意见？</h3>\n<p>不是这样。这些指导方针不在标准之内。它们是为标准服务的，而当前维护的指导方针是为了更有效地使用当前的标准 C++ 的。我们的目标是使其与委员会所设计的标准保持同步。</p>\n<h3 id=\"a-namefaq-isocppafaq7-既然这些指导方针并不是委员会所采纳的它们为何在-githubcomisocpp-之下呢\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-isocppafaq7-既然这些指导方针并不是委员会所采纳的它们为何在-githubcomisocpp-之下呢\">#</a> <a name=\"Faq-isocpp\"></a>FAQ.7: 既然这些指导方针并不是委员会所采纳的，它们为何在  <code>github.com/isocpp</code>  之下呢？</h3>\n<p>因为  <code>isocpp</code>  是标准 C++ 基金会；而标准委员会的仓库则处于 <a href=\"https://github.com/cplusplus\">github.com/<em>cplusplus</em></a> 之下。我们需要一个中立组织来持有版权和许可以明确其并不是由某个人或供应商所控制的。这个自然实体就是基金会，其设立是为了推进使用并持续更新对现代标准 C++ 的理解，以及推进标准委员会的工作。其所遵循的正是与 <span class=\"exturl\" data-url=\"aHR0cDovL2lzb2NwcC5vcmc=\">isocpp.org</span> 为 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9pc29jcHAub3JnL2ZhcQ==\">C++ FAQ</span> 所做的相同模式，它是有 Bjarne Stroustrup，Marshall Cline，和 Herb Sutter 所发起的工作，并以相同的方式贡献为了开放项目。</p>\n<h3 id=\"a-namefaq-cpp98afaq8-会有-c98-版本的指导方针吗c11-版本呢\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-cpp98afaq8-会有-c98-版本的指导方针吗c11-版本呢\">#</a> <a name=\"Faq-cpp98\"></a>FAQ.8: 会有 C<ins>98 版本的指导方针吗？C</ins>11 版本呢？</h3>\n<p>不会。这些指导方针的目标是更好地使用现代标准 C++，以及假定你有一个现代的遵循标准的编译器时如何进行代码编写的。</p>\n<h3 id=\"a-namefaq-language-extensionsafaq9-这些指导方针中会提出新的语言功能吗\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-language-extensionsafaq9-这些指导方针中会提出新的语言功能吗\">#</a> <a name=\"Faq-language-extensions\"></a>FAQ.9: 这些指导方针中会提出新的语言功能吗？</h3>\n<p>不会。这些指导方针的目标是更好地使用现代标准 C++，它们自我限定为仅建议使用这些功能。</p>\n<h3 id=\"a-namefaq-markdownafaq10-这些指导方针的书写使用的是哪个版本的-markdown\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-markdownafaq10-这些指导方针的书写使用的是哪个版本的-markdown\">#</a> <a name=\"Faq-markdown\"></a>FAQ.10: 这些指导方针的书写使用的是哪个版本的 Markdown？</h3>\n<p>这些编码指导方针使用的是 <span class=\"exturl\" data-url=\"aHR0cDovL2NvbW1vbm1hcmsub3Jn\">CommonMark</span>，以及  <code>&lt;a&gt;</code>  HTML 锚定元素。</p>\n<p>我们正在考虑以下这些来自 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vYXJ0aWNsZXMvZ2l0aHViLWZsYXZvcmVkLW1hcmtkb3duLw==\">GitHub Flavored Markdown (GFM)</span> 的扩展：</p>\n<ul>\n<li>有围栏代码块（正在讨论是否统一使用缩进还是围栏代码块）</li>\n<li>表格（我们虽然还没用到，但很需要它们，这是一种 GFM 扩展）</li>\n</ul>\n<p>避免使用其他 HTML 标签和其他扩展。</p>\n<p>注意：我们还没对这种风格达成一致。</p>\n<h3 id=\"a-namefaq-gslafaq50-什么是-gsl指导方针支持程序库\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-gslafaq50-什么是-gsl指导方针支持程序库\">#</a> <a name=\"Faq-gsl\"></a>FAQ.50: 什么是 GSL（指导方针支持程序库）？</h3>\n<p>GSL 是在指导方针中所指定的类型和别名的一个小集合。当写下本文时，对它们的说明还过于松散；我们计划添加一个 WG21 风格的接口规范来确保不同实现之间保持一致，并作为一项可能的标准化提案，按常规遵循标准委员会进行采纳、改进、修订或否决。</p>\n<h3 id=\"a-namefaq-msgslafaq51-githubcommicrosoftgsl-是-gsl-吗\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-msgslafaq51-githubcommicrosoftgsl-是-gsl-吗\">#</a> <a name=\"Faq-msgsl\"></a>FAQ.51: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9HU0w=\">github.com/Microsoft/GSL</span> 是 GSL 吗？</h3>\n<p>不是。它只是由 Microsoft 所贡献的第一个实现。我们鼓励其他供应商提供其他的实现，对该实现的分支和贡献也是被鼓励的。书写本文作为一项公开项目的一周中，已经出现了至少一个 GPLv3 的开源实现。我们计划制定一个 WG21 风格的接口规范来确保不同实现之间保持一致。</p>\n<h3 id=\"a-namefaq-gsl-implementationafaq52-为何不在指导方针之中提供一个真正的-gsl-实现呢\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-gsl-implementationafaq52-为何不在指导方针之中提供一个真正的-gsl-实现呢\">#</a> <a name=\"Faq-gsl-implementation\"></a>FAQ.52: 为何不在指导方针之中提供一个真正的 GSL 实现呢？</h3>\n<p>我们不愿去保佑某个特定的实现，因为我们不希望让人们以为只有一个实现，而疏忽大意地扼杀了其他并行的实现。而如果在指导方针中包含一个真正实现的话，无论是谁提供了它都会变得过于有影响力。我们更倾向于采用委员会的更具长期性的方案，即指定其接口而不是实现。但同时我们也需要至少存在一个实现；希望可以有很多。</p>\n<h3 id=\"a-namefaq-boostafaq53-为什么不把-gsl-类型提交给-boost-呢\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-boostafaq53-为什么不把-gsl-类型提交给-boost-呢\">#</a> <a name=\"Faq-boost\"></a>FAQ.53: 为什么不把 GSL 类型提交给 Boost 呢？</h3>\n<p>因为我们想要立刻使用它们，也因为我们想要在一旦标准库中出现了满足其需要的类型时立刻将它们撤销掉。</p>\n<h3 id=\"a-namefaq-gsl-isoafaq54-iso-c-标准委员会采纳了-gsl指导方针支持程序库吗\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-gsl-isoafaq54-iso-c-标准委员会采纳了-gsl指导方针支持程序库吗\">#</a> <a name=\"Faq-gsl-iso\"></a>FAQ.54: ISO C++ 标准委员会采纳了 GSL（指导方针支持程序库）吗？</h3>\n<p>没有。GSL 的存在只为提供少量标准库中还没有的类型和别名。如果委员会决定了（这些类型或者满足其需要的其他类型的）标准化的版本，就可以将它们从 GSL 中删除了。</p>\n<h3 id=\"a-namefaq-gsl-string-viewafaq55-既然你是尽可能使用标准类型为什么-gsl-的-spanchar-同-library-fundamentals-1-technical-specification-和-c17-工作文本中的-string_view-不同呢为什么不使用委员会采纳的-string_view\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-gsl-string-viewafaq55-既然你是尽可能使用标准类型为什么-gsl-的-spanchar-同-library-fundamentals-1-technical-specification-和-c17-工作文本中的-string_view-不同呢为什么不使用委员会采纳的-string_view\">#</a> <a name=\"Faq-gsl-string-view\"></a>FAQ.55: 既然你是尽可能使用标准类型，为什么 GSL 的  <code>span&lt;char&gt;</code>  同 Library Fundamentals 1 Technical Specification 和 C++17 工作文本中的  <code>string_view</code>  不同呢？为什么不使用委员会采纳的  <code>string_view</code> ？</h3>\n<p>有关 C++ 标准库的视图的分类的统一观点是，“视图（view）” 意味着 “只读”，而 “跨距（span）” 意味着 “可读写”。如果你只需要一组字符的不需要保证边界检查的只读视图，并且你可以用 C<ins>17，那就使用 C</ins>17 的  <code>std::string_view</code> 。否则，如果你需要的是不需要保证边界检查的可读写视图，并且可以用 C<ins>20，那就用 C</ins>20 的  <code>std::span&lt;char&gt;</code> 。否则，就用  <code>gsl::span&lt;char&gt;</code> 。</p>\n<h3 id=\"a-namefaq-gsl-ownerafaq56-owner-和提案的-observer_ptr-一样吗\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-gsl-ownerafaq56-owner-和提案的-observer_ptr-一样吗\">#</a> <a name=\"Faq-gsl-owner\"></a>FAQ.56:  <code>owner</code>  和提案的  <code>observer_ptr</code>  一样吗？</h3>\n<p>不一样。 <code>owner</code>  有所有权，它是一个别名，而且适用于任何间接类型。而  <code>observer_ptr</code>  的主要意图则是明确某个<em>没有</em>所有权的指针。</p>\n<h3 id=\"a-namefaq-gsl-stack-arrayafaq57-stack_array-和标准的-array-一样吗\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-gsl-stack-arrayafaq57-stack_array-和标准的-array-一样吗\">#</a> <a name=\"Faq-gsl-stack-array\"></a>FAQ.57:  <code>stack_array</code>  和标准的  <code>array</code>  一样吗？</h3>\n<p>不一样。 <code>stack_array</code>  保证在栈上分配。虽然  <code>std::array</code>  直接在其自身内部包含存储，但  <code>array</code>  对象可以放在包括堆在内的任何地方。</p>\n<h3 id=\"a-namefaq-gsl-dyn-arrayafaq58-dyn_array-和-vector-或者提案的-dynarray-一样吗\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-gsl-dyn-arrayafaq58-dyn_array-和-vector-或者提案的-dynarray-一样吗\">#</a> <a name=\"Faq-gsl-dyn-array\"></a>FAQ.58:  <code>dyn_array</code>  和  <code>vector</code>  或者提案的  <code>dynarray</code>  一样吗？</h3>\n<p>不一样。 <code>dyn_array</code>  是不可改变大小的，是一种指代堆分配的固定大小数组的一种安全方式。与  <code>vector</code>  不同，它是为了取代数组  <code>new[]</code>  的。与委员会中提案的  <code>dynarray</code>  不同，它并不会参与编译器和语言的魔法，来在当它作为分配于栈上的对象的成员时也在栈上分配；它只不过指代一个 “动态的” 或基于堆的数组而已。</p>\n<h3 id=\"a-namefaq-gsl-expectsafaq59-expects-和-assert-一样吗\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-gsl-expectsafaq59-expects-和-assert-一样吗\">#</a> <a name=\"Faq-gsl-expects\"></a>FAQ.59:  <code>Expects</code>  和  <code>assert</code>  一样吗？</h3>\n<p>不一样。它是一种对于契约前条件语言支持的占位符。</p>\n<h3 id=\"a-namefaq-gsl-ensuresafaq60-ensures-和-assert-一样吗\"><a class=\"markdownIt-Anchor\" href=\"#a-namefaq-gsl-ensuresafaq60-ensures-和-assert-一样吗\">#</a> <a name=\"Faq-gsl-ensures\"></a>FAQ.60:  <code>Ensures</code>  和  <code>assert</code>  一样吗？</h3>\n<p>不一样。它是一种对于契约后条件语言支持的占位符。</p>\n<h1 id=\"a-names-librariesa附录-a-程序库\"><a class=\"markdownIt-Anchor\" href=\"#a-names-librariesa附录-a-程序库\">#</a> <a name=\"S-libraries\"></a>附录 A: 程序库</h1>\n<p>这个部分列出了一些推荐的程序库，并且特别推荐了其中的几个。</p>\n<p>??? 这个对一般性指南来说合适吗？我觉得不是？？？</p>\n<h1 id=\"a-names-modernizinga附录-b-代码的现代化转换\"><a class=\"markdownIt-Anchor\" href=\"#a-names-modernizinga附录-b-代码的现代化转换\">#</a> <a name=\"S-modernizing\"></a>附录 B: 代码的现代化转换</h1>\n<p>理想情况下，我们的所有代码都应当遵循全部的规则。<br>\n而实际情况则是，我们不得不对付大量的老代码：</p>\n<ul>\n<li>那些在我们的指导方针被建立或者被了解到之前所编写的代码</li>\n<li>那些依据老的或者不同的标准所编写的程序库</li>\n<li>那些在 “不寻常” 的约束下编写的代码</li>\n<li>那些我们还未来得及使其现代化的代码</li>\n</ul>\n<p>如果有上百万行的新代码的话，“立刻改掉它们” 的想法一般都是不现实的。<br>\n因此，我们需要一种方式能够渐进地对代码库进行现代化转换。</p>\n<p>将老代码升级为现代风格可能是很让人却步的工作。<br>\n老代码通常即混乱（难于理解）又可以（在当前使用范围内）正确工作。<br>\n很有可能，原来的程序员并不在场，而且测试用例也不完整。<br>\n代码的混乱性显著地增大了为进行任何改动所需要的工作量和引入错误的风险。<br>\n通常，混乱的老代码的运行会有不必要的缓慢，因为它需要过期的编译器，并且无法得益于当代硬件的改进。<br>\n许多情况下，都需要某种自动进行 “现代化转换” 的工具支持来进行主要的升级工作。</p>\n<p>对代码现代化转换的目的在于简化新功能的添加，简化维护工作，以及增加性能（吞吐量或延迟），和更好地利用当代的硬件能力。<br>\n而让代码 “看起来更好” 或 “遵循现代风格” 自身并不能成为改动的理由。<br>\n每一种改动都蕴含着风险，而是由过时的代码库则会蕴含一些成本（包含丢失机会带来的成本）。<br>\n成本的缩减必须超过风险。</p>\n<p>如何做呢？</p>\n<p>并不存在唯一的代码现代化转换的方案。<br>\n如何最好地执行，依赖于代码，更新的进度压力，开发者的背景，以及可用的工具。<br>\n下面是一些（非常一般的）想法：</p>\n<ul>\n<li>理想情况是 “对全部代码一起进行升级”。这将在最短的总时间内获得做大的好处。<br>\n在大多数情况下，这也是不可能的。</li>\n<li>我们可以对代码库以模块为单位进行转换，不过任何影响接口（尤其是 ABI）的规则，如 <a href=\"#SS-views\">使用  <code>span</code> </a>，都无法按模块来达成。</li>\n<li>我们可以 “自底向上” 转换代码，并最先应用我们估计在给定的代码库上将会带来最大好处和最少麻烦的那些规则。</li>\n<li>我们可以从关注接口开始，比如说，保证没有资源的泄漏，没有指针误用等。<br>\n这可能会导致涉及整个代码库的一些改动，不过它们是最可能会带来巨大好处的改动。<br>\n以后，隐藏在这些接口后面的代码可以渐进地进行现代化转换而不会影响其他的代码。</li>\n</ul>\n<p>无论你选择哪种方式，都要注意，对指导方针的最高度的遵循性才会带来大多数的好处。<br>\n这些指导方针并不是一组无关规则的随机集合，并不能让你随意选取并期望取得成功。</p>\n<p>我们衷心希望听到有关它们的使用经验，以及有关工具是如何使用的。<br>\n如果有分析工具（即便是代码变换工具）的支持的话，代码现代化转换后可以变得更快，更简单，而且更安全。</p>\n<h1 id=\"a-names-discussiona附录-c-讨论\"><a class=\"markdownIt-Anchor\" href=\"#a-names-discussiona附录-c-讨论\">#</a> <a name=\"S-discussion\"></a>附录 C: 讨论</h1>\n<p>这个部分包含了对规则和规则集合的跟进材料。<br>\n尤其是，我们列出了更多的原理说明，更长的例子，以及对替代方案的探讨等。</p>\n<h3 id=\"a-namesd-ordera讨论-以成员的声明顺序进行成员变量的定义和初始化\"><a class=\"markdownIt-Anchor\" href=\"#a-namesd-ordera讨论-以成员的声明顺序进行成员变量的定义和初始化\">#</a> <a name=\"Sd-order\"></a>讨论：以成员的声明顺序进行成员变量的定义和初始化</h3>\n<p>成员变量总是以它们在类定义中的声明顺序进行初始化，因此在构造函数初始化列表中应当以该顺序来书写它们。以别的顺序书写它们只会让代码混淆，因为它并不会以你所见到的顺序来运行，而这会导致难于发现与顺序有关的 BUG。</p>\n<pre><code>class Employee &#123;\n    string email, first, last;\npublic:\n    Employee(const char* firstName, const char* lastName);\n    // ...\n&#125;;\n\nEmployee::Employee(const char* firstName, const char* lastName)\n  : first(firstName),\n    last(lastName),\n    // 不好: first 和 last 还未构造\n    email(first + &quot;.&quot; + last + &quot;@acme.com&quot;)\n&#123;&#125;\n</code></pre>\n<p>在这个例子中， <code>email</code>  比  <code>first</code>  和  <code>last</code>  构造得早，因为它是先声明的。这意味着其构造函数对  <code>first</code>  和  <code>last</code>  的使用过早了 —— 不只在它们被设为所需的值之前，而完全是在它们被构造之前就使用了。</p>\n<p>如果类定义和构造函数体是在不同文件中的话，这种由成员变量声明顺序对构造函数的正确性造成的远距离影响将更难于发现。</p>\n<p><strong>参考</strong>：</p>\n<p><a href=\"#Cline99\">[Cline99]</a> §22.03-11, <a href=\"#Dewhurst03\">[Dewhurst03]</a> §52-53, <a href=\"#Koenig97\">[Koenig97]</a> §4, <a href=\"#Lakos96\">[Lakos96]</a> §10.3.5, <a href=\"#Meyers97\">[Meyers97]</a> §13, <a href=\"#Murray93\">[Murray93]</a> §2.1.3, <a href=\"#Sutter00\">[Sutter00]</a> §47</p>\n<h3 id=\"a-namesd-inita讨论使用-和-作为初始化式\"><a class=\"markdownIt-Anchor\" href=\"#a-namesd-inita讨论使用-和-作为初始化式\">#</a> <a name=\"Sd-init\"></a>讨论：使用  <code>=</code> ， <code>&#123;&#125;</code> ，和  <code>()</code>  作为初始化式</h3>\n<p>???</p>\n<h3 id=\"a-namesd-factorya讨论-当需要在初始化过程中使用虚函数行为时使用工厂函数\"><a class=\"markdownIt-Anchor\" href=\"#a-namesd-factorya讨论-当需要在初始化过程中使用虚函数行为时使用工厂函数\">#</a> <a name=\"Sd-factory\"></a>讨论：当需要在初始化过程中使用 “虚函数行为” 时，使用工厂函数</h3>\n<p>如果你的设计需要从基类的构造函数或析构函数中对  <code>f</code>  或者  <code>g</code>  这样的函数向派生类进行虚函数派发的话，你其实需要的是其他技巧，比如后构造函数 —— 一种必须由调用者调用以完成初始化过程的成员函数，它可以安全地调用  <code>f</code>  和  <code>g</code> ，这是由于成员函数中的虚函数调用能够正常工作。“参考” 部分中列出了一些这样的技巧。以下是一个不完整的可选项列表：</p>\n<ul>\n<li><em>推卸责任：</em> 仅仅给出文档说明，要求用户代码在对象构造之后必须立刻调用后初始化函数。</li>\n<li><em>惰性后初始化：</em> 在第一个调用的成员函数中进行。用基类中的一个布尔标记说明后初始化是否已经执行过。</li>\n<li><em>使用虚基类语义：</em> 语言规则要求由最终派生类的构造函数来决定调用哪个基类构造函数；你可以利用这点。（参见<a href=\"#Taligent94\"> [Taligent94]</a>。）</li>\n<li><em>使用工厂函数：</em> 以这种方式，你可以轻易确保进行对后构造函数的调用。</li>\n</ul>\n<p>以下是对最后一种选项的一个例子：</p>\n<pre><code>class B &#123;\npublic:\n    B()\n    &#123;\n        /* ... */\n        f(); // 不好: C.82：不要在构造函数和析构函数中调用虚函数\n        /* ... */\n    &#125;\n\n    virtual void f() = 0;\n&#125;;\n\nclass B &#123;\nprotected:\n    class Token &#123;&#125;;\n\npublic:\n    // 需要公开构造函数以使 make_shared 可以访问它。\n    // 通过要求一个 Token 达成受保护访问等级。\n    explicit B(Token) &#123; /* ... */ &#125;  // 创建不完全初始化的对象\n    virtual void f() = 0;\n\n    template&lt;class T&gt;\n    static shared_ptr&lt;T&gt; create()    // 创建共享对象的接口\n    &#123;\n        auto p = make_shared&lt;T&gt;(typename T::Token&#123;&#125;);\n        p-&gt;post_initialize();\n        return p;\n    &#125;\n\nprotected:\n    virtual void post_initialize()   // 构造之后立即调用\n        &#123; /* ... */ f(); /* ... */ &#125; // 好: 虚函数分派是安全的\n    &#125;\n&#125;;\n\n\nclass D : public B &#123;                 // 某个派生类\nprotected:\n    class Token &#123;&#125;;\n\npublic:\n    // 需要公开构造函数以使 make_shared 可以访问它。\n    // 通过要求一个 Token 达成受保护访问等级。\n    explicit D(Token) : B( B::Token&#123;&#125; ) &#123;&#125;\n    void f() override &#123; /* ... */ &#125;;\n\nprotected:\n    template&lt;class T&gt;\n    friend shared_ptr&lt;T&gt; B::create();\n&#125;;\n\nshared_ptr&lt;D&gt; p = D::Create&lt;D&gt;();    // 创建一个 D 对象\n</code></pre>\n<p>这种设计需要遵守以下纪律：</p>\n<ul>\n<li>像  <code>D</code>  这样的派生类不能暴露可公开调用的构造函数。否则的话， <code>D</code>  的使用者就能够创建  <code>D</code>  对象而不调用  <code>post_initialize</code>  了。</li>\n<li>分配被限定为使用  <code>operator new</code> 。不过， <code>B</code>  可以覆盖  <code>new</code> （参见 <a href=\"#SuttAlex05\">SuttAlex05</a> 条款 45 和 46）。</li>\n<li><code>D</code>  必须定义一个带有与  <code>B</code>  所选择的相同的参数的构造函数。不过，定义多个重载的  <code>create</code>  可以缓和这个问题；而且还可以是这些重载对参数类型进行模板化。</li>\n</ul>\n<p>一旦满足了上述要求，这个设计就可以保证对于任意完全构造的  <code>B</code>  的派生类对象，都将调用  <code>post_initialize</code> 。 <code>post_initialize</code>  不必是虚函数；它可以随意进行虚函数调用。</p>\n<p>总之，不存在完美的后构造技巧。最差的方式是完全回避问题而只是让调用方来人工调用后构造函数。即便是最佳方案也需要采用一种不同的对象构造语法（易于进行编译期检查）以及需要派生类的作者的协作（这无法进行编译期进行检查）。</p>\n<p><strong>参考</strong>: <a href=\"#Alexandrescu01\">[Alexandrescu01]</a> §3, <a href=\"#Boost\">[Boost]</a>, <a href=\"#Dewhurst03\">[Dewhurst03]</a> §75, <a href=\"#Meyers97\">[Meyers97]</a> §46, <a href=\"#Stroustrup00\">[Stroustrup00]</a> §15.4.3, <a href=\"#Taligent94\">[Taligent94]</a></p>\n<h3 id=\"a-namesd-dtora讨论-基类的析构函数应当要么是-public-和-virtual要么是-protected-且非-virtual\"><a class=\"markdownIt-Anchor\" href=\"#a-namesd-dtora讨论-基类的析构函数应当要么是-public-和-virtual要么是-protected-且非-virtual\">#</a> <a name=\"Sd-dtor\"></a>讨论：基类的析构函数应当要么是 public 和 virtual，要么是 protected 且非 virtual</h3>\n<p>析构应不应该表现为虚函数？就是说，是否允许通过指向  <code>base</code>  类的指针来进行析构呢？如果是的话， <code>base</code>  的析构函数为被调用则必须是 public 的，而且必须 virtual，否则调用就会导致未定义行为。否则的话，它应当是 protected 的，这样就只有派生类可以在它们自己的析构函数中调用它，且应当是非 virtual 的，因为它并不需要表现为虚函数的行为。</p>\n<h5 id=\"示例-407\"><a class=\"markdownIt-Anchor\" href=\"#示例-407\">#</a> 示例</h5>\n<p>基类的一般情况是为了具有 public 的派生类，因而调用方代码基本上可以确定要用到某种比如  <code>shared_ptr&lt;base&gt;</code>  这样的东西：</p>\n<pre><code>class Base &#123;\npublic:\n    ~Base();                   // 不好, 非 virtual\n    virtual ~Base();           // 好\n    // ...\n&#125;;\n\nclass Derived : public Base &#123; /* ... */ &#125;;\n\n&#123;\n    unique_ptr&lt;Base&gt; pb = make_unique&lt;Derived&gt;();\n    // ...\n&#125; // 只有当 ~Base 是虚函数时 ~pb 才会调用正确的析构函数\n</code></pre>\n<p>少数比如策略类这类的情况下，类被用作基类是为方便起见，而并非是其多态行为。建议将它们的析构函数作为 protected 和非 virtual 函数：</p>\n<pre><code>class My_policy &#123;\npublic:\n    virtual ~My_policy();      // 不好, public 并且 virtual\nprotected:\n    ~My_policy();              // 好\n    // ...\n&#125;;\n\ntemplate&lt;class Policy&gt;\nclass customizable : Policy &#123; /* ... */ &#125;; // 注: private 继承\n</code></pre>\n<h5 id=\"注解-399\"><a class=\"markdownIt-Anchor\" href=\"#注解-399\">#</a> 注解</h5>\n<p>这个简单的指导方针演示了一种微妙的问题，而且反映了继承的现代用法以及面向对象的设计原则。</p>\n<p>对于某个基类  <code>Base</code> ，调用方代码可能通过指向  <code>Base</code>  的指针来销毁派生类对象，比如使用一个  <code>unique_ptr&lt;Base&gt;</code> 。如果  <code>Base</code>  的析构函数是 public 的且非 virtual（默认情况），它就可能意外地在实际指向一个派生类对象的指针上进行调用，这种情况下想要进行的删除的行为是未定义的。这种状况曾导致一些老编码标准提出通用的要求，让所有基类析构函数都必须 virtual。这种做法杀伤力过大了（虽然这是常见的情况）；其实，规则应当是当且仅当基类析构函数是 public 时才要求它是 virtual 的。</p>\n<p>编写一个基类就是在定义一种抽象（参见条款 35 到 37）。注意对于参与这个抽象的每个成员函数来说，你都需要作出以下决定：</p>\n<ul>\n<li>它是否应当表现为虚函数。</li>\n<li>它是应当对所有使用  <code>Base</code>  指针的调用方公开，还是作为隐藏的内部实现细节。</li>\n</ul>\n<p>如条款 39 中所述，对于普通成员函数来说，其选择可以是：允许通过  <code>Base</code>  指针对其进行非虚调用（但当它调用了虚函数时可具有虚行为，比如在 NVI 或者模板方法模式中那样），进行虚调用，或者完全不能调用。NVI 模式是一种避免公开虚函数的技巧。</p>\n<p>析构可以仅仅被看做是另一种操作，虽然它带有特殊的语义，并且非虚调用要么很危险要么是错误的。因而，对于基类析构函数来说，其选择有：允许通过  <code>Base</code>  指针进行虚函数调用，或者完全不能调用；“非虚调用” 是不行的。这样的话，基类析构函数当其可以被调用（即为 public）时应当是 virtual 的，否则就为非 virtual。</p>\n<p>注意 NVI 模式并不适用于析构函数，因为构造函数和析构函数无法进行深析构调用。（参见条款 39 和 55。）</p>\n<p>推论：当编写基类时，一定要明确编写析构函数，因为隐式生成的析构函数是 public 和非 virtual 的。当预置函数体没问题是你当然可以用  <code>=default</code> ，而仅仅为其指定正确的可见性和虚函数性质即可。</p>\n<h5 id=\"例外-61\"><a class=\"markdownIt-Anchor\" href=\"#例外-61\">#</a> 例外</h5>\n<p>某些组件体系架构（如 COM 和 CORBA）并不适用标准的删除机制，而是为对象的处置设立了不同的方案。请遵循相应的模式和惯用法，并在适当时采纳本条指导方针。</p>\n<p>再考虑一下这种罕见情况：</p>\n<ul>\n<li><code>B</code>  既是一个基类，也是可以被实例化的具体类，因而其析构函数必须为 public 以便  <code>B</code>  的对象可以创建和销毁。</li>\n<li>而  <code>B</code>  也没有虚函数，且并不打算按多态方式使用，因此虽然其析构函数是 public 它也不必是 virtual 的。</li>\n</ul>\n<p>这样的话，虽然析构函数必须为 public，也会有很强的压力来阻止它变为 virtual，因为作为第一个 virtual 函数，若其所添加的功能永远不会被利用的话，它就会损害所有的运行时类型开销。</p>\n<p>在这种罕见情况下，可以是析构函数 public 且非 virtual，但要明确说明其派生类对象绝不能当作  <code>B</code>  来多态地使用。我们对  <code>std::unary_function</code>  正是这样做的。</p>\n<p>不过，一般来说应当避免具体的基类（参见条款 35）。例如， <code>unary_function</code>  不过是聚合了一组 typedef，它不可能会被有意单独实例化。给它提供 public 的析构函数完全没有任何意义；更好的设计应当是遵循本条款的建议来给它一个 protected 非虚析构函数猜到。</p>\n<p><strong>参考</strong>: <a href=\"#SuttAlex05\">[SuttAlex05]</a> Item 50, <a href=\"#Cargill92\">[Cargill92]</a> pp. 77-79, 207? <a href=\"#Cline99\">[Cline99]</a> §21.06, 21.12-13? <a href=\"#Henricson97\">[Henricson97]</a> pp. 110-114? <a href=\"#Koenig97\">[Koenig97]</a> Chapters 4, 11? <a href=\"#Meyers97\">[Meyers97]</a> §14? <a href=\"#Stroustrup00\">[Stroustrup00]</a> §12.4.2? <a href=\"#Sutter02\">[Sutter02]</a> §27? <a href=\"#Sutter04\">[Sutter04]</a> §18</p>\n<h3 id=\"a-namesd-noexcepta讨论-noexcept-的用法\"><a class=\"markdownIt-Anchor\" href=\"#a-namesd-noexcepta讨论-noexcept-的用法\">#</a> <a name=\"Sd-noexcept\"></a>讨论: noexcept 的用法</h3>\n<p>???</p>\n<h3 id=\"a-namesd-never-faila讨论-虚构函数回收函数和-swap-不允许失败\"><a class=\"markdownIt-Anchor\" href=\"#a-namesd-never-faila讨论-虚构函数回收函数和-swap-不允许失败\">#</a> <a name=\"Sd-never-fail\"></a>讨论：虚构函数，回收函数和 swap 不允许失败</h3>\n<p>绝不能允许从虚构函数，资源回收函数（如  <code>operator delete</code> ），或者  <code>swap</code>  函数中用  <code>throw</code>  来报告错误。如果这些操作可以失败的话，就几乎不可能编写有用的代码了，而且即便真的发生了某种错误，也几乎不可能有进行重试的任何意义。特别是，C++ 标准库是直截了当地禁止使用可能在析构函数中抛出异常的类型的。现在，大多数析构函数缺省就隐含带有  <code>noexcept</code>  了。</p>\n<h5 id=\"示例-408\"><a class=\"markdownIt-Anchor\" href=\"#示例-408\">#</a> 示例</h5>\n<pre><code>class Nefarious &#123;\npublic:\n    Nefarious() &#123; /* 可能抛出异常的代码 */ &#125;    // 好\n    ~Nefarious() &#123; /* 可能抛出异常的代码 */ &#125;   // 不好, 可能抛出异常\n    // ...\n&#125;;\n</code></pre>\n<ol>\n<li>\n<p><code>Nefarious</code>  对象很难安全地使用，即便是作为局部变量也是如此：</p>\n<pre><code> void test(string&amp; s)\n &#123;\n     Nefarious n;          // 要有麻烦了\n     string copy = s;      // 复制 string\n &#125; // 先后销毁 copy 和 n\n</code></pre>\n<p>这里，对  <code>s</code>  的复制可能抛出异常，且当其抛出了异常而  <code>n</code>  的析构函数也抛出了异常时，程序就会因调用  <code>std::terminate</code>  而退出，因为无法同时传播两个异常。</p>\n</li>\n<li>\n<p>以  <code>Nefarious</code>  为成员或者基类的类同样很难安全地使用，因为它们的析构函数必须调用  <code>Nefarious</code>  的析构函数，且同样遭受其糟糕行为的毒害：</p>\n<pre><code> class Innocent_bystander &#123;\n     Nefarious member;     // 噢，毒害了外围类的析构函数\n     // ...\n &#125;;\n\n void test(string&amp; s)\n &#123;\n     Innocent_bystander i;  // 要有更多麻烦了\n     string copy2 = s;      // 复制 string\n &#125; // 依次销毁 copy 和 i\n</code></pre>\n<p>这里，当  <code>copy2</code>  的构造中抛出了异常时，我们会遇到同样的问题，因为  <code>i</code>  的析构函数现在也会抛出异常，且因此会使我们调用  <code>std::terminate</code> 。</p>\n</li>\n<li>\n<p>你也无法可靠地创建全局或静态的  <code>Nefarious</code>  对象：</p>\n<pre><code> static Nefarious n;       // 噢，无法捕获任何析构函数异常\n</code></pre>\n</li>\n<li>\n<p>你无法可靠地创建  <code>Nefarious</code>  的数组：</p>\n<pre><code> void test()\n &#123;\n     std::array&lt;Nefarious, 10&gt; arr; // 这行代码会导致 std::terminate()\n &#125;\n</code></pre>\n<p>当出现可能抛出异常的析构函数时，数组的行为是未定义的，因为根本不可能发明出合理的回退行为。请想象一下：编译器如何才能生成用来构造  <code>arr</code>  的代码，如果第四个对象的构造函数抛出了异常，这段代码必须放弃，且在其清理模式中将试图调用已经构造完成的每个对象的析构函数…… 而这些析构函数中的一个或更多会抛出异常呢？不存在令人满意的答案。</p>\n</li>\n<li>\n<p>你无法在标准容器中使用  <code>Nefarious</code> ：</p>\n<pre><code> std::vector&lt;Nefarious&gt; vec(10);   // 这行代码会导致 std::terminate()\n</code></pre>\n<p>标准库禁止其所使用的任何析构函数抛出异常。你无法把  <code>Nefarious</code>  对象存储到标准容器中，或者在标准库的任何其他组件上使用它们。</p>\n</li>\n</ol>\n<h5 id=\"注解-400\"><a class=\"markdownIt-Anchor\" href=\"#注解-400\">#</a> 注解</h5>\n<p>它们是绝不能失败的关键函数，因为在事务性编程中需要它们提供两种关键操作：当处理过程中遇到问题时撤回工作，以及当未发生问题时提交工作。如果没有办法可以用无失败操作来安全地撤回的话，就不可能实现无失败的回滚操作。如果没有办法可以用无失败操作（显然  <code>swap</code>  可以，但并不仅限于它）来安全地提交状态的改变的话，就不可能实现无失败的提交操作。</p>\n<p>请考虑以下在 C++ 标准中所找到的建议和要求：</p>\n<blockquote>\n<p>当在栈回溯过程中所调用的析构函数因为异常而退出时，将调用 terminate (15.5.1)。因此析构函数通常应当捕获异常，并防止它们被传播出析构函数。 –<a href=\"#Cplusplus03\">[C++03]</a> §15.2(3)</p>\n<p>C++ 标准库中所定义的任何析构函数（也包括用于实例化标准库模板的任何类型的析构函数）的操作都不会抛出异常。 –<a href=\"#Cplusplus03\">[C++03]</a> §17.4.4.8(3)</p>\n</blockquote>\n<p>包括专门重载的  <code>operator delete</code>  和  <code>operator delete[]</code>  在内的回收函数也属于这一类别，因为一般它们也被用在清理过程，尤其是在异常处理过程中，用以对部分完成的工作进行撤回。<br>\n除了析构函数和回收函数之外，一般的错误安全性技术也依赖于永不失败的  <code>swap</code>  操作 —— 这种情况下，它们不仅用于实现确保成功的回滚操作，也用于实现确保成功的提交操作。例如，以下是对类型  <code>T</code>  的一种惯用的  <code>operator=</code>  实现，它在复制构造之后，调用了无失败的  <code>swap</code> ：</p>\n<pre><code>T&amp; T::operator=(const T&amp; other)\n&#123;\n    auto temp = other;\n    swap(temp);\n    return *this;\n&#125;\n</code></pre>\n<p>(另见条款 56。 ???)</p>\n<p>幸运的是，当进行资源释放时，发生故障的范围肯定会比较小。如果使用异常作为错误报告机制的话，请确保这样的函数会处理其内部的处理中可能会产生的所有异常和其他错误。（对于异常，可以直接把你的析构函数中的所有相关部分都包围到一个  <code>try/catch(...)</code>  块中。）这点非常重要，因为析构函数可能会在某种紧要关头被调用，比如当无法分配某种系统资源（如内存、文件、锁、端口、窗口，或者其他系统对象）的时候。</p>\n<p>当使用异常作为错误处理机制的时候，请始终明示这种行为，将这些函数声明为  <code>noexcept</code> 。（参见条款 75。）</p>\n<p><strong>参考</strong>: <a href=\"#SuttAlex05\">[SuttAlex05]</a> Item 51; <a href=\"#Cplusplus03\">[C++03]</a> §15.2(3), §17.4.4.8(3)? <a href=\"#Meyers96\">[Meyers96]</a> §11? <a href=\"#Stroustrup00\">[Stroustrup00]</a> §14.4.7, §E.2-4? <a href=\"#Sutter00\">[Sutter00]</a> §8, §16? <a href=\"#Sutter02\">[Sutter02]</a> §18-19</p>\n<h2 id=\"a-namesd-consistenta统一对复制-移动和销毁操作进行定义\"><a class=\"markdownIt-Anchor\" href=\"#a-namesd-consistenta统一对复制-移动和销毁操作进行定义\">#</a> <a name=\"Sd-consistent\"></a>统一对复制、移动和销毁操作进行定义</h2>\n<h5 id=\"理由-452\"><a class=\"markdownIt-Anchor\" href=\"#理由-452\">#</a> 理由</h5>\n<p>???</p>\n<h5 id=\"注解-401\"><a class=\"markdownIt-Anchor\" href=\"#注解-401\">#</a> 注解</h5>\n<p>一旦定义了复制构造函数，就也得定义复制赋值运算符。</p>\n<h5 id=\"注解-402\"><a class=\"markdownIt-Anchor\" href=\"#注解-402\">#</a> 注解</h5>\n<p>一旦定义了移动构造函数，就也得定义移动赋值运算符。</p>\n<h5 id=\"示例-409\"><a class=\"markdownIt-Anchor\" href=\"#示例-409\">#</a> 示例</h5>\n<pre><code>class X &#123;\npublic:\n    X(const x&amp;) &#123; /* stuff */ &#125;\n\n    // 不好: 未同时定义复制赋值运算符\n\n    X(x&amp;&amp;) noexcept &#123; /* stuff */ &#125;\n\n    // 不好: 未同时定义移动赋值运算符\n\n    // ...\n&#125;;\n\nX x1;\nX x2 = x1; // ok\nx2 = x1;   // 陷阱：要么不能通过编译，要么会做出不好的事\n</code></pre>\n<p>一旦定义了析构函数，就不能再使用编译器所生成的复制或移动操作了；你可能需要定义或者抑制掉移动或复制操作。</p>\n<pre><code>class X &#123;\n    HANDLE hnd;\n    // ...\npublic:\n    ~X() &#123; /* 自定义的行为，比如关闭 hnd */ &#125;\n    // 可疑: 未提到过复制或移动操作——hnd 会怎么样？\n&#125;;\n\nX x1;\nX x2 = x1; // 陷阱：要么不能通过编译，要么会做出不好的事\nx2 = x1;   // 陷阱：要么不能通过编译，要么会做出不好的事\n</code></pre>\n<p>如果定义了复制操作，且有任何基类或成员的诶性定义了移动操作的话，应当同样定义移动操作。</p>\n<pre><code>class X &#123;\n    string s; // 定义了更高效的移动操作\n    // ... 其他数据成员 ...\npublic:\n    X(const X&amp;) &#123; /* stuff */ &#125;\n    X&amp; operator=(const X&amp;) &#123; /* stuff */ &#125;\n\n    //    不好: 并未一同定义移动构造函数和移动赋值\n    //   （为何不把那些自定义的“stuff”重复一下呢？）\n&#125;;\n\nX test()\n&#123;\n    X local;\n    // ...\n    return local;  // 陷阱：可能会低效甚或产生错误的行为\n&#125;\n</code></pre>\n<p>一旦定义了复制构造函数，复制赋值运算符，或者析构函数中额任何一个，你就可能需要也定义其他的。</p>\n<h5 id=\"注解-403\"><a class=\"markdownIt-Anchor\" href=\"#注解-403\">#</a> 注解</h5>\n<p>如果需要定义这五个函数中的任何一个，这就意味着你需要得到与其预置行为不同的行为 —— 而这五者则是非对称相关的。如下所述：</p>\n<ul>\n<li>当编写或禁用复制构造函数或复制赋值运算符之一时，很可能需要对另一个同样对待：若其中之一有 “特别的” 任务，则很可能另一个也应当如此，因为这两个函数应当具有相似的效果。（参见条款 53，其中对这点进行专门的展开说明。）</li>\n<li>当明确编写复制函数时，很可能需要编写析构函数：若复制构造函数所做的 “特别的” 任务为分配或复制某中资源（诸如内存、文件、socket 等），则需要在析构函数中对其进行回收。</li>\n<li>当明确编写析构函数时，很可能需要明确编写或禁用复制操作：若不得不编写一个不平凡的析构函数的话，这通常是由于你需要人工释放对象所持有的某个资源。若是如此的话，很可能需要特别小心这些资源的复制，而你就需要关注对象进行复制和赋值的方式，或者完全禁止复制操作。</li>\n</ul>\n<p>许多情况下，持有以 RAII 的 “拥有者” 对象恰当封装了的资源，是能够吧自己编写这些操作的需要消除掉的。（参见条款 13。）</p>\n<p>应当优先采用编译器生成（包括  <code>=default</code> ）的特殊成员；只有它们才被归类为 “平凡的”，而且至少有一家主要的标准库供应商针对带有平凡特殊成员的类进行了大量地优化。这可能会成为一种常规实践。</p>\n<p><strong>例外</strong>：当特殊函数的声明仅为了使其非公开或者为虚函数而没有特殊的语义时，它并不导致需要其他的特殊成员。<br>\n少数情况下，带有奇怪类型的成员（诸如引用成员）的类也是例外，因为它们的复制语义很古怪。<br>\n在持有引用的类中，你可能需要编写复制构造函数和赋值运算符，但预置的析构函数仍能够做出正确的处理。（需要注意，基本上使用引用成员几乎总是错误的。）</p>\n<p><strong>参考</strong>: <a href=\"#SuttAlex05\">[SuttAlex05]</a> Item 52; <a href=\"#Cline99\">[Cline99]</a> §30.01-14? <a href=\"#Koenig97\">[Koenig97]</a> §4? <a href=\"#Stroustrup00\">[Stroustrup00]</a> §5.5, §10.4? <a href=\"#SuttHysl04b\">[SuttHysl04b]</a></p>\n<p>资源管理规则概览：</p>\n<ul>\n<li><a href=\"#Cr-safety\">提供强资源安全性；亦即，绝不让你认为是资源的任何东西发生泄漏</a></li>\n<li><a href=\"#Cr-never\">绝不在持有未被句柄所拥有的资源时返回或抛出异常</a></li>\n<li><a href=\"#Cr-raw\">“原生” 的指针或引用不可能是资源句柄</a></li>\n<li><a href=\"#Cr-outlive\">绝不让指针的生存期超过其所指向的对象</a></li>\n<li><a href=\"#Cr-templates\">用模板来表现容器（和其他资源句柄）</a></li>\n<li><a href=\"#Cr-value-return\">按值返回容器（依靠移动或复制消除来获得性能）</a></li>\n<li><a href=\"#Cr-handle\">若类为资源句柄，则它需要构造函数，析构函数，复制以及移动操作</a></li>\n<li><a href=\"#Cr-list\">若类为容器，则应为其提供一个初始化式列表构造函数</a></li>\n</ul>\n<h3 id=\"a-namecr-safetya讨论提供强资源安全性亦即绝不让你认为是资源的任何东西发生泄漏\"><a class=\"markdownIt-Anchor\" href=\"#a-namecr-safetya讨论提供强资源安全性亦即绝不让你认为是资源的任何东西发生泄漏\">#</a> <a name=\"Cr-safety\"></a>讨论：提供强资源安全性；亦即，绝不让你认为是资源的任何东西发生泄漏</h3>\n<h5 id=\"理由-453\"><a class=\"markdownIt-Anchor\" href=\"#理由-453\">#</a> 理由</h5>\n<p>避免泄漏。泄漏会导致性能损耗，发生神秘的错误，系统崩溃，以及安全性的违犯。</p>\n<p><strong>其他形式</strong>：使所有资源都表示为某种可以自我管理生存期的类的对象。</p>\n<h5 id=\"示例-410\"><a class=\"markdownIt-Anchor\" href=\"#示例-410\">#</a> 示例</h5>\n<pre><code>template&lt;class T&gt;\nclass Vector &#123;\nprivate:\n    T* elem;   // 自由存储中的 sz 个元素，由类对象所拥有\n    int sz;\n    // ...\n&#125;;\n</code></pre>\n<p>这个类是一个资源句柄。它管理各个  <code>T</code>  对象的生存期。为此， <code>Vector</code>  必然要对<a href=\"???\">一组特殊操作</a>（几个构造函数，析构函数，等等）进行定义或弃置。</p>\n<h5 id=\"示例-411\"><a class=\"markdownIt-Anchor\" href=\"#示例-411\">#</a> 示例</h5>\n<pre><code>??? “奇异的”非内存资源 ???\n</code></pre>\n<h5 id=\"强制实施-406\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-406\">#</a> 强制实施</h5>\n<p>防止泄漏的基本技巧是让所有的资源都被某种带有回档析构函数的资源句柄所拥有。检查工具能够查找出 “裸  <code>new</code> ”。给定一组 C 风格的分配函数（如  <code>fopen()</code> ），检查工具也能够查找出未被资源句柄管理的使用点。一般来说，可以带着怀疑看待 “裸指针”，对其进行标记和分析。如果没有人为输入的话，时无法产生资源的完整列表的（“资源” 的定义有些过于宽泛），不过可以用一个资源列表来对工具进行 “参数化”。</p>\n<h3 id=\"a-namecr-nevera讨论绝不在持有未被句柄所拥有的资源时返回或抛出异常\"><a class=\"markdownIt-Anchor\" href=\"#a-namecr-nevera讨论绝不在持有未被句柄所拥有的资源时返回或抛出异常\">#</a> <a name=\"Cr-never\"></a>讨论：绝不在持有未被句柄所拥有的资源时返回或抛出异常</h3>\n<h5 id=\"理由-454\"><a class=\"markdownIt-Anchor\" href=\"#理由-454\">#</a> 理由</h5>\n<p>这会导致泄漏。</p>\n<h5 id=\"示例-412\"><a class=\"markdownIt-Anchor\" href=\"#示例-412\">#</a> 示例</h5>\n<pre><code>void f(int i)\n&#123;\n    FILE* f = fopen(&quot;a file&quot;, &quot;r&quot;);\n    ifstream is &#123; &quot;another file&quot; &#125;;\n    // ...\n    if (i == 0) return;\n    // ...\n    fclose(f);\n&#125;\n</code></pre>\n<p>当  <code>i == 0</code>  时  <code>a file</code>  的文件句柄就会泄漏。另一方面， <code>another file</code>  的  <code>ifstream</code>  则将会（在销毁时）正确关闭它的文件。如果你必须显式使用指针而不是带有特定语义的资源句柄的话，可以使用带有自定义删除器的  <code>unique_ptr</code>  或  <code>shared_ptr</code> ：</p>\n<pre><code>void f(int i)\n&#123;\n    unique_ptr&lt;FILE, int(*)(FILE*)&gt; f(fopen(&quot;a file&quot;, &quot;r&quot;), fclose);\n    // ...\n    if (i == 0) return;\n    // ...\n&#125;\n</code></pre>\n<p>这样更好：</p>\n<pre><code>void f(int i)\n&#123;\n    ifstream input &#123;&quot;a file&quot;&#125;;\n    // ...\n    if (i == 0) return;\n    // ...\n&#125;\n</code></pre>\n<h5 id=\"强制实施-407\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-407\">#</a> 强制实施</h5>\n<p>检查器必须将任何 “裸指针” 当作可疑处理。<br>\n检查器可能必须依赖于人工提供的资源列表进行工作。<br>\n上手时，我们知道标准库容器， <code>string</code> ，以及智能指针。<br>\n <code>span</code>  和  <code>string_view</code>  的使用能够提供巨大的帮助（它们并非资源句柄）。</p>\n<h3 id=\"a-namecr-rawa讨论原生的指针或引用不可能是资源句柄\"><a class=\"markdownIt-Anchor\" href=\"#a-namecr-rawa讨论原生的指针或引用不可能是资源句柄\">#</a> <a name=\"Cr-raw\"></a>讨论：“原生” 的指针或引用不可能是资源句柄</h3>\n<h5 id=\"理由-455\"><a class=\"markdownIt-Anchor\" href=\"#理由-455\">#</a> 理由</h5>\n<p>使得能够区分所有者和视图。</p>\n<h5 id=\"注解-404\"><a class=\"markdownIt-Anchor\" href=\"#注解-404\">#</a> 注解</h5>\n<p>这和你如何 “拼写” 指针是两回事： <code>T*</code> ， <code>T&amp;</code> ， <code>Ptr&lt;T&gt;</code>  和  <code>Range&lt;T&gt;</code>  都不是所有者。</p>\n<h3 id=\"a-namecr-outlivea讨论绝不让指针的生存期超过其所指向的对象\"><a class=\"markdownIt-Anchor\" href=\"#a-namecr-outlivea讨论绝不让指针的生存期超过其所指向的对象\">#</a> <a name=\"Cr-outlive\"></a>讨论：绝不让指针的生存期超过其所指向的对象</h3>\n<h5 id=\"理由-456\"><a class=\"markdownIt-Anchor\" href=\"#理由-456\">#</a> 理由</h5>\n<p>避免极难找到的错误。这种指针的解引用时未定义行为，能够导致发生对类型系统的违犯。</p>\n<h5 id=\"示例-413\"><a class=\"markdownIt-Anchor\" href=\"#示例-413\">#</a> 示例</h5>\n<pre><code>string* bad()   // 确实很坏\n&#123;\n    vector&lt;string&gt; v = &#123; &quot;This&quot;, &quot;will&quot;, &quot;cause&quot;, &quot;trouble&quot;, &quot;!&quot; &#125;;\n    // 导致指向已经销毁的对象（v）的已经销毁的成员的一个指针被泄漏出去\n    return &amp;v[0];\n&#125;\n\nvoid use()\n&#123;\n    string* p = bad();\n    vector&lt;int&gt; xx = &#123;7, 8, 9&#125;;\n    // 未定义行为: x 可能不是字符串 &quot;This&quot;\n    string x = *p;\n    // 未定义行为: 我们不知道在位置 p 上分配的到底是什么（如果有的话）\n    *p = &quot;Evil!&quot;;\n&#125;\n</code></pre>\n<p><code>v</code>  中的各个  <code>string</code>  都在  <code>bad()</code>  退出之时被销毁了，  <code>v</code>  自身也是如此。其所返回的指针指向自由存储上的未分配内存。（由  <code>p</code>  所指向的）这块内存，在执行  <code>*p</code>  之时可能已经被重新分配了。此时很可能并不存在可以读取的  <code>string</code>  对象，而通过  <code>p</code>  进行写入则会轻易损坏某些无关类型的对象。</p>\n<h5 id=\"强制实施-408\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-408\">#</a> 强制实施</h5>\n<p>大多数编译器已经能对简单情况进行警告，而且它们带有可以更进一步的信息。将函数所返回的任何指针都当作是可疑的。用容器、资源句柄和视图（例如  <code>span</code> ，它不是资源句柄）来减少需要检查的情形。上手时，可将带有析构函数的类都当作是资源句柄处理。</p>\n<h3 id=\"a-namecr-templatesa讨论用模板来表现容器和其他资源句柄\"><a class=\"markdownIt-Anchor\" href=\"#a-namecr-templatesa讨论用模板来表现容器和其他资源句柄\">#</a> <a name=\"Cr-templates\"></a>讨论：用模板来表现容器（和其他资源句柄）</h3>\n<h5 id=\"理由-457\"><a class=\"markdownIt-Anchor\" href=\"#理由-457\">#</a> 理由</h5>\n<p>提供静态类型安全的元素操作。</p>\n<h5 id=\"示例-414\"><a class=\"markdownIt-Anchor\" href=\"#示例-414\">#</a> 示例</h5>\n<pre><code>template&lt;typename T&gt; class Vector &#123;\n    // ...\n    T* elem;   // 指向 sz 个 T 类型的元素\n    int sz;\n&#125;;\n</code></pre>\n<h3 id=\"a-namecr-value-returna讨论按值返回容器依靠移动或复制消除来获得性能\"><a class=\"markdownIt-Anchor\" href=\"#a-namecr-value-returna讨论按值返回容器依靠移动或复制消除来获得性能\">#</a> <a name=\"Cr-value-return\"></a>讨论：按值返回容器（依靠移动或复制消除来获得性能）</h3>\n<h5 id=\"理由-458\"><a class=\"markdownIt-Anchor\" href=\"#理由-458\">#</a> 理由</h5>\n<p>简化代码并消除一种进行显式内存管理的需要。将对象递交给外围作用域，由此扩展其生存期。</p>\n<p><strong>参见</strong>：<a href=\"#Rf-out\">F.20，有关 “输出（Out）” 值的一般条款</a></p>\n<h5 id=\"示例-415\"><a class=\"markdownIt-Anchor\" href=\"#示例-415\">#</a> 示例</h5>\n<pre><code>vector&lt;int&gt; get_large_vector()\n&#123;\n    return ...;\n&#125;\n\nauto v = get_large_vector(); //  按值返回没有问题，大多数现代编译器都会进行复制消除\n</code></pre>\n<h5 id=\"例外-62\"><a class=\"markdownIt-Anchor\" href=\"#例外-62\">#</a> 例外</h5>\n<p>见 <a href=\"#Rf-out\">F.20</a> 中的例外。</p>\n<h5 id=\"强制实施-409\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-409\">#</a> 强制实施</h5>\n<p>检查函数所返回额指针和引用，看看它们是否被赋值给资源句柄（如  <code>unique_ptr</code> ）。</p>\n<h3 id=\"a-namecr-handlea讨论若类为资源句柄则它需要构造函数析构函数复制以及移动操作\"><a class=\"markdownIt-Anchor\" href=\"#a-namecr-handlea讨论若类为资源句柄则它需要构造函数析构函数复制以及移动操作\">#</a> <a name=\"Cr-handle\"></a>讨论：若类为资源句柄，则它需要构造函数，析构函数，复制以及移动操作</h3>\n<h5 id=\"理由-459\"><a class=\"markdownIt-Anchor\" href=\"#理由-459\">#</a> 理由</h5>\n<p>以提供对资源的生存期的完全控制。以提供一组协调的对资源的操作。</p>\n<h5 id=\"示例-416\"><a class=\"markdownIt-Anchor\" href=\"#示例-416\">#</a> 示例</h5>\n<pre><code>??? 折腾指针\n</code></pre>\n<h5 id=\"注解-405\"><a class=\"markdownIt-Anchor\" href=\"#注解-405\">#</a> 注解</h5>\n<p>若所有的成员都为资源句柄，则尽可能要依赖预置的特殊操作。</p>\n<pre><code>template&lt;typename T&gt; struct Named &#123;\n    string name;\n    T value;\n&#125;;\n</code></pre>\n<p>现在  <code>Named</code>  带有一个默认构造函数，一个析构函数，以及高效的复制和移动操作，只要  <code>T</code>  也提供了它们。</p>\n<h5 id=\"强制实施-410\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-410\">#</a> 强制实施</h5>\n<p>一般来说，工具是无法知道类是否是资源句柄的。不过，如果类带有某种<a href=\"#SS-ctor\">默认操作</a>的话，它就得拥有全部，而如果类中有成员为资源句柄的话，它也应被当做是资源句柄。</p>\n<h3 id=\"a-namecr-lista讨论若类为容器则应为其提供一个初始化式列表构造函数\"><a class=\"markdownIt-Anchor\" href=\"#a-namecr-lista讨论若类为容器则应为其提供一个初始化式列表构造函数\">#</a> <a name=\"Cr-list\"></a>讨论：若类为容器，则应为其提供一个初始化式列表构造函数</h3>\n<h5 id=\"理由-460\"><a class=\"markdownIt-Anchor\" href=\"#理由-460\">#</a> 理由</h5>\n<p>提供一组初始元素是一种常见情形。</p>\n<h5 id=\"示例-417\"><a class=\"markdownIt-Anchor\" href=\"#示例-417\">#</a> 示例</h5>\n<pre><code>template&lt;typename T&gt; class Vector &#123;\npublic:\n    Vector(std::initializer_list&lt;T&gt;);\n    // ...\n&#125;;\n\nVector&lt;string&gt; vs &#123; &quot;Nygaard&quot;, &quot;Ritchie&quot; &#125;;\n</code></pre>\n<h5 id=\"强制实施-411\"><a class=\"markdownIt-Anchor\" href=\"#强制实施-411\">#</a> 强制实施</h5>\n<p>类怎么算作是容器呢？ ???</p>\n<h1 id=\"a-names-toolsa附录-d-支持工具\"><a class=\"markdownIt-Anchor\" href=\"#a-names-toolsa附录-d-支持工具\">#</a> <a name=\"S-tools\"></a>附录 D: 支持工具</h1>\n<p>这个部分列出了直接支持采用 C++ 核心指导方针的一些工具。这个列表并非要穷尽那些有助于编写良好的 C++ 代码的工具。<br>\n如果一个工具被专门设计以支持并关联到 C++ 核心指导方针，那它就是包括进来的候选者。</p>\n<h3 id=\"a-namest-clangtidya工具-clang-tidy\"><a class=\"markdownIt-Anchor\" href=\"#a-namest-clangtidya工具-clang-tidy\">#</a> <a name=\"St-clangtidy\"></a>工具: <span class=\"exturl\" data-url=\"aHR0cDovL2NsYW5nLmxsdm0ub3JnL2V4dHJhL2NsYW5nLXRpZHkvY2hlY2tzL2xpc3QuaHRtbA==\">Clang-tidy</span></h3>\n<p>Clang-tidy 有一组专门用于强制实施 C++ 核心指导方针的规则。这些规则的命名模式为  <code>cppcoreguidelines-*</code> 。</p>\n<h3 id=\"a-namest-cppcorechecka工具-cppcorecheck\"><a class=\"markdownIt-Anchor\" href=\"#a-namest-cppcorechecka工具-cppcorecheck\">#</a> <a name=\"St-cppcorecheck\"></a>工具: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdmlzdWFsc3R1ZGlvL2NvZGUtcXVhbGl0eS91c2luZy10aGUtY3BwLWNvcmUtZ3VpZGVsaW5lcy1jaGVja2Vycw==\">CppCoreCheck</span></h3>\n<p>微软编译器的 C++ 代码分析中包含一组专门用于强制实施 C++ 核心指导方针的规则。</p>\n<h1 id=\"a-names-glossarya词汇表\"><a class=\"markdownIt-Anchor\" href=\"#a-names-glossarya词汇表\">#</a> <a name=\"S-glossary\"></a>词汇表</h1>\n<p>这是在指导方针中用到的一些术语的相对非正式的定义<br>\n（基于 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9wcm9ncmFtbWluZy5odG1s\">Programming: Principles and Practice using C++</span> 中的词汇表）。</p>\n<p>有关 C++ 的许多主题的更多信息，可以在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pc29jcHAub3Jn\">标准 C++ 基金会的网站</span> 找到。</p>\n<ul>\n<li><em>ABI</em>: 应用二进制接口，对于特定硬件平台与操作系统的组合的一种规范。与 API 相对。</li>\n<li><em>抽象类（abstract class）</em>: 不能直接用于创建对象的类；通常用于为派生类定义接口。<br>\n当类带有纯虚函数或只有受保护的构造函数时，它就是抽象的。</li>\n<li><em>抽象（abstraction）</em>: 对事物的描述，有选择并有意忽略（隐藏）了细节（如实现细节）；选择性忽略。</li>\n<li><em>地址（address）</em>: 用以在计算机的内存中找到某个对象的值。</li>\n<li><em>算法（algorithm）</em>: 用以解决某个问题的过程或公式；有限的一系列计算步骤以产生一个结果。</li>\n<li><em>别名（alias）</em>: 指代某个对象的替代方式；通常为名字，指针，或者引用。</li>\n<li><em>API</em>: 应用编程接口，一组构成不同软件之间之间的交互的函数。与 ABI 相对。</li>\n<li><em>应用程序（application）</em>: 程序或程序的集合，用户将其看作一个实体。</li>\n<li><em>近似（approximation）</em>: 事物（比如值或者设计），接近于完美的或者理想的（值或设计）。<br>\n通常近似都是在理想情形中进行各种权衡的结果。</li>\n<li><em>参数 / 实参（argument）</em>: 传递给函数或模板的值，其中以形参来进行访问。</li>\n<li><em>数组（array）</em>: 同质元素序列，通常是数值，例如  <code>[0:max)</code> 。</li>\n<li><em>断言（assertion）</em>: 插入到程序中的语句，以声称（断言）在程序的这个位置某事物必定为真。</li>\n<li><em>基类（base class）</em>: 目的是为从其进行派生的类型（比如它带有非  <code>final</code>  的虚函数），且有意仅间接使用该类型的对象（如通过指针）。[严格地说，“基类” 可被定义为 “从之进行派生的类型”，但我们这里以类设计者意图的角度来给出定义] 通常基类带有一个或更多的虚函数。</li>\n<li><em>位（bit）</em>: 计算机中信息的基本单位。一个位的值可以为 0 或 1。</li>\n<li><em>bug</em>: 程序中的错误。</li>\n<li><em>字节（byte）</em>: 大多数计算机中进行寻址的基本单位。通常一个字节有 8 位。</li>\n<li><em>类（class）</em>: 一种用户定义的类型，可以包含数据成员，函数成员，以及成员类型。</li>\n<li><em>代码（code）</em>: 程序或程序的部分；有歧义地同时用于源代码和目标代码。</li>\n<li><em>编译器（compiler）</em>: 一种将源代码变为目标代码的程序。</li>\n<li><em>复杂度（complexity）</em>: 对某个问题构造解决方案的难度，或解决方案自身的一种难于精确定义的记法或度量。<br>\n有时候复杂度只是（简单地）表示对执行某个算法所需操作的数量的估计。</li>\n<li><em>计算（computation）</em>: 执行一些代码，通常接受一些输入并产生一些输出。</li>\n<li><em>概念（concept）</em>: (1) 提法，想法；(2) 一组要求，通常针对模板参数。</li>\n<li><em>具体类（concrete type）</em>: 并非基类的类型，且有意直接使用该类型的对象（而非仅通过指针 / 间接），其大小是已知的，通常可以按程序员的意图在任何地方分配（比如静态地在运行栈上分配）。</li>\n<li><em>常量（constant）</em>: （在给定作用域中）不能改变的值；不可变。</li>\n<li><em>构造函数（constructor）</em>: 初始化（“构造”）一个对象的操作。<br>\n通常构造函数会建立起不变式，并且通常会获取对象被使用时所需的资源（并通常将由析构函数所释放）。</li>\n<li><em>容器（container）</em>: 持有一些元素（其他对象）的对象。</li>\n<li><em>复制（copy）</em>: 制造两个对象使其值比较为相等的操作。另见移动。</li>\n<li><em>正确性（correctness）</em>: 如果程序或程序片段符合其说明，则其为正确的。<br>\n不幸的是，说明可能不完整或不一致，或者也可能无法满足用户的合理预期。<br>\n因此为了产生可接受的代码，我们有时候比仅仅遵守形式说明要做更多的事。</li>\n<li><em>成本（cost）</em>: 产生一个程序，或者执行它的耗费（如开发时间，执行时间或空间等）。<br>\n理想情况下，成本应当是复杂度的函数。</li>\n<li><em>定制点（customization point）</em>:</li>\n<li><em>数据（data）</em>: 计算中所用到的值。</li>\n<li><em>调试（debugging）</em>: 寻找并移除程序中的错误的行为；通常远没有测试那样系统化。</li>\n<li><em>声明式（declaration）</em>: 程序中对一个名字及其类型的说明。</li>\n<li><em>定义式（definition）</em>: 实体的声明式，提供了程序使用该实体所需的所有信息。<br>\n简化版定义：分配了内存额声明。</li>\n<li><em>派生类（derived class）</em>: 派生自一个或多个基类的类。</li>\n<li><em>设计（design）</em>: 对软件的某个片段应当如何运作以满足其说明的一个总体描述。</li>\n<li><em>析构函数（destructor）</em>: 当对象销毁（如在作用域结束时）被隐式执行（调用）的操作。它通常进行资源的释放。</li>\n<li><em>封装（encapsulation）</em>: 将某些事物（如实现细节）保护为私有的，不接受未授权的访问。</li>\n<li><em>错误（error）</em>: 对程序行为的合理期望（通常表现为某种需求或者一份用户指南）和程序的实际行为之间的不一致。</li>\n<li><em>可执行程序（executable）</em>: 预备在计算机上运行（执行）的程序。</li>\n<li><em>功能蔓延（feature creep）</em>: 为 “预防万一” 而向程序添加过量的功能的倾向。</li>\n<li><em>文件（file）</em>: 计算机中的持久信息的容器。</li>\n<li><em>浮点数（floating-point number）</em>: 计算机对实数（如 7.93 和 10.78e–3）的近似。</li>\n<li><em>函数（function）</em>: 命名的代码单元，可以从程序的不同部分执行（调用）；计算的逻辑单元。</li>\n<li><em>泛型编程（generic programming）</em>: 关注于算法的设计和高效实现的一种编程风格。<br>\n泛型算法能够对所有符合其要求的参数类型正确工作。在 C++ 中，泛型编程通常使用模板进行。</li>\n<li><em>全局变量（global variable）</em>: 技术上说，命名空间作用域中的具名对象。</li>\n<li><em>句柄（handle）</em>: 一个类，允许通过一个成员指针或引用来访问另一个对象。另见资源，复制，移动。</li>\n<li><em>头文件（header）</em>: 包含用于在程序的各个部分中共享接口的声明的文件。</li>\n<li><em>隐藏（hiding）</em>: 防止一个信息片段被直接看到或访问的行为。<br>\n例如，嵌套（内部）作用域中的名字会防止外部（外围）作用域中相同的名字被直接使用。</li>\n<li><em>理想的（ideal）</em>: 我们力争达成的事物的完美版本。我们经常不得不进行各种权衡最后获得一个近似。</li>\n<li><em>实现（implementation）</em>: (1) 编写代码并测试的活动；(2) 用以实现一个程序的代码。</li>\n<li><em>无限循环（infinite loop）</em>: 终止条件永不为真的循环。参见重复。</li>\n<li><em>无限递归（infinite recursion）</em>: 无法终止的递归，直到机器耗尽内存无法维持其调用。<br>\n在现实中这种递归不可能是无限的，它会因某种硬件错误而终止。</li>\n<li><em>信息隐藏（information hiding）</em>: 分离接口和实现，以此将用户不感兴趣的实现细节隐藏起来，并提供一种抽象的活动。</li>\n<li><em>初始化（initialize）</em>: 为一个对象给定其第一个（初始）值。</li>\n<li><em>输入（input）</em>: 计算中所使用的值（比如函数参数以及通过键盘所输入的字符）。</li>\n<li><em>整数（integer）</em>: 整数，比如 42 和 –99。</li>\n<li><em>接口（interface）</em>: 一个或一组声明，说明了一个代码片段（比如函数或者类）应当如何进行调用。</li>\n<li><em>不变式（invariant）</em>: 程序中的某些点必然总为真的事物；通常用于描述对象的状态（值的集合），或者循环进入其重复的语句之前的状态。</li>\n<li><em>重复（iteration）</em>: 重复执行代码片段的行为；参见递归。</li>\n<li><em>迭代器（iterator）</em>: 用以标识序列中的一个元素的对象。</li>\n<li><em>ISO</em>: 国际标准化组织。C++ 语言是一项 ISO 标准：ISO/IEC 14882。更多信息请参考 <span class=\"exturl\" data-url=\"aHR0cDovL2lzby5vcmc=\">iso.org</span>。</li>\n<li><em>程序库（library）</em>: 类型、函数、类等等的集合，它们实现了一组设施（抽象），预备可能被用作不止一个程序的组成部分。</li>\n<li><em>生存期（lifetime）</em>: 从对象的初始化直到它变为不可用（离开作用域，被删除，或程序终止）的时间。</li>\n<li><em>连接器（linker）</em>: 用以将目标代码文件和程序库合并构成一个可执行程序的程序。</li>\n<li><em>字面量（literal）</em>: 直接指定一个值的写法，比如 12 指定的是整数值 “十二”。</li>\n<li><em>循环（loop）</em>: 重复执行的代码片段；在 C++ 中，通常是  <code>for</code>  语句或者  <code>while</code>  语句。</li>\n<li><em>移动（move）</em>: 将值从一个对象转移到另一个对象，并遗留一个表示 “空” 的值的操作。另见复制。</li>\n<li><em>仅可移动类型（move-only type）</em>：可以移动但不能复制的具体类型。</li>\n<li><em>可变的（mutable）</em>: 可以改动；不可变、常量和不变量的反义词。</li>\n<li><em>对象（object）</em>: (1) 已经初始化的一块具有已知类型的内存区域，持有该类型的一个值；(2) 一块内存区域。</li>\n<li><em>目标代码（object code）</em>: 编译器的输出，预备作为连接器的输入（连接器以其产生可执行代码）。</li>\n<li><em>目标文件（object file）</em>: 包含目标代码的文件。</li>\n<li><em>面向对象编程（object-oriented programming）</em>: （OOP）一种关注类和类层次的设计和使用的编程风格。</li>\n<li><em>操作（operation）</em>: 能够实施某种活动的事物，比如函数或运算符。</li>\n<li><em>输出（output）</em>: 由计算所产生的值（例如函数的结果，或者在屏幕上写下的一行行字符等）。</li>\n<li><em>溢出（overflow）</em>: 产生无法被其预期目标所存储的值。</li>\n<li><em>重载（overload）</em>: 定义两个函数或运算符，使其具有相同名字但不同的参数（操作数）类型。</li>\n<li><em>覆盖（override）</em>: 在派生类中用声明和基类中的某个虚函数具有相同名字和参数类型的函数，以此使该函数可以通过由基类所定义的接口来进行调用。</li>\n<li><em>所有者（owner）</em>: 负责释放某个资源的对象。</li>\n<li><em>范式（paradigm）</em>: 设计和编程风格的一种多少有些做作的术语；通常会被用于（错误地）暗示有一种范式被其他的都更优秀。</li>\n<li><em>形参（parameter）</em>: 对函数或模板的一个明确输入的声明。当进行调用时，函数可以通过其形参的名字来访问向其所传递的各个实参。</li>\n<li><em>指针（pointer）</em>: (1) 值，用于标识内存中的一个有类型的对象；(2) 持有这种值的变量。</li>\n<li><em>后条件（post-condition）</em>: 当从一个代码片段（如函数或者循环）退出时必须满足的条件。</li>\n<li><em>前条件（pre-condition）</em>: 当进入一个代码片段（如函数或者循环）时必须满足的条件。</li>\n<li><em>程序（program）</em>: 足够完整以便能够在计算机上执行的代码（可能带有关联的数据）。</li>\n<li><em>编程（programming）</em>: 将问题的解决方案表现为代码的工艺。</li>\n<li><em>编程语言（programming language）</em>: 用于表达程序的语言。</li>\n<li><em>伪代码（pseudo code）</em>: 以非正式的写法而非编程语言所编写的对计算的一种描述。</li>\n<li><em>纯虚函数（pure virtual function）</em>: 必须在派生类中予以覆盖的虚函数。</li>\n<li><em>RAII</em>: （“资源获取即初始化，Resource Acquisition Is Initialization”）一种基于作用域进行资源管理的基本技术。</li>\n<li><em>范围（range）</em>: 值的序列，可以以一个开始点和一个结尾点进行描述。例如， <code>[0:5)</code>  的意思是值 0，1，2，3，和 4。</li>\n<li><em>递归（recursion）</em>: 函数调用其自身的行为；另见重复。</li>\n<li><em>引用（reference）</em>: (1) 一种值，描述内存中具有类型的值的位置；(2) 持有这种值的变量。</li>\n<li><em>正则表达式（regular expression）</em>: 对字符串的模式的一种表示法。</li>\n<li><em>正规</em>：可以进行相等性比较的半正规类型（参见  <code>std::regular</code>  概念）。进行复制之后，副本对象与原对象比较为相等。正规类型的行为与如  <code>int</code>  这样的内建类型相似，且可以用  <code>==</code>  进行比较。<br>\n特别是，正规类型的对象可以进行复制，且复制的结果是与原对象比较为相等的一个独立对象。另见<em>半正规类型</em>。</li>\n<li><em>要求（requirement）</em>: (1) 对程序或程序的一部分的预期行为的描述；(2) 对函数或模板对其参数所作出的假设的描述。</li>\n<li><em>资源（resource）</em>: 获取而得的并随后必须被释放的事物，比如文件句柄，锁，或者内存。另见句柄，所有者。</li>\n<li><em>舍入（rounding）</em>: 将一个值转换为某个较不精确类型的数学上最接近的值。</li>\n<li><em>RTTI</em>: 运行时类型信息（Run-Time Type Information）。 ???</li>\n<li><em>作用域（scope）</em>: 程序文本（源代码）的区域，在其中可以对一个名字进行涉指。</li>\n<li><em>半正规（semiregular）</em>: 可复制的（也包括可移动的）且可默认构造的具体类型（参见  <code>std::semiregular</code>  概念）。复制的结果是一个与原对象具有相同的值的独立类型。半正规类型的行为与像  <code>int</code>  这样内建类型大致相似，但可能没有  <code>==</code>  运算符。另见<em>正规类型</em>。</li>\n<li><em>序列（sequence）</em>: 可以以线性的顺序访问的一组元素。</li>\n<li><em>软件（software）</em>: 代码片段及其关联数据的集合；通常可以和程序互换运用。</li>\n<li><em>源代码（source code）</em>: 由程序员所生产的代码，（原则上）可以被其他程序员阅读。</li>\n<li><em>源文件（source file）</em>: 包含源代码的文件。</li>\n<li><em>规范（specification）</em>: 对代码片段应当做什么的描述。</li>\n<li><em>标准（standard）</em>: 由官方承认的对某事物的定义，比如编程语言。</li>\n<li><em>状态（state）</em>: 一组值。</li>\n<li><em>STL</em>: 标准库中的容器，迭代器，以及算法部分。</li>\n<li><em>字符串（string）</em>: 字符的序列。</li>\n<li><em>风格（style）</em>: 旨在统一语言功能特征的使用的一组编程技巧；有时候以非常限定的方式来仅代表诸如命名和代码展现等的低层次规则。</li>\n<li><em>子类型（subtype）</em>: 派生类型；一个类型具有另一个类型的所有（可能更多）的性质。</li>\n<li><em>超类型（supertype）</em>: 基类型；一个类型具有另一个类型的性质的子集。</li>\n<li><em>系统（system）</em>: (1) 用以在计算机上实施某种任务的一个或一组程序；(2) 对 “操作系统” 的简称，即计算机的基本执行环境及工具。</li>\n<li><em>TS</em>: [技术规范](<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaXNvLm9yZy9kZWxpdmVyYWJsZXMtYWxsLmh0bWw=\">https://www.iso.org/deliverables-all.html</span> type=ts)。技术规范所处理的是仍处于技术开发之中的工作，或者是认为这项工作以后可能会被同意采纳为国际标准，但并不会立即处理。技术规范的出版是为了其立即可用，也是为了提供一种获得反馈的方法。其目标是最终能够被转化并重新作为国际标准来出版。</li>\n<li><em>模板（template）</em>: 由一个或多个的类型或（编译时）值进行参数化的类或函数；支持泛型编程的基本 C++ 语言构造。</li>\n<li><em>测试（testing）</em>: 系统化地查找程序中的错误。</li>\n<li><em>权衡（trade-off）</em>: 对多个设计和实现准则进行平衡的结果。</li>\n<li><em>截断（truncation）</em>: 从一个类型转换为另一个无法精确表示被转换的值的类型时发生的信息损失。</li>\n<li><em>类型（type）</em>: 为一个对象定义了一组可能的值和一组操作的事物。</li>\n<li><em>未初始化的（uninitialized）</em>: 对象在初始化之前的（未定义的）状态。</li>\n<li><em>单元（unit）</em>: (1) 为值赋予含义的一种标准度量（例如，距离单位 km）；(2) 较大的整体中的一个可区分的（比如命名的）部分。</li>\n<li><em>用例（use case）</em>: 程序的某个特定（通常简化的）使用，以测试其功能并演示其目的。</li>\n<li><em>值（value）</em>: 根据某个类型所解释的一组内存中的位。</li>\n<li><em>值类型（value type）</em>：一些人用这个术语来表示正规或半正规类型。</li>\n<li><em>变量（variable）</em>: 给定类型的具名对象；除非未初始化否则包含一个值。</li>\n<li><em>虚函数（virtual function）</em>: 可在派生类中进行覆盖的成员函数。</li>\n<li><em>字（word）</em>: 计算机中内存的基本单元，通常是用以持有一个整数的单元。</li>\n</ul>\n<h1 id=\"a-names-unclassifiedato-do-未分类的规则原型\"><a class=\"markdownIt-Anchor\" href=\"#a-names-unclassifiedato-do-未分类的规则原型\">#</a> <a name=\"S-unclassified\"></a>To-do: 未分类的规则原型</h1>\n<p>这是我们的未完成列表。<br>\n以下各条目最终将成为规则或者规则的一部分。<br>\n或者，我们也会决定不需要做出改动并将条目移除。</p>\n<ul>\n<li>\n<p>禁止远距离友元关系</p>\n</li>\n<li>\n<p>应不应该处理物理设计（文件里有什么）和大规模设计（程序库，程序库的组合）？</p>\n</li>\n<li>\n<p>命名空间</p>\n</li>\n<li>\n<p>避免在全局作用域中使用 using 指令（但允许如 std 或其他的 “基础” 命名空间（如 experimental））</p>\n</li>\n<li>\n<p>命名空间应当有什么粒度？是（如 Sutter/Alexandrescu 所定义的）所有被设计为一同工作或者一同发布的类和函数，还是应该更窄或是更宽？</p>\n</li>\n<li>\n<p>应该用内联命名空间吗（比如  <code>std::literals::*_literals</code> ）？</p>\n</li>\n<li>\n<p>避免隐式转换</p>\n</li>\n<li>\n<p>Const 成员函数应当是线程安全的……aka, 但我并不想真的改掉变量，只是在第一次调用它的时候向它赋一个值……argh</p>\n</li>\n<li>\n<p>始终初始化变量，为成员变量使用初始化列表。</p>\n</li>\n<li>\n<p>无论谁编写了接受或返回  <code>void*</code>  的公开接口，都应该上火刑。我曾经好多年都以它作为自己的个人喜好来着。 😃</p>\n</li>\n<li>\n<p>尽可能应用  <code>const</code> ：成员函数，变量，以及  <code>const_iterators</code></p>\n</li>\n<li>\n<p>使用  <code>auto</code></p>\n</li>\n<li>\n<p><code>(size)</code>  vs.  <code>&#123;initializers&#125;</code>  vs.  <code>&#123;Extent&#123;size&#125;&#125;</code></p>\n</li>\n<li>\n<p>不要过度抽象</p>\n</li>\n<li>\n<p>不要沿着调用栈向下传递指针</p>\n</li>\n<li>\n<p>通过函数底部退出</p>\n</li>\n<li>\n<p>应当提供在多态之间进行选择的指导方针吗？是的。经典的（虚函数，引用语义） vs. Sean Parent 风格（值语义，类型擦除，类似  <code>std::function</code> ）  vs. CRTP / 静态的？也许还需要 vs. 标签派发？</p>\n</li>\n<li>\n<p>我们的指导方针是否应当在构造函数或析构函数中禁止进行虚函数调用？是的。许多人都禁止了，虽然我觉得这是 C++ 的一大优势？？？- 保留意见（D 走向 Java 之路太让我失望了）。有好的例子吗？</p>\n</li>\n<li>\n<p>在 lambda 方面，在算法调用和其他回调场景中什么因素会影响决定使用 lambda 还是（局部？）类？</p>\n</li>\n<li>\n<p>讨论一下  <code>std::bind</code> ，Stephen T. Lavavej 对它有太多批评，使我开始觉得它是不是真的会在未来消失掉。应该建议以 lambda 代替它吗？</p>\n</li>\n<li>\n<p>怎么处理泄漏的临时变量？ :  <code>p = (s1 + s2).c_str();</code></p>\n</li>\n<li>\n<p>指针和迭代器的失效会导致悬挂指针：</p>\n<pre><code>void bad()\n&#123;\n    int* p = new int[700];\n    int* q = &amp;p[7];\n    delete p;\n\n    vector&lt;int&gt; v(700);\n    int* q2 = &amp;v[7];\n    v.resize(900);\n\n    // ... 使用 q 和 q2 ...\n&#125;\n</code></pre>\n</li>\n<li>\n<p>LSP</p>\n</li>\n<li>\n<p>私有继承 vs/and 成员</p>\n</li>\n<li>\n<p>避免静态类成员变量（竞争条件，几乎就是全局变量）</p>\n</li>\n<li>\n<p>使用 RAII 锁定保护（ <code>lock_guard</code> ， <code>unique_lock</code> ， <code>shared_lock</code> ），绝不直接调用  <code>mutex.lock</code>  和  <code>mutex.unlock</code> （RAII）</p>\n</li>\n<li>\n<p>优先使用非递归锁（它们通常用作不良情况的变通手段，有开销）</p>\n</li>\n<li>\n<p>联结（join）你的每个线程！（因为如果没被联结或脱离（detach）的话，析构函数会调用  <code>std::terminate</code> …… 有什么好理由来脱离线程吗？） – ??? 支持库该不该为  <code>std::thread</code>  提供一个 RAII 包装呢？</p>\n</li>\n<li>\n<p>当必须同时获取两个或更多的互斥体时，应当使用  <code>std::lock</code> （或者别的死锁免除算法？）</p>\n</li>\n<li>\n<p>当使用  <code>condition_variable</code>  时，始终用一个互斥体来保护它（在互斥体外面设置原子 bool 的值的做法是错误的！），并对条件变量自身使用同一个互斥体。</p>\n</li>\n<li>\n<p>绝不对  <code>std::atomic&lt;user-defined-struct&gt;</code>  使用  <code>atomic_compare_exchange_strong</code> （填充位中的区别会造成影响，而在循环中使用  <code>compare_exchange_weak</code>  则能够归于稳定的填充位）</p>\n</li>\n<li>\n<p>单独的  <code>shared_future</code>  对象不是线程安全的：两个线程不能等待同一个  <code>shared_future</code>  对象（它们可以等待指代相同共享状态的  <code>shared_future</code>  的副本）</p>\n</li>\n<li>\n<p>单独的  <code>shared_ptr</code>  对象不是线程安全的：不同的线程可以调用指代相同共享对象的<em>不同</em>  <code>shared_ptr</code>  的非  <code>const</code>  成员函数，但当一个线程访问一个  <code>shared_ptr</code>  对象时，另一个线程不能调用相同  <code>shared_ptr</code>  对象的非  <code>const</code>  成员函数（如果确实需要，考虑代之以  <code>atomic_shared_ptr</code> ）</p>\n</li>\n<li>\n<p>算术相关规则</p>\n</li>\n</ul>\n<h1 id=\"参考文献-2\"><a class=\"markdownIt-Anchor\" href=\"#参考文献-2\">#</a> 参考文献</h1>\n<ul>\n<li><a name=\"Abrahams01\"></a><br>\n[Abrahams01]:  D. Abrahams. <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ib29zdC5vcmcvY29tbXVuaXR5L2V4Y2VwdGlvbl9zYWZldHkuaHRtbA==\">Exception-Safety in Generic Components</span>.</li>\n<li><a name=\"Alexandrescu01\"></a><br>\n[Alexandrescu01]:  A. Alexandrescu. Modern C++ Design (Addison-Wesley, 2001).</li>\n<li><a name=\"Cplusplus03\"></a><br>\n[C<ins>03]:           ISO/IEC 14882:2003(E), Programming Languages — C</ins> (updated ISO and ANSI C++ Standard including the contents of (C++98) plus errata corrections).</li>\n<li><a name=\"Cargill92\"></a><br>\n[Cargill92]:       T. Cargill. C++ Programming Style (Addison-Wesley, 1992).</li>\n<li><a name=\"Cline99\"></a><br>\n[Cline99]:         M. Cline, G. Lomow, and M. Girou. C++ FAQs (2ndEdition) (Addison-Wesley, 1999).</li>\n<li><a name=\"Dewhurst03\"></a><br>\n[Dewhurst03]:      S. Dewhurst. C++ Gotchas (Addison-Wesley, 2003).</li>\n<li><a name=\"Henricson97\"></a><br>\n[Henricson97]:     M. Henricson and E. Nyquist. Industrial Strength C++ (Prentice Hall, 1997).</li>\n<li><a name=\"Koenig97\"></a><br>\n[Koenig97]:        A. Koenig and B. Moo. Ruminations on C++ (Addison-Wesley, 1997).</li>\n<li><a name=\"Lakos96\"></a><br>\n[Lakos96]:         J. Lakos. Large-Scale C++ Software Design (Addison-Wesley, 1996).</li>\n<li><a name=\"Meyers96\"></a><br>\n[Meyers96]:        S. Meyers. More Effective C++ (Addison-Wesley, 1996).</li>\n<li><a name=\"Meyers97\"></a><br>\n[Meyers97]:        S. Meyers. Effective C++ (2nd Edition) (Addison-Wesley, 1997).</li>\n<li><a name=\"Meyers01\"></a><br>\n[Meyers01]:        S. Meyers. Effective STL (Addison-Wesley, 2001).</li>\n<li><a name=\"Meyers05\"></a><br>\n[Meyers05]:        S. Meyers. Effective C++ (3rd Edition) (Addison-Wesley, 2005).</li>\n<li><a name=\"Meyers15\"></a><br>\n[Meyers15]:        S. Meyers. Effective Modern C++ (O’Reilly, 2015).</li>\n<li><a name=\"Murray93\"></a><br>\n[Murray93]:        R. Murray. C++ Strategies and Tactics (Addison-Wesley, 1993).</li>\n<li><a name=\"Stroustrup94\"></a><br>\n[Stroustrup94]:    B. Stroustrup. The Design and Evolution of C++ (Addison-Wesley, 1994).</li>\n<li><a name=\"Stroustrup00\"></a><br>\n[Stroustrup00]:    B. Stroustrup. The C++ Programming Language (Special 3rdEdition) (Addison-Wesley, 2000).</li>\n<li><a name=\"Stroustrup05\"></a><br>\n[Stroustrup05]:    B. Stroustrup. <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9TRUxMcmF0aW9uYWxlLnBkZg==\">A rationale for semantically enhanced library languages</span>.</li>\n<li><a name=\"Stroustrup13\"></a><br>\n[Stroustrup13]:    B. Stroustrup. <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS80dGguaHRtbA==\">The C++ Programming Language (4th Edition)</span>. Addison Wesley 2013.</li>\n<li><a name=\"Stroustrup14\"></a><br>\n[Stroustrup14]:    B. Stroustrup. <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHJvdXN0cnVwLmNvbS9Ub3VyLmh0bWw=\">A Tour of C++</span>.<br>\nAddison Wesley 2014.</li>\n<li>&lt;a name=&quot;Stroustrup15&gt;</a><br>\n[Stroustrup15]:    B. Stroustrup, Herb Sutter, and G. Dos Reis: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2lzb2NwcC9DcHBDb3JlR3VpZGVsaW5lcy9ibG9iL21hc3Rlci9kb2NzL0ludHJvZHVjdGlvbiUyMHRvJTIwdHlwZSUyMGFuZCUyMHJlc291cmNlJTIwc2FmZXR5LnBkZg==\">A brief introduction to C++'s model for type- and resource-safety</span>.</li>\n<li><a name=\"SuttHysl04b\"></a><br>\n[SuttHysl04b]:     H. Sutter and J. Hyslop. <span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTIwOTI2MDExODM3L2h0dHA6Ly93d3cuZHJkb2Jicy5jb20vY29sbGVjdGluZy1zaGFyZWQtb2JqZWN0cy8xODQ0MDE4Mzk=\">Collecting Shared Objects</span> (C/C++ Users Journal, 22(8), August 2004).</li>\n<li><a name=\"SuttAlex05\"></a><br>\n[SuttAlex05]:      H. Sutter and  A. Alexandrescu. C++ Coding Standards. Addison-Wesley 2005.</li>\n<li><a name=\"Sutter00\"></a><br>\n[Sutter00]:        H. Sutter. Exceptional C++ (Addison-Wesley, 2000).</li>\n<li><a name=\"Sutter02\"></a><br>\n[Sutter02]:        H. Sutter. More Exceptional C++ (Addison-Wesley, 2002).</li>\n<li><a name=\"Sutter04\"></a><br>\n[Sutter04]:        H. Sutter. Exceptional C++ Style (Addison-Wesley, 2004).</li>\n<li><a name=\"Taligent94\"></a><br>\n[Taligent94]: Taligent’s Guide to Designing Programs (Addison-Wesley, 1994).</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/02/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/",
            "url": "http://example.com/2023/07/02/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/",
            "title": "C++学习笔记（二）",
            "date_published": "2023-07-02T10:29:01.000Z",
            "content_html": "<h1 id=\"c-教程\"><a class=\"markdownIt-Anchor\" href=\"#c-教程\">#</a> C++ 教程</h1>\n<p><img data-src=\"https://edu.aliyun.com/files/course/2017/09-24/1539291c8853274278.png\" alt=\"\"></p>\n<p>C++ 是一种中级语言，它是由 Bjarne Stroustrup 于 1979 年在贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，是一种面向对象的程序设计语言。C++ 可运行于多种平台上，如 Windows、MAC 操作系统以及 UNIX 的各种版本。</p>\n<p>本教程通过通俗易懂的语言来讲解 C++ 编程语言。</p>\n<p><strong>现在开始学习 C++ 编程！</strong></p>\n<h2 id=\"谁适合阅读本教程\"><a class=\"markdownIt-Anchor\" href=\"#谁适合阅读本教程\">#</a> 谁适合阅读本教程？</h2>\n<p>本教程是专门为初学者打造的，帮助他们理解与 C++ 编程语言相关的基础到高级的概念。</p>\n<h2 id=\"阅读本教程前您需要了解的知识\"><a class=\"markdownIt-Anchor\" href=\"#阅读本教程前您需要了解的知识\">#</a> 阅读本教程前，您需要了解的知识：</h2>\n<p>在您开始练习本教程中所给出的各种实例之前，您需要对计算机程序和计算机程序设计语言有基本的了解。</p>\n<h2 id=\"编译执行-c-程序\"><a class=\"markdownIt-Anchor\" href=\"#编译执行-c-程序\">#</a> 编译 / 执行 C++ 程序</h2>\n<h2 id=\"实例\"><a class=\"markdownIt-Anchor\" href=\"#实例\">#</a> 实例</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main()&#123;</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Hello, world!&quot;</span> &lt;&lt; endl;    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello, world!</span><br></pre></td></tr></table></figure>\n<p>你可以用 “\\n” 代替以上代码里的 “endl”。</p>\n<h1 id=\"c-简介\"><a class=\"markdownIt-Anchor\" href=\"#c-简介\">#</a> C++ 简介</h1>\n<p>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。</p>\n<p>C++ 被认为是一种<strong>中级</strong>语言，它综合了高级语言和低级语言的特点。</p>\n<p>C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的 C，后来在 1983 年更名为 C++。</p>\n<p>C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。</p>\n<p>** 注意：** 使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。</p>\n<h2 id=\"面向对象程序设计\"><a class=\"markdownIt-Anchor\" href=\"#面向对象程序设计\">#</a> 面向对象程序设计</h2>\n<p>C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：</p>\n<ul>\n<li>封装</li>\n<li>抽象</li>\n<li>继承</li>\n<li>多态</li>\n</ul>\n<h2 id=\"标准库\"><a class=\"markdownIt-Anchor\" href=\"#标准库\">#</a> 标准库</h2>\n<p>标准的 C++ 由三个重要部分组成：</p>\n<ul>\n<li>核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。</li>\n<li>C++ 标准库，提供了大量的函数，用于操作文件、字符串等。</li>\n<li>标准模板库（STL），提供了大量的方法，用于操作数据结构等。</li>\n</ul>\n<h2 id=\"ansi-标准\"><a class=\"markdownIt-Anchor\" href=\"#ansi-标准\">#</a> ANSI 标准</h2>\n<p>ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。</p>\n<p>由于 ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。</p>\n<h2 id=\"学习-c\"><a class=\"markdownIt-Anchor\" href=\"#学习-c\">#</a> 学习 C++</h2>\n<p>学习 C++，关键是要理解概念，而不应过于深究语言的技术细节。</p>\n<p>学习程序设计语言的目的是为了成为一个更好的程序员，也就是说，是为了能更有效率地设计和实现新系统，以及维护旧系统。</p>\n<p>C++ 支持多种编程风格。您可以使用 Fortran、C、Smalltalk 等任意一种语言的编程风格来编写代码。每种风格都能有效地保证运行时间效率和空间效率。</p>\n<h2 id=\"c-的使用\"><a class=\"markdownIt-Anchor\" href=\"#c-的使用\">#</a> C++ 的使用</h2>\n<p>基本上每个应用程序领域的程序员都有使用 C++。</p>\n<p>C++ 通常用于编写设备驱动程序和其他要求实时性的直接操作硬件的软件。</p>\n<p>C++ 广泛用于教学和研究。</p>\n<p>任何一个使用苹果电脑或 Windows PC 机的用户都在间接地使用 C++，因为这些系统的主要用户接口是使用 C++ 编写的。</p>\n<hr>\n<h2 id=\"标准化\"><a class=\"markdownIt-Anchor\" href=\"#标准化\">#</a> 标准化</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">发布时间</th>\n<th style=\"text-align:left\">文档</th>\n<th style=\"text-align:left\">通称</th>\n<th style=\"text-align:left\">备注</th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">2015</td>\n<td style=\"text-align:left\">ISO/IEC TS 19570:2015</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">用于并行计算的扩展</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2015</td>\n<td style=\"text-align:left\">ISO/IEC TS 18822:2015</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">文件系统</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2014</td>\n<td style=\"text-align:left\">ISO/IEC 14882:2014</td>\n<td style=\"text-align:left\">C++14</td>\n<td style=\"text-align:left\">第四个 C++ 标准</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2011</td>\n<td style=\"text-align:left\">ISO/IEC TR 24733:2011</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">十进制浮点数扩展</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2011</td>\n<td style=\"text-align:left\">ISO/IEC 14882:2011</td>\n<td style=\"text-align:left\">C++11</td>\n<td style=\"text-align:left\">第三个 C++ 标准</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2010</td>\n<td style=\"text-align:left\">ISO/IEC TR 29124:2010</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">数学函数扩展</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2007</td>\n<td style=\"text-align:left\">ISO/IEC TR 19768:2007</td>\n<td style=\"text-align:left\">C++TR1</td>\n<td style=\"text-align:left\">C++ 技术报告：库扩展</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2006</td>\n<td style=\"text-align:left\">ISO/IEC TR 18015:2006</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">C++ 性能技术报告</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2003</td>\n<td style=\"text-align:left\">ISO/IEC 14882:2003</td>\n<td style=\"text-align:left\">C++03</td>\n<td style=\"text-align:left\">第二个 C++ 标准</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1998</td>\n<td style=\"text-align:left\">ISO/IEC 14882:1998</td>\n<td style=\"text-align:left\">C++98</td>\n<td style=\"text-align:left\">第一个 C++ 标准</td>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"c-环境设置\"><a class=\"markdownIt-Anchor\" href=\"#c-环境设置\">#</a> C++ 环境设置</h1>\n<h2 id=\"本地环境设置\"><a class=\"markdownIt-Anchor\" href=\"#本地环境设置\">#</a> 本地环境设置</h2>\n<p>如果您想要设置 C++ 语言环境，您需要确保电脑上有以下两款可用的软件，文本编辑器和 C++ 编译器。</p>\n<h2 id=\"文本编辑器\"><a class=\"markdownIt-Anchor\" href=\"#文本编辑器\">#</a> 文本编辑器</h2>\n<p>这将用于输入您的程序。文本编辑器包括 Windows Notepad、OS Edit command、Brief、Epsilon、EMACS 和 vim/vi。</p>\n<p>文本编辑器的名称和版本在不同的操作系统上可能会有所不同。例如，Notepad 通常用于 Windows 操作系统上，vim/vi 可用于 Windows 和 Linux/UNIX 操作系统上。</p>\n<p>通过编辑器创建的文件通常称为源文件，源文件包含程序源代码。C++ 程序的源文件通常使用扩展名 .cpp、.cp 或 .c。</p>\n<p>在开始编程之前，请确保您有一个文本编辑器，且有足够的经验来编写一个计算机程序，然后把它保存在一个文件中，编译并执行它。</p>\n<h2 id=\"c-编译器\"><a class=\"markdownIt-Anchor\" href=\"#c-编译器\">#</a> C++ 编译器</h2>\n<p>写在源文件中的源代码是人类可读的源。它需要 &quot;编译&quot;，转为机器语言，这样 CPU 可以按给定指令执行程序。</p>\n<p>C++ 编译器用于把源代码编译成最终的可执行程序。</p>\n<p>大多数的 C++ 编译器并不在乎源文件的扩展名，但是如果您未指定扩展名，则默认使用 .cpp。</p>\n<p>最常用的免费可用的编译器是 GNU 的 C/C++ 编译器，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。</p>\n<p>以下部分将指导您如何在不同的操作系统上安装 GNU 的 C/C++ 编译器。这里同时提到 C/C++，主要是因为 GNU 的 gcc 编译器适合于 C 和 C++ 编程语言。</p>\n<h2 id=\"安装-gnu-的-cc-编译器\"><a class=\"markdownIt-Anchor\" href=\"#安装-gnu-的-cc-编译器\">#</a> 安装 GNU 的 C/C++ 编译器</h2>\n<h3 id=\"unixlinux-上的安装\"><a class=\"markdownIt-Anchor\" href=\"#unixlinux-上的安装\">#</a> UNIX/Linux 上的安装</h3>\n<p>如果您使用的是 <strong>Linux 或 UNIX</strong>，请在命令行使用下面的命令来检查您的系统上是否安装了 GCC：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ -v</span><br></pre></td></tr></table></figure>\n<p>如果您的计算机上已经安装了 GNU 编译器，则会显示如下消息：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Using built-in specs.Target: i386-redhat-linuxConfigured with: ../configure --prefix=/usr .......Thread model: posix</span><br><span class=\"line\">gcc version <span class=\"number\">4.1</span><span class=\"number\">.2</span> <span class=\"number\">20080704</span> (Red Hat <span class=\"number\">4.1</span><span class=\"number\">.2</span><span class=\"number\">-46</span>)</span><br></pre></td></tr></table></figure>\n<p>如果未安装 GCC，那么请按照 <span class=\"exturl\" data-url=\"aHR0cDovL2djYy5nbnUub3JnL2luc3RhbGwv\">http://gcc.gnu.org/install/</span> 上的详细说明安装 GCC。</p>\n<h3 id=\"mac-os-x-上的安装\"><a class=\"markdownIt-Anchor\" href=\"#mac-os-x-上的安装\">#</a> Mac OS X 上的安装</h3>\n<p>如果您使用的是 Mac OS X，最快捷的获取 GCC 的方法是从苹果的网站上下载 Xcode 开发环境，并按照安装说明进行安装。一旦安装上 Xcode，您就能使用 GNU 编译器。</p>\n<p>Xcode 目前可从 <span class=\"exturl\" data-url=\"aHR0cDovL2RldmVsb3Blci5hcHBsZS5jb20vdGVjaG5vbG9naWVzL3Rvb2xzLw==\">developer.apple.com/technologies/tools/</span> 上下载。</p>\n<h3 id=\"windows-上的安装\"><a class=\"markdownIt-Anchor\" href=\"#windows-上的安装\">#</a> Windows 上的安装</h3>\n<p>为了在 Windows 上安装 GCC，您需要安装 MinGW。为了安装 MinGW，请访问 MinGW 的主页 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5taW5ndy5vcmc=\">www.mingw.org</span>，进入 MinGW 下载页面，下载最新版本的 MinGW 安装程序，命名格式为 MinGW-<version>.exe。</p>\n<p>当安装 MinGW 时，您至少要安装 gcc-core、gcc-g++、binutils 和 MinGW runtime，但是一般情况下都会安装更多其他的项。</p>\n<p>添加您安装的 MinGW 的 bin 子目录到您的 <strong>PATH</strong> 环境变量中，这样您就可以在命令行中通过简单的名称来指定这些工具。</p>\n<p>当完成安装时，您可以从 Windows 命令行上运行 gcc、g++、ar、ranlib、dlltool 和其他一些 GNU 工具。</p>\n<hr>\n<h2 id=\"使用-visual-studio-graphical-interface-编译\"><a class=\"markdownIt-Anchor\" href=\"#使用-visual-studio-graphical-interface-编译\">#</a> 使用 Visual Studio (Graphical Interface) 编译</h2>\n<p>1、下载及安装 Visual Studio Community 2015。</p>\n<p>2、打开 Visual Studio Community</p>\n<p>3、点击 File -&gt; New -&gt; Project</p>\n<p><img data-src=\"https://edu.aliyun.com/files/course/2017/09-24/154425967c4e731874.png\" alt=\"img\"></p>\n<p>4、左侧列表选择 Templates -&gt; Visual C++ -&gt; Win32 Console Application，并设置项目名为 MyFirstProgram。</p>\n<p><img data-src=\"https://edu.aliyun.com/files/course/2017/09-24/154430e60ee9018384.png\" alt=\"img\"></p>\n<p>5、点击 OK。</p>\n<p>6、在以下窗口中点击 Next</p>\n<p><img data-src=\"https://edu.aliyun.com/files/course/2017/09-24/15444190dd2e989801.png\" alt=\"img\"></p>\n<p>7、在弹出的窗口中选择 Empty project 选项后，点击 Finish 按钮：</p>\n<p>8、右击文件夹 Source File 并点击 Add --&gt; New Item… :</p>\n<p><img data-src=\"https://edu.aliyun.com/files/course/2017/09-24/15445135154c170829.png\" alt=\"img\"></p>\n<p>9、选择 C++ File 然后设置文件名为 main.cpp，然后点击 Add：</p>\n<p><img data-src=\"https://edu.aliyun.com/files/course/2017/09-24/154459b03a55098499.png\" alt=\"img\"></p>\n<p>10、拷贝以下代码到 main.cpp 中：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>int main()&#123;</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Hello World!\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>界面如下所示：</p>\n<p><img data-src=\"https://edu.aliyun.com/files/course/2017/09-24/15450518149e040143.png\" alt=\"img\"></p>\n<p>11、点击菜单上的 Debug -&gt; Start Without Debugging (或按下 ctrl + F5) :</p>\n<p><img data-src=\"https://edu.aliyun.com/files/course/2017/09-24/154511746480630632.png\" alt=\"img\"></p>\n<p>12、完成以上操作后，你可以看到以下输出：</p>\n<p><img data-src=\"https://edu.aliyun.com/files/course/2017/09-24/154519fb938f394280.png\" alt=\"img\"></p>\n<hr>\n<h2 id=\"g-应用说明\"><a class=\"markdownIt-Anchor\" href=\"#g-应用说明\">#</a> g++ 应用说明</h2>\n<p>程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。通过遵循源码的命名规范并指定对应库的名字，用 gcc 来编译链接 C++ 程序是可行的，如下例所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gcc main.cpp -lstdc++ -o main</span><br></pre></td></tr></table></figure>\n<p>下面是一个保存在文件 helloworld.cpp 中一个简单的 C++ 程序的代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main()&#123;</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Hello, world!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>最简单的编译方式：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ helloworld.cpp</span><br></pre></td></tr></table></figure>\n<p>由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./a.outHello, world!</span><br></pre></td></tr></table></figure>\n<p>通常我们使用 <strong>-o</strong> 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ helloworld.cpp -o helloworld</span><br></pre></td></tr></table></figure>\n<p>执行 helloworld:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./helloworldHello, world!</span><br></pre></td></tr></table></figure>\n<p>如果是多个 C++ 代码文件，如 runoob1.cpp、runoob2.cpp，编译命令如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ runoob1.cpp cpp、runoob2.cpp -o runoob</span><br></pre></td></tr></table></figure>\n<p>生成一个 runoob 可执行文件。</p>\n<p>g++ 有些系统默认是使用 C<ins>98，我们可以指定使用 C</ins>11 来编译 main.cpp 文件：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g++ -g -Wall -std=c++<span class=\"number\">11</span> main.cpp</span><br></pre></td></tr></table></figure>\n<h3 id=\"g-常用命令选项\"><a class=\"markdownIt-Anchor\" href=\"#g-常用命令选项\">#</a> g++ 常用命令选项</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">选项</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">-ansi</td>\n<td style=\"text-align:left\">只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-c</td>\n<td style=\"text-align:left\">只编译并生成目标文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-DMACRO</td>\n<td style=\"text-align:left\">以字符串 &quot;1&quot; 定义 MACRO 宏。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-DMACRO=DEFN</td>\n<td style=\"text-align:left\">以字符串 &quot;DEFN&quot; 定义 MACRO 宏。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-E</td>\n<td style=\"text-align:left\">只运行 C 预编译器。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-g</td>\n<td style=\"text-align:left\">生成调试信息。GNU 调试器可利用该信息。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-IDIRECTORY</td>\n<td style=\"text-align:left\">指定额外的头文件搜索路径 DIRECTORY。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-LDIRECTORY</td>\n<td style=\"text-align:left\">指定额外的函数库搜索路径 DIRECTORY。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-lLIBRARY</td>\n<td style=\"text-align:left\">连接时搜索指定的函数库 LIBRARY。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-m486</td>\n<td style=\"text-align:left\">针对 486 进行代码优化。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-o</td>\n<td style=\"text-align:left\">FILE 生成指定的输出文件。用在生成可执行文件时。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-O0</td>\n<td style=\"text-align:left\">不进行优化处理。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-O</td>\n<td style=\"text-align:left\">或 -O1 优化生成代码。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-O2</td>\n<td style=\"text-align:left\">进一步优化。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-O3</td>\n<td style=\"text-align:left\">比 -O2 更进一步优化，包括 inline 函数。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-shared</td>\n<td style=\"text-align:left\">生成共享目标文件。通常用在建立共享库时。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-static</td>\n<td style=\"text-align:left\">禁止使用共享连接。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-UMACRO</td>\n<td style=\"text-align:left\">取消对 MACRO 宏的定义。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-w</td>\n<td style=\"text-align:left\">不生成任何警告信息。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-Wall</td>\n<td style=\"text-align:left\">生成所有警告信息。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"c-基本语法\"><a class=\"markdownIt-Anchor\" href=\"#c-基本语法\">#</a> C++ 基本语法</h1>\n<p>C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。</p>\n<ul>\n<li><strong>对象 -</strong> 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。</li>\n<li><strong>类 -</strong> 类可以定义为描述对象行为 / 状态的模板 / 蓝图。</li>\n<li><strong>方法 -</strong> 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。</li>\n<li><strong>即时变量 -</strong> 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。</li>\n</ul>\n<h2 id=\"c-程序结构\"><a class=\"markdownIt-Anchor\" href=\"#c-程序结构\">#</a> C++ 程序结构</h2>\n<p>让我们看一段简单的代码，可以输出单词 <em>Hello World</em>。</p>\n<h2 id=\"实例-2\"><a class=\"markdownIt-Anchor\" href=\"#实例-2\">#</a> 实例</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; <span class=\"comment\">// main() 是程序开始执行的地方 </span></span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;   </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Hello World&quot;</span>; <span class=\"comment\">// 输出 Hello World   return 0;</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来我们讲解一下上面这段程序：</p>\n<ul>\n<li>C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 <strong><iostream></strong>。</li>\n<li>行 <strong>using namespace std;</strong> 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。</li>\n<li>下一行 <strong>//main () 是程序开始执行的地方</strong> 是一个单行注释。单行注释以 // 开头，在行末结束。</li>\n<li>下一行 <strong>int main()</strong> 是主函数，程序从这里开始执行。</li>\n<li>下一行 <strong>cout &lt;&lt; “Hello World”;</strong> 会在屏幕上显示消息 “Hello World”。</li>\n<li>下一行 <strong>return 0;</strong> 终止 main ( ) 函数，并向调用进程返回值 0。</li>\n</ul>\n<h2 id=\"编译-执行-c-程序\"><a class=\"markdownIt-Anchor\" href=\"#编译-执行-c-程序\">#</a> 编译 &amp; 执行 C++ 程序</h2>\n<p>接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤：</p>\n<ul>\n<li>打开一个文本编辑器，添加上述代码。</li>\n<li>保存文件为 hello.cpp。</li>\n<li>打开命令提示符，进入到保存文件所在的目录。</li>\n<li>键入 'g++ hello.cpp '，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。</li>\n<li>现在，键入 ’ a.out’ 来运行程序。</li>\n<li>您可以看到屏幕上显示 ’ Hello World '。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ hello.cpp$ ./a.outHello World</span><br></pre></td></tr></table></figure>\n<p>请确保您的路径中已包含 g++ 编译器，并确保在包含源文件 hello.cpp 的目录中运行它。</p>\n<p>您也可以使用 makefile 来编译 C/C++ 程序。</p>\n<h2 id=\"c-中的分号-块\"><a class=\"markdownIt-Anchor\" href=\"#c-中的分号-块\">#</a> C++ 中的分号 &amp; 块</h2>\n<p>在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。</p>\n<p>例如，下面是三个不同的语句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = y;y = y+<span class=\"number\">1</span>;<span class=\"built_in\">add</span>(x, y);</span><br></pre></td></tr></table></figure>\n<p>块是一组使用大括号括起来的按逻辑连接的语句。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;   cout &lt;&lt; <span class=\"string\">&quot;Hello World&quot;</span>; <span class=\"comment\">// 输出 Hello World   return 0;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>C++ 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = y;y = y+<span class=\"number\">1</span>;<span class=\"built_in\">add</span>(x, y);</span><br></pre></td></tr></table></figure>\n<p>等同于</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = y; y = y+<span class=\"number\">1</span>; <span class=\"built_in\">add</span>(x, y);</span><br></pre></td></tr></table></figure>\n<h2 id=\"c-标识符\"><a class=\"markdownIt-Anchor\" href=\"#c-标识符\">#</a> C++ 标识符</h2>\n<p>C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</p>\n<p>C++ 标识符内不允许出现标点字符，比如 @、$ 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，<strong>Manpower</strong> 和 <strong>manpower</strong> 是两个不同的标识符。</p>\n<p>下面列出几个有效的标识符：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mohd       zara    abc   move_name  a_123myname50   _temp   j     a23b9      retVal</span><br></pre></td></tr></table></figure>\n<h2 id=\"c-关键字\"><a class=\"markdownIt-Anchor\" href=\"#c-关键字\">#</a> C++ 关键字</h2>\n<p>下表列出了 C++ 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p>\n<table>\n<thead>\n<tr>\n<th>asm</th>\n<th>else</th>\n<th>new</th>\n<th>this</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>auto</td>\n<td>enum</td>\n<td>operator</td>\n<td>throw</td>\n</tr>\n<tr>\n<td>bool</td>\n<td>explicit</td>\n<td>private</td>\n<td>true</td>\n</tr>\n<tr>\n<td>break</td>\n<td>export</td>\n<td>protected</td>\n<td>try</td>\n</tr>\n<tr>\n<td>case</td>\n<td>extern</td>\n<td>public</td>\n<td>typedef</td>\n</tr>\n<tr>\n<td>catch</td>\n<td>false</td>\n<td>register</td>\n<td>typeid</td>\n</tr>\n<tr>\n<td>char</td>\n<td>float</td>\n<td>reinterpret_cast</td>\n<td>typename</td>\n</tr>\n<tr>\n<td>class</td>\n<td>for</td>\n<td>return</td>\n<td>union</td>\n</tr>\n<tr>\n<td>const</td>\n<td>friend</td>\n<td>short</td>\n<td>unsigned</td>\n</tr>\n<tr>\n<td>const_cast</td>\n<td>goto</td>\n<td>signed</td>\n<td>using</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>if</td>\n<td>sizeof</td>\n<td>virtual</td>\n</tr>\n<tr>\n<td>default</td>\n<td>inline</td>\n<td>static</td>\n<td>void</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>int</td>\n<td>static_cast</td>\n<td>volatile</td>\n</tr>\n<tr>\n<td>do</td>\n<td>long</td>\n<td>struct</td>\n<td>wchar_t</td>\n</tr>\n<tr>\n<td>double</td>\n<td>mutable</td>\n<td>switch</td>\n<td>while</td>\n</tr>\n<tr>\n<td>dynamic_cast</td>\n<td>namespace</td>\n<td>template</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"三字符组\"><a class=\"markdownIt-Anchor\" href=\"#三字符组\">#</a> 三字符组</h2>\n<p>三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。</p>\n<p>三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。</p>\n<p>三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。</p>\n<p>下面列出了最常用的三字符序列：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">三字符组</th>\n<th style=\"text-align:left\">替换</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">??=</td>\n<td style=\"text-align:left\">#</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">??/</td>\n<td style=\"text-align:left\">\\</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">??’</td>\n<td style=\"text-align:left\">^</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">??(</td>\n<td style=\"text-align:left\">[</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">??)</td>\n<td style=\"text-align:left\">]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">??!</td>\n<td style=\"text-align:left\">|</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">??&lt;</td>\n<td style=\"text-align:left\">{</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">??&gt;</td>\n<td style=\"text-align:left\">}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">??-</td>\n<td style=\"text-align:left\">~</td>\n</tr>\n</tbody>\n</table>\n<p>如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接：“…?”“?..“或者转义序列：”…??…”。</p>\n<p>从 Microsoft Visual C++ 2010 版开始，该编译器默认不再自动替换三字符组。如果需要使用三字符组替换（如为了兼容古老的软件代码），需要设置编译器命令行选项 / Zc:trigraphs</p>\n<p>g++ 仍默认支持三字符组，但会给出编译警告。</p>\n<h2 id=\"c-中的空格\"><a class=\"markdownIt-Anchor\" href=\"#c-中的空格\">#</a> C++ 中的空格</h2>\n<p>只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。</p>\n<p>在 C++ 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> age;</span><br></pre></td></tr></table></figure>\n<p>在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fruit = apples + oranges;   <span class=\"comment\">// 获取水果的总数</span></span><br></pre></td></tr></table></figure>\n<p>fruit 和 =，或者 = 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。</p>\n<h1 id=\"c-注释\"><a class=\"markdownIt-Anchor\" href=\"#c-注释\">#</a> C++ 注释</h1>\n<p>程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。</p>\n<p>C++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。</p>\n<p>C++ 注释以 /* 开始，以 */ 终止。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 这是注释 */</span><span class=\"comment\">/* C++ 注释也可以</span></span><br><span class=\"line\"><span class=\"comment\"> * 跨行</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<p>注释也能以 // 开始，直到行末为止。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;main()&#123;</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Hello World&quot;</span>; <span class=\"comment\">// 输出 Hello World</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译时，编译器会忽略 <strong>// 输出 Hello World</strong>，最后会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello World</span><br></pre></td></tr></table></figure>\n<p>在 /* 和 <em>/ 注释内部，// 字符没有特殊的含义。在 // 注释内，/</em> 和 */ 字符也没有特殊的含义。因此，您可以在一种注释内嵌套另一种注释。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">/* 用于输出 Hello World 的注释</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; &quot;Hello World&quot;; // 输出 Hello World</span><br><span class=\"line\"></span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n<h1 id=\"c-数据类型\"><a class=\"markdownIt-Anchor\" href=\"#c-数据类型\">#</a> C++ 数据类型</h1>\n<p>使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。</p>\n<p>您可能需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。</p>\n<h2 id=\"基本的内置类型\"><a class=\"markdownIt-Anchor\" href=\"#基本的内置类型\">#</a> 基本的内置类型</h2>\n<p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">关键字</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">布尔型</td>\n<td style=\"text-align:left\">bool</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">字符型</td>\n<td style=\"text-align:left\">char</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">整型</td>\n<td style=\"text-align:left\">int</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">浮点型</td>\n<td style=\"text-align:left\">float</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">双浮点型</td>\n<td style=\"text-align:left\">double</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">无类型</td>\n<td style=\"text-align:left\">void</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">宽字符型</td>\n<td style=\"text-align:left\">wchar_t</td>\n</tr>\n</tbody>\n</table>\n<p>一些基本类型可以使用一个或多个类型修饰符进行修饰：</p>\n<ul>\n<li>signed</li>\n<li>unsigned</li>\n<li>short</li>\n<li>long</li>\n</ul>\n<p>下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">位</th>\n<th style=\"text-align:left\">范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">char</td>\n<td style=\"text-align:left\">1 个字节</td>\n<td style=\"text-align:left\">-128 到 127 或者 0 到 255</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">unsigned char</td>\n<td style=\"text-align:left\">1 个字节</td>\n<td style=\"text-align:left\">0 到 255</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">signed char</td>\n<td style=\"text-align:left\">1 个字节</td>\n<td style=\"text-align:left\">-128 到 127</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">int</td>\n<td style=\"text-align:left\">4 个字节</td>\n<td style=\"text-align:left\">-2147483648 到 2147483647</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">unsigned int</td>\n<td style=\"text-align:left\">4 个字节</td>\n<td style=\"text-align:left\">0 到 4294967295</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">signed int</td>\n<td style=\"text-align:left\">4 个字节</td>\n<td style=\"text-align:left\">-2147483648 到 2147483647</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">short int</td>\n<td style=\"text-align:left\">2 个字节</td>\n<td style=\"text-align:left\">-32768 到 32767</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">unsigned short int</td>\n<td style=\"text-align:left\">2 个字节</td>\n<td style=\"text-align:left\">0 到 65,535</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">signed short int</td>\n<td style=\"text-align:left\">2 个字节</td>\n<td style=\"text-align:left\">-32768 到 32767</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">long int</td>\n<td style=\"text-align:left\">8 个字节</td>\n<td style=\"text-align:left\">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">signed long int</td>\n<td style=\"text-align:left\">8 个字节</td>\n<td style=\"text-align:left\">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">unsigned long int</td>\n<td style=\"text-align:left\">8 个字节</td>\n<td style=\"text-align:left\">0 to 18,446,744,073,709,551,615</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">float</td>\n<td style=\"text-align:left\">4 个字节</td>\n<td style=\"text-align:left\">+/- 3.4e +/- 38 (~7 个数字)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">double</td>\n<td style=\"text-align:left\">8 个字节</td>\n<td style=\"text-align:left\">+/- 1.7e +/- 308 (~15 个数字)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">long double</td>\n<td style=\"text-align:left\">8 个字节</td>\n<td style=\"text-align:left\">+/- 1.7e +/- 308 (~15 个数字)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">wchar_t</td>\n<td style=\"text-align:left\">2 或 4 个字节</td>\n<td style=\"text-align:left\">1 个宽字符</td>\n</tr>\n</tbody>\n</table>\n<p>从上表可得知，变量的大小会根据编译器和所使用的电脑而有所不同。</p>\n<p>下面实例会输出您电脑上各种数据类型的大小。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main()&#123;   </span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of char : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">char</span>) &lt;&lt; endl;   </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of int : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>) &lt;&lt; endl;  </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of short int : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">short</span> <span class=\"type\">int</span>) &lt;&lt; endl;  </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of long int : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">long</span> <span class=\"type\">int</span>) &lt;&lt; endl;   </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of float : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span>) &lt;&lt; endl;   </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of double : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">double</span>) &lt;&lt; endl;  </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of wchar_t : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">wchar_t</span>) &lt;&lt; endl;   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本实例使用了 <strong>endl</strong>，这将在每一行后插入一个换行符，&lt;&lt; 运算符用于向屏幕传多个值。我们也使用 <strong>sizeof()</strong> 函数来获取各种数据类型的大小。</p>\n<p>当上面的代码被编译和执行时，它会产生以下的结果，结果会根据所使用的计算机而有所不同：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Size of <span class=\"type\">char</span> : <span class=\"number\">1</span>Size of <span class=\"type\">int</span> : <span class=\"number\">4</span>Size of <span class=\"type\">short</span> <span class=\"type\">int</span> : <span class=\"number\">2</span>Size of <span class=\"type\">long</span> <span class=\"type\">int</span> : <span class=\"number\">8</span>Size of <span class=\"type\">float</span> : <span class=\"number\">4</span>Size of <span class=\"type\">double</span> : <span class=\"number\">8</span>Size of <span class=\"type\">wchar_t</span> : <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"typedef-声明\"><a class=\"markdownIt-Anchor\" href=\"#typedef-声明\">#</a> typedef 声明</h2>\n<p>您可以使用 <strong>typedef</strong> 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> type newname;</span><br></pre></td></tr></table></figure>\n<p>例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> feet;</span><br></pre></td></tr></table></figure>\n<p>现在，下面的声明是完全合法的，它创建了一个整型变量 distance：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">feet distance;</span><br></pre></td></tr></table></figure>\n<h2 id=\"枚举类型\"><a class=\"markdownIt-Anchor\" href=\"#枚举类型\">#</a> 枚举类型</h2>\n<p>枚举类型 (enumeration) 是 C++ 中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p>\n<p>如果一个变量只有几种可能的值，可以定义为枚举 (enumeration) 类型。所谓 &quot;枚举&quot; 是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p>\n<p>创建枚举，需要使用关键字 <strong>enum</strong>。枚举类型的一般形式为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">enum</span>-name &#123; list of names &#125; var-list;</span><br></pre></td></tr></table></figure>\n<p>在这里，enum-name 是枚举类型的名称。名称列表 {list of names} 是用逗号分隔的。</p>\n<p>例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">color</span> &#123; red, green, blue &#125; c;c = blue;</span><br></pre></td></tr></table></figure>\n<p>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，<strong>green</strong> 的值为 5。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">color</span> &#123; red, green=<span class=\"number\">5</span>, blue &#125;;</span><br></pre></td></tr></table></figure>\n<p>在这里，<strong>blue</strong> 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1。</p>\n<h1 id=\"c-变量类型\"><a class=\"markdownIt-Anchor\" href=\"#c-变量类型\">#</a> C++ 变量类型</h1>\n<p>变量其实只不过是程序可操作的存储区的名称。C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</p>\n<p>变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。</p>\n<p>基于前一章讲解的基本类型，有以下几种基本的变量类型，将在下一章中进行讲解：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">bool</td>\n<td style=\"text-align:left\">存储值 true 或 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">char</td>\n<td style=\"text-align:left\">通常是一个八位字节（一个字节）。这是一个整数类型。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">int</td>\n<td style=\"text-align:left\">对机器而言，整数的最自然的大小。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">float</td>\n<td style=\"text-align:left\">单精度浮点值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">double</td>\n<td style=\"text-align:left\">双精度浮点值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">void</td>\n<td style=\"text-align:left\">表示类型的缺失。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">wchar_t</td>\n<td style=\"text-align:left\">宽字符类型。</td>\n</tr>\n</tbody>\n</table>\n<p>C++ 也允许定义各种其他类型的变量，比如<strong>枚举、指针、数组、引用、数据结构、类</strong>等等，这将会在后续的章节中进行讲解。</p>\n<p>下面我们将讲解如何定义、声明和使用各种类型的变量。</p>\n<h2 id=\"c-中的变量定义\"><a class=\"markdownIt-Anchor\" href=\"#c-中的变量定义\">#</a> C++ 中的变量定义</h2>\n<p>变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type variable_list;</span><br></pre></td></tr></table></figure>\n<p>在这里，<strong>type</strong> 必须是一个有效的 C++ 数据类型，可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象，<strong>variable_list</strong> 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>    i, j, k;<span class=\"type\">char</span>   c, ch;<span class=\"type\">float</span>  f, salary;<span class=\"type\">double</span> d;</span><br></pre></td></tr></table></figure>\n<p>行 <strong>int i, j, k;</strong> 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。</p>\n<p>变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type variable_name = value;</span><br></pre></td></tr></table></figure>\n<p>下面列举几个实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> d = <span class=\"number\">3</span>, f = <span class=\"number\">5</span>;   </span><br><span class=\"line\">\t<span class=\"comment\">// d 和 f 的声明 int d = 3, f = 5;          </span></span><br><span class=\"line\">\t<span class=\"comment\">// 定义并初始化 d 和 fbyte z = 22;               </span></span><br><span class=\"line\">\t<span class=\"comment\">// 定义并初始化 zchar x = &#x27;x&#x27;;              </span></span><br><span class=\"line\">\t<span class=\"comment\">// 变量 x 的值为 &#x27;x&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。</p>\n<h2 id=\"c-中的变量声明\"><a class=\"markdownIt-Anchor\" href=\"#c-中的变量声明\">#</a> C++ 中的变量声明</h2>\n<p>变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>\n<p>当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 <strong>extern</strong> 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。</p>\n<h2 id=\"实例-3\"><a class=\"markdownIt-Anchor\" href=\"#实例-3\">#</a> 实例</h2>\n<p>尝试下面的实例，其中，变量在头部就已经被声明，但它们是在主函数内被定义和初始化的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;<span class=\"comment\">// 变量声明extern int a, b;extern int c;extern float f;</span></span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 变量定义</span></span><br><span class=\"line\">  <span class=\"type\">int</span> a, b;</span><br><span class=\"line\">  <span class=\"type\">int</span> c;</span><br><span class=\"line\">  <span class=\"type\">float</span> f;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 实际初始化</span></span><br><span class=\"line\">  a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  b = <span class=\"number\">20</span>;</span><br><span class=\"line\">  c = a + b;</span><br><span class=\"line\"> </span><br><span class=\"line\">  cout &lt;&lt; c &lt;&lt; endl ;</span><br><span class=\"line\"></span><br><span class=\"line\">  f = <span class=\"number\">70.0</span>/<span class=\"number\">3.0</span>;</span><br><span class=\"line\">  cout &lt;&lt; f &lt;&lt; endl ;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3023.3333</span></span><br></pre></td></tr></table></figure>\n<p>同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数声明int func();int main()&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 函数调用</span></span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"built_in\">func</span>();&#125;<span class=\"comment\">// 函数定义int func()&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"c-中的左值lvalues和右值rvalues\"><a class=\"markdownIt-Anchor\" href=\"#c-中的左值lvalues和右值rvalues\">#</a> C++ 中的左值（Lvalues）和右值（Rvalues）</h2>\n<p>C++ 中有两种类型的表达式：</p>\n<ul>\n<li>** 左值（lvalue）：** 指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</li>\n<li>** 右值（rvalue）：** 术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li>\n</ul>\n<p>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> g = <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n<p>但是下面这个就不是一个有效的语句，会生成编译时错误：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span> = <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n<h1 id=\"c-变量作用域\"><a class=\"markdownIt-Anchor\" href=\"#c-变量作用域\">#</a> C++ 变量作用域</h1>\n<p>作用域是程序的一个区域，一般来说有三个地方可以声明变量：</p>\n<ul>\n<li>在函数或一个代码块内部声明的变量，称为局部变量。</li>\n<li>在函数参数的定义中声明的变量，称为形式参数。</li>\n<li>在所有函数外部声明的变量，称为全局变量。</li>\n</ul>\n<p>我们将在后续的章节中学习什么是函数和参数。本章我们先来讲解声明是局部变量和全局变量。</p>\n<h2 id=\"局部变量\"><a class=\"markdownIt-Anchor\" href=\"#局部变量\">#</a> 局部变量</h2>\n<p>在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">  <span class=\"type\">int</span> a, b;</span><br><span class=\"line\">  <span class=\"type\">int</span> c;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 实际初始化</span></span><br><span class=\"line\">  a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  b = <span class=\"number\">20</span>;</span><br><span class=\"line\">  c = a + b;</span><br><span class=\"line\"> </span><br><span class=\"line\">  cout &lt;&lt; c;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"全局变量\"><a class=\"markdownIt-Anchor\" href=\"#全局变量\">#</a> 全局变量</h2>\n<p>在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。</p>\n<p>全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"comment\">// 全局变量声明int g;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">  <span class=\"type\">int</span> a, b;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 实际初始化</span></span><br><span class=\"line\">  a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  b = <span class=\"number\">20</span>;</span><br><span class=\"line\">  g = a + b;</span><br><span class=\"line\"> </span><br><span class=\"line\">  cout &lt;&lt; g;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"comment\">// 全局变量声明int g = 20;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">  <span class=\"type\">int</span> g = <span class=\"number\">10</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">  cout &lt;&lt; g;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"初始化局部变量和全局变量\"><a class=\"markdownIt-Anchor\" href=\"#初始化局部变量和全局变量\">#</a> 初始化局部变量和全局变量</h2>\n<p>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">数据类型</th>\n<th style=\"text-align:left\">初始化默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">int</td>\n<td style=\"text-align:left\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">char</td>\n<td style=\"text-align:left\">‘\\0’</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">float</td>\n<td style=\"text-align:left\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">double</td>\n<td style=\"text-align:left\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">pointer</td>\n<td style=\"text-align:left\">NULL</td>\n</tr>\n</tbody>\n</table>\n<p>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。</p>\n<h1 id=\"c-常量\"><a class=\"markdownIt-Anchor\" href=\"#c-常量\">#</a> C++ 常量</h1>\n<p>常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做<strong>字面量</strong>。</p>\n<p>常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。</p>\n<p>常量就像是常规的变量，只不过常量的值在定义后不能进行修改。</p>\n<h2 id=\"整数常量\"><a class=\"markdownIt-Anchor\" href=\"#整数常量\">#</a> 整数常量</h2>\n<p>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。</p>\n<p>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</p>\n<p>下面列举几个整数常量的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">212</span>         <span class=\"comment\">// 合法的215u        // 合法的0xFeeL      // 合法的078         // 非法的：8 不是八进制的数字032UU       // 非法的：不能重复后缀</span></span><br></pre></td></tr></table></figure>\n<p>以下是各种类型的整数常量的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">85</span>         <span class=\"comment\">// 十进制0213       // 八进制 0x4b       // 十六进制 30         // 整数 30u        // 无符号整数 30l        // 长整数 30ul       // 无符号长整数</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"浮点常量\"><a class=\"markdownIt-Anchor\" href=\"#浮点常量\">#</a> 浮点常量</h2>\n<p>浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。</p>\n<p>当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。</p>\n<p>下面列举几个浮点常量的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3.14159</span>       <span class=\"comment\">// 合法的 314159E-5L    // 合法的 510E          // 非法的：不完整的指数210f          // 非法的：没有小数或指数.e55          // 非法的：缺少整数或分数</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"布尔常量\"><a class=\"markdownIt-Anchor\" href=\"#布尔常量\">#</a> 布尔常量</h2>\n<p>布尔常量共有两个，它们都是标准的 C++ 关键字：</p>\n<ul>\n<li><strong>true</strong> 值代表真。</li>\n<li><strong>false</strong> 值代表假。</li>\n</ul>\n<p>我们不应把 true 的值看成 1，把 false 的值看成 0。</p>\n<h2 id=\"字符常量\"><a class=\"markdownIt-Anchor\" href=\"#字符常量\">#</a> 字符常量</h2>\n<p>字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L’x’），此时它必须存储在 <strong>wchar_t</strong> 类型的变量中。否则，它就是一个窄字符常量（例如 ‘x’），此时它可以存储在 <strong>char</strong> 类型的简单变量中。</p>\n<p>字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\\t’），或一个通用的字符（例如 ‘\\u02C0’）。</p>\n<p>在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\\n）或制表符（\\t）等。下表列出了一些这样的转义序列码：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">转义序列</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">\\</td>\n<td style=\"text-align:left\">\\ 字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">'</td>\n<td style=\"text-align:left\">’ 字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&quot;</td>\n<td style=\"text-align:left\">&quot; 字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">?</td>\n<td style=\"text-align:left\">? 字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\a</td>\n<td style=\"text-align:left\">警报铃声</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\b</td>\n<td style=\"text-align:left\">退格键</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\f</td>\n<td style=\"text-align:left\">换页符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\n</td>\n<td style=\"text-align:left\">换行符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\r</td>\n<td style=\"text-align:left\">回车</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\t</td>\n<td style=\"text-align:left\">水平制表符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\v</td>\n<td style=\"text-align:left\">垂直制表符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\ooo</td>\n<td style=\"text-align:left\">一到三位的八进制数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\xhh . . .</td>\n<td style=\"text-align:left\">一个或多个数字的十六进制数</td>\n</tr>\n</tbody>\n</table>\n<p>下面的实例显示了一些转义序列字符：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main()&#123;   cout &lt;&lt; <span class=\"string\">&quot;Hello\\tWorld\\n\\n&quot;</span>;   return 0;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello   World</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串常量\"><a class=\"markdownIt-Anchor\" href=\"#字符串常量\">#</a> 字符串常量</h2>\n<p>字符串字面值或常量是括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。</p>\n<p>您可以使用空格做分隔符，把一个很长的字符串常量进行分行。</p>\n<p>下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;quot;hello, dear&quot;</span><span class=\"string\">&quot;hello, \\dear&quot;</span><span class=\"string\">&quot;hello, &quot;</span> <span class=\"string\">&quot;d&quot;</span> <span class=\"string\">&quot;ear&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"定义常量\"><a class=\"markdownIt-Anchor\" href=\"#定义常量\">#</a> 定义常量</h2>\n<p>在 C++ 中，有两种简单的定义常量的方式：</p>\n<ul>\n<li>使用 <strong>#define</strong> 预处理器。</li>\n<li>使用 <strong>const</strong> 关键字。</li>\n</ul>\n<h2 id=\"define-预处理器\"><a class=\"markdownIt-Anchor\" href=\"#define-预处理器\">#</a> #define 预处理器</h2>\n<p>下面是使用 #define 预处理器定义常量的形式：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> identifier value</span></span><br></pre></td></tr></table></figure>\n<p>具体请看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;#<span class=\"keyword\">define</span> LENGTH 10   #<span class=\"keyword\">define</span> WIDTH  5#<span class=\"keyword\">define</span> NEWLINE <span class=\"string\">&#x27;\\n&#x27;</span>int main()&#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"type\">int</span> area;  </span><br><span class=\"line\">   </span><br><span class=\"line\">   area = LENGTH * WIDTH;</span><br><span class=\"line\">   cout &lt;&lt; area;</span><br><span class=\"line\">   cout &lt;&lt; NEWLINE;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">50</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"const-关键字\"><a class=\"markdownIt-Anchor\" href=\"#const-关键字\">#</a> const 关键字</h2>\n<p>您可以使用 <strong>const</strong> 前缀声明指定类型的常量，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> type variable = value;</span><br></pre></td></tr></table></figure>\n<p>具体请看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main()&#123;</span></span><br><span class=\"line\">   <span class=\"type\">const</span> <span class=\"type\">int</span>  LENGTH = <span class=\"number\">10</span>;</span><br><span class=\"line\">   <span class=\"type\">const</span> <span class=\"type\">int</span>  WIDTH  = <span class=\"number\">5</span>;</span><br><span class=\"line\">   <span class=\"type\">const</span> <span class=\"type\">char</span> NEWLINE = <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span> area;  </span><br><span class=\"line\">   </span><br><span class=\"line\">   area = LENGTH * WIDTH;</span><br><span class=\"line\">   cout &lt;&lt; area;</span><br><span class=\"line\">   cout &lt;&lt; NEWLINE;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">50</span></span><br></pre></td></tr></table></figure>\n<p>请注意，把常量定义为大写字母形式，是一个很好的编程实践。</p>\n<h1 id=\"c-修饰符类型\"><a class=\"markdownIt-Anchor\" href=\"#c-修饰符类型\">#</a> C++ 修饰符类型</h1>\n<p>C++ 允许在 <strong>char、int 和 double</strong> 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。</p>\n<p>下面列出了数据类型修饰符：</p>\n<ul>\n<li>signed</li>\n<li>unsigned</li>\n<li>long</li>\n<li>short</li>\n</ul>\n<p>修饰符 <strong>signed、unsigned、long 和 short</strong> 可应用于整型，<strong>signed</strong> 和 <strong>unsigned</strong> 可应用于字符型，<strong>long</strong> 可应用于双精度型。</p>\n<p>修饰符 <strong>signed</strong> 和 <strong>unsigned</strong> 也可以作为 <strong>long</strong> 或 <strong>short</strong> 修饰符的前缀。例如：<strong>unsigned long int</strong>。</p>\n<p>C++ 允许使用速记符号来声明<strong>无符号短整数</strong>或<strong>无符号长整数</strong>。您可以不写 int，只写单词 <strong>unsigned、short</strong> 或 <strong>unsigned、long</strong>，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> x;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> y;</span><br></pre></td></tr></table></figure>\n<p>为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 这个程序演示了有符号整数和无符号整数之间的差别</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">short</span> <span class=\"type\">int</span> i;           <span class=\"comment\">// 有符号短整数</span></span><br><span class=\"line\">   <span class=\"type\">short</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> j;  <span class=\"comment\">// 无符号短整数</span></span><br><span class=\"line\"></span><br><span class=\"line\">   j = <span class=\"number\">50000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   i = j;</span><br><span class=\"line\">   cout &lt;&lt; i &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; j;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的程序运行时，会输出下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">-15536</span> <span class=\"number\">50000</span></span><br></pre></td></tr></table></figure>\n<p>上述结果中，无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536。</p>\n<h2 id=\"c-中的类型限定符\"><a class=\"markdownIt-Anchor\" href=\"#c-中的类型限定符\">#</a> C++ 中的类型限定符</h2>\n<p>类型限定符提供了变量的额外信息。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">限定符</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">const</td>\n<td style=\"text-align:left\"><strong>const</strong> 类型的对象在程序执行期间不能被修改改变。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">volatile</td>\n<td style=\"text-align:left\">修饰符 <strong>volatile</strong> 告诉编译器，变量的值可能以程序未明确指定的方式被改变。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">restrict</td>\n<td style=\"text-align:left\">由 <strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"c-存储类\"><a class=\"markdownIt-Anchor\" href=\"#c-存储类\">#</a> C++ 存储类</h1>\n<p>存储类定义 C++ 程序中变量 / 函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p>\n<ul>\n<li>auto</li>\n<li>register</li>\n<li>static</li>\n<li>extern</li>\n<li>mutable</li>\n<li>thread_local (C++11)</li>\n</ul>\n<p>从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p>\n<h2 id=\"auto-存储类\"><a class=\"markdownIt-Anchor\" href=\"#auto-存储类\">#</a> auto 存储类</h2>\n<p>自 C++ 11 以来，<strong>auto</strong> 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。</p>\n<p>C<ins>98 标准中 auto 关键字用于自动变量的声明，但由于使用极少且多余，在 C</ins>11 中已删除这一用法。</p>\n<p>根据初始化表达式自动推断被声明的变量的类型，如：</p>\n<p>auto f=3.14;    //doubleauto s(“hello”);  //const char<em>auto z = new auto(9); // int</em>auto x1 = 5, x2 = 5.0, x3=‘r’;// 错误，必须是初始化为同一类型</p>\n<h2 id=\"register-存储类\"><a class=\"markdownIt-Anchor\" href=\"#register-存储类\">#</a> register 存储类</h2>\n<p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p>\n<p register=\"\" int=\"\" miles;=\"\"></p>\n<p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p>\n<h2 id=\"static-存储类\"><a class=\"markdownIt-Anchor\" href=\"#static-存储类\">#</a> static 存储类</h2>\n<p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>\n<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p>\n<p>在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p>\n<h2 id=\"实例-4\"><a class=\"markdownIt-Anchor\" href=\"#实例-4\">#</a> 实例</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"comment\">// 函数声明 void func(void); </span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> count = <span class=\"number\">10</span>; <span class=\"comment\">/* 全局变量 */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(count--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       <span class=\"built_in\">func</span>();    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;<span class=\"comment\">// 函数定义void func( void )&#123;</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> i = <span class=\"number\">5</span>; <span class=\"comment\">// 局部静态变量</span></span><br><span class=\"line\">    i++;    std::cout &lt;&lt; <span class=\"string\">&quot;变量 i 为 &quot;</span> &lt;&lt; i ;    std::cout &lt;&lt; <span class=\"string\">&quot; , 变量 count 为 &quot;</span> &lt;&lt; count &lt;&lt; std::endl;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量 i 为 <span class=\"number\">6</span> , 变量 count 为 <span class=\"number\">9</span>变量 i 为 <span class=\"number\">7</span> , 变量 count 为 <span class=\"number\">8</span>变量 i 为 <span class=\"number\">8</span> , 变量 count 为 <span class=\"number\">7</span>变量 i 为 <span class=\"number\">9</span> , 变量 count 为 <span class=\"number\">6</span>变量 i 为 <span class=\"number\">10</span> , 变量 count 为 <span class=\"number\">5</span>变量 i 为 <span class=\"number\">11</span> , 变量 count 为 <span class=\"number\">4</span>变量 i 为 <span class=\"number\">12</span> , 变量 count 为 <span class=\"number\">3</span>变量 i 为 <span class=\"number\">13</span> , 变量 count 为 <span class=\"number\">2</span>变量 i 为 <span class=\"number\">14</span> , 变量 count 为 <span class=\"number\">1</span>变量 i 为 <span class=\"number\">15</span> , 变量 count 为 <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"extern-存储类\"><a class=\"markdownIt-Anchor\" href=\"#extern-存储类\">#</a> extern 存储类</h2>\n<p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>\n<p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p>\n<p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p>\n<p>第一个文件：main.cpp</p>\n<h2 id=\"实例-5\"><a class=\"markdownIt-Anchor\" href=\"#实例-5\">#</a> 实例</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"type\">int</span> count ;<span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title\">write_extern</span><span class=\"params\">()</span></span>; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   count = <span class=\"number\">5</span>;   <span class=\"built_in\">write_extern</span>();&#125;</span><br></pre></td></tr></table></figure>\n<p>第二个文件：support.cpp</p>\n<h2 id=\"实例-6\"><a class=\"markdownIt-Anchor\" href=\"#实例-6\">#</a> 实例</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">extern</span> <span class=\"type\">int</span> count; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">write_extern</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;</span><br><span class=\"line\">   std::cout &lt;&lt; <span class=\"string\">&quot;Count is &quot;</span> &lt;&lt; count &lt;&lt; std::endl;&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里，第二个文件中的 <em>extern</em> 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ main.cpp support.cpp -o write</span><br></pre></td></tr></table></figure>\n<p>这会产生 <strong>write</strong> 可执行程序，尝试执行 <strong>write</strong>，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./writeCount is <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"mutable-存储类\"><a class=\"markdownIt-Anchor\" href=\"#mutable-存储类\">#</a> mutable 存储类</h2>\n<p><strong>mutable</strong> 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p>\n<h2 id=\"thread_local-存储类\"><a class=\"markdownIt-Anchor\" href=\"#thread_local-存储类\">#</a> thread_local 存储类</h2>\n<p>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p>\n<p>thread_local 说明符可以与 static 或 extern 合并。</p>\n<p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p>\n<p>以下演示了可以被声明为 thread_local 的变量：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">thread_local</span> <span class=\"type\">int</span> x;  <span class=\"comment\">// 命名空间下的全局变量class X&#123;</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"keyword\">thread_local</span> std::string s; <span class=\"comment\">// 类的static成员变量&#125;;static thread_local std::string X::s;  // X::s 是需要定义的</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">thread_local</span> std::vector&lt;<span class=\"type\">int</span>&gt; v;  <span class=\"comment\">// 本地变量&#125;</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"c-运算符\"><a class=\"markdownIt-Anchor\" href=\"#c-运算符\">#</a> C++ 运算符</h1>\n<p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符：</p>\n<ul>\n<li>算术运算符</li>\n<li>关系运算符</li>\n<li>逻辑运算符</li>\n<li>位运算符</li>\n<li>赋值运算符</li>\n<li>杂项运算符</li>\n</ul>\n<p>本章将逐一介绍算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。</p>\n<h2 id=\"算术运算符\"><a class=\"markdownIt-Anchor\" href=\"#算术运算符\">#</a> 算术运算符</h2>\n<p>下表显示了 C++ 支持的算术运算符。</p>\n<p>假设变量 A 的值为 10，变量 B 的值为 20，则：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">运算符</th>\n<th style=\"text-align:left\">描述</th>\n<th style=\"text-align:left\">实例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">+</td>\n<td style=\"text-align:left\">把两个操作数相加</td>\n<td style=\"text-align:left\">A + B 将得到 30</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">从第一个操作数中减去第二个操作数</td>\n<td style=\"text-align:left\">A - B 将得到 -10</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">*</td>\n<td style=\"text-align:left\">把两个操作数相乘</td>\n<td style=\"text-align:left\">A * B 将得到 200</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">/</td>\n<td style=\"text-align:left\">分子除以分母</td>\n<td style=\"text-align:left\">B / A 将得到 2</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">%</td>\n<td style=\"text-align:left\">取模运算符，整除后的余数</td>\n<td style=\"text-align:left\">B % A 将得到 0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">++</td>\n<td style=\"text-align:left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lZHUuYWxpeXVuLmNvbS9jcGx1c3BsdXMvY3BwLWluY3JlbWVudC1kZWNyZW1lbnQtb3BlcmF0b3JzLmh0bWw=\">自增运算符</span>，整数值增加 1</td>\n<td style=\"text-align:left\">A++ 将得到 11</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">–</td>\n<td style=\"text-align:left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lZHUuYWxpeXVuLmNvbS9jcGx1c3BsdXMvY3BwLWluY3JlbWVudC1kZWNyZW1lbnQtb3BlcmF0b3JzLmh0bWw=\">自减运算符</span>，整数值减少 1</td>\n<td style=\"text-align:left\">A-- 将得到 9</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"实例-7\"><a class=\"markdownIt-Anchor\" href=\"#实例-7\">#</a> 实例</h3>\n<p>请看下面的实例，了解 C++ 中可用的算术运算符。</p>\n<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>\n<h2 id=\"实例-8\"><a class=\"markdownIt-Anchor\" href=\"#实例-8\">#</a> 实例</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">21</span>;   <span class=\"type\">int</span> b = <span class=\"number\">10</span>;   <span class=\"type\">int</span> c ; </span><br><span class=\"line\">   c = a + b;   cout &lt;&lt; <span class=\"string\">&quot;Line 1 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ;   c = a - b;   cout &lt;&lt; <span class=\"string\">&quot;Line 2 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ;   c = a * b;   cout &lt;&lt; <span class=\"string\">&quot;Line 3 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ;   c = a / b;   cout &lt;&lt; <span class=\"string\">&quot;Line 4 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ;   c = a % b;   cout &lt;&lt; <span class=\"string\">&quot;Line 5 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   <span class=\"type\">int</span> d = <span class=\"number\">10</span>;   <span class=\"comment\">//  测试自增、自减</span></span><br><span class=\"line\">   c = d++;   cout &lt;&lt; <span class=\"string\">&quot;Line 6 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   d = <span class=\"number\">10</span>;    <span class=\"comment\">// 重新赋值</span></span><br><span class=\"line\">   c = d--;   cout &lt;&lt; <span class=\"string\">&quot;Line 7 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ;   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Line <span class=\"number\">1</span> - c 的值是 <span class=\"number\">31L</span>ine <span class=\"number\">2</span> - c 的值是 <span class=\"number\">11L</span>ine <span class=\"number\">3</span> - c 的值是 <span class=\"number\">210L</span>ine <span class=\"number\">4</span> - c 的值是 <span class=\"number\">2L</span>ine <span class=\"number\">5</span> - c 的值是 <span class=\"number\">1L</span>ine <span class=\"number\">6</span> - c 的值是 <span class=\"number\">10L</span>ine <span class=\"number\">7</span> - c 的值是 <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"关系运算符\"><a class=\"markdownIt-Anchor\" href=\"#关系运算符\">#</a> 关系运算符</h2>\n<p>下表显示了 C++ 支持的关系运算符。</p>\n<p>假设变量 A 的值为 10，变量 B 的值为 20，则：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">运算符</th>\n<th style=\"text-align:left\">描述</th>\n<th style=\"text-align:left\">实例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">==</td>\n<td style=\"text-align:left\">检查两个操作数的值是否相等，如果相等则条件为真。</td>\n<td style=\"text-align:left\">(A == B) 不为真。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">!=</td>\n<td style=\"text-align:left\">检查两个操作数的值是否相等，如果不相等则条件为真。</td>\n<td style=\"text-align:left\">(A != B) 为真。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&gt;</td>\n<td style=\"text-align:left\">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>\n<td style=\"text-align:left\">(A&gt; B) 不为真。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;</td>\n<td style=\"text-align:left\">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>\n<td style=\"text-align:left\">(A &lt; B) 为真。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td>\n<td style=\"text-align:left\">(A&gt;= B) 不为真。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;=</td>\n<td style=\"text-align:left\">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td>\n<td style=\"text-align:left\">(A &lt;= B) 为真。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"实例-9\"><a class=\"markdownIt-Anchor\" href=\"#实例-9\">#</a> 实例</h3>\n<p>请看下面的实例，了解 C++ 中可用的关系运算符。</p>\n<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>\n<h2 id=\"实例-10\"><a class=\"markdownIt-Anchor\" href=\"#实例-10\">#</a> 实例</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">21</span>;   <span class=\"type\">int</span> b = <span class=\"number\">10</span>;   <span class=\"type\">int</span> c ; </span><br><span class=\"line\">   <span class=\"keyword\">if</span>( a == b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 1 - a 等于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 1 - a 不等于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( a &lt; b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 2 - a 小于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 2 - a 不小于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( a &gt; b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 3 - a 大于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 3 - a 不大于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"comment\">/* 改变 a 和 b 的值 */</span></span><br><span class=\"line\">   a = <span class=\"number\">5</span>;   b = <span class=\"number\">20</span>;   <span class=\"keyword\">if</span> ( a &lt;= b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 4 - a 小于或等于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( b &gt;= a )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 5 - b 大于或等于 a&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Line <span class=\"number\">1</span> - a 不等于 bLine <span class=\"number\">2</span> - a 不小于 bLine <span class=\"number\">3</span> - a 大于 bLine <span class=\"number\">4</span> - a 小于或等于 bLine <span class=\"number\">5</span> - b 大于或等于 a</span><br></pre></td></tr></table></figure>\n<h2 id=\"逻辑运算符\"><a class=\"markdownIt-Anchor\" href=\"#逻辑运算符\">#</a> 逻辑运算符</h2>\n<p>下表显示了 C++ 支持的关系逻辑运算符。</p>\n<p>假设变量 A 的值为 1，变量 B 的值为 0，则：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">运算符</th>\n<th style=\"text-align:left\">描述</th>\n<th style=\"text-align:left\">实例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">&amp;&amp;</td>\n<td style=\"text-align:left\">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>\n<td style=\"text-align:left\">(A &amp;&amp; B) 为假。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">||</td>\n<td style=\"text-align:left\">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>\n<td style=\"text-align:left\">(A || B) 为真。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">!</td>\n<td style=\"text-align:left\">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>\n<td style=\"text-align:left\">!(A &amp;&amp; B) 为真。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"实例-11\"><a class=\"markdownIt-Anchor\" href=\"#实例-11\">#</a> 实例</h3>\n<p>请看下面的实例，了解 C++ 中可用的逻辑运算符。</p>\n<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>\n<h2 id=\"实例-12\"><a class=\"markdownIt-Anchor\" href=\"#实例-12\">#</a> 实例</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">5</span>;   <span class=\"type\">int</span> b = <span class=\"number\">20</span>;   <span class=\"type\">int</span> c ; </span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( a &amp;&amp; b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 1 - 条件为真&quot;</span>&lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( a || b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 2 - 条件为真&quot;</span>&lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"comment\">/* 改变 a 和 b 的值 */</span></span><br><span class=\"line\">   a = <span class=\"number\">0</span>;   b = <span class=\"number\">10</span>;   <span class=\"keyword\">if</span> ( a &amp;&amp; b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 3 - 条件为真&quot;</span>&lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 4 - 条件不为真&quot;</span>&lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( !(a &amp;&amp; b) )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 5 - 条件为真&quot;</span>&lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Line <span class=\"number\">1</span> - 条件为真Line <span class=\"number\">2</span> - 条件为真Line <span class=\"number\">4</span> - 条件不为真Line <span class=\"number\">5</span> - 条件为真</span><br></pre></td></tr></table></figure>\n<h2 id=\"位运算符\"><a class=\"markdownIt-Anchor\" href=\"#位运算符\">#</a> 位运算符</h2>\n<p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">p</th>\n<th style=\"text-align:left\">q</th>\n<th style=\"text-align:left\">p &amp; q</th>\n<th style=\"text-align:left\">p | q</th>\n<th style=\"text-align:left\">p ^ q</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n</tr>\n</tbody>\n</table>\n<p>假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：</p>\n<p>A = 0011 1100</p>\n<p>B = 0000 1101</p>\n<p>-----------------</p>\n<p>A&amp;B = 0000 1100</p>\n<p>A|B = 0011 1101</p>\n<p>A^B = 0011 0001</p>\n<p>~A = 1100 0011</p>\n<p>下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">运算符</th>\n<th style=\"text-align:left\">描述</th>\n<th style=\"text-align:left\">实例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">&amp;</td>\n<td style=\"text-align:left\">如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>\n<td style=\"text-align:left\">(A &amp; B) 将得到 12，即为 0000 1100</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">|</td>\n<td style=\"text-align:left\">如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>\n<td style=\"text-align:left\">(A | B) 将得到 61，即为 0011 1101</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">^</td>\n<td style=\"text-align:left\">如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td>\n<td style=\"text-align:left\">(A ^ B) 将得到 49，即为 0011 0001</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">~</td>\n<td style=\"text-align:left\">二进制补码运算符是一元运算符，具有 &quot;翻转&quot; 位效果，即 0 变成 1，1 变成 0。</td>\n<td style=\"text-align:left\">(~A) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;&lt;</td>\n<td style=\"text-align:left\">二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>\n<td style=\"text-align:left\">A &lt;&lt; 2 将得到 240，即为 1111 0000</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&gt;&gt;</td>\n<td style=\"text-align:left\">二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>\n<td style=\"text-align:left\">A &gt;&gt; 2 将得到 15，即为 0000 1111</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"实例-13\"><a class=\"markdownIt-Anchor\" href=\"#实例-13\">#</a> 实例</h3>\n<p>请看下面的实例，了解 C++ 中可用的位运算符。</p>\n<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>\n<h2 id=\"实例-14\"><a class=\"markdownIt-Anchor\" href=\"#实例-14\">#</a> 实例</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">unsigned</span> <span class=\"type\">int</span> a = <span class=\"number\">60</span>;      <span class=\"comment\">// 60 = 0011 1100  </span></span><br><span class=\"line\">   <span class=\"type\">unsigned</span> <span class=\"type\">int</span> b = <span class=\"number\">13</span>;      <span class=\"comment\">// 13 = 0000 1101</span></span><br><span class=\"line\">   <span class=\"type\">int</span> c = <span class=\"number\">0</span>;           </span><br><span class=\"line\"> </span><br><span class=\"line\">   c = a &amp; b;             <span class=\"comment\">// 12 = 0000 1100</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Line 1 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   c = a | b;             <span class=\"comment\">// 61 = 0011 1101</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Line 2 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   c = a ^ b;             <span class=\"comment\">// 49 = 0011 0001</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Line 3 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   c = ~a;                <span class=\"comment\">// -61 = 1100 0011</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Line 4 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   c = a &lt;&lt; <span class=\"number\">2</span>;            <span class=\"comment\">// 240 = 1111 0000</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Line 5 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   c = a &gt;&gt; <span class=\"number\">2</span>;            <span class=\"comment\">// 15 = 0000 1111</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Line 6 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生以下结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">Line 1 - c 的值是 12Line 2 - c 的值是 61Line 3 - c 的值是 49Line 4 - c 的值是 -61Line 5 - c 的值是 240Line 6 - c 的值是 15</span><br></pre></td></tr></table></figure>\n<h2 id=\"赋值运算符\"><a class=\"markdownIt-Anchor\" href=\"#赋值运算符\">#</a> 赋值运算符</h2>\n<p>下表列出了 C++ 支持的赋值运算符：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">运算符</th>\n<th style=\"text-align:left\">描述</th>\n<th style=\"text-align:left\">实例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">=</td>\n<td style=\"text-align:left\">简单的赋值运算符，把右边操作数的值赋给左边操作数</td>\n<td style=\"text-align:left\">C = A + B 将把 A + B 的值赋给 C</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+=</td>\n<td style=\"text-align:left\">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>\n<td style=\"text-align:left\">C += A 相当于 C = C + A</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-=</td>\n<td style=\"text-align:left\">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>\n<td style=\"text-align:left\">C -= A 相当于 C = C - A</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">*=</td>\n<td style=\"text-align:left\">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>\n<td style=\"text-align:left\">C *= A 相当于 C = C * A</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">/=</td>\n<td style=\"text-align:left\">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>\n<td style=\"text-align:left\">C /= A 相当于 C = C / A</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">%=</td>\n<td style=\"text-align:left\">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>\n<td style=\"text-align:left\">C %= A 相当于 C = C % A</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;&lt;=</td>\n<td style=\"text-align:left\">左移且赋值运算符</td>\n<td style=\"text-align:left\">C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&gt;&gt;=</td>\n<td style=\"text-align:left\">右移且赋值运算符</td>\n<td style=\"text-align:left\">C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&amp;=</td>\n<td style=\"text-align:left\">按位与且赋值运算符</td>\n<td style=\"text-align:left\">C &amp;= 2 等同于 C = C &amp; 2</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">^=</td>\n<td style=\"text-align:left\">按位异或且赋值运算符</td>\n<td style=\"text-align:left\">C ^= 2 等同于 C = C ^ 2</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">|=</td>\n<td style=\"text-align:left\">按位或且赋值运算符</td>\n<td style=\"text-align:left\">C |= 2 等同于 C = C | 2</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"实例-15\"><a class=\"markdownIt-Anchor\" href=\"#实例-15\">#</a> 实例</h3>\n<p>请看下面的实例，了解 C++ 中可用的赋值运算符。</p>\n<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>\n<h2 id=\"实例-16\"><a class=\"markdownIt-Anchor\" href=\"#实例-16\">#</a> 实例</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">21</span>;   <span class=\"type\">int</span> c ; </span><br><span class=\"line\">   c =  a;   cout &lt;&lt; <span class=\"string\">&quot;Line 1 - =  运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c +=  a;   cout &lt;&lt; <span class=\"string\">&quot;Line 2 - += 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c -=  a;   cout &lt;&lt; <span class=\"string\">&quot;Line 3 - -= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c *=  a;   cout &lt;&lt; <span class=\"string\">&quot;Line 4 - *= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c /=  a;   cout &lt;&lt; <span class=\"string\">&quot;Line 5 - /= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c  = <span class=\"number\">200</span>;   c %=  a;   cout &lt;&lt; <span class=\"string\">&quot;Line 6 - %= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c &lt;&lt;=  <span class=\"number\">2</span>;   cout &lt;&lt; <span class=\"string\">&quot;Line 7 - &lt;&lt;= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c &gt;&gt;=  <span class=\"number\">2</span>;   cout &lt;&lt; <span class=\"string\">&quot;Line 8 - &gt;&gt;= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c &amp;=  <span class=\"number\">2</span>;   cout &lt;&lt; <span class=\"string\">&quot;Line 9 - &amp;= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c ^=  <span class=\"number\">2</span>;   cout &lt;&lt; <span class=\"string\">&quot;Line 10 - ^= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c |=  <span class=\"number\">2</span>;   cout &lt;&lt; <span class=\"string\">&quot;Line 11 - |= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Line <span class=\"number\">1</span> - =  运算符实例，c 的值 = <span class=\"number\">21L</span>ine <span class=\"number\">2</span> - += 运算符实例，c 的值 = <span class=\"number\">42L</span>ine <span class=\"number\">3</span> - -= 运算符实例，c 的值 = <span class=\"number\">21L</span>ine <span class=\"number\">4</span> - *= 运算符实例，c 的值 = <span class=\"number\">441L</span>ine <span class=\"number\">5</span> - /= 运算符实例，c 的值 = <span class=\"number\">21L</span>ine <span class=\"number\">6</span> - %= 运算符实例，c 的值 = <span class=\"number\">11L</span>ine <span class=\"number\">7</span> - &lt;&lt;= 运算符实例，c 的值 = <span class=\"number\">44L</span>ine <span class=\"number\">8</span> - &gt;&gt;= 运算符实例，c 的值 = <span class=\"number\">11L</span>ine <span class=\"number\">9</span> - &amp;= 运算符实例，c 的值 = <span class=\"number\">2L</span>ine <span class=\"number\">10</span> - ^= 运算符实例，c 的值 = <span class=\"number\">0L</span>ine <span class=\"number\">11</span> - |= 运算符实例，c 的值 = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"杂项运算符\"><a class=\"markdownIt-Anchor\" href=\"#杂项运算符\">#</a> 杂项运算符</h2>\n<p>下表列出了 C++ 支持的其他一些重要的运算符。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">运算符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">sizeof</td>\n<td style=\"text-align:left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lZHUuYWxpeXVuLmNvbS9jcGx1c3BsdXMvY3BwLXNpemVvZi1vcGVyYXRvci5odG1s\">sizeof 运算符</span>返回变量的大小。例如，sizeof (a) 将返回 4，其中 a 是整数。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Condition ? X : Y</td>\n<td style=\"text-align:left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lZHUuYWxpeXVuLmNvbS9jcGx1c3BsdXMvY3BwLWNvbmRpdGlvbmFsLW9wZXJhdG9yLmh0bWw=\">条件运算符</span>。如果 Condition 为真？则值为 X : 否则值为 Y。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">,</td>\n<td style=\"text-align:left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lZHUuYWxpeXVuLmNvbS9jcGx1c3BsdXMvY3BwLWNvbW1hLW9wZXJhdG9yLmh0bWw=\">逗号运算符</span>会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">.（点）和 -&gt;（箭头）</td>\n<td style=\"text-align:left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lZHUuYWxpeXVuLmNvbS9jcGx1c3BsdXMvY3BwLW1lbWJlci1vcGVyYXRvcnMuaHRtbA==\">成员运算符</span>用于引用类、结构和共用体的成员。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Cast</td>\n<td style=\"text-align:left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lZHUuYWxpeXVuLmNvbS9jcGx1c3BsdXMvY3BwLWNhc3Rpbmctb3BlcmF0b3JzLmh0bWw=\">强制转换运算符</span>把一种数据类型转换为另一种数据类型。例如，int (2.2000) 将返回 2。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&amp;</td>\n<td style=\"text-align:left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lZHUuYWxpeXVuLmNvbS9jcGx1c3BsdXMvY3BwLXBvaW50ZXItb3BlcmF0b3JzLmh0bWw=\">指针运算符 &amp;</span> 返回变量的地址。例如 &amp;a; 将给出变量的实际地址。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">*</td>\n<td style=\"text-align:left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lZHUuYWxpeXVuLmNvbS9jcGx1c3BsdXMvY3BwLXBvaW50ZXItb3BlcmF0b3JzLmh0bWw=\">指针运算符 *</span> 指向一个变量。例如，*var; 将指向变量 var。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"c-中的运算符优先级\"><a class=\"markdownIt-Anchor\" href=\"#c-中的运算符优先级\">#</a> C++ 中的运算符优先级</h2>\n<p>运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。</p>\n<p>例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。</p>\n<p>下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类别</th>\n<th style=\"text-align:left\">运算符</th>\n<th style=\"text-align:left\">结合性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">后缀</td>\n<td style=\"text-align:left\">() [] -&gt; . ++ - -</td>\n<td style=\"text-align:left\">从左到右</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">一元</td>\n<td style=\"text-align:left\">+ - ! ~ ++ - - (type)* &amp; sizeof</td>\n<td style=\"text-align:left\">从右到左</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">乘除</td>\n<td style=\"text-align:left\">* / %</td>\n<td style=\"text-align:left\">从左到右</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">加减</td>\n<td style=\"text-align:left\">+ -</td>\n<td style=\"text-align:left\">从左到右</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">移位</td>\n<td style=\"text-align:left\">&lt;&lt; &gt;&gt;</td>\n<td style=\"text-align:left\">从左到右</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">关系</td>\n<td style=\"text-align:left\">&lt; &lt;= &gt; &gt;=</td>\n<td style=\"text-align:left\">从左到右</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">相等</td>\n<td style=\"text-align:left\">== !=</td>\n<td style=\"text-align:left\">从左到右</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">位与 AND</td>\n<td style=\"text-align:left\">&amp;</td>\n<td style=\"text-align:left\">从左到右</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">位异或 XOR</td>\n<td style=\"text-align:left\">^</td>\n<td style=\"text-align:left\">从左到右</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">位或 OR</td>\n<td style=\"text-align:left\">|</td>\n<td style=\"text-align:left\">从左到右</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">逻辑与 AND</td>\n<td style=\"text-align:left\">&amp;&amp;</td>\n<td style=\"text-align:left\">从左到右</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">逻辑或 OR</td>\n<td style=\"text-align:left\">||</td>\n<td style=\"text-align:left\">从左到右</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">条件</td>\n<td style=\"text-align:left\">?:</td>\n<td style=\"text-align:left\">从右到左</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">赋值</td>\n<td style=\"text-align:left\">= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |=</td>\n<td style=\"text-align:left\">从右到左</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">逗号</td>\n<td style=\"text-align:left\">,</td>\n<td style=\"text-align:left\">从左到右</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"实例-17\"><a class=\"markdownIt-Anchor\" href=\"#实例-17\">#</a> 实例</h3>\n<p>请看下面的实例，了解 C++ 中运算符的优先级。</p>\n<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>\n<p>对比有括号和没有括号时的区别，这将产生不同的结果。因为 ()、 /、 * 和 + 有不同的优先级，高优先级的操作符将优先计算。</p>\n<h2 id=\"实例-18\"><a class=\"markdownIt-Anchor\" href=\"#实例-18\">#</a> 实例</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">20</span>;   <span class=\"type\">int</span> b = <span class=\"number\">10</span>;   <span class=\"type\">int</span> c = <span class=\"number\">15</span>;   <span class=\"type\">int</span> d = <span class=\"number\">5</span>;   <span class=\"type\">int</span> e; </span><br><span class=\"line\">   e = (a + b) * c / d;      <span class=\"comment\">// ( 30 * 15 ) / 5</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;(a + b) * c / d 的值是 &quot;</span> &lt;&lt; e &lt;&lt; endl ; </span><br><span class=\"line\">   e = ((a + b) * c) / d;    <span class=\"comment\">// (30 * 15 ) / 5</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;((a + b) * c) / d 的值是 &quot;</span> &lt;&lt; e &lt;&lt; endl ; </span><br><span class=\"line\">   e = (a + b) * (c / d);   <span class=\"comment\">// (30) * (15/5)</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;(a + b) * (c / d) 的值是 &quot;</span> &lt;&lt; e &lt;&lt; endl ; </span><br><span class=\"line\">   e = a + (b * c) / d;     <span class=\"comment\">//  20 + (150/5)</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;a + (b * c) / d 的值是 &quot;</span> &lt;&lt; e &lt;&lt; endl ;  </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(a + b) * c / d 的值是 <span class=\"number\">90</span>((a + b) * c) / d 的值是 <span class=\"number\">90</span>(a + b) * (c / d) 的值是 <span class=\"number\">90</span>a + (b * c) / d 的值是 <span class=\"number\">50</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"c-循环\"><a class=\"markdownIt-Anchor\" href=\"#c-循环\">#</a> C++ 循环</h1>\n<p>有的时候，可能需要多次执行同一块代码。一般情况下，语句是顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。</p>\n<p>编程语言提供了允许更为复杂的执行路径的多种控制结构。</p>\n<p>循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的一般形式：</p>\n<p><img data-src=\"https://edu.aliyun.com/files/course/2017/09-24/16103394c44b631388.png\" alt=\"img\"></p>\n<h2 id=\"循环类型\"><a class=\"markdownIt-Anchor\" href=\"#循环类型\">#</a> 循环类型</h2>\n<p>C++ 编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">循环类型</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">while 循环</td>\n<td style=\"text-align:left\">当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">for 循环</td>\n<td style=\"text-align:left\">多次执行一个语句序列，简化管理循环变量的代码。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">do…while 循环</td>\n<td style=\"text-align:left\">除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">嵌套循环</td>\n<td style=\"text-align:left\">您可以在 while、for 或 do…while 循环内使用一个或多个循环。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"循环控制语句\"><a class=\"markdownIt-Anchor\" href=\"#循环控制语句\">#</a> 循环控制语句</h2>\n<p>循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。</p>\n<p>C++ 提供了下列的控制语句。点击链接查看每个语句的细节。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">控制语句</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">break 语句</td>\n<td style=\"text-align:left\">终止 <strong>loop</strong> 或 <strong>switch</strong> 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">continue 语句</td>\n<td style=\"text-align:left\">引起循环跳过主体的剩余部分，立即重新开始测试条件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">goto 语句</td>\n<td style=\"text-align:left\">将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"无限循环\"><a class=\"markdownIt-Anchor\" href=\"#无限循环\">#</a> 无限循环</h2>\n<p>如果条件永远不为假，则循环将变成无限循环。<strong>for</strong> 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span>( ; ; )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;This loop will run forever.\\n&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，C++ 程序员偏向于使用 for (;😉 结构来表示一个无限循环。</p>\n<p>** 注意：** 您可以按 Ctrl + C 键终止一个无限循环。</p>\n<h1 id=\"c-判断\"><a class=\"markdownIt-Anchor\" href=\"#c-判断\">#</a> C++ 判断</h1>\n<p>判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。</p>\n<p>下面是大多数编程语言中典型的判断结构的一般形式：</p>\n<p><img data-src=\"https://edu.aliyun.com/files/course/2017/09-24/161155bc605b784844.png\" alt=\"img\"></p>\n<h2 id=\"判断语句\"><a class=\"markdownIt-Anchor\" href=\"#判断语句\">#</a> 判断语句</h2>\n<p>C++ 编程语言提供了以下类型的判断语句。点击链接查看每个语句的细节。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">语句</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">if 语句</td>\n<td style=\"text-align:left\">一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">if…else 语句</td>\n<td style=\"text-align:left\">一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为假时执行。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">嵌套 if 语句</td>\n<td style=\"text-align:left\">您可以在一个 <strong>if</strong> 或 <strong>else if</strong> 语句内使用另一个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">switch 语句</td>\n<td style=\"text-align:left\">一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">嵌套 switch 语句</td>\n<td style=\"text-align:left\">您可以在一个 <strong>switch</strong> 语句内使用另一个 <strong>switch</strong> 语句。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"运算符\"><a class=\"markdownIt-Anchor\" href=\"#运算符\">#</a> ? : 运算符</h2>\n<p>我们已经在前面的章节中讲解了 <a href=\"https://edu.aliyun.com/cplusplus/cpp-conditional-operator.html\"><strong>条件运算符？:</strong></a>，可以用来替代 <strong>if…else</strong> 语句。它的一般形式如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exp1 ? Exp2 : Exp3;</span><br></pre></td></tr></table></figure>\n<p>其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。</p>\n<p>? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个？表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个？表达式的值。</p>\n<h1 id=\"c-函数\"><a class=\"markdownIt-Anchor\" href=\"#c-函数\">#</a> C++ 函数</h1>\n<p>函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 <strong>main()</strong> ，所有简单的程序都可以定义其他额外的函数。</p>\n<p>您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</p>\n<p>函数<strong>声明</strong>告诉编译器函数的名称、返回类型和参数。函数<strong>定义</strong>提供了函数的实际主体。</p>\n<p>C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 <strong>strcat()</strong> 用来连接两个字符串，函数 <strong>memcpy()</strong> 用来复制内存到另一个位置。</p>\n<p>函数还有很多叫法，比如方法、子例程或程序，等等。</p>\n<h2 id=\"定义函数\"><a class=\"markdownIt-Anchor\" href=\"#定义函数\">#</a> 定义函数</h2>\n<p>C++ 中的函数定义的一般形式如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">return_type <span class=\"title\">function_name</span><span class=\"params\">( parameter list )</span></span>&#123;   body of the function&#125;</span><br></pre></td></tr></table></figure>\n<p>在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：</p>\n<ul>\n<li>** 返回类型：** 一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li>\n<li>** 函数名称：** 这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li>\n<li>** 参数：** 参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li>\n<li>** 函数主体：** 函数主体包含一组定义函数执行任务的语句。</li>\n</ul>\n<h2 id=\"实例-19\"><a class=\"markdownIt-Anchor\" href=\"#实例-19\">#</a> 实例</h2>\n<p>以下是 <strong>max()</strong> 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数返回两个数中较大的那个数 int max(int num1, int num2) &#123;   // 局部变量声明   int result;    if (num1 &gt; num2)      result = num1;   else      result = num2;    return result; &#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"函数声明\"><a class=\"markdownIt-Anchor\" href=\"#函数声明\">#</a> 函数声明</h2>\n<p>函数<strong>声明</strong>会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>\n<p>函数声明包括以下几个部分：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">return_type <span class=\"title\">function_name</span><span class=\"params\">( parameter list )</span></span>;</span><br></pre></td></tr></table></figure>\n<p>针对上面定义的函数 max ()，以下是函数声明：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"type\">int</span> num1, <span class=\"type\">int</span> num2)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"type\">int</span>, <span class=\"type\">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。</p>\n<h2 id=\"调用函数\"><a class=\"markdownIt-Anchor\" href=\"#调用函数\">#</a> 调用函数</h2>\n<p>创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。</p>\n<p>当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。</p>\n<p>调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"comment\">// 函数声明int max(int num1, int num2);</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span> b = <span class=\"number\">200</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span> ret;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 调用函数来获取最大值</span></span><br><span class=\"line\">   ret = <span class=\"built_in\">max</span>(a, b);</span><br><span class=\"line\"> </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Max value is : &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br><span class=\"line\"> <span class=\"comment\">// 函数返回两个数中较大的那个数int max(int num1, int num2) &#123;</span></span><br><span class=\"line\">   <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">   <span class=\"type\">int</span> result;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">if</span> (num1 &gt; num2)</span><br><span class=\"line\">      result = num1;</span><br><span class=\"line\">   <span class=\"keyword\">else</span></span><br><span class=\"line\">      result = num2;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> result; &#125;</span><br></pre></td></tr></table></figure>\n<p>把 max () 函数和 main () 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Max value is : <span class=\"number\">200</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"函数参数\"><a class=\"markdownIt-Anchor\" href=\"#函数参数\">#</a> 函数参数</h2>\n<p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p>\n<p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p>\n<p>当调用函数时，有两种向函数传递参数的方式：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">调用类型</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lZHUuYWxpeXVuLmNvbS9jcGx1c3BsdXMvY3BwLWZ1bmN0aW9uLWNhbGwtYnktdmFsdWUuaHRtbA==\">传值调用</span></td>\n<td style=\"text-align:left\">该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lZHUuYWxpeXVuLmNvbS9jcGx1c3BsdXMvY3BwLWZ1bmN0aW9uLWNhbGwtYnktcG9pbnRlci5odG1s\">指针调用</span></td>\n<td style=\"text-align:left\">该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lZHUuYWxpeXVuLmNvbS9jcGx1c3BsdXMvY3BwLWZ1bmN0aW9uLWNhbGwtYnktcmVmZXJlbmNlLmh0bWw=\">引用调用</span></td>\n<td style=\"text-align:left\">该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>\n</tr>\n</tbody>\n</table>\n<p>默认情况下，C++ 使用<strong>传值调用</strong>来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前提到的实例，调用 max () 函数时，使用了相同的方法。</p>\n<h2 id=\"参数的默认值\"><a class=\"markdownIt-Anchor\" href=\"#参数的默认值\">#</a> 参数的默认值</h2>\n<p>当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。</p>\n<p>这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b=<span class=\"number\">20</span>)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">  result = a + b;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> (result);&#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span> b = <span class=\"number\">200</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span> result;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 调用函数来添加值</span></span><br><span class=\"line\">   result = <span class=\"built_in\">sum</span>(a, b);</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total value is :&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 再次调用函数</span></span><br><span class=\"line\">   result = <span class=\"built_in\">sum</span>(a);</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total value is :&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Total value is :<span class=\"number\">300</span>Total value is :<span class=\"number\">120</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"lambda-函数与表达式\"><a class=\"markdownIt-Anchor\" href=\"#lambda-函数与表达式\">#</a> Lambda 函数与表达式</h2>\n<p>C++11 提供了对匿名函数的支持，称为 Lambda 函数 (也叫 Lambda 表达式)。</p>\n<p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p>\n<p>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[capture](parameters)-&gt;<span class=\"keyword\">return</span>-type&#123;body&#125;</span><br></pre></td></tr></table></figure>\n<p>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">[](int x, int y)&#123; return x &lt; y ; &#125;</span><br></pre></td></tr></table></figure>\n<p>如果没有参数可以表示为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[capture](parameters)&#123;body&#125;</span><br></pre></td></tr></table></figure>\n<p>例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[]&#123; ++global_x; &#125;</span><br></pre></td></tr></table></figure>\n<p>在一个更为复杂的例子中，返回类型可以被明确的指定如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[](<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) -&gt; <span class=\"type\">int</span> &#123; <span class=\"type\">int</span> z = x + y; <span class=\"keyword\">return</span> z + x; &#125;</span><br></pre></td></tr></table></figure>\n<p>本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。</p>\n<p>如果 lambda 函数没有传回值（例如 void），其回返类型可被完全忽略。</p>\n<p>在 Lambda 表达式内可以访问当前作用域的变量，这是 Lambda 表达式的闭包（Closure）行为。 与 JavaScript 闭包不同，C++ 变量传递有传值和传引用的区别。可以通过前面的 [] 来指定：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[]      <span class=\"comment\">// 沒有定义任何变量。使用未定义变量会引发错误。[x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。[&amp;]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。[&amp;, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。[=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span></span><br></pre></td></tr></table></figure>\n<p>另外有一点需要注意。对于 [=] 或 [&amp;] 的形式，lambda 表达式可以直接使用 this 指针。但是，对于 [] 的形式，如果要使用 this 指针，必须显式传入：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">this</span>]() &#123; <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">someFunc</span>(); &#125;();</span><br></pre></td></tr></table></figure>\n<h1 id=\"c-数字\"><a class=\"markdownIt-Anchor\" href=\"#c-数字\">#</a> C++ 数字</h1>\n<p>通常，当我们需要用到数字时，我们会使用原始的数据类型，如 int、short、long、float 和 double 等等。这些用于数字的数据类型，其可能的值和数值范围，我们已经在 C++ 数据类型一章中讨论过。</p>\n<h2 id=\"c-定义数字\"><a class=\"markdownIt-Anchor\" href=\"#c-定义数字\">#</a> C++ 定义数字</h2>\n<p>我们已经在之前章节的各种实例中定义过数字。下面是一个 C++ 中定义各种类型数字的综合实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 数字定义</span></span><br><span class=\"line\">   <span class=\"type\">short</span>  s;</span><br><span class=\"line\">   <span class=\"type\">int</span>    i;</span><br><span class=\"line\">   <span class=\"type\">long</span>   l;</span><br><span class=\"line\">   <span class=\"type\">float</span>  f;</span><br><span class=\"line\">   <span class=\"type\">double</span> d;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 数字赋值</span></span><br><span class=\"line\">   s = <span class=\"number\">10</span>;      </span><br><span class=\"line\">   i = <span class=\"number\">1000</span>;    </span><br><span class=\"line\">   l = <span class=\"number\">1000000</span>; </span><br><span class=\"line\">   f = <span class=\"number\">230.47</span>;  </span><br><span class=\"line\">   d = <span class=\"number\">30949.374</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 数字输出</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;short  s :&quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;int    i :&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;long   l :&quot;</span> &lt;&lt; l &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;float  f :&quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;double d :&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">short</span>  s :<span class=\"number\">10</span><span class=\"type\">int</span>    i :<span class=\"number\">1000l</span>ong   l :<span class=\"number\">1000000f</span>loat  f :<span class=\"number\">230.47</span><span class=\"type\">double</span> d :<span class=\"number\">30949.4</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"c-数学运算\"><a class=\"markdownIt-Anchor\" href=\"#c-数学运算\">#</a> C++ 数学运算</h2>\n<p>在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做<strong>内置</strong>函数。您可以在程序中引用这些函数。</p>\n<p>C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。</p>\n<p>为了利用这些函数，您需要引用数学头文件 <strong><cmath></strong>。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序号</th>\n<th style=\"text-align:left\">函数 &amp; 描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\"><strong>double cos(double);</strong> 该函数返回弧度角（double 型）的余弦。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\"><strong>double sin(double);</strong> 该函数返回弧度角（double 型）的正弦。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\"><strong>double tan(double);</strong> 该函数返回弧度角（double 型）的正切。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\"><strong>double log(double);</strong> 该函数返回参数的自然对数。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\"><strong>double pow(double, double);</strong> 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\"><strong>double hypot(double, double);</strong> 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\"><strong>double sqrt(double);</strong> 该函数返回参数的平方根。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\"><strong>int abs(int);</strong> 该函数返回整数的绝对值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">9</td>\n<td style=\"text-align:left\"><strong>double fabs(double);</strong> 该函数返回任意一个十进制数的绝对值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">10</td>\n<td style=\"text-align:left\"><strong>double floor(double);</strong> 该函数返回一个小于或等于传入参数的最大整数。</td>\n</tr>\n</tbody>\n</table>\n<p>下面是一个关于数学运算的简单实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 数字定义</span></span><br><span class=\"line\">   <span class=\"type\">short</span>  s = <span class=\"number\">10</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span>    i = <span class=\"number\">-1000</span>;</span><br><span class=\"line\">   <span class=\"type\">long</span>   l = <span class=\"number\">100000</span>;</span><br><span class=\"line\">   <span class=\"type\">float</span>  f = <span class=\"number\">230.47</span>;</span><br><span class=\"line\">   <span class=\"type\">double</span> d = <span class=\"number\">200.374</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 数学运算</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;sin(d) :&quot;</span> &lt;&lt; <span class=\"built_in\">sin</span>(d) &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;abs(i)  :&quot;</span> &lt;&lt; <span class=\"built_in\">abs</span>(i) &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;floor(d) :&quot;</span> &lt;&lt; <span class=\"built_in\">floor</span>(d) &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;sqrt(f) :&quot;</span> &lt;&lt; <span class=\"built_in\">sqrt</span>(f) &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;pow( d, 2) :&quot;</span> &lt;&lt; <span class=\"built_in\">pow</span>(d, <span class=\"number\">2</span>) &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sign</span>(d) :<span class=\"number\">-0.634939</span>abs(i)  :<span class=\"number\">1000f</span>loor(d) :<span class=\"number\">200</span>sqrt(f) :<span class=\"number\">15.1812</span>pow( d, <span class=\"number\">2</span> ) :<span class=\"number\">40149.7</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"c-随机数\"><a class=\"markdownIt-Anchor\" href=\"#c-随机数\">#</a> C++ 随机数</h2>\n<p>在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 <strong>rand()</strong>，该函数只返回一个伪随机数。生成随机数之前必须先调用 <strong>srand()</strong> 函数。</p>\n<p>下面是一个关于生成随机数的简单实例。实例中使用了 <strong>time()</strong> 函数来获取系统时间的秒数，通过调用 rand () 函数来生成随机数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ctime&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> i,j;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 设置种子</span></span><br><span class=\"line\">   <span class=\"built_in\">srand</span>( (<span class=\"type\">unsigned</span>)<span class=\"built_in\">time</span>( <span class=\"literal\">NULL</span> ) );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/* 生成 10 个随机数 */</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>( i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 生成实际的随机数</span></span><br><span class=\"line\">      j= <span class=\"built_in\">rand</span>();</span><br><span class=\"line\">      cout &lt;&lt;<span class=\"string\">&quot;随机数： &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">随机数： <span class=\"number\">1748144778</span>随机数： <span class=\"number\">630873888</span>随机数： <span class=\"number\">2134540646</span>随机数： <span class=\"number\">219404170</span>随机数： <span class=\"number\">902129458</span>随机数： <span class=\"number\">920445370</span>随机数： <span class=\"number\">1319072661</span>随机数： <span class=\"number\">257938873</span>随机数： <span class=\"number\">1256201101</span>随机数： <span class=\"number\">580322989</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"c-数组\"><a class=\"markdownIt-Anchor\" href=\"#c-数组\">#</a> C++ 数组</h1>\n<p>C++ 支持<strong>数组</strong>数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。</p>\n<p>数组的声明并不是声明一个个单独的变量，比如 number0、number1、…、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers [0]、numbers [1]、…、numbers [99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。</p>\n<p>所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。</p>\n<h2 id=\"声明数组\"><a class=\"markdownIt-Anchor\" href=\"#声明数组\">#</a> 声明数组</h2>\n<p>在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type arrayName [ arraySize ];</span><br></pre></td></tr></table></figure>\n<p>这叫做一维数组。<strong>arraySize</strong> 必须是一个大于零的整数常量，<strong>type</strong> 可以是任意有效的 C++ 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 <strong>balance</strong>，声明语句如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> balance[<span class=\"number\">10</span>];</span><br></pre></td></tr></table></figure>\n<p>现在 <em>balance</em> 是一个可用的数组，可以容纳 10 个类型为 double 的数字。</p>\n<h2 id=\"初始化数组\"><a class=\"markdownIt-Anchor\" href=\"#初始化数组\">#</a> 初始化数组</h2>\n<p>在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> balance[<span class=\"number\">5</span>] = &#123;<span class=\"number\">1000.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.4</span>, <span class=\"number\">17.0</span>, <span class=\"number\">50.0</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p>大括号 {} 之间的值的数目不能大于我们在数组声明时在方括号 [] 中指定的元素数目。</p>\n<p>如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> balance[] = &#123;<span class=\"number\">1000.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.4</span>, <span class=\"number\">17.0</span>, <span class=\"number\">50.0</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p>您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">balance[<span class=\"number\">4</span>] = <span class=\"number\">50.0</span>;</span><br></pre></td></tr></table></figure>\n<p>上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示：</p>\n<p><img data-src=\"https://edu.aliyun.com/ueditor/php/upload/image/20170504/1493862028514037.jpg\" alt=\"数组表示\"></p>\n<h2 id=\"访问数组元素\"><a class=\"markdownIt-Anchor\" href=\"#访问数组元素\">#</a> 访问数组元素</h2>\n<p>数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> salary = balance[<span class=\"number\">9</span>];</span><br></pre></td></tr></table></figure>\n<p>上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iomanip&gt;</span>using std::setw;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> n[ <span class=\"number\">10</span> ]; <span class=\"comment\">// n 是一个包含 10 个整数的数组</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 初始化数组元素          </span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> ( <span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      n[ i ] = i + <span class=\"number\">100</span>; <span class=\"comment\">// 设置元素 i 为 i + 100</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Element&quot;</span> &lt;&lt; <span class=\"built_in\">setw</span>( <span class=\"number\">13</span> ) &lt;&lt; <span class=\"string\">&quot;Value&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 输出数组中每个元素的值                     </span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> ( <span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++ )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"built_in\">setw</span>( <span class=\"number\">7</span> )&lt;&lt; j &lt;&lt; <span class=\"built_in\">setw</span>( <span class=\"number\">13</span> ) &lt;&lt; n[ j ] &lt;&lt; endl;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的程序使用了 <strong>setw()</strong> 函数来格式化输出。当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element        Value</span><br><span class=\"line\">      <span class=\"number\">0</span>          <span class=\"number\">100</span></span><br><span class=\"line\">      <span class=\"number\">1</span>          <span class=\"number\">101</span></span><br><span class=\"line\">      <span class=\"number\">2</span>          <span class=\"number\">102</span></span><br><span class=\"line\">      <span class=\"number\">3</span>          <span class=\"number\">103</span></span><br><span class=\"line\">      <span class=\"number\">4</span>          <span class=\"number\">104</span></span><br><span class=\"line\">      <span class=\"number\">5</span>          <span class=\"number\">105</span></span><br><span class=\"line\">      <span class=\"number\">6</span>          <span class=\"number\">106</span></span><br><span class=\"line\">      <span class=\"number\">7</span>          <span class=\"number\">107</span></span><br><span class=\"line\">      <span class=\"number\">8</span>          <span class=\"number\">108</span></span><br><span class=\"line\">      <span class=\"number\">9</span>          <span class=\"number\">109</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"c-中数组详解\"><a class=\"markdownIt-Anchor\" href=\"#c-中数组详解\">#</a> C++ 中数组详解</h2>\n<p>在 C++ 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C++ 程序员必须清楚的一些与数组相关的重要概念：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">概念</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">多维数组</td>\n<td style=\"text-align:left\">C++ 支持多维数组。多维数组最简单的形式是二维数组。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">指向数组的指针</td>\n<td style=\"text-align:left\">您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">传递数组给函数</td>\n<td style=\"text-align:left\">您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">从函数返回数组</td>\n<td style=\"text-align:left\">C++ 允许从函数返回数组。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"c-字符串\"><a class=\"markdownIt-Anchor\" href=\"#c-字符串\">#</a> C++ 字符串</h1>\n<p>C++ 提供了以下两种类型的字符串表示形式：</p>\n<ul>\n<li>C 风格字符串</li>\n<li>C++ 引入的 string 类类型</li>\n</ul>\n<h2 id=\"c-风格字符串\"><a class=\"markdownIt-Anchor\" href=\"#c-风格字符串\">#</a> C 风格字符串</h2>\n<p>C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 <strong>null</strong> 字符 ‘\\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p>\n<p>下面的声明和初始化创建了一个 “Hello” 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 “Hello” 的字符数多一个。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> greeting[<span class=\"number\">6</span>] = &#123;<span class=\"string\">&#x27;H&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>, <span class=\"string\">&#x27;\\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p>依据数组初始化规则，您可以把上面的语句写成以下语句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> greeting[] = <span class=\"string\">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>以下是 C/C++ 中定义的字符串的内存表示：</p>\n<p><img data-src=\"https://edu.aliyun.com/files/course/2017/09-24/1618593bac57374932.jpg\" alt=\"img\"></p>\n<p>其实，您不需要把 <em>null</em> 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 ‘\\0’ 放在字符串的末尾。让我们尝试输出上面的字符串：</p>\n<h2 id=\"实例-20\"><a class=\"markdownIt-Anchor\" href=\"#实例-20\">#</a> 实例</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span> greeting[<span class=\"number\">6</span>] = &#123;<span class=\"string\">&#x27;H&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>, <span class=\"string\">&#x27;\\0&#x27;</span>&#125;; </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Greeting message: &quot;</span>;   cout &lt;&lt; greeting &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Greeting message: Hello</span><br></pre></td></tr></table></figure>\n<p>C++ 中有大量的函数用来操作以 null 结尾的字符串：supports a wide range of functions that manipulate null-terminated strings:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序号</th>\n<th style=\"text-align:left\">函数 &amp; 目的</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>\n</tr>\n</tbody>\n</table>\n<p>下面的实例使用了上述的一些函数：</p>\n<h2 id=\"实例-21\"><a class=\"markdownIt-Anchor\" href=\"#实例-21\">#</a> 实例</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span> str1[<span class=\"number\">11</span>] = <span class=\"string\">&quot;Hello&quot;</span>;   <span class=\"type\">char</span> str2[<span class=\"number\">11</span>] = <span class=\"string\">&quot;World&quot;</span>;   <span class=\"type\">char</span> str3[<span class=\"number\">11</span>];   <span class=\"type\">int</span>  len ; </span><br><span class=\"line\">   <span class=\"comment\">// 复制 str1 到 str3</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( str3, str1);   cout &lt;&lt; <span class=\"string\">&quot;strcpy( str3, str1) : &quot;</span> &lt;&lt; str3 &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"comment\">// 连接 str1 和 str2</span></span><br><span class=\"line\">   <span class=\"built_in\">strcat</span>( str1, str2);   cout &lt;&lt; <span class=\"string\">&quot;strcat( str1, str2): &quot;</span> &lt;&lt; str1 &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"comment\">// 连接后，str1 的总长度</span></span><br><span class=\"line\">   len = <span class=\"built_in\">strlen</span>(str1);   cout &lt;&lt; <span class=\"string\">&quot;strlen(str1) : &quot;</span> &lt;&lt; len &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">strcpy</span>( str3, str1) : <span class=\"built_in\">Hellostrcat</span>( str1, str2): <span class=\"built_in\">HelloWorldstrlen</span>(str1) : <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"c-中的-string-类\"><a class=\"markdownIt-Anchor\" href=\"#c-中的-string-类\">#</a> C++ 中的 String 类</h2>\n<p>C++ 标准库提供了 <strong>string</strong> 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：</p>\n<p>现在您可能还无法透彻地理解这个实例，因为到目前为止我们还没有讨论类和对象。所以现在您可以只是粗略地看下这个实例，等理解了面向对象的概念之后再回头来理解这个实例。</p>\n<h2 id=\"实例-22\"><a class=\"markdownIt-Anchor\" href=\"#实例-22\">#</a> 实例</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   string str1 = <span class=\"string\">&quot;Hello&quot;</span>;   string str2 = <span class=\"string\">&quot;World&quot;</span>;   string str3;   <span class=\"type\">int</span>  len ; </span><br><span class=\"line\">   <span class=\"comment\">// 复制 str1 到 str3</span></span><br><span class=\"line\">   str3 = str1;   cout &lt;&lt; <span class=\"string\">&quot;str3 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"comment\">// 连接 str1 和 str2</span></span><br><span class=\"line\">   str3 = str1 + str2;   cout &lt;&lt; <span class=\"string\">&quot;str1 + str2 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"comment\">// 连接后，str3 的总长度</span></span><br><span class=\"line\">   len = str3.<span class=\"built_in\">size</span>();   cout &lt;&lt; <span class=\"string\">&quot;str3.size() :  &quot;</span> &lt;&lt; len &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str3 : Hellostr1 + str2 : HelloWorldstr3.<span class=\"built_in\">size</span>() :  <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"c-指针\"><a class=\"markdownIt-Anchor\" href=\"#c-指针\">#</a> C++ 指针</h1>\n<p>学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。</p>\n<p>正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main ()&#123;</span></span><br><span class=\"line\">   <span class=\"type\">int</span>  var1;</span><br><span class=\"line\">   <span class=\"type\">char</span> var2[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;var1 变量的地址： &quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; &amp;var1 &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;var2 变量的地址： &quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; &amp;var2 &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var1 变量的地址： <span class=\"number\">0xbfebd5c0</span>var2 变量的地址： <span class=\"number\">0xbfebd5b6</span></span><br></pre></td></tr></table></figure>\n<p>通过上面的实例，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针。</p>\n<h2 id=\"什么是指针\"><a class=\"markdownIt-Anchor\" href=\"#什么是指针\">#</a> 什么是指针？</h2>\n<p><strong>指针</strong>是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type *var-name;</span><br></pre></td></tr></table></figure>\n<p>在这里，<strong>type</strong> 是指针的基类型，它必须是一个有效的 C++ 数据类型，<strong>var-name</strong> 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>    *ip;    <span class=\"comment\">/* 一个整型的指针 */</span><span class=\"type\">double</span> *dp;    <span class=\"comment\">/* 一个 double 型的指针 */</span><span class=\"type\">float</span>  *fp;    <span class=\"comment\">/* 一个浮点型的指针 */</span><span class=\"type\">char</span>   *ch;    <span class=\"comment\">/* 一个字符型的指针 */</span></span><br></pre></td></tr></table></figure>\n<p>所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</p>\n<h2 id=\"c-中使用指针\"><a class=\"markdownIt-Anchor\" href=\"#c-中使用指针\">#</a> C++ 中使用指针</h2>\n<p>使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main ()&#123;</span></span><br><span class=\"line\">   <span class=\"type\">int</span>  var = <span class=\"number\">20</span>;   <span class=\"comment\">// 实际变量的声明</span></span><br><span class=\"line\">   <span class=\"type\">int</span>  *ip;        <span class=\"comment\">// 指针变量的声明</span></span><br><span class=\"line\"></span><br><span class=\"line\">   ip = &amp;var;       <span class=\"comment\">// 在指针变量中存储 var 的地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of var variable: &quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; var &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出在指针变量中存储的地址</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Address stored in ip variable: &quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; ip &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 访问指针中地址的值</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of *ip variable: &quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; *ip &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of var variable: <span class=\"number\">20</span>Address stored in ip variable: <span class=\"number\">0xbfc601ac</span>Value of *ip variable: <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"c-指针详解\"><a class=\"markdownIt-Anchor\" href=\"#c-指针详解\">#</a> C++ 指针详解</h2>\n<p>在 C++ 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C++ 程序员必须清楚的一些与指针相关的重要概念：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">概念</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">C++ Null 指针</td>\n<td style=\"text-align:left\">C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">C++ 指针的算术运算</td>\n<td style=\"text-align:left\">可以对指针进行四种算术运算：++、–、+、-</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">C++ 指针 vs 数组</td>\n<td style=\"text-align:left\">指针和数组之间有着密切的关系。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">C++ 指针数组</td>\n<td style=\"text-align:left\">可以定义用来存储指针的数组。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">C++ 指向指针的指针</td>\n<td style=\"text-align:left\">C++ 允许指向指针的指针。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">C++ 传递指针给函数</td>\n<td style=\"text-align:left\">通过引用或地址传递参数，使传递的参数在调用函数中被改变。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">C++ 从函数返回指针</td>\n<td style=\"text-align:left\">C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"c-引用\"><a class=\"markdownIt-Anchor\" href=\"#c-引用\">#</a> C++ 引用</h1>\n<p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p>\n<h2 id=\"c-引用-vs-指针\"><a class=\"markdownIt-Anchor\" href=\"#c-引用-vs-指针\">#</a> C++ 引用 vs 指针</h2>\n<p>引用很容易与指针混淆，它们之间有三个主要的不同：</p>\n<ul>\n<li>不存在空引用。引用必须连接到一块合法的内存。</li>\n<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>\n<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>\n</ul>\n<h2 id=\"c-中创建引用\"><a class=\"markdownIt-Anchor\" href=\"#c-中创建引用\">#</a> C++ 中创建引用</h2>\n<p>试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">17</span>;</span><br></pre></td></tr></table></figure>\n<p>我们可以为 i 声明引用变量，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>&amp;    r = i;</span><br></pre></td></tr></table></figure>\n<p>在这些声明中，&amp; 读作<strong>引用</strong>。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 声明简单的变量</span></span><br><span class=\"line\">   <span class=\"type\">int</span>    i;</span><br><span class=\"line\">   <span class=\"type\">double</span> d;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 声明引用变量</span></span><br><span class=\"line\">   <span class=\"type\">int</span>&amp;    r = i;</span><br><span class=\"line\">   <span class=\"type\">double</span>&amp; s = d;</span><br><span class=\"line\">   </span><br><span class=\"line\">   i = <span class=\"number\">5</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of i : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of i reference : &quot;</span> &lt;&lt; r  &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   d = <span class=\"number\">11.7</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of d : &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of d reference : &quot;</span> &lt;&lt; s  &lt;&lt; endl;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of i : <span class=\"number\">5</span>Value of i reference : <span class=\"number\">5</span>Value of d : <span class=\"number\">11.7</span>Value of d reference : <span class=\"number\">11.7</span></span><br></pre></td></tr></table></figure>\n<p>引用通常用于函数参数列表和函数返回值。下面列出了 C++ 程序员必须清楚的两个与 C++ 引用相关的重要概念：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">概念</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">把引用作为参数</td>\n<td style=\"text-align:left\">C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">把引用作为返回值</td>\n<td style=\"text-align:left\">可以从 C++ 函数中返回引用，就像返回其他数据类型一样。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"c-日期-时间\"><a class=\"markdownIt-Anchor\" href=\"#c-日期-时间\">#</a> C++ 日期 &amp; 时间</h1>\n<p>C++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 <ctime> 头文件。</p>\n<p>有四个与时间相关的类型：<strong>clock_t、time_t、size_t</strong> 和 <strong>tm</strong>。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。</p>\n<p>结构类型 <strong>tm</strong> 把日期和时间以 C 结构的形式保存，tm 结构的定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tm</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> tm_sec;   <span class=\"comment\">// 秒，正常范围从 0 到 59，但允许至 61</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_min;   <span class=\"comment\">// 分，范围从 0 到 59</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_hour;  <span class=\"comment\">// 小时，范围从 0 到 23</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_mday;  <span class=\"comment\">// 一月中的第几天，范围从 1 到 31</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_mon;   <span class=\"comment\">// 月，范围从 0 到 11</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_year;  <span class=\"comment\">// 自 1900 年起的年数</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_wday;  <span class=\"comment\">// 一周中的第几天，范围从 0 到 6，从星期日算起</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_yday;  <span class=\"comment\">// 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_isdst; <span class=\"comment\">// 夏令时&#125;</span></span><br></pre></td></tr></table></figure>\n<p>下面是 C/C++ 中关于日期和时间的重要函数。所有这些函数都是 C/C++ 标准库的组成部分，您可以在 C++ 标准库中查看一下各个函数的细节。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序号</th>\n<th style=\"text-align:left\">函数 &amp; 描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\"><strong>time_t time(time_t *time);</strong> 该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 .1。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\"><strong>char *ctime(const time_t *time);</strong> 该返回一个表示当地时间的字符串指针，字符串形式 <em>day month year hours:minutes:seconds year\\n\\0</em>。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\"><strong>struct tm *localtime(const time_t *time);</strong> 该函数返回一个指向表示本地时间的 <strong>tm</strong> 结构的指针。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\"><strong>clock_t clock(void);</strong> 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 .1。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\"><strong>char * asctime ( const struct tm * time );</strong> 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\\n\\0。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\"><strong>struct tm *gmtime(const time_t *time);</strong> 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\"><strong>time_t mktime(struct tm *time);</strong> 该函数返回日历时间，相当于 time 所指向结构中存储的时间。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\"><strong>double difftime ( time_t time2, time_t time1 );</strong> 该函数返回 time1 和 time2 之间相差的秒数。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">9</td>\n<td style=\"text-align:left\"><strong>size_t strftime();</strong> 该函数可用于格式化日期和时间为指定的格式。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"当前日期和时间\"><a class=\"markdownIt-Anchor\" href=\"#当前日期和时间\">#</a> 当前日期和时间</h2>\n<p>下面的实例获取当前系统的日期和时间，包括本地时间和协调世界时（UTC）。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ctime&gt;</span>using namespace std;int main( )&#123;</span></span><br><span class=\"line\">   <span class=\"comment\">// 基于当前系统的当前日期/时间</span></span><br><span class=\"line\">   <span class=\"type\">time_t</span> now = <span class=\"built_in\">time</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 把 now 转换为字符串形式</span></span><br><span class=\"line\">   <span class=\"type\">char</span>* dt = <span class=\"built_in\">ctime</span>(&amp;now);</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;本地日期和时间：&quot;</span> &lt;&lt; dt &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 把 now 转换为 tm 结构</span></span><br><span class=\"line\">   tm *gmtm = <span class=\"built_in\">gmtime</span>(&amp;now);</span><br><span class=\"line\">   dt = <span class=\"built_in\">asctime</span>(gmtm);</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;UTC 日期和时间：&quot;</span>&lt;&lt; dt &lt;&lt; endl;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本地日期和时间：Sat Jan  <span class=\"number\">8</span> <span class=\"number\">20</span>:<span class=\"number\">07</span>:<span class=\"number\">41</span> <span class=\"number\">2011U</span>TC 日期和时间：Sun Jan  <span class=\"number\">9</span> <span class=\"number\">03</span>:<span class=\"number\">07</span>:<span class=\"number\">41</span> <span class=\"number\">2011</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"使用结构-tm-格式化时间\"><a class=\"markdownIt-Anchor\" href=\"#使用结构-tm-格式化时间\">#</a> 使用结构 tm 格式化时间</h2>\n<p><strong>tm</strong> 结构在 C/C++ 中处理日期和时间相关的操作时，显得尤为重要。tm 结构以 C 结构的形式保存日期和时间。大多数与时间相关的函数都使用了 tm 结构。下面的实例使用了 tm 结构和各种与日期和时间相关的函数。</p>\n<p>在练习使用结构之前，需要对 C 结构有基本的了解，并懂得如何使用箭头 -&gt; 运算符来访问结构成员。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ctime&gt;</span>using namespace std;int main( )&#123;</span></span><br><span class=\"line\">   <span class=\"comment\">// 基于当前系统的当前日期/时间</span></span><br><span class=\"line\">   <span class=\"type\">time_t</span> now = <span class=\"built_in\">time</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Number of sec since January 1,1970:&quot;</span> &lt;&lt; now &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   tm *ltm = <span class=\"built_in\">localtime</span>(&amp;now);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出 tm 结构的各个组成部分</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Year: &quot;</span>&lt;&lt; <span class=\"number\">1900</span> + ltm-&gt;tm_year &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Month: &quot;</span>&lt;&lt; <span class=\"number\">1</span> + ltm-&gt;tm_mon&lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Day: &quot;</span>&lt;&lt;  ltm-&gt;tm_mday &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Time: &quot;</span>&lt;&lt; <span class=\"number\">1</span> + ltm-&gt;tm_hour &lt;&lt; <span class=\"string\">&quot;:&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"number\">1</span> + ltm-&gt;tm_min &lt;&lt; <span class=\"string\">&quot;:&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"number\">1</span> + ltm-&gt;tm_sec &lt;&lt; endl;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number of sec since January <span class=\"number\">1</span>, <span class=\"number\">1970</span>:<span class=\"number\">1294548238</span>Year: <span class=\"number\">2011</span>Month: <span class=\"number\">1</span>Day: <span class=\"number\">8</span>Time: <span class=\"number\">22</span>: <span class=\"number\">44</span>:<span class=\"number\">59</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"c-基本的输入输出\"><a class=\"markdownIt-Anchor\" href=\"#c-基本的输入输出\">#</a> C++ 基本的输入输出</h1>\n<p>C++ 标准库提供了一组丰富的输入 / 输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I/O 操作。</p>\n<p>C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做<strong>输入操作</strong>。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做<strong>输出操作</strong>。</p>\n<h2 id=\"io-库头文件\"><a class=\"markdownIt-Anchor\" href=\"#io-库头文件\">#</a> I/O 库头文件</h2>\n<p>下列的头文件在 C++ 编程中很重要。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">头文件</th>\n<th style=\"text-align:left\">函数和描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><iostream></td>\n<td style=\"text-align:left\">该文件定义了 <strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><iomanip></td>\n<td style=\"text-align:left\">该文件通过所谓的参数化的流操纵器（比如 <strong>setw</strong> 和 <strong>setprecision</strong>），来声明对执行标准化 I/O 有用的服务。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><fstream></td>\n<td style=\"text-align:left\">该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"标准输出流cout\"><a class=\"markdownIt-Anchor\" href=\"#标准输出流cout\">#</a> 标准输出流（cout）</h2>\n<p>预定义的对象 <strong>cout</strong> 是 <strong>ostream</strong> 类的一个实例。cout 对象 &quot;连接&quot; 到标准输出设备，通常是显示屏。<strong>cout</strong> 是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span> using namespace std; int main( )&#123;   char str[] = <span class=\"string\">&quot;Hello C++&quot;</span>;    cout &lt;&lt; <span class=\"string\">&quot;Value of str is : &quot;</span> &lt;&lt; str &lt;&lt; endl;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of str is : Hello C++</span><br></pre></td></tr></table></figure>\n<p>C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。</p>\n<p>流插入运算符 &lt;&lt; 在一个语句中可以多次使用，如上面实例中所示，<strong>endl</strong> 用于在行末添加一个换行符。</p>\n<h2 id=\"标准输入流cin\"><a class=\"markdownIt-Anchor\" href=\"#标准输入流cin\">#</a> 标准输入流（cin）</h2>\n<p>预定义的对象 <strong>cin</strong> 是 <strong>istream</strong> 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。<strong>cin</strong> 是与流提取运算符 &gt;&gt; 结合使用的，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span> using namespace std; int main( )&#123;  </span></span><br><span class=\"line\">\t<span class=\"type\">char</span> name[<span class=\"number\">50</span>];    cout &lt;&lt; <span class=\"string\">&quot;请输入您的名称： &quot;</span>;   </span><br><span class=\"line\">\tcin &gt;&gt; name;   cout &lt;&lt; <span class=\"string\">&quot;您的名称是： &quot;</span> &lt;&lt; name &lt;&lt; endl; &#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会提示用户输入名称。当用户输入一个值，并按回车键，就会看到下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入您的名称： cplusplus您的名称是： cplusplus</span><br></pre></td></tr></table></figure>\n<p>C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。</p>\n<p>流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cin &gt;&gt; name &gt;&gt; age;</span><br></pre></td></tr></table></figure>\n<p>这相当于下面两个语句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cin &gt;&gt; name;cin &gt;&gt; age;</span><br></pre></td></tr></table></figure>\n<h2 id=\"标准错误流cerr\"><a class=\"markdownIt-Anchor\" href=\"#标准错误流cerr\">#</a> 标准错误流（cerr）</h2>\n<p>预定义的对象 <strong>cerr</strong> 是 <strong>ostream</strong> 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 <strong>cerr</strong> 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。</p>\n<p><strong>cerr</strong> 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span> str[] = <span class=\"string\">&quot;Unable to read....&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   cerr &lt;&lt; <span class=\"string\">&quot;Error message : &quot;</span> &lt;&lt; str &lt;&lt; endl;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error message : Unable to read....</span><br></pre></td></tr></table></figure>\n<h2 id=\"标准日志流clog\"><a class=\"markdownIt-Anchor\" href=\"#标准日志流clog\">#</a> 标准日志流（clog）</h2>\n<p>预定义的对象 <strong>clog</strong> 是 <strong>ostream</strong> 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 <strong>clog</strong> 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。</p>\n<p><strong>clog</strong> 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span> str[] = <span class=\"string\">&quot;Unable to read....&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   clog &lt;&lt; <span class=\"string\">&quot;Error message : &quot;</span> &lt;&lt; str &lt;&lt; endl;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error message : Unable to read....</span><br></pre></td></tr></table></figure>\n<p>通过这些小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。</p>\n<h1 id=\"c-数据结构\"><a class=\"markdownIt-Anchor\" href=\"#c-数据结构\">#</a> C++ 数据结构</h1>\n<p>C/C++ 数组允许定义可存储相同类型数据项的变量，但是<strong>结构</strong>是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>\n<p>结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：</p>\n<ul>\n<li>Title ：标题</li>\n<li>Author ：作者</li>\n<li>Subject ：类目</li>\n<li>Book ID ：书的 ID</li>\n</ul>\n<h2 id=\"定义结构\"><a class=\"markdownIt-Anchor\" href=\"#定义结构\">#</a> 定义结构</h2>\n<p>为了定义结构，您必须使用 <strong>struct</strong> 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">type_name</span> &#123;member_type1 member_name1;member_type2 member_name2;member_type3 member_name3;..&#125; object_names;</span><br></pre></td></tr></table></figure>\n<p><strong>type_name</strong> 是结构体类型的名称，<strong>member_type1 member_name1</strong> 是标准的变量定义，比如 <strong>int i;</strong> 或者 <strong>float f;</strong> 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明一个结构体类型 <strong>Books</strong>，变量为 <strong>book</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Books</span>&#123;   <span class=\"type\">char</span>  title[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  author[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  subject[<span class=\"number\">100</span>];      <span class=\"type\">int</span>   book_id;&#125; book;</span><br></pre></td></tr></table></figure>\n<h2 id=\"访问结构成员\"><a class=\"markdownIt-Anchor\" href=\"#访问结构成员\">#</a> 访问结构成员</h2>\n<p>为了访问结构的成员，我们使用<strong>成员访问运算符（.）</strong>。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。</p>\n<p>下面的实例演示了结构的用法：</p>\n<h2 id=\"实例-23\"><a class=\"markdownIt-Anchor\" href=\"#实例-23\">#</a> 实例</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"><span class=\"comment\">// 声明一个结构体类型 Books struct Books&#123;</span></span><br><span class=\"line\">   <span class=\"type\">char</span>  title[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  author[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  subject[<span class=\"number\">100</span>];   <span class=\"type\">int</span>   book_id;&#125;; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   Books Book1;        <span class=\"comment\">// 定义结构体类型 Books 的变量 Book1</span></span><br><span class=\"line\">   Books Book2;        <span class=\"comment\">// 定义结构体类型 Books 的变量 Book2</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// Book1 详述</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book1.title, <span class=\"string\">&quot;C++ 教程&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book1.author, <span class=\"string\">&quot;Runoob&quot;</span>); </span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book1.subject, <span class=\"string\">&quot;编程语言&quot;</span>);   Book1.book_id = <span class=\"number\">12345</span>; </span><br><span class=\"line\">   <span class=\"comment\">// Book2 详述</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book2.title, <span class=\"string\">&quot;CSS 教程&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book2.author, <span class=\"string\">&quot;Runoob&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book2.subject, <span class=\"string\">&quot;前端技术&quot;</span>);   Book2.book_id = <span class=\"number\">12346</span>; </span><br><span class=\"line\">   <span class=\"comment\">// 输出 Book1 信息</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;第一本书标题 : &quot;</span> &lt;&lt; Book1.title &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;第一本书作者 : &quot;</span> &lt;&lt; Book1.author &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;第一本书类目 : &quot;</span> &lt;&lt; Book1.subject &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;第一本书 ID : &quot;</span> &lt;&lt; Book1.book_id &lt;&lt;endl; </span><br><span class=\"line\">   <span class=\"comment\">// 输出 Book2 信息</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;第二本书标题 : &quot;</span> &lt;&lt; Book2.title &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;第二本书作者 : &quot;</span> &lt;&lt; Book2.author &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;第二本书类目 : &quot;</span> &lt;&lt; Book2.subject &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;第二本书 ID : &quot;</span> &lt;&lt; Book2.book_id &lt;&lt;endl; </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>实例中定义了结构体类似 Books 及其两个变量 Book1 和 Book2。当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一本书标题 : C++ 教程第一本书作者 : Runoob第一本书类目 : 编程语言第一本书 ID : <span class=\"number\">12345</span>第二本书标题 : CSS 教程第二本书作者 : Runoob第二本书类目 : 前端技术第二本书 ID : <span class=\"number\">12346</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"结构作为函数参数\"><a class=\"markdownIt-Anchor\" href=\"#结构作为函数参数\">#</a> 结构作为函数参数</h2>\n<p>您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：</p>\n<h2 id=\"实例-24\"><a class=\"markdownIt-Anchor\" href=\"#实例-24\">#</a> 实例</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printBook</span><span class=\"params\">( <span class=\"keyword\">struct</span> Books book )</span></span>; </span><br><span class=\"line\"><span class=\"comment\">// 声明一个结构体类型 Books struct Books&#123;</span></span><br><span class=\"line\">   <span class=\"type\">char</span>  title[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  author[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  subject[<span class=\"number\">100</span>];   <span class=\"type\">int</span>   book_id;&#125;; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   Books Book1;        <span class=\"comment\">// 定义结构体类型 Books 的变量 Book1</span></span><br><span class=\"line\">   Books Book2;        <span class=\"comment\">// 定义结构体类型 Books 的变量 Book2</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Book1 详述</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book1.title, <span class=\"string\">&quot;C++ 教程&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book1.author, <span class=\"string\">&quot;Runoob&quot;</span>); </span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book1.subject, <span class=\"string\">&quot;编程语言&quot;</span>);   Book1.book_id = <span class=\"number\">12345</span>; </span><br><span class=\"line\">   <span class=\"comment\">// Book2 详述</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book2.title, <span class=\"string\">&quot;CSS 教程&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book2.author, <span class=\"string\">&quot;Runoob&quot;</span>);   </span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book2.subject, <span class=\"string\">&quot;前端技术&quot;</span>);   Book2.book_id = <span class=\"number\">12346</span>; </span><br><span class=\"line\">   <span class=\"comment\">// 输出 Book1 信息</span></span><br><span class=\"line\">   <span class=\"built_in\">printBook</span>( Book1 ); </span><br><span class=\"line\">   <span class=\"comment\">// 输出 Book2 信息</span></span><br><span class=\"line\">   <span class=\"built_in\">printBook</span>( Book2 ); </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printBook</span><span class=\"params\">( <span class=\"keyword\">struct</span> Books book )</span></span>&#123;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;书标题 : &quot;</span> &lt;&lt; book.title &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;书作者 : &quot;</span> </span><br><span class=\"line\">   &lt;&lt; book.author &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;书类目 : &quot;</span> &lt;&lt; book.subject &lt;&lt;endl;   </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;书 ID : &quot;</span> &lt;&lt; book.book_id &lt;&lt;endl;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">书标题 : C++ 教程书作者 : Runoob书类目 : 编程语言书 ID : <span class=\"number\">12345</span>书标题 : CSS 教程书作者 : Runoob书类目 : 前端技术书 ID : <span class=\"number\">12346</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"指向结构的指针\"><a class=\"markdownIt-Anchor\" href=\"#指向结构的指针\">#</a> 指向结构的指针</h2>\n<p>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Books</span> *struct_pointer;</span><br></pre></td></tr></table></figure>\n<p>现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct_pointer = &amp;Book1;</span><br></pre></td></tr></table></figure>\n<p>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct_pointer-&gt;title;</span><br></pre></td></tr></table></figure>\n<p>让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念：</p>\n<h2 id=\"实例-25\"><a class=\"markdownIt-Anchor\" href=\"#实例-25\">#</a> 实例</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printBook</span><span class=\"params\">( <span class=\"keyword\">struct</span> Books *book )</span></span>; </span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Books</span>&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span>  title[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  author[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  subject[<span class=\"number\">100</span>];   <span class=\"type\">int</span>   book_id;&#125;; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   Books Book1;        <span class=\"comment\">// 定义结构体类型 Books 的变量 Book1</span></span><br><span class=\"line\">   Books Book2;        <span class=\"comment\">// 定义结构体类型 Books 的变量 Book2</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Book1 详述</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book1.title, <span class=\"string\">&quot;C++ 教程&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book1.author, <span class=\"string\">&quot;Runoob&quot;</span>); </span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book1.subject, <span class=\"string\">&quot;编程语言&quot;</span>);   Book1.book_id = <span class=\"number\">12345</span>; </span><br><span class=\"line\">   <span class=\"comment\">// Book2 详述</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book2.title, <span class=\"string\">&quot;CSS 教程&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book2.author, <span class=\"string\">&quot;Runoob&quot;</span>);   </span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book2.subject, <span class=\"string\">&quot;前端技术&quot;</span>);   Book2.book_id = <span class=\"number\">12346</span>; </span><br><span class=\"line\">   <span class=\"comment\">// 通过传 Book1 的地址来输出 Book1 信息</span></span><br><span class=\"line\">   <span class=\"built_in\">printBook</span>( &amp;Book1 ); </span><br><span class=\"line\">   <span class=\"comment\">// 通过传 Book2 的地址来输出 Book2 信息</span></span><br><span class=\"line\">   <span class=\"built_in\">printBook</span>( &amp;Book2 ); </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;<span class=\"comment\">// 该函数以结构指针作为参数void printBook( struct Books *book )&#123;</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;书标题  : &quot;</span> &lt;&lt; book-&gt;title &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;书作者 : &quot;</span> </span><br><span class=\"line\">   &lt;&lt; book-&gt;author &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;书类目 : &quot;</span> &lt;&lt; book-&gt;subject &lt;&lt;endl;   </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;书 ID : &quot;</span> &lt;&lt; book-&gt;book_id &lt;&lt;endl;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">书标题  : C++ 教程书作者 : Runoob书类目 : 编程语言书 ID : <span class=\"number\">12345</span>书标题  : CSS 教程书作者 : Runoob书类目 : 前端技术书 ID : <span class=\"number\">12346</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"typedef-关键字\"><a class=\"markdownIt-Anchor\" href=\"#typedef-关键字\">#</a> typedef 关键字</h2>\n<p>下面是一种更简单的定义结构的方式，您可以为创建的类型取一个 &quot;别名&quot;。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span>  title[<span class=\"number\">50</span>];</span><br><span class=\"line\">   <span class=\"type\">char</span>  author[<span class=\"number\">50</span>];</span><br><span class=\"line\">   <span class=\"type\">char</span>  subject[<span class=\"number\">100</span>];</span><br><span class=\"line\">   <span class=\"type\">int</span>   book_id;&#125;Books;</span><br></pre></td></tr></table></figure>\n<p>现在，您可以直接使用 <em>Books</em> 来定义 <em>Books</em> 类型的变量，而不需要使用 struct 关键字。下面是实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Books Book1, Book2;</span><br></pre></td></tr></table></figure>\n<p>您可以使用 <strong>typedef</strong> 关键字来定义非结构类型，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">int</span> *pint32;</span><br><span class=\"line\"> pint32 x, y, z;</span><br></pre></td></tr></table></figure>\n<p>x, y 和 z 都是指向长整型 long int 的指针。</p>\n<h1 id=\"c-类-对象\"><a class=\"markdownIt-Anchor\" href=\"#c-类-对象\">#</a> C++ 类 &amp; 对象</h1>\n<p>C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。</p>\n<p>类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类被称为类的成员。</p>\n<h2 id=\"c-类定义\"><a class=\"markdownIt-Anchor\" href=\"#c-类定义\">#</a> C++ 类定义</h2>\n<p>定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。</p>\n<p>类定义是以关键字 <strong>class</strong> 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 <strong>class</strong> 定义 Box 数据类型，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span>&#123;   <span class=\"keyword\">public</span>:      <span class=\"type\">double</span> length;   <span class=\"comment\">// Length of a box      double breadth;  // Breadth of a box      double height;   // Height of a box&#125;;</span></span><br></pre></td></tr></table></figure>\n<p>关键字 <strong>public</strong> 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 <strong>private</strong> 或 <strong>protected</strong>，这个我们稍后会进行讲解。</p>\n<h2 id=\"定义-c-对象\"><a class=\"markdownIt-Anchor\" href=\"#定义-c-对象\">#</a> 定义 C++ 对象</h2>\n<p>类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Box Box1;          <span class=\"comment\">// 声明 Box1，类型为 BoxBox Box2;          // 声明 Box2，类型为 Box</span></span><br></pre></td></tr></table></figure>\n<p>对象 Box1 和 Box2 都有它们各自的数据成员。</p>\n<h2 id=\"访问数据成员\"><a class=\"markdownIt-Anchor\" href=\"#访问数据成员\">#</a> 访问数据成员</h2>\n<p>类的对象的公共数据成员可以使用直接成员访问运算符 (.) 来访问。为了更好地理解这些概念，让我们尝试一下下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;class Box&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> length;   <span class=\"comment\">// 长度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> breadth;  <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> height;   <span class=\"comment\">// 高度&#125;;int main( )&#123;</span></span><br><span class=\"line\">   Box Box1;        <span class=\"comment\">// 声明 Box1，类型为 Box</span></span><br><span class=\"line\">   Box Box2;        <span class=\"comment\">// 声明 Box2，类型为 Box</span></span><br><span class=\"line\">   <span class=\"type\">double</span> volume = <span class=\"number\">0.0</span>;     <span class=\"comment\">// 用于存储体积</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// box 1 详述</span></span><br><span class=\"line\">   Box1.height = <span class=\"number\">5.0</span>; </span><br><span class=\"line\">   Box1.length = <span class=\"number\">6.0</span>; </span><br><span class=\"line\">   Box1.breadth = <span class=\"number\">7.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// box 2 详述</span></span><br><span class=\"line\">   Box2.height = <span class=\"number\">10.0</span>;</span><br><span class=\"line\">   Box2.length = <span class=\"number\">12.0</span>;</span><br><span class=\"line\">   Box2.breadth = <span class=\"number\">13.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// box 1 的体积</span></span><br><span class=\"line\">   volume = Box1.height * Box1.length * Box1.breadth;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Box1 的体积：&quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// box 2 的体积</span></span><br><span class=\"line\">   volume = Box2.height * Box2.length * Box2.breadth;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Box2 的体积：&quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Box1 的体积：<span class=\"number\">210B</span>ox2 的体积：<span class=\"number\">1560</span></span><br></pre></td></tr></table></figure>\n<p>需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。我们将在后续的教程中学习如何访问私有成员和受保护的成员。</p>\n<h1 id=\"类-对象详解\"><a class=\"markdownIt-Anchor\" href=\"#类-对象详解\">#</a> 类 &amp; 对象详解</h1>\n<p>到目前为止，我们已经对 C++ 的类和对象有了基本的了解。下面的列表中还列出了其他一些 C++ 类和对象相关的概念，可以点击相应的链接进行学习。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">概念</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">类成员函数</td>\n<td style=\"text-align:left\">类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">类访问修饰符</td>\n<td style=\"text-align:left\">类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">构造函数 &amp; 析构函数</td>\n<td style=\"text-align:left\">类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">C++ 拷贝构造函数</td>\n<td style=\"text-align:left\">拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">C++ 友元函数</td>\n<td style=\"text-align:left\"><strong>友元函数</strong>可以访问类的 private 和 protected 成员。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">C++ 内联函数</td>\n<td style=\"text-align:left\">通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">C++ 中的 this 指针</td>\n<td style=\"text-align:left\">每个对象都有一个特殊的指针 <strong>this</strong>，它指向对象本身。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">C++ 中指向类的指针</td>\n<td style=\"text-align:left\">指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">C++ 类的静态成员</td>\n<td style=\"text-align:left\">类的数据成员和函数成员都可以被声明为静态的。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"c-继承\"><a class=\"markdownIt-Anchor\" href=\"#c-继承\">#</a> C++ 继承</h1>\n<p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。</p>\n<p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p>\n<p>继承代表了 <strong>is a</strong> 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。</p>\n<h2 id=\"基类-派生类\"><a class=\"markdownIt-Anchor\" href=\"#基类-派生类\">#</a> 基类 &amp; 派生类</h2>\n<p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">derived</span>-<span class=\"keyword\">class</span>: access-specifier base-<span class=\"keyword\">class</span></span><br></pre></td></tr></table></figure>\n<p>其中，访问修饰符 access-specifier 是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p>\n<p>假设有一个基类 <strong>Shape</strong>，<strong>Rectangle</strong> 是它的派生类，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;<span class=\"comment\">// 基类class Shape &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">(<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         width = w;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setHeight</span><span class=\"params\">(<span class=\"type\">int</span> h)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         height = h;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"type\">int</span> width;</span><br><span class=\"line\">      <span class=\"type\">int</span> height;&#125;;<span class=\"comment\">// 派生类class Rectangle: public Shape&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getArea</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123; </span><br><span class=\"line\">         <span class=\"keyword\">return</span> (width * height); </span><br><span class=\"line\">      &#125;&#125;;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;</span><br><span class=\"line\">   Rectangle Rect;</span><br><span class=\"line\"> </span><br><span class=\"line\">   Rect.<span class=\"built_in\">setWidth</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">   Rect.<span class=\"built_in\">setHeight</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出对象的面积</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class=\"built_in\">getArea</span>() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Total area: 35</span><br></pre></td></tr></table></figure>\n<h2 id=\"访问控制和继承\"><a class=\"markdownIt-Anchor\" href=\"#访问控制和继承\">#</a> 访问控制和继承</h2>\n<p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p>\n<p>我们可以根据访问权限总结出不同的访问类型，如下所示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">访问</th>\n<th style=\"text-align:left\">public</th>\n<th style=\"text-align:left\">protected</th>\n<th style=\"text-align:left\">private</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">同一个类</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">派生类</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">no</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">外部的类</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">no</td>\n<td style=\"text-align:left\">no</td>\n</tr>\n</tbody>\n</table>\n<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>\n<ul>\n<li>基类的构造函数、析构函数和拷贝构造函数。</li>\n<li>基类的重载运算符。</li>\n<li>基类的友元函数。</li>\n</ul>\n<h2 id=\"继承类型\"><a class=\"markdownIt-Anchor\" href=\"#继承类型\">#</a> 继承类型</h2>\n<p>当一个类派生自基类，该基类可以被继承为 <strong>public、protected</strong> 或 <strong>private</strong> 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p>\n<p>我们几乎不使用 <strong>protected</strong> 或 <strong>private</strong> 继承，通常使用 <strong>public</strong> 继承。当使用不同类型的继承时，遵循以下几个规则：</p>\n<ul>\n<li><strong>公有继承（public）：<strong>当一个类派生自</strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li>\n<li><strong>保护继承（protected）：</strong> 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li>\n<li><strong>私有继承（private）：<strong>当一个类派生自</strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li>\n</ul>\n<h2 id=\"多继承\"><a class=\"markdownIt-Anchor\" href=\"#多继承\">#</a> 多继承</h2>\n<p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p>\n<p>C++ 类可以从多个类继承成员，语法如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> &lt;派生类名&gt;:&lt;继承方式<span class=\"number\">1</span>&gt;&lt;基类名<span class=\"number\">1</span>&gt;,&lt;继承方式<span class=\"number\">2</span>&gt;&lt;基类名<span class=\"number\">2</span>&gt;,…&#123;&lt;派生类类体&gt;&#125;;</span><br></pre></td></tr></table></figure>\n<p>其中，访问修饰符继承方式是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;<span class=\"comment\">// 基类 Shapeclass Shape &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">(<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         width = w;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setHeight</span><span class=\"params\">(<span class=\"type\">int</span> h)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         height = h;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"type\">int</span> width;</span><br><span class=\"line\">      <span class=\"type\">int</span> height;&#125;;<span class=\"comment\">// 基类 PaintCostclass PaintCost &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getCost</span><span class=\"params\">(<span class=\"type\">int</span> area)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> area * <span class=\"number\">70</span>;</span><br><span class=\"line\">      &#125;&#125;;<span class=\"comment\">// 派生类class Rectangle: public Shape, public PaintCost&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getArea</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123; </span><br><span class=\"line\">         <span class=\"keyword\">return</span> (width * height); </span><br><span class=\"line\">      &#125;&#125;;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;</span><br><span class=\"line\">   Rectangle Rect;</span><br><span class=\"line\">   <span class=\"type\">int</span> area;</span><br><span class=\"line\"> </span><br><span class=\"line\">   Rect.<span class=\"built_in\">setWidth</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">   Rect.<span class=\"built_in\">setHeight</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   area = Rect.<span class=\"built_in\">getArea</span>();</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 输出对象的面积</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class=\"built_in\">getArea</span>() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出总花费</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total paint cost: $&quot;</span> &lt;&lt; Rect.<span class=\"built_in\">getCost</span>(area) &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Total area: <span class=\"number\">35</span>Total paint cost: $<span class=\"number\">2450</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"c-重载运算符和重载函数\"><a class=\"markdownIt-Anchor\" href=\"#c-重载运算符和重载函数\">#</a> C++ 重载运算符和重载函数</h1>\n<p>C++ 允许在同一作用域中的某个<strong>函数</strong>和<strong>运算符</strong>指定多个定义，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。</p>\n<p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</p>\n<p>当您调用一个<strong>重载函数</strong>或<strong>重载运算符</strong>时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为<strong>重载决策</strong>。</p>\n<h2 id=\"c-中的函数重载\"><a class=\"markdownIt-Anchor\" href=\"#c-中的函数重载\">#</a> C++ 中的函数重载</h2>\n<p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。</p>\n<p>下面的实例中，同名函数 <strong>print()</strong> 被用于输出不同的数据类型：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"keyword\">class</span> <span class=\"title class_\">printData</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Printing int: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">double</span>  f)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Printing float: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">char</span>* c)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Printing character: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class=\"line\">      &#125;&#125;;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;</span><br><span class=\"line\">   printData pd;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// Call print to print integer</span></span><br><span class=\"line\">   pd.<span class=\"built_in\">print</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">   <span class=\"comment\">// Call print to print float</span></span><br><span class=\"line\">   pd.<span class=\"built_in\">print</span>(<span class=\"number\">500.263</span>);</span><br><span class=\"line\">   <span class=\"comment\">// Call print to print character</span></span><br><span class=\"line\">   pd.<span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello C++&quot;</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Printing <span class=\"type\">int</span>: <span class=\"number\">5</span>Printing <span class=\"type\">float</span>: <span class=\"number\">500.263</span>Printing character: Hello C++</span><br></pre></td></tr></table></figure>\n<h2 id=\"c-中的运算符重载\"><a class=\"markdownIt-Anchor\" href=\"#c-中的运算符重载\">#</a> C++ 中的运算符重载</h2>\n<p>您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。</p>\n<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Box <span class=\"keyword\">operator</span>+(<span class=\"type\">const</span> Box&amp;);</span><br></pre></td></tr></table></figure>\n<p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Box <span class=\"keyword\">operator</span>+(<span class=\"type\">const</span> Box&amp;, <span class=\"type\">const</span> Box&amp;);</span><br></pre></td></tr></table></figure>\n<p>下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 <strong>this</strong> 运算符进行访问，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;class Box&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getVolume</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setLength</span><span class=\"params\">( <span class=\"type\">double</span> len )</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          length = len;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setBreadth</span><span class=\"params\">( <span class=\"type\">double</span> bre )</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          breadth = bre;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setHeight</span><span class=\"params\">( <span class=\"type\">double</span> hei )</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          height = hei;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 重载 + 运算符，用于把两个 Box 对象相加</span></span><br><span class=\"line\">      Box <span class=\"keyword\">operator</span>+(<span class=\"type\">const</span> Box&amp; b)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         Box box;</span><br><span class=\"line\">         box.length = <span class=\"keyword\">this</span>-&gt;length + b.length;</span><br><span class=\"line\">         box.breadth = <span class=\"keyword\">this</span>-&gt;breadth + b.breadth;</span><br><span class=\"line\">         box.height = <span class=\"keyword\">this</span>-&gt;height + b.height;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> box;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> length;      <span class=\"comment\">// 长度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> breadth;     <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> height;      <span class=\"comment\">// 高度&#125;;// 程序的主函数int main( )&#123;</span></span><br><span class=\"line\">   Box Box1;                <span class=\"comment\">// 声明 Box1，类型为 Box</span></span><br><span class=\"line\">   Box Box2;                <span class=\"comment\">// 声明 Box2，类型为 Box</span></span><br><span class=\"line\">   Box Box3;                <span class=\"comment\">// 声明 Box3，类型为 Box</span></span><br><span class=\"line\">   <span class=\"type\">double</span> volume = <span class=\"number\">0.0</span>;     <span class=\"comment\">// 把体积存储在该变量中</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// Box1 详述</span></span><br><span class=\"line\">   Box1.<span class=\"built_in\">setLength</span>(<span class=\"number\">6.0</span>); </span><br><span class=\"line\">   Box1.<span class=\"built_in\">setBreadth</span>(<span class=\"number\">7.0</span>); </span><br><span class=\"line\">   Box1.<span class=\"built_in\">setHeight</span>(<span class=\"number\">5.0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// Box2 详述</span></span><br><span class=\"line\">   Box2.<span class=\"built_in\">setLength</span>(<span class=\"number\">12.0</span>); </span><br><span class=\"line\">   Box2.<span class=\"built_in\">setBreadth</span>(<span class=\"number\">13.0</span>); </span><br><span class=\"line\">   Box2.<span class=\"built_in\">setHeight</span>(<span class=\"number\">10.0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// Box1 的体积</span></span><br><span class=\"line\">   volume = Box1.<span class=\"built_in\">getVolume</span>();</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Volume of Box1 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// Box2 的体积</span></span><br><span class=\"line\">   volume = Box2.<span class=\"built_in\">getVolume</span>();</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Volume of Box2 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 把两个对象相加，得到 Box3</span></span><br><span class=\"line\">   Box3 = Box1 + Box2;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Box3 的体积</span></span><br><span class=\"line\">   volume = Box3.<span class=\"built_in\">getVolume</span>();</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Volume of Box3 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Volume of Box1 : <span class=\"number\">210</span>Volume of Box2 : <span class=\"number\">1560</span>Volume of Box3 : <span class=\"number\">5400</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"可重载运算符不可重载运算符\"><a class=\"markdownIt-Anchor\" href=\"#可重载运算符不可重载运算符\">#</a> 可重载运算符 / 不可重载运算符</h2>\n<p>下面是可重载的运算符列表：</p>\n<table>\n<thead>\n<tr>\n<th>+</th>\n<th>-</th>\n<th>*</th>\n<th>/</th>\n<th>%</th>\n<th>^</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&amp;</td>\n<td>|</td>\n<td>~</td>\n<td>!</td>\n<td>,</td>\n<td>=</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>&gt;</td>\n<td>&lt;=</td>\n<td>&gt;=</td>\n<td>++</td>\n<td>–</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>&gt;&gt;</td>\n<td>==</td>\n<td>!=</td>\n<td>&amp;&amp;</td>\n<td>||</td>\n</tr>\n<tr>\n<td>+=</td>\n<td>-=</td>\n<td>/=</td>\n<td>%=</td>\n<td>^=</td>\n<td>&amp;=</td>\n</tr>\n<tr>\n<td>|=</td>\n<td>*=</td>\n<td>&lt;&lt;=</td>\n<td>&gt;&gt;=</td>\n<td>[]</td>\n<td>()</td>\n</tr>\n<tr>\n<td>-&gt;</td>\n<td>-&gt;*</td>\n<td>new</td>\n<td>new []</td>\n<td>delete</td>\n<td>delete []</td>\n</tr>\n</tbody>\n</table>\n<p>下面是不可重载的运算符列表：</p>\n<table>\n<thead>\n<tr>\n<th>::</th>\n<th>.*</th>\n<th>.</th>\n<th>?:</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"运算符重载实例\"><a class=\"markdownIt-Anchor\" href=\"#运算符重载实例\">#</a> 运算符重载实例</h2>\n<p>下面提供了各种运算符重载的实例，帮助您更好地理解重载的概念。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序号</th>\n<th style=\"text-align:left\">运算符和实例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">一元运算符重载</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">二元运算符重载</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">关系运算符重载</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">输入 / 输出运算符重载</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">++ 和 – 运算符重载</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\">赋值运算符重载</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\">函数调用运算符 () 重载</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">下标运算符 [] 重载</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">9</td>\n<td style=\"text-align:left\">类成员访问运算符 -&gt; 重载</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"c-多态\"><a class=\"markdownIt-Anchor\" href=\"#c-多态\">#</a> C++ 多态</h1>\n<p><strong>多态</strong>按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</p>\n<p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>\n<p>下面的实例中，基类 Shape 被派生为两个类，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span> using namespace std;</span></span><br><span class=\"line\"> <span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"type\">int</span> width, height;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"built_in\">Shape</span>( <span class=\"type\">int</span> a=<span class=\"number\">0</span>, <span class=\"type\">int</span> b=<span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         width = a;</span><br><span class=\"line\">         height = b;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">area</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Parent class area :&quot;</span> &lt;&lt;endl;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;&#125;;<span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span>: <span class=\"keyword\">public</span> Shape&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"built_in\">Rectangle</span>( <span class=\"type\">int</span> a=<span class=\"number\">0</span>, <span class=\"type\">int</span> b=<span class=\"number\">0</span>):<span class=\"built_in\">Shape</span>(a, b) &#123; &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">area</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123; </span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Rectangle class area :&quot;</span> &lt;&lt;endl;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> (width * height); </span><br><span class=\"line\">      &#125;&#125;;<span class=\"keyword\">class</span> <span class=\"title class_\">Triangle</span>: <span class=\"keyword\">public</span> Shape&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"built_in\">Triangle</span>( <span class=\"type\">int</span> a=<span class=\"number\">0</span>, <span class=\"type\">int</span> b=<span class=\"number\">0</span>):<span class=\"built_in\">Shape</span>(a, b) &#123; &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">area</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123; </span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Triangle class area :&quot;</span> &lt;&lt;endl;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> (width * height / <span class=\"number\">2</span>); </span><br><span class=\"line\">      &#125;&#125;;<span class=\"comment\">// 程序的主函数int main( )&#123;</span></span><br><span class=\"line\">   Shape *shape;</span><br><span class=\"line\">   <span class=\"function\">Rectangle <span class=\"title\">rec</span><span class=\"params\">(<span class=\"number\">10</span>,<span class=\"number\">7</span>)</span></span>;</span><br><span class=\"line\">   <span class=\"function\">Triangle  <span class=\"title\">tri</span><span class=\"params\">(<span class=\"number\">10</span>,<span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 存储矩形的地址</span></span><br><span class=\"line\">   shape = &amp;rec;</span><br><span class=\"line\">   <span class=\"comment\">// 调用矩形的求面积函数 area</span></span><br><span class=\"line\">   shape-&gt;<span class=\"built_in\">area</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 存储三角形的地址</span></span><br><span class=\"line\">   shape = &amp;tri;</span><br><span class=\"line\">   <span class=\"comment\">// 调用三角形的求面积函数 area</span></span><br><span class=\"line\">   shape-&gt;<span class=\"built_in\">area</span>();</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Parent <span class=\"keyword\">class</span> <span class=\"title class_\">areaParent</span> <span class=\"keyword\">class</span> <span class=\"title class_\">area</span></span><br></pre></td></tr></table></figure>\n<p>导致错误输出的原因是，调用函数 area () 被编译器设置为基类中的版本，这就是所谓的<strong>静态多态</strong>，或<strong>静态链接</strong> - 函数调用在程序执行前就准备好了。有时候这也被称为<strong>早绑定</strong>，因为 area () 函数在程序编译期间就已经设置好了。</p>\n<p>但现在，让我们对程序稍作修改，在 Shape 类中，area () 的声明前放置关键字 <strong>virtual</strong>，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"type\">int</span> width, height;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"built_in\">Shape</span>( <span class=\"type\">int</span> a=<span class=\"number\">0</span>, <span class=\"type\">int</span> b=<span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         width = a;</span><br><span class=\"line\">         height = b;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">area</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Parent class area :&quot;</span> &lt;&lt;endl;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;&#125;;</span><br></pre></td></tr></table></figure>\n<p>修改后，当编译和执行前面的实例代码时，它会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rectangle <span class=\"keyword\">class</span> <span class=\"title class_\">areaTriangle</span> <span class=\"keyword\">class</span> <span class=\"title class_\">area</span></span><br></pre></td></tr></table></figure>\n<p>此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area () 函数。</p>\n<p>正如您所看到的，每个子类都有一个函数 area () 的独立实现。这就是<strong>多态</strong>的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。</p>\n<h2 id=\"虚函数\"><a class=\"markdownIt-Anchor\" href=\"#虚函数\">#</a> 虚函数</h2>\n<p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>\n<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p>\n<h2 id=\"纯虚函数\"><a class=\"markdownIt-Anchor\" href=\"#纯虚函数\">#</a> 纯虚函数</h2>\n<p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。</p>\n<p>我们可以把基类中的虚函数 area () 改写如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"type\">int</span> width, height;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"built_in\">Shape</span>( <span class=\"type\">int</span> a=<span class=\"number\">0</span>, <span class=\"type\">int</span> b=<span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         width = a;</span><br><span class=\"line\">         height = b;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// pure virtual function</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">area</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;&#125;;</span><br></pre></td></tr></table></figure>\n<p>= 0 告诉编译器，函数没有主体，上面的虚函数是<strong>纯虚函数</strong>。</p>\n<h1 id=\"c-数据抽象\"><a class=\"markdownIt-Anchor\" href=\"#c-数据抽象\">#</a> C++ 数据抽象</h1>\n<p>数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。</p>\n<p>数据抽象是一种依赖于接口和实现分离的编程（设计）技术。</p>\n<p>让我们举一个现实生活中的真实例子，比如一台电视机，您可以打开和关闭、切换频道、调整音量、添加外部组件（如喇叭、录像机、DVD 播放器），但是您不知道它的内部实现细节，也就是说，您并不知道它是如何通过缆线接收信号，如何转换信号，并最终显示在屏幕上。</p>\n<p>因此，我们可以说电视把它的内部实现和外部接口分离开了，您无需知道它的内部实现原理，直接通过它的外部接口（比如电源按钮、遥控器、声量控制器）就可以操控电视。</p>\n<p>现在，让我们言归正传，就 C++ 编程而言，C++ 类为<strong>数据抽象</strong>提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。</p>\n<p>例如，您的程序可以调用 <strong>sort()</strong> 函数，而不需要知道函数中排序数据所用到的算法。实际上，函数排序的底层实现会因库的版本不同而有所差异，只要接口不变，函数调用就可以照常工作。</p>\n<p>在 C++ 中，我们使用<strong>类</strong>来定义我们自己的抽象数据类型（ADT）。您可以使用类 <strong>ostream</strong> 的 <strong>cout</strong> 对象来输出数据到标准输出，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main( )&#123;   cout &lt;&lt; <span class=\"string\">&quot;Hello C++&quot;</span> &lt;&lt;endl;   return 0;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>在这里，您不需要理解 <strong>cout</strong> 是如何在用户的屏幕上显示文本。您只需要知道公共接口即可，cout 的底层实现可以自由改变。</p>\n<h2 id=\"访问标签强制抽象\"><a class=\"markdownIt-Anchor\" href=\"#访问标签强制抽象\">#</a> 访问标签强制抽象</h2>\n<p>在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签：</p>\n<ul>\n<li>使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。</li>\n<li>使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。</li>\n</ul>\n<p>访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。</p>\n<h2 id=\"数据抽象的好处\"><a class=\"markdownIt-Anchor\" href=\"#数据抽象的好处\">#</a> 数据抽象的好处</h2>\n<p>数据抽象有两个重要的优势：</p>\n<ul>\n<li>类的内部受到保护，不会因无意的用户级错误导致对象状态受损。</li>\n<li>类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。</li>\n</ul>\n<p>如果只在类的私有部分定义数据成员，编写该类的作者就可以随意更改数据。如果实现发生改变，则只需要检查类的代码，看看这个改变会导致哪些影响。如果数据是公有的，则任何直接访问旧表示形式的数据成员的函数都可能受到影响。</p>\n<h2 id=\"数据抽象的实例\"><a class=\"markdownIt-Anchor\" href=\"#数据抽象的实例\">#</a> 数据抽象的实例</h2>\n<p>C++ 程序中，任何带有公有和私有成员的类都可以作为数据抽象的实例。请看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;class Adder&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">      <span class=\"built_in\">Adder</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        total = i;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 对外的接口</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addNum</span><span class=\"params\">(<span class=\"type\">int</span> number)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          total += number;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 对外的接口</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getTotal</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 对外隐藏的数据</span></span><br><span class=\"line\">      <span class=\"type\">int</span> total;&#125;;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   Adder a;</span><br><span class=\"line\">   </span><br><span class=\"line\">   a.<span class=\"built_in\">addNum</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">   a.<span class=\"built_in\">addNum</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\">   a.<span class=\"built_in\">addNum</span>(<span class=\"number\">30</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total &quot;</span> &lt;&lt; a.<span class=\"built_in\">getTotal</span>() &lt;&lt;endl;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Total <span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n<p>上面的类把数字相加，并返回总和。公有成员 <strong>addNum</strong> 和 <strong>getTotal</strong> 是对外的接口，用户需要知道它们以便使用类。私有成员 <strong>total</strong> 是用户不需要了解的，但又是类能正常工作所必需的。</p>\n<h2 id=\"设计策略\"><a class=\"markdownIt-Anchor\" href=\"#设计策略\">#</a> 设计策略</h2>\n<p>抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。</p>\n<p>在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可。</p>\n<h1 id=\"c-数据封装\"><a class=\"markdownIt-Anchor\" href=\"#c-数据封装\">#</a> C++ 数据封装</h1>\n<p>所有的 C++ 程序都有以下两个基本要素：</p>\n<ul>\n<li>** 程序语句（代码）：** 这是程序中执行动作的部分，它们被称为函数。</li>\n<li>** 程序数据：** 数据是程序的信息，会受到程序函数的影响。</li>\n</ul>\n<p>封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即<strong>数据隐藏</strong>。</p>\n<p><strong>数据封装</strong>是一种把数据和操作数据的函数捆绑在一起的机制，<strong>数据抽象</strong>是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。</p>\n<p>C++ 通过创建<strong>类</strong>来支持封装和数据隐藏（public、protected、private）。我们已经知道，类包含私有成员（private）、保护成员（protected）和公有成员（public）成员。默认情况下，在类中定义的所有项目都是私有的。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getVolume</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> length;      <span class=\"comment\">// 长度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> breadth;     <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> height;      <span class=\"comment\">// 高度</span></span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure>\n<p>变量 length、breadth 和 height 都是私有的（private）。这意味着它们只能被 Box 类中的其他成员访问，而不能被程序中其他部分访问。这是实现封装的一种方式。</p>\n<p>为了使类中的成员变成公有的（即，程序中的其他部分也能访问），必须在这些成员前使用 <strong>public</strong> 关键字进行声明。所有定义在 public 标识符后边的变量或函数可以被程序中所有其他的函数访问。</p>\n<p>把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节。</p>\n<h2 id=\"数据封装的实例\"><a class=\"markdownIt-Anchor\" href=\"#数据封装的实例\">#</a> 数据封装的实例</h2>\n<p>C++ 程序中，任何带有公有和私有成员的类都可以作为数据封装和数据抽象的实例。请看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;class Adder&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">      <span class=\"built_in\">Adder</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        total = i;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 对外的接口</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addNum</span><span class=\"params\">(<span class=\"type\">int</span> number)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          total += number;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 对外的接口</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getTotal</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 对外隐藏的数据</span></span><br><span class=\"line\">      <span class=\"type\">int</span> total;&#125;;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   Adder a;</span><br><span class=\"line\">   </span><br><span class=\"line\">   a.<span class=\"built_in\">addNum</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">   a.<span class=\"built_in\">addNum</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\">   a.<span class=\"built_in\">addNum</span>(<span class=\"number\">30</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total &quot;</span> &lt;&lt; a.<span class=\"built_in\">getTotal</span>() &lt;&lt;endl;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Total <span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n<p>上面的类把数字相加，并返回总和。公有成员 <strong>addNum</strong> 和 <strong>getTotal</strong> 是对外的接口，用户需要知道它们以便使用类。私有成员 <strong>total</strong> 是对外隐藏的，用户不需要了解它，但它又是类能正常工作所必需的。</p>\n<h2 id=\"设计策略-2\"><a class=\"markdownIt-Anchor\" href=\"#设计策略-2\">#</a> 设计策略</h2>\n<p>通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的<strong>封装性</strong>。</p>\n<p>这通常应用于数据成员，但它同样适用于所有成员，包括虚函数。</p>\n<h1 id=\"c-接口抽象类\"><a class=\"markdownIt-Anchor\" href=\"#c-接口抽象类\">#</a> C++ 接口（抽象类）</h1>\n<p>接口描述了类的行为和功能，而不需要完成类的特定实现。</p>\n<p>C++ 接口是使用<strong>抽象类</strong>来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。</p>\n<p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 纯虚函数</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">double</span> <span class=\"title\">getVolume</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> length;      <span class=\"comment\">// 长度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> breadth;     <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> height;      <span class=\"comment\">// 高度&#125;;</span></span><br></pre></td></tr></table></figure>\n<p>设计<strong>抽象类</strong>（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为<strong>接口</strong>使用。如果试图实例化一个抽象类的对象，会导致编译错误。</p>\n<p>因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。</p>\n<p>可用于实例化对象的类被称为<strong>具体类</strong>。</p>\n<h2 id=\"抽象类的实例\"><a class=\"markdownIt-Anchor\" href=\"#抽象类的实例\">#</a> 抽象类的实例</h2>\n<p>请看下面的实例，基类 Shape 提供了一个接口 <strong>getArea()</strong>，在两个派生类 Rectangle 和 Triangle 中分别实现了 <strong>getArea()</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> <span class=\"comment\">// 基类class Shape &#123;public:</span></span><br><span class=\"line\">   <span class=\"comment\">// 提供接口框架的纯虚函数</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">getArea</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">(<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">      width = w;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setHeight</span><span class=\"params\">(<span class=\"type\">int</span> h)</span></span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">      height = h;</span><br><span class=\"line\">   &#125;<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">   <span class=\"type\">int</span> width;</span><br><span class=\"line\">   <span class=\"type\">int</span> height;&#125;;</span><br><span class=\"line\"> <span class=\"comment\">// 派生类class Rectangle: public Shape&#123;public:</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getArea</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> (width * height); </span><br><span class=\"line\">   &#125;&#125;;<span class=\"keyword\">class</span> <span class=\"title class_\">Triangle</span>: <span class=\"keyword\">public</span> Shape&#123;<span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getArea</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> (width * height)/<span class=\"number\">2</span>; </span><br><span class=\"line\">   &#125;&#125;;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;</span><br><span class=\"line\">   Rectangle Rect;</span><br><span class=\"line\">   Triangle  Tri;</span><br><span class=\"line\"> </span><br><span class=\"line\">   Rect.<span class=\"built_in\">setWidth</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">   Rect.<span class=\"built_in\">setHeight</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 输出对象的面积</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total Rectangle area: &quot;</span> &lt;&lt; Rect.<span class=\"built_in\">getArea</span>() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   Tri.<span class=\"built_in\">setWidth</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">   Tri.<span class=\"built_in\">setHeight</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 输出对象的面积</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total Triangle area: &quot;</span> &lt;&lt; Tri.<span class=\"built_in\">getArea</span>() &lt;&lt; endl; </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Total Rectangle area: <span class=\"number\">35</span>Total Triangle area: <span class=\"number\">17</span></span><br></pre></td></tr></table></figure>\n<p>从上面的实例中，我们可以看到一个抽象类是如何定义一个接口 getArea ()，两个派生类是如何通过不同的计算面积的算法来实现这个相同的函数。</p>\n<h2 id=\"设计策略-3\"><a class=\"markdownIt-Anchor\" href=\"#设计策略-3\">#</a> 设计策略</h2>\n<p>面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。</p>\n<p>外部应用程序提供的功能（即公有函数）在抽象基类中是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类中被实现。</p>\n<p>这个架构也使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此。</p>\n<h1 id=\"c-文件和流\"><a class=\"markdownIt-Anchor\" href=\"#c-文件和流\">#</a> C++ 文件和流</h1>\n<p>到目前为止，我们已经使用了 <strong>iostream</strong> 标准库，它提供了 <strong>cin</strong> 和 <strong>cout</strong> 方法分别用于从标准输入读取流和向标准输出写入流。</p>\n<p>本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 <strong>fstream</strong>，它定义了三个新的数据类型：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">数据类型</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ofstream</td>\n<td style=\"text-align:left\">该数据类型表示输出文件流，用于创建文件并向文件写入信息。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ifstream</td>\n<td style=\"text-align:left\">该数据类型表示输入文件流，用于从文件读取信息。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">fstream</td>\n<td style=\"text-align:left\">该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</td>\n</tr>\n</tbody>\n</table>\n<p>要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 <iostream> 和 <fstream>。</p>\n<h2 id=\"打开文件\"><a class=\"markdownIt-Anchor\" href=\"#打开文件\">#</a> 打开文件</h2>\n<p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。<strong>ofstream</strong> 和 <strong>fstream</strong> 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 <strong>ifstream</strong> 对象。</p>\n<p>下面是 open () 函数的标准语法，open () 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">open</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *filename, ios::openmode mode)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>在这里，<strong>open()</strong> 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">模式标志</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ios::app</td>\n<td style=\"text-align:left\">追加模式。所有写入都追加到文件末尾。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ios::ate</td>\n<td style=\"text-align:left\">文件打开后定位到文件末尾。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ios::in</td>\n<td style=\"text-align:left\">打开文件用于读取。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ios::out</td>\n<td style=\"text-align:left\">打开文件用于写入。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ios::trunc</td>\n<td style=\"text-align:left\">如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</td>\n</tr>\n</tbody>\n</table>\n<p>您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ofstream outfile;outfile.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;file.dat&quot;</span>, ios::out | ios::trunc );</span><br></pre></td></tr></table></figure>\n<p>类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fstream  afile;afile.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;file.dat&quot;</span>, ios::out | ios::in );</span><br></pre></td></tr></table></figure>\n<h2 id=\"关闭文件\"><a class=\"markdownIt-Anchor\" href=\"#关闭文件\">#</a> 关闭文件</h2>\n<p>当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。</p>\n<p>下面是 close () 函数的标准语法，close () 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"写入文件\"><a class=\"markdownIt-Anchor\" href=\"#写入文件\">#</a> 写入文件</h2>\n<p>在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 <strong>ofstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cout</strong> 对象。</p>\n<h2 id=\"读取文件\"><a class=\"markdownIt-Anchor\" href=\"#读取文件\">#</a> 读取文件</h2>\n<p>在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 <strong>ifstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cin</strong> 对象。</p>\n<h2 id=\"读取-写入实例\"><a class=\"markdownIt-Anchor\" href=\"#读取-写入实例\">#</a> 读取 &amp; 写入实例</h2>\n<p>下面的 C++ 程序以读写模式打开一个文件。在向文件 afile.dat 写入用户输入的信息之后，程序从文件读取信息，并将其输出到屏幕上：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"type\">char</span> data[<span class=\"number\">100</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 以写模式打开文件</span></span><br><span class=\"line\">   ofstream outfile;</span><br><span class=\"line\">   outfile.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;afile.dat&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Writing to the file&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Enter your name: &quot;</span>; </span><br><span class=\"line\">   cin.<span class=\"built_in\">getline</span>(data, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 向文件写入用户输入的数据</span></span><br><span class=\"line\">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Enter your age: &quot;</span>; </span><br><span class=\"line\">   cin &gt;&gt; data;</span><br><span class=\"line\">   cin.<span class=\"built_in\">ignore</span>();</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 再次向文件写入用户输入的数据</span></span><br><span class=\"line\">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 关闭打开的文件</span></span><br><span class=\"line\">   outfile.<span class=\"built_in\">close</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 以读模式打开文件</span></span><br><span class=\"line\">   ifstream infile; </span><br><span class=\"line\">   infile.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;afile.dat&quot;</span>); </span><br><span class=\"line\"> </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Reading from the file&quot;</span> &lt;&lt; endl; </span><br><span class=\"line\">   infile &gt;&gt; data; </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 在屏幕上写入数据</span></span><br><span class=\"line\">   cout &lt;&lt; data &lt;&lt; endl;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 再次从文件读取数据，并显示它</span></span><br><span class=\"line\">   infile &gt;&gt; data; </span><br><span class=\"line\">   cout &lt;&lt; data &lt;&lt; endl; </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 关闭打开的文件</span></span><br><span class=\"line\">   infile.<span class=\"built_in\">close</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列输入和输出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$./a.outWriting to the fileEnter your name: ZaraEnter your age: <span class=\"number\">9</span>Reading from the fileZara9</span><br></pre></td></tr></table></figure>\n<p>上面的实例中使用了 cin 对象的附加函数，比如 getline () 函数从外部读取一行，ignore () 函数会忽略掉之前读语句留下的多余字符。</p>\n<h2 id=\"文件位置指针\"><a class=\"markdownIt-Anchor\" href=\"#文件位置指针\">#</a> 文件位置指针</h2>\n<p><strong>istream</strong> 和 <strong>ostream</strong> 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 <strong>seekg</strong>（“seek get”）和关于 ostream 的 <strong>seekp</strong>（“seek put”）。</p>\n<p>seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 <strong>ios::beg</strong>（默认的，从流的开头开始定位），也可以是 <strong>ios::cur</strong>（从流的当前位置开始定位），也可以是 <strong>ios::end</strong>（从流的末尾开始定位）。</p>\n<p>文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）fileObject.seekg( n );// 把文件的读指针从 fileObject 当前位置向后移 n 个字节fileObject.seekg( n, ios::cur );// 把文件的读指针从 fileObject 末尾往回移 n 个字节fileObject.seekg( n, ios::end );// 定位到 fileObject 的末尾fileObject.seekg( 0, ios::end );</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"c-异常处理\"><a class=\"markdownIt-Anchor\" href=\"#c-异常处理\">#</a> C++ 异常处理</h1>\n<p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p>\n<p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p>\n<ul>\n<li><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。</li>\n<li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</li>\n<li><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li>\n</ul>\n<p>如果有一个块抛出一个异常，捕获异常的方法会使用 <strong>try</strong> 和 <strong>catch</strong> 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 保护代码&#125;catch( ExceptionName e1 )&#123;</span></span><br><span class=\"line\">   <span class=\"comment\">// catch 块&#125;catch( ExceptionName e2 )&#123;</span></span><br><span class=\"line\">   <span class=\"comment\">// catch 块&#125;catch( ExceptionName eN )&#123;</span></span><br><span class=\"line\">   <span class=\"comment\">// catch 块&#125;</span></span><br></pre></td></tr></table></figure>\n<p>如果 <strong>try</strong> 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 <strong>catch</strong> 语句，用于捕获不同类型的异常。</p>\n<h2 id=\"抛出异常\"><a class=\"markdownIt-Anchor\" href=\"#抛出异常\">#</a> 抛出异常</h2>\n<p>您可以使用 <strong>throw</strong> 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。</p>\n<p>以下是尝试除以零时抛出异常的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">division</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>( b == <span class=\"number\">0</span> )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"string\">&quot;Division by zero condition!&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> (a/b);&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"捕获异常\"><a class=\"markdownIt-Anchor\" href=\"#捕获异常\">#</a> 捕获异常</h2>\n<p><strong>catch</strong> 块跟在 <strong>try</strong> 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 保护代码&#125;catch( ExceptionName e )&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">// 处理 ExceptionName 异常的代码&#125;</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码会捕获一个类型为 <strong>ExceptionName</strong> 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 …，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 保护代码&#125;catch(...)&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">// 能处理任何异常的代码&#125;</span></span><br></pre></td></tr></table></figure>\n<p>下面是一个实例，抛出一个除以零的异常，并在 catch 块中捕获该异常。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;double division(int a, int b)&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span>( b == <span class=\"number\">0</span> )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"string\">&quot;Division by zero condition!&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> (a/b);&#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> x = <span class=\"number\">50</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span> y = <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"type\">double</span> z = <span class=\"number\">0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">     z = <span class=\"built_in\">division</span>(x, y);</span><br><span class=\"line\">     cout &lt;&lt; z &lt;&lt; endl;</span><br><span class=\"line\">   &#125;<span class=\"built_in\">catch</span> (<span class=\"type\">const</span> <span class=\"type\">char</span>* msg) &#123;</span><br><span class=\"line\">     cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>由于我们抛出了一个类型为 <strong>const char*</strong> 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Division by zero condition!</span><br></pre></td></tr></table></figure>\n<h2 id=\"c-标准的异常\"><a class=\"markdownIt-Anchor\" href=\"#c-标准的异常\">#</a> C++ 标准的异常</h2>\n<p>C++ 提供了一系列标准的异常，定义在 <strong><exception></strong> 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示：</p>\n<p><img data-src=\"https://edu.aliyun.com/files/course/2017/09-24/1641382aba76354408.jpg\" alt=\"img\"></p>\n<p>下表是对上面层次结构中出现的每个异常的说明：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">异常</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>std::exception</strong></td>\n<td style=\"text-align:left\">该异常是所有标准 C++ 异常的父类。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">std::bad_alloc</td>\n<td style=\"text-align:left\">该异常可以通过 <strong>new</strong> 抛出。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">std::bad_cast</td>\n<td style=\"text-align:left\">该异常可以通过 <strong>dynamic_cast</strong> 抛出。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">std::bad_exception</td>\n<td style=\"text-align:left\">这在处理 C++ 程序中无法预期的异常时非常有用。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">std::bad_typeid</td>\n<td style=\"text-align:left\">该异常可以通过 <strong>typeid</strong> 抛出。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>std::logic_error</strong></td>\n<td style=\"text-align:left\">理论上可以通过读取代码来检测到的异常。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">std::domain_error</td>\n<td style=\"text-align:left\">当使用了一个无效的数学域时，会抛出该异常。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">std::invalid_argument</td>\n<td style=\"text-align:left\">当使用了无效的参数时，会抛出该异常。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">std::length_error</td>\n<td style=\"text-align:left\">当创建了太长的 std::string 时，会抛出该异常。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">std::out_of_range</td>\n<td style=\"text-align:left\">该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator<a href=\"\"></a>。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>std::runtime_error</strong></td>\n<td style=\"text-align:left\">理论上不可以通过读取代码来检测到的异常。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">std::overflow_error</td>\n<td style=\"text-align:left\">当发生数学上溢时，会抛出该异常。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">std::range_error</td>\n<td style=\"text-align:left\">当尝试存储超出范围的值时，会抛出该异常。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">std::underflow_error</td>\n<td style=\"text-align:left\">当发生数学下溢时，会抛出该异常。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"定义新的异常\"><a class=\"markdownIt-Anchor\" href=\"#定义新的异常\">#</a> 定义新的异常</h2>\n<p>您可以通过继承和重载 <strong>exception</strong> 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;exception&gt;</span>using namespace std;struct MyException : public exception&#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"title\">what</span> <span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"title\">throw</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;C++ Exception&quot;</span>;</span><br><span class=\"line\">  &#125;&#125;;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"built_in\">MyException</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">catch</span>(MyException&amp; e)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;MyException caught&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; e.<span class=\"built_in\">what</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">catch</span>(std::exception&amp; e)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">//其他的错误</span></span><br><span class=\"line\">  &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>这将产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyException caught</span><br><span class=\"line\">C++ Exception</span><br></pre></td></tr></table></figure>\n<p>在这里，<strong>what()</strong> 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因。</p>\n<h1 id=\"c-动态内存\"><a class=\"markdownIt-Anchor\" href=\"#c-动态内存\">#</a> C++ 动态内存</h1>\n<p>了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序员必不可少的。C++ 程序中的内存分为两个部分：</p>\n<ul>\n<li>** 栈：** 在函数内部声明的所有变量都将占用栈内存。</li>\n<li>** 堆：** 这是程序中未使用的内存，在程序运行时可用于动态分配内存。</li>\n</ul>\n<p>很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。</p>\n<p>在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 <strong>new</strong> 运算符。</p>\n<p>如果您不需要动态分配内存，可以使用 <strong>delete</strong> 运算符，删除之前由 new 运算符分配的内存。</p>\n<h2 id=\"new-和-delete-运算符\"><a class=\"markdownIt-Anchor\" href=\"#new-和-delete-运算符\">#</a> new 和 delete 运算符</h2>\n<p>下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> data-type;</span><br></pre></td></tr></table></figure>\n<p>在这里，<strong>data-type</strong> 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。让我们先来看下内置的数据类型。例如，我们可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 <strong>new</strong> 运算符来完成这点：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span>* pvalue  = <span class=\"literal\">NULL</span>; <span class=\"comment\">// 初始化为 null 的指针pvalue  = new double;   // 为变量请求内存</span></span><br></pre></td></tr></table></figure>\n<p>如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span>* pvalue  = <span class=\"literal\">NULL</span>;<span class=\"keyword\">if</span>( !(pvalue  = <span class=\"keyword\">new</span> <span class=\"type\">double</span> ))&#123;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Error: out of memory.&quot;</span> &lt;&lt;endl;</span><br><span class=\"line\">   <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>malloc()</strong> 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc () 函数。new 与 malloc () 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。</p>\n<p>在任何时候，当您觉得某个已经动态分配内存的变量不再需要使用时，您可以使用 delete 操作符释放它所占用的内存，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> pvalue;        <span class=\"comment\">// 释放 pvalue 所指向的内存</span></span><br></pre></td></tr></table></figure>\n<p>下面的实例中使用了上面的概念，演示了如何使用 new 和 delete 运算符：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main ()&#123;</span></span><br><span class=\"line\">   <span class=\"type\">double</span>* pvalue  = <span class=\"literal\">NULL</span>; <span class=\"comment\">// 初始化为 null 的指针</span></span><br><span class=\"line\">   pvalue  = <span class=\"keyword\">new</span> <span class=\"type\">double</span>;   <span class=\"comment\">// 为变量请求内存</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   *pvalue = <span class=\"number\">29494.99</span>;     <span class=\"comment\">// 在分配的地址存储值</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of pvalue : &quot;</span> &lt;&lt; *pvalue &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">delete</span> pvalue;         <span class=\"comment\">// 释放内存</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of pvalue : <span class=\"number\">29495</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"数组的动态内存分配\"><a class=\"markdownIt-Anchor\" href=\"#数组的动态内存分配\">#</a> 数组的动态内存分配</h2>\n<p>假设我们要为一个字符数组（一个有 20 个字符的字符串）分配内存，我们可以使用上面实例中的语法来为数组动态地分配内存，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span>* pvalue  = <span class=\"literal\">NULL</span>;   <span class=\"comment\">// 初始化为 null 的指针pvalue  = new char[20]; // 为变量请求内存</span></span><br></pre></td></tr></table></figure>\n<p>要删除我们刚才创建的数组，语句如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> [] pvalue;        <span class=\"comment\">// 删除 pvalue 所指向的数组</span></span><br></pre></td></tr></table></figure>\n<p>下面是 new 操作符的通用语法，可以为多维数组分配内存，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> ROW = <span class=\"number\">2</span>;<span class=\"type\">int</span> COL = <span class=\"number\">3</span>;<span class=\"type\">double</span> **pvalue  = <span class=\"keyword\">new</span> <span class=\"type\">double</span>* [ROW]; <span class=\"comment\">// 为行分配内存// 为列分配内存for(int i = 0; i &lt; COL; i++) &#123;</span></span><br><span class=\"line\">    pvalue[i] = <span class=\"keyword\">new</span> <span class=\"type\">double</span>[COL];&#125;</span><br></pre></td></tr></table></figure>\n<p>释放多维数组内存：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; COL; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] pvalue[i];&#125;<span class=\"keyword\">delete</span> [] pvalue;</span><br></pre></td></tr></table></figure>\n<h2 id=\"对象的动态内存分配\"><a class=\"markdownIt-Anchor\" href=\"#对象的动态内存分配\">#</a> 对象的动态内存分配</h2>\n<p>对象与简单的数据类型没有什么不同。例如，请看下面的代码，我们将使用一个对象数组来理清这一概念：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;class Box&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"built_in\">Box</span>() &#123; </span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;调用构造函数！&quot;</span> &lt;&lt;endl; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      ~<span class=\"built_in\">Box</span>() &#123; </span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;调用析构函数！&quot;</span> &lt;&lt;endl; </span><br><span class=\"line\">      &#125;&#125;;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   Box* myBoxArray = <span class=\"keyword\">new</span> Box[<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">delete</span> [] myBoxArray; <span class=\"comment\">// Delete array</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>如果要为一个包含四个 Box 对象的数组分配内存，构造函数将被调用 4 次，同样地，当删除这些对象时，析构函数也将被调用相同的次数（4 次）。</p>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">调用构造函数！调用构造函数！调用构造函数！调用构造函数！调用析构函数！调用析构函数！调用析构函数！调用析构函数！</span><br></pre></td></tr></table></figure>\n<h1 id=\"c-命名空间\"><a class=\"markdownIt-Anchor\" href=\"#c-命名空间\">#</a> C++ 命名空间</h1>\n<p>假设这样一种情况，当一个班上有两个名叫 Zara 的学生时，为了明确区分它们，我们在使用名字之外，不得不使用一些额外的信息，比如他们的家庭住址，或者他们父母的名字等等。</p>\n<p>同样的情况也出现在 C++ 应用程序中。例如，您可能会写一个名为 xyz () 的函数，在另一个可用的库中也存在一个相同的函数 xyz ()。这样，编译器就无法判断您所使用的是哪一个 xyz () 函数。</p>\n<p>因此，引入了<strong>命名空间</strong>这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。</p>\n<h2 id=\"定义命名空间\"><a class=\"markdownIt-Anchor\" href=\"#定义命名空间\">#</a> 定义命名空间</h2>\n<p>命名空间的定义使用关键字 <strong>namespace</strong>，后跟命名空间的名称，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> namespace_name &#123;   <span class=\"comment\">// 代码声明&#125;</span></span><br></pre></td></tr></table></figure>\n<p>为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name::code;  <span class=\"comment\">// code 可以是变量或函数</span></span><br></pre></td></tr></table></figure>\n<p>让我们来看看命名空间如何为变量或函数等实体定义范围：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;<span class=\"comment\">// 第一个命名空间namespace first_space&#123;</span></span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   &#125;&#125;<span class=\"comment\">// 第二个命名空间namespace second_space&#123;</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   &#125;&#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 调用第一个命名空间中的函数</span></span><br><span class=\"line\">   first_space::<span class=\"built_in\">func</span>();</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 调用第二个命名空间中的函数</span></span><br><span class=\"line\">   second_space::<span class=\"built_in\">func</span>(); </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inside first_spaceInside second_space</span><br></pre></td></tr></table></figure>\n<h2 id=\"using-指令\"><a class=\"markdownIt-Anchor\" href=\"#using-指令\">#</a> using 指令</h2>\n<p>您可以使用 <strong>using namespace</strong> 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;<span class=\"comment\">// 第一个命名空间namespace first_space&#123;</span></span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   &#125;&#125;<span class=\"comment\">// 第二个命名空间namespace second_space&#123;</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   &#125;&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> first_space;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 调用第一个命名空间中的函数</span></span><br><span class=\"line\">   <span class=\"built_in\">func</span>();</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inside first_space</span><br></pre></td></tr></table></figure>\n<p>using 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> std::cout;</span><br></pre></td></tr></table></figure>\n<p>随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 <strong>std</strong> 命名空间中的其他项目仍然需要加上命名空间名称作为前缀，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using std::cout;int main ()&#123;   </span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;std::endl is used with std!&quot;</span> &lt;&lt; std::endl;      </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::endl is used with std!</span><br></pre></td></tr></table></figure>\n<p><strong>using</strong> 指令引入的名称遵循正常的范围规则。名称从使用 <strong>using</strong> 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。</p>\n<h2 id=\"不连续的命名空间\"><a class=\"markdownIt-Anchor\" href=\"#不连续的命名空间\">#</a> 不连续的命名空间</h2>\n<p>命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。</p>\n<p>所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> namespace_name &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 代码声明&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"嵌套的命名空间\"><a class=\"markdownIt-Anchor\" href=\"#嵌套的命名空间\">#</a> 嵌套的命名空间</h2>\n<p>命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> namespace_name1 &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 代码声明</span></span><br><span class=\"line\">   <span class=\"keyword\">namespace</span> namespace_name2 &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 代码声明</span></span><br><span class=\"line\">   &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>您可以通过使用：：运算符来访问嵌套的命名空间中的成员：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 访问 namespace_name2 中的成员using namespace namespace_name1::namespace_name2;// 访问 namespace:name1 中的成员using namespace namespace_name1;</span></span><br></pre></td></tr></table></figure>\n<p>在上面的语句中，如果使用的是 namespace_name1，那么在该范围内 namespace_name2 中的元素也是可用的，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;<span class=\"comment\">// 第一个命名空间namespace first_space&#123;</span></span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 第二个命名空间</span></span><br><span class=\"line\">   <span class=\"keyword\">namespace</span> second_space&#123;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> first_space::second_space;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 调用第二个命名空间中的函数</span></span><br><span class=\"line\">   <span class=\"built_in\">func</span>();</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inside second_space</span><br></pre></td></tr></table></figure>\n<h1 id=\"c-模板\"><a class=\"markdownIt-Anchor\" href=\"#c-模板\">#</a> C++ 模板</h1>\n<p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p>\n<p>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。</p>\n<p>每个容器都有一个单一的定义，比如 <strong>向量</strong>，我们可以定义许多不同类型的向量，比如 <strong>vector <int></strong> 或 <strong>vector <string></strong>。</p>\n<p>您可以使用模板来定义函数和类，接下来让我们一起来看看如何使用。</p>\n<h2 id=\"函数模板\"><a class=\"markdownIt-Anchor\" href=\"#函数模板\">#</a> 函数模板</h2>\n<p>模板函数定义的一般形式如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">type</span>&gt; ret-type func-<span class=\"built_in\">name</span>(parameter list)&#123;   <span class=\"comment\">// 函数的主体&#125;</span></span><br></pre></td></tr></table></figure>\n<p>在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。</p>\n<p>下面是函数模板的实例，返回两个数种的最大值：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>using namespace std;template <span class=\"string\">&lt;typename T&gt;</span>inline T const&amp; Max (T const&amp; a, T const&amp; b) &#123; </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a &lt; b ? b:a; &#125; <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">39</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">20</span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Max(i, j): &quot;</span> &lt;&lt; <span class=\"built_in\">Max</span>(i, j) &lt;&lt; endl; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">double</span> f1 = <span class=\"number\">13.5</span>; </span><br><span class=\"line\">    <span class=\"type\">double</span> f2 = <span class=\"number\">20.7</span>; </span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Max(f1, f2): &quot;</span> &lt;&lt; <span class=\"built_in\">Max</span>(f1, f2) &lt;&lt; endl; </span><br><span class=\"line\"></span><br><span class=\"line\">    string s1 = <span class=\"string\">&quot;Hello&quot;</span>; </span><br><span class=\"line\">    string s2 = <span class=\"string\">&quot;World&quot;</span>; </span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Max(s1, s2): &quot;</span> &lt;&lt; <span class=\"built_in\">Max</span>(s1, s2) &lt;&lt; endl; </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Max</span>(i, j): <span class=\"number\">39</span>Max(f1, f2): <span class=\"number\">20.7</span>Max(s1, s2): World</span><br></pre></td></tr></table></figure>\n<h2 id=\"类模板\"><a class=\"markdownIt-Anchor\" href=\"#类模板\">#</a> 类模板</h2>\n<p>正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">type</span>&gt; <span class=\"keyword\">class</span> <span class=\"title class_\">class</span>-name &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里，<strong>type</strong> 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。</p>\n<p>下面的实例定义了类 Stack&lt;&gt;，并实现了泛型方法来对元素进行入栈出栈操作：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdexcept&gt;</span>using namespace std;template <span class=\"string\">&lt;class T&gt;</span>class Stack &#123; </span></span><br><span class=\"line\">  <span class=\"keyword\">private</span>: </span><br><span class=\"line\">    vector&lt;T&gt; elems;     <span class=\"comment\">// 元素 </span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>: </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push</span><span class=\"params\">(T <span class=\"type\">const</span>&amp;)</span></span>;  <span class=\"comment\">// 入栈</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span></span>;               <span class=\"comment\">// 出栈</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">top</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;            <span class=\"comment\">// 返回栈顶元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;       <span class=\"comment\">// 如果为空则返回真。</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> elems.<span class=\"built_in\">empty</span>(); </span><br><span class=\"line\">    &#125; &#125;; <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;<span class=\"type\">void</span> Stack&lt;T&gt;::<span class=\"built_in\">push</span> (T <span class=\"type\">const</span>&amp; elem) &#123; </span><br><span class=\"line\">    <span class=\"comment\">// 追加传入元素的副本</span></span><br><span class=\"line\">    elems.<span class=\"built_in\">push_back</span>(elem);    &#125; <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;<span class=\"type\">void</span> Stack&lt;T&gt;::<span class=\"built_in\">pop</span> () &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elems.<span class=\"built_in\">empty</span>()) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"built_in\">out_of_range</span>(<span class=\"string\">&quot;Stack&lt;&gt;::pop(): empty stack&quot;</span>); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 删除最后一个元素</span></span><br><span class=\"line\">    elems.<span class=\"built_in\">pop_back</span>();         &#125; <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;T Stack&lt;T&gt;::<span class=\"built_in\">top</span> () <span class=\"type\">const</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elems.<span class=\"built_in\">empty</span>()) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"built_in\">out_of_range</span>(<span class=\"string\">&quot;Stack&lt;&gt;::top(): empty stack&quot;</span>); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 返回最后一个元素的副本 </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> elems.<span class=\"built_in\">back</span>();      &#125; <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123; </span><br><span class=\"line\">        Stack&lt;<span class=\"type\">int</span>&gt;         intStack;  <span class=\"comment\">// int 类型的栈 </span></span><br><span class=\"line\">        Stack&lt;string&gt; stringStack;    <span class=\"comment\">// string 类型的栈 </span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 操作 int 类型的栈 </span></span><br><span class=\"line\">        intStack.<span class=\"built_in\">push</span>(<span class=\"number\">7</span>); </span><br><span class=\"line\">        cout &lt;&lt; intStack.<span class=\"built_in\">top</span>() &lt;&lt;endl; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 操作 string 类型的栈 </span></span><br><span class=\"line\">        stringStack.<span class=\"built_in\">push</span>(<span class=\"string\">&quot;hello&quot;</span>); </span><br><span class=\"line\">        cout &lt;&lt; stringStack.<span class=\"built_in\">top</span>() &lt;&lt; std::endl; </span><br><span class=\"line\">        stringStack.<span class=\"built_in\">pop</span>(); </span><br><span class=\"line\">        stringStack.<span class=\"built_in\">pop</span>(); </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"built_in\">catch</span> (exception <span class=\"type\">const</span>&amp; ex) &#123; </span><br><span class=\"line\">        cerr &lt;&lt; <span class=\"string\">&quot;Exception: &quot;</span> &lt;&lt; ex.<span class=\"built_in\">what</span>() &lt;&lt;endl; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125; &#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">7</span>helloException: Stack&lt;&gt;::<span class=\"built_in\">pop</span>(): empty stack</span><br></pre></td></tr></table></figure>\n<h1 id=\"c-预处理器\"><a class=\"markdownIt-Anchor\" href=\"#c-预处理器\">#</a> C++ 预处理器</h1>\n<p>预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。</p>\n<p>所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。</p>\n<p>我们已经看到，之前所有的实例中都有 <strong>#include</strong> 指令。这个宏用于把头文件包含到源文件中。</p>\n<p>C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等，让我们一起看看这些重要指令。</p>\n<h2 id=\"define-预处理\"><a class=\"markdownIt-Anchor\" href=\"#define-预处理\">#</a> #define 预处理</h2>\n<p>#define 预处理指令用于创建符号常量。该符号常量通常称为<strong>宏</strong>，指令的一般形式是：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> macro-name replacement-text</span></span><br></pre></td></tr></table></figure>\n<p>当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;#<span class=\"keyword\">define</span> PI 3.14159int main ()&#123;     cout &lt;&lt; <span class=\"string\">&quot;Value of PI :&quot;</span> &lt;&lt; PI &lt;&lt; endl;     return 0;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>现在，让我们测试这段代码，看看预处理的结果。假设源代码文件已经存在，接下来使用 -E 选项进行编译，并把结果重定向到 test.p。现在，如果您查看 test.p 文件，将会看到它已经包含大量的信息，而且在文件底部的值被改为如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gcc -E test.cpp &gt; test.p...<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;     cout &lt;&lt; <span class=\"string\">&quot;Value of PI :&quot;</span> &lt;&lt; <span class=\"number\">3.14159</span> &lt;&lt; endl;     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数宏\"><a class=\"markdownIt-Anchor\" href=\"#函数宏\">#</a> 函数宏</h2>\n<p>您可以使用 #define 来定义一个带有参数的宏，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;#<span class=\"keyword\">define</span> MIN(a,b) (a&lt;b ? a : b)int main ()&#123;</span></span><br><span class=\"line\">   <span class=\"type\">int</span> i, j;</span><br><span class=\"line\">   i = <span class=\"number\">100</span>;</span><br><span class=\"line\">   j = <span class=\"number\">30</span>;</span><br><span class=\"line\">   cout &lt;&lt;<span class=\"string\">&quot;较小的值为：&quot;</span> &lt;&lt; <span class=\"built_in\">MIN</span>(i, j) &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">较小的值为：<span class=\"number\">30</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"条件编译\"><a class=\"markdownIt-Anchor\" href=\"#条件编译\">#</a> 条件编译</h2>\n<p>有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。</p>\n<p>条件预处理器的结构与 if 选择结构很像。请看下面这段预处理器的代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> NULL   #<span class=\"keyword\">define</span> NULL 0#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>您可以只在调试时进行编译，调试开关可以使用一个宏来实现，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> DEBUG   cerr &lt;&lt;<span class=\"string\">&quot;Variable x = &quot;</span> &lt;&lt; x &lt;&lt; endl;#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>如果在指令 #ifdef DEBUG 之前已经定义了符号常量 DEBUG，则会对程序中的 <strong>cerr</strong> 语句进行编译。您可以使用 #if 0 语句注释掉程序的一部分，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> 0   不进行编译的代码#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>让我们尝试下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;#<span class=\"keyword\">define</span> DEBUG#<span class=\"keyword\">define</span> MIN(a,b) (((a)&lt;(b)) ? a : b)int main ()&#123;</span></span><br><span class=\"line\">   <span class=\"type\">int</span> i, j;</span><br><span class=\"line\">   i = <span class=\"number\">100</span>;</span><br><span class=\"line\">   j = <span class=\"number\">30</span>;<span class=\"meta\">#<span class=\"keyword\">ifdef</span> DEBUG</span></span><br><span class=\"line\">   cerr &lt;&lt;<span class=\"string\">&quot;Trace: Inside main function&quot;</span> &lt;&lt; endl;<span class=\"meta\">#<span class=\"keyword\">endif</span>#<span class=\"keyword\">if</span> 0</span></span><br><span class=\"line\">   <span class=\"comment\">/* 这是注释部分 */</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"built_in\">MKSTR</span>(HELLO C++) &lt;&lt; endl;<span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt;<span class=\"string\">&quot;The minimum is &quot;</span> &lt;&lt; <span class=\"built_in\">MIN</span>(i, j) &lt;&lt; endl;<span class=\"meta\">#<span class=\"keyword\">ifdef</span> DEBUG</span></span><br><span class=\"line\">   cerr &lt;&lt;<span class=\"string\">&quot;Trace: Coming out of main function&quot;</span> &lt;&lt; endl;<span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Trace: Inside main functionThe minimum is <span class=\"number\">30</span>Trace: Coming out of main function</span><br></pre></td></tr></table></figure>\n<h2 id=\"和-运算符\"><a class=\"markdownIt-Anchor\" href=\"#和-运算符\">#</a> # 和 ## 运算符</h2>\n<p># 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串。</p>\n<p>请看下面的宏定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;#<span class=\"keyword\">define</span> MKSTR( x ) #xint main ()&#123;    cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl;    return 0;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HELLO C++</span><br></pre></td></tr></table></figure>\n<p>让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; <span class=\"built_in\">MKSTR</span>(HELLO C++) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<p>转换成了：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;HELLO C++&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<p>## 运算符用于连接两个令牌。下面是一个实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONCAT( x, y )  x ## y</span></span><br></pre></td></tr></table></figure>\n<p>当 CONCAT 出现在程序中时，它的参数会被连接起来，并用来取代宏。例如，程序中 CONCAT (HELLO, C++) 会被替换为 “HELLO C++”，如下面实例所示。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;#<span class=\"keyword\">define</span> concat(a, b) a ## bint main()&#123;   int xy = 100;      cout &lt;&lt; concat(x, y);   return 0;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n<p>让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; <span class=\"built_in\">concat</span>(x, y);</span><br></pre></td></tr></table></figure>\n<p>转换成了：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; xy;</span><br></pre></td></tr></table></figure>\n<h2 id=\"c-中的预定义宏\"><a class=\"markdownIt-Anchor\" href=\"#c-中的预定义宏\">#</a> C++ 中的预定义宏</h2>\n<p>C++ 提供了下表所示的一些预定义宏：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">宏</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>LINE</strong></td>\n<td style=\"text-align:left\">这会在程序编译时包含当前行号。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>FILE</strong></td>\n<td style=\"text-align:left\">这会在程序编译时包含当前文件名。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>DATE</strong></td>\n<td style=\"text-align:left\">这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>TIME</strong></td>\n<td style=\"text-align:left\">这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。</td>\n</tr>\n</tbody>\n</table>\n<p>让我们看看上述这些宏的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main ()&#123;</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Value of __LINE__ : &quot;</span> &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Value of __FILE__ : &quot;</span> &lt;&lt; __FILE__ &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Value of __DATE__ : &quot;</span> &lt;&lt; __DATE__ &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Value of __TIME__ : &quot;</span> &lt;&lt; __TIME__ &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of __LINE__ : <span class=\"number\">6</span>Value of __FILE__ : test.cppValue of __DATE__ : Feb <span class=\"number\">28</span> <span class=\"number\">2011</span>Value of __TIME__ : <span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">48</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"c-信号处理\"><a class=\"markdownIt-Anchor\" href=\"#c-信号处理\">#</a> C++ 信号处理</h1>\n<p>信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。</p>\n<p>有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 <csignal> 中。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">信号</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">SIGABRT</td>\n<td style=\"text-align:left\">程序的异常终止，如调用 <strong>abort</strong>。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SIGFPE</td>\n<td style=\"text-align:left\">错误的算术运算，比如除以零或导致溢出的操作。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SIGILL</td>\n<td style=\"text-align:left\">检测非法指令。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SIGINT</td>\n<td style=\"text-align:left\">接收到交互注意信号。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SIGSEGV</td>\n<td style=\"text-align:left\">非法访问内存。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SIGTERM</td>\n<td style=\"text-align:left\">发送到程序的终止请求。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"signal-函数\"><a class=\"markdownIt-Anchor\" href=\"#signal-函数\">#</a> signal () 函数</h2>\n<p>C++ 信号处理库提供了 <strong>signal</strong> 函数，用来捕获突发事件。以下是 signal () 函数的语法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">void</span> (*<span class=\"built_in\">signal</span> (<span class=\"type\">int</span> sig, <span class=\"built_in\">void</span> (*func)(<span class=\"type\">int</span>)))(<span class=\"type\">int</span>);</span><br></pre></td></tr></table></figure>\n<p>这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。</p>\n<p>让我们编写一个简单的 C++ 程序，使用 signal () 函数捕获 SIGINT 信号。不管您想在程序中捕获什么信号，您都必须使用 <strong>signal</strong> 函数来注册信号，并将其与信号处理程序相关联。看看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;csignal&gt;</span>using namespace std;void signalHandler( int signum )&#123;</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Interrupt signal (&quot;</span> &lt;&lt; signum &lt;&lt; <span class=\"string\">&quot;) received.\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 清理并关闭</span></span><br><span class=\"line\">    <span class=\"comment\">// 终止程序  </span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">exit</span>(signum);  &#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注册信号 SIGINT 和信号处理程序</span></span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGINT, signalHandler);  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">       cout &lt;&lt; <span class=\"string\">&quot;Going to sleep....&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">       <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Going to sleep....Going to sleep....Going to sleep....</span><br></pre></td></tr></table></figure>\n<p>现在，按 Ctrl+C 来中断程序，您会看到程序捕获信号，程序打印如下内容并退出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Going to sleep....Going to sleep....Going to sleep....<span class=\"function\">Interrupt <span class=\"title\">signal</span> <span class=\"params\">(<span class=\"number\">2</span>)</span> received.</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"raise-函数\"><a class=\"markdownIt-Anchor\" href=\"#raise-函数\">#</a> raise () 函数</h2>\n<p>您可以使用函数 <strong>raise()</strong> 生成信号，该函数带有一个整数信号编号作为参数，语法如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">raise</span> <span class=\"params\">(signal sig)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>在这里，<strong>sig</strong> 是要发送的信号的编号，这些信号包括：SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP。以下是我们使用 raise () 函数内部生成信号的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;csignal&gt;</span>using namespace std;void signalHandler( int signum )&#123;</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Interrupt signal (&quot;</span> &lt;&lt; signum &lt;&lt; <span class=\"string\">&quot;) received.\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 清理并关闭</span></span><br><span class=\"line\">    <span class=\"comment\">// 终止程序 </span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">exit</span>(signum);  &#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 注册信号 SIGINT 和信号处理程序</span></span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGINT, signalHandler);  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(++i)&#123;</span><br><span class=\"line\">       cout &lt;&lt; <span class=\"string\">&quot;Going to sleep....&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>( i == <span class=\"number\">3</span> )&#123;</span><br><span class=\"line\">          <span class=\"built_in\">raise</span>( SIGINT);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果，并会自动退出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Going to sleep....Going to sleep....Going to sleep....<span class=\"function\">Interrupt <span class=\"title\">signal</span> <span class=\"params\">(<span class=\"number\">2</span>)</span> received.</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"c-多线程\"><a class=\"markdownIt-Anchor\" href=\"#c-多线程\">#</a> C++ 多线程</h1>\n<p>多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：<strong>基于进程和基于线程</strong>。</p>\n<ul>\n<li>基于进程的多任务处理是程序的并发执行。</li>\n<li>基于线程的多任务处理是同一程序的片段的并发执行。</li>\n</ul>\n<p>多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。</p>\n<p>本教程假设您使用的是 Linux 操作系统，我们要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。</p>\n<h2 id=\"创建线程\"><a class=\"markdownIt-Anchor\" href=\"#创建线程\">#</a> 创建线程</h2>\n<p>下面的程序，我们可以用它来创建一个 POSIX 线程：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span>pthread_create (thread, attr, start_routine, arg)</span></span><br></pre></td></tr></table></figure>\n<p>在这里，<strong>pthread_create</strong> 创建一个新的线程，并让它可执行。下面是关于参数的说明：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">thread</td>\n<td style=\"text-align:left\">指向线程标识符指针。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">attr</td>\n<td style=\"text-align:left\">一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">start_routine</td>\n<td style=\"text-align:left\">线程运行函数起始地址，一旦线程被创建就会执行。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">arg</td>\n<td style=\"text-align:left\">运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。</td>\n</tr>\n</tbody>\n</table>\n<p>创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。</p>\n<h2 id=\"终止线程\"><a class=\"markdownIt-Anchor\" href=\"#终止线程\">#</a> 终止线程</h2>\n<p>使用下面的程序，我们可以用它来终止一个 POSIX 线程：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span>pthread_exit (status)</span></span><br></pre></td></tr></table></figure>\n<p>在这里，<strong>pthread_exit</strong> 用于显式地退出一个线程。通常情况下，pthread_exit () 函数是在线程完成工作后无需继续存在时被调用。</p>\n<p>如果 main () 是在它所创建的线程之前结束，并通过 pthread_exit () 退出，那么其他线程将继续执行。否则，它们将在 main () 结束时自动被终止。</p>\n<h2 id=\"实例-26\"><a class=\"markdownIt-Anchor\" href=\"#实例-26\">#</a> 实例</h2>\n<p>以下简单的实例代码使用 pthread_create () 函数创建了 5 个线程，每个线程输出 &quot;Hello Runoob！&quot;:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span><span class=\"comment\">// 必须的头文件是#include &lt;pthread.h&gt;using namespace std;#define NUM_THREADS 5// 线程的运行函数void* say_hello(void* args)&#123;</span></span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Hello Runoob！&quot;</span> &lt;&lt; endl;&#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义线程的 id 变量，多个变量使用数组</span></span><br><span class=\"line\">    <span class=\"type\">pthread_t</span> tids[NUM_THREADS];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; NUM_THREADS; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"built_in\">pthread_create</span>(&amp;tids[i], <span class=\"literal\">NULL</span>, say_hello, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">           cout &lt;&lt; <span class=\"string\">&quot;pthread_create error: error_code=&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来；</span></span><br><span class=\"line\">    <span class=\"built_in\">pthread_exit</span>(<span class=\"literal\">NULL</span>);&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 -lpthread 库编译下面的程序：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ test.cpp -lpthread -o test.o</span><br></pre></td></tr></table></figure>\n<p>现在，执行程序，将产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./test.oHello Runoob！Hello Runoob！Hello Runoob！Hello Runoob！Hello Runoob！</span><br></pre></td></tr></table></figure>\n<p>以下简单的实例代码使用 pthread_create () 函数创建了 5 个线程，并接收传入的参数。每个线程打印一个 “Hello Runoob!” 消息，并输出接收的参数，然后调用 pthread_exit () 终止线程。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//文件名：test.cpp#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;pthread.h&gt;using namespace std;#define NUM_THREADS     5void *PrintHello(void *threadid)&#123;  </span></span><br><span class=\"line\">   <span class=\"comment\">// 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取</span></span><br><span class=\"line\">   <span class=\"type\">int</span> tid = *((<span class=\"type\">int</span>*)threadid);</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Hello Runoob! 线程 ID, &quot;</span> &lt;&lt; tid &lt;&lt; endl;</span><br><span class=\"line\">   <span class=\"built_in\">pthread_exit</span>(<span class=\"literal\">NULL</span>);&#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">pthread_t</span> threads[NUM_THREADS];</span><br><span class=\"line\">   <span class=\"type\">int</span> indexes[NUM_THREADS];<span class=\"comment\">// 用数组来保存i的值</span></span><br><span class=\"line\">   <span class=\"type\">int</span> rc;</span><br><span class=\"line\">   <span class=\"type\">int</span> i;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( i=<span class=\"number\">0</span>; i &lt; NUM_THREADS; i++ )&#123;      </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;main() : 创建线程, &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">      indexes[i] = i; <span class=\"comment\">//先保存i的值</span></span><br><span class=\"line\">      <span class=\"comment\">// 传入的时候必须强制转换为void* 类型，即无类型指针        </span></span><br><span class=\"line\">      rc = <span class=\"built_in\">pthread_create</span>(&amp;threads[i], <span class=\"literal\">NULL</span>, </span><br><span class=\"line\">                          PrintHello, (<span class=\"type\">void</span> *)&amp;(indexes[i]));</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rc)&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Error:无法创建线程,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class=\"line\">         <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">pthread_exit</span>(<span class=\"literal\">NULL</span>);&#125;</span><br></pre></td></tr></table></figure>\n<p>现在编译并执行程序，将产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ test.cpp -lpthread -o test.o$ ./test.<span class=\"built_in\">omain</span>() : 创建线程, <span class=\"number\">0</span>main() : 创建线程, <span class=\"number\">1</span>main() : 创建线程, <span class=\"number\">2</span>main() : 创建线程, <span class=\"number\">3</span>main() : 创建线程, <span class=\"number\">4</span>Hello Runoob! 线程 ID, <span class=\"number\">4</span>Hello Runoob! 线程 ID, <span class=\"number\">3</span>Hello Runoob! 线程 ID, <span class=\"number\">2</span>Hello Runoob! 线程 ID, <span class=\"number\">1</span>Hello Runoob! 线程 ID, <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"向线程传递参数\"><a class=\"markdownIt-Anchor\" href=\"#向线程传递参数\">#</a> 向线程传递参数</h2>\n<p>这个实例演示了如何通过结构传递多个参数。您可以在线程回调中传递任意的数据类型，因为它指向 void，如下面的实例所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span>using namespace std;#<span class=\"keyword\">define</span> NUM_THREADS     5struct thread_data&#123;   int  thread_id;   char *message;&#125;;void *PrintHello(void *threadarg)&#123;   struct thread_data *my_data;   my_data = (struct thread_data *) threadarg;   cout <span class=\"string\">&lt;&lt; &quot;Thread ID : &quot; &lt;&lt; my_data-&gt;</span>thread_id ;   cout <span class=\"string\">&lt;&lt; &quot; Message : &quot; &lt;&lt; my_data-&gt;</span>message &lt;&lt; endl;   pthread_exit(NULL);&#125;int main ()&#123;   pthread_t threads[NUM_THREADS];   struct thread_data td[NUM_THREADS];   int rc;   int i;   for( i=0; i &lt; NUM_THREADS; i++ )&#123;      cout &lt;&lt;<span class=\"string\">&quot;main() : creating thread, &quot;</span> &lt;&lt; i &lt;&lt; endl;      td[i].thread_id = i;      td[i].message = <span class=\"string\">&quot;This is message&quot;</span>;      rc = pthread_create(&amp;threads[i], NULL,                          PrintHello, (void *)&amp;td[i]);      <span class=\"keyword\">if</span> (rc)&#123;         cout &lt;&lt; <span class=\"string\">&quot;Error:unable to create thread,&quot;</span> &lt;&lt; rc &lt;&lt; endl;         exit(-1);      &#125;   &#125;   pthread_exit(NULL);&#125;</span></span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ test.cpp -lpthread -o test.o</span><br><span class=\"line\">$ ./test.<span class=\"function\">o</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">main</span><span class=\"params\">()</span> : 创建线程, <span class=\"number\">0</span>main() : 创建线程, <span class=\"number\">1</span>main() : 创建线程, <span class=\"number\">2</span>main() : 创建线程, <span class=\"number\">3</span>main() : 创建线程, <span class=\"number\">4</span>Hello Runoob! 线程 ID, <span class=\"number\">4</span>Hello Runoob! 线程 ID, <span class=\"number\">3</span>Hello Runoob! 线程 ID, <span class=\"number\">2</span>Hello Runoob! 线程 ID, <span class=\"number\">1</span>Hello Runoob! 线程 ID, <span class=\"number\">0</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"连接和分离线程\"><a class=\"markdownIt-Anchor\" href=\"#连接和分离线程\">#</a> 连接和分离线程</h2>\n<p>我们可以使用以下两个函数来连接或分离线程：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">pthread_join</span> (threadid, status) <span class=\"built_in\">pthread_detach</span> (threadid)</span><br></pre></td></tr></table></figure>\n<p>pthread_join () 子程序阻碍调用程序，直到指定的 threadid 线程终止为止。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。</p>\n<p>这个实例演示了如何使用 pthread_join () 函数来等待线程的完成。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span>using namespace std;#<span class=\"keyword\">define</span> NUM_THREADS     5void *wait(void *t)&#123;</span></span><br><span class=\"line\">   <span class=\"type\">int</span> i;</span><br><span class=\"line\">   <span class=\"type\">long</span> tid;</span><br><span class=\"line\"></span><br><span class=\"line\">   tid = (<span class=\"type\">long</span>)t;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Sleeping in thread &quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Thread with id : &quot;</span> &lt;&lt; tid &lt;&lt; <span class=\"string\">&quot;  ...exiting &quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   <span class=\"built_in\">pthread_exit</span>(<span class=\"literal\">NULL</span>);&#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> rc;</span><br><span class=\"line\">   <span class=\"type\">int</span> i;</span><br><span class=\"line\">   <span class=\"type\">pthread_t</span> threads[NUM_THREADS];</span><br><span class=\"line\">   <span class=\"type\">pthread_attr_t</span> attr;</span><br><span class=\"line\">   <span class=\"type\">void</span> *status;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 初始化并设置线程为可连接的（joinable）</span></span><br><span class=\"line\">   <span class=\"built_in\">pthread_attr_init</span>(&amp;attr);</span><br><span class=\"line\">   <span class=\"built_in\">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span>( i=<span class=\"number\">0</span>; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;main() : creating thread, &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">      rc = <span class=\"built_in\">pthread_create</span>(&amp;threads[i], <span class=\"literal\">NULL</span>, wait, (<span class=\"type\">void</span> *)&amp;i );</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rc)&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Error:unable to create thread,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class=\"line\">         <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 删除属性，并等待其他线程</span></span><br><span class=\"line\">   <span class=\"built_in\">pthread_attr_destroy</span>(&amp;attr);</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( i=<span class=\"number\">0</span>; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class=\"line\">      rc = <span class=\"built_in\">pthread_join</span>(threads[i], &amp;status);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rc)&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Error:unable to join,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class=\"line\">         <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Main: completed thread id :&quot;</span> &lt;&lt; i ;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;  exiting with status :&quot;</span> &lt;&lt; status &lt;&lt; endl;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Main: program exiting.&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   <span class=\"built_in\">pthread_exit</span>(<span class=\"literal\">NULL</span>);&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">main</span>() : creating thread, <span class=\"number\">0</span>main() : creating thread, <span class=\"number\">1</span>main() : creating thread, <span class=\"number\">2</span>main() : creating thread, <span class=\"number\">3</span>main() : creating thread, <span class=\"number\">4</span>Sleeping in thread </span><br><span class=\"line\">Thread with id : <span class=\"number\">4</span>  ...exiting </span><br><span class=\"line\">Sleeping in thread </span><br><span class=\"line\">Thread with id : <span class=\"number\">3</span>  ...exiting </span><br><span class=\"line\">Sleeping in thread </span><br><span class=\"line\">Thread with id : <span class=\"number\">2</span>  ...exiting </span><br><span class=\"line\">Sleeping in thread </span><br><span class=\"line\">Thread with id : <span class=\"number\">1</span>  ...exiting </span><br><span class=\"line\">Sleeping in thread </span><br><span class=\"line\">Thread with id : <span class=\"number\">0</span>  ...exiting </span><br><span class=\"line\">Main: completed thread id :<span class=\"number\">0</span>  exiting with status :<span class=\"number\">0</span>Main: completed thread id :<span class=\"number\">1</span>  exiting with status :<span class=\"number\">0</span>Main: completed thread id :<span class=\"number\">2</span>  exiting with status :<span class=\"number\">0</span>Main: completed thread id :<span class=\"number\">3</span>  exiting with status :<span class=\"number\">0</span>Main: completed thread id :<span class=\"number\">4</span>  exiting with status :<span class=\"number\">0</span>Main: program exiting.</span><br></pre></td></tr></table></figure>\n<h1 id=\"c-web-编程\"><a class=\"markdownIt-Anchor\" href=\"#c-web-编程\">#</a> C++ Web 编程</h1>\n<h2 id=\"什么是-cgi\"><a class=\"markdownIt-Anchor\" href=\"#什么是-cgi\">#</a> 什么是 CGI？</h2>\n<ul>\n<li>公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。</li>\n<li>CGI 规范目前是由 NCSA 维护的，NCSA 定义 CGI 如下：</li>\n<li>公共网关接口（CGI），是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。</li>\n<li>目前的版本是 CGI/1.1，CGI/1.2 版本正在推进中。</li>\n</ul>\n<h2 id=\"web-浏览\"><a class=\"markdownIt-Anchor\" href=\"#web-浏览\">#</a> Web 浏览</h2>\n<p>为了更好地了解 CGI 的概念，让我们点击一个超链接，浏览一个特定的网页或 URL，看看会发生什么。</p>\n<ul>\n<li>您的浏览器联系上 HTTP Web 服务器，并请求 URL，即文件名。</li>\n<li>Web 服务器将解析 URL，并查找文件名。如果找到请求的文件，Web 服务器会把文件发送回浏览器，否则发送一条错误消息，表明您请求了一个错误的文件。</li>\n<li>Web 浏览器从 Web 服务器获取响应，并根据接收到的响应来显示文件或错误消息。</li>\n</ul>\n<p>然而，以这种方式搭建起来的 HTTP 服务器，不管何时请求目录中的某个文件，HTTP 服务器发送回来的不是该文件，而是以程序形式执行，并把执行产生的输出发送回浏览器显示出来。</p>\n<p>公共网关接口（CGI），是使得应用程序（称为 CGI 程序或 CGI 脚本）能够与 Web 服务器以及客户端进行交互的标准协议。这些 CGI 程序可以用 Python、PERL、Shell、C 或 C++ 等进行编写。</p>\n<h2 id=\"cgi-架构图\"><a class=\"markdownIt-Anchor\" href=\"#cgi-架构图\">#</a> CGI 架构图</h2>\n<p>下图演示了 CGI 的架构：</p>\n<p><img data-src=\"https://edu.aliyun.com/files/course/2017/09-24/1655506773c2493212.gif\" alt=\"img\"></p>\n<h2 id=\"web-服务器配置\"><a class=\"markdownIt-Anchor\" href=\"#web-服务器配置\">#</a> Web 服务器配置</h2>\n<p>在您进行 CGI 编程之前，请确保您的 Web 服务器支持 CGI，并已配置成可以处理 CGI 程序。所有由 HTTP 服务器执行的 CGI 程序，都必须在预配置的目录中。该目录称为 CGI 目录，按照惯例命名为 /var/www/cgi-bin。虽然 CGI 文件是 C++ 可执行文件，但是按照惯例它的扩展名是 <strong>.cgi</strong>。</p>\n<p>默认情况下，Apache Web 服务器会配置在 /var/www/cgi-bin 中运行 CGI 程序。如果您想指定其他目录来运行 CGI 脚本，您可以在 httpd.conf 文件中修改以下部分：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Directory <span class=\"string\">&quot;/var/www/cgi-bin&quot;</span>&gt;   AllowOverride None   Options ExecCGI   Order allow,deny   Allow from all&lt;/Directory&gt; &lt;Directory <span class=\"string\">&quot;/var/www/cgi-bin&quot;</span>&gt;Options All&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>\n<p>在这里，我们假设已经配置好 Web 服务器并能成功运行，你可以运行任意的 CGI 程序，比如 Perl 或 Shell 等。</p>\n<h2 id=\"第一个-cgi-程序\"><a class=\"markdownIt-Anchor\" href=\"#第一个-cgi-程序\">#</a> 第一个 CGI 程序</h2>\n<p>请看下面的 C++ 程序：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;Hello World - 第一个 CGI 程序&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;h2&gt;Hello World! 这是我的第一个 CGI 程序&lt;/h2&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>编译上面的代码，把可执行文件命名为 cplusplus.cgi，并把这个文件保存在 /var/www/cgi-bin 目录中。在运行 CGI 程序之前，请使用 <strong>chmod 755 cplusplus.cgi</strong> UNIX 命令来修改文件模式，确保文件可执行。访问可执行文件，您会看到下面的输出：</p>\n<h2 id=\"hello-world-这是我的第一个-cgi-程序\"><a class=\"markdownIt-Anchor\" href=\"#hello-world-这是我的第一个-cgi-程序\">#</a> Hello World! 这是我的第一个 CGI 程序</h2>\n<p>上面的 C++ 程序是一个简单的程序，把它的输出写在 STDOUT 文件上，即显示在屏幕上。在这里，值得注意一点，第一行输出 <strong>Content-type:text/html\\r\\n\\r\\n</strong>。这一行发送回浏览器，并指定要显示在浏览器窗口上的内容类型。您必须理解 CGI 的基本概念，这样才能进一步使用 Python 编写更多复杂的 CGI 程序。C++ CGI 程序可以与任何其他外部的系统（如 RDBMS）进行交互。</p>\n<h2 id=\"http-头信息\"><a class=\"markdownIt-Anchor\" href=\"#http-头信息\">#</a> HTTP 头信息</h2>\n<p>行 <strong>Content-type:text/html\\r\\n\\r\\n</strong> 是 HTTP 头信息的组成部分，它被发送到浏览器，以便更好地理解页面内容。HTTP 头信息的形式如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP 字段名称: 字段内容 例如Content-type: text/html\\r\\n\\r\\n</span><br></pre></td></tr></table></figure>\n<p>还有一些其他的重要的 HTTP 头信息，这些在您的 CGI 编程中都会经常被用到。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">头信息</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Content-type:</td>\n<td style=\"text-align:left\">MIME 字符串，定义返回的文件格式。例如 Content-type:text/html。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Expires: Date</td>\n<td style=\"text-align:left\">信息变成无效的日期。浏览器使用它来判断一个页面何时需要刷新。一个有效的日期字符串的格式应为 01 Jan 1998 12:00:00 GMT。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Location: URL</td>\n<td style=\"text-align:left\">这个 URL 是指应该返回的 URL，而不是请求的 URL。你可以使用它来重定向一个请求到任意的文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Last-modified: Date</td>\n<td style=\"text-align:left\">资源的最后修改日期。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Content-length: N</td>\n<td style=\"text-align:left\">要返回的数据的长度，以字节为单位。浏览器使用这个值来表示一个文件的预计下载时间。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Set-Cookie: String</td>\n<td style=\"text-align:left\">通过 <em>string</em> 设置 cookie。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"cgi-环境变量\"><a class=\"markdownIt-Anchor\" href=\"#cgi-环境变量\">#</a> CGI 环境变量</h2>\n<p>所有的 CGI 程序都可以访问下列的环境变量。这些变量在编写 CGI 程序时扮演了非常重要的角色。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">变量名</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">CONTENT_TYPE</td>\n<td style=\"text-align:left\">内容的数据类型。当客户端向服务器发送附加内容时使用。例如，文件上传等功能。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CONTENT_LENGTH</td>\n<td style=\"text-align:left\">查询的信息长度。只对 POST 请求可用。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HTTP_COOKIE</td>\n<td style=\"text-align:left\">以键 &amp; 值对的形式返回设置的 cookies。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HTTP_USER_AGENT</td>\n<td style=\"text-align:left\">用户代理请求标头字段，递交用户发起请求的有关信息，包含了浏览器的名称、版本和其他平台性的附加信息。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PATH_INFO</td>\n<td style=\"text-align:left\">CGI 脚本的路径。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">QUERY_STRING</td>\n<td style=\"text-align:left\">通过 GET 方法发送请求时的 URL 编码信息，包含 URL 中问号后面的参数。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">REMOTE_ADDR</td>\n<td style=\"text-align:left\">发出请求的远程主机的 IP 地址。这在日志记录和认证时是非常有用的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">REMOTE_HOST</td>\n<td style=\"text-align:left\">发出请求的主机的完全限定名称。如果此信息不可用，则可以用 REMOTE_ADDR 来获取 IP 地址。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">REQUEST_METHOD</td>\n<td style=\"text-align:left\">用于发出请求的方法。最常见的方法是 GET 和 POST。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SCRIPT_FILENAME</td>\n<td style=\"text-align:left\">CGI 脚本的完整路径。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SCRIPT_NAME</td>\n<td style=\"text-align:left\">CGI 脚本的名称。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SERVER_NAME</td>\n<td style=\"text-align:left\">服务器的主机名或 IP 地址。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SERVER_SOFTWARE</td>\n<td style=\"text-align:left\">服务器上运行的软件的名称和版本。</td>\n</tr>\n</tbody>\n</table>\n<p>下面的 CGI 程序列出了所有的 CGI 变量。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span>using namespace std;const string ENV[ 24 ] = &#123;                 </span></span><br><span class=\"line\">        <span class=\"string\">&quot;COMSPEC&quot;</span>, <span class=\"string\">&quot;DOCUMENT_ROOT&quot;</span>, <span class=\"string\">&quot;GATEWAY_INTERFACE&quot;</span>,   </span><br><span class=\"line\">        <span class=\"string\">&quot;HTTP_ACCEPT&quot;</span>, <span class=\"string\">&quot;HTTP_ACCEPT_ENCODING&quot;</span>,    &amp;nbsnbsp;        </span><br><span class=\"line\">        <span class=\"string\">&quot;HTTP_ACCEPT_LANGUAGE&quot;</span>, <span class=\"string\">&quot;HTTP_CONNECTION&quot;</span>,         </span><br><span class=\"line\">        <span class=\"string\">&quot;HTTP_HOST&quot;</span>, <span class=\"string\">&quot;HTTP_USER_AGENT&quot;</span>, <span class=\"string\">&quot;PATH&quot;</span>,            </span><br><span class=\"line\">        <span class=\"string\">&quot;QUERY_STRING&quot;</span>, <span class=\"string\">&quot;REMOTE_ADDR&quot;</span>, <span class=\"string\">&quot;REMOTE_PORT&quot;</span>,      </span><br><span class=\"line\">        <span class=\"string\">&quot;REQUEST_METHOD&quot;</span>, <span class=\"string\">&quot;REQUEST_URI&quot;</span>, <span class=\"string\">&quot;SCRIPT_FILENAME&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;SCRIPT_NAME&quot;</span>, <span class=\"string\">&quot;SERVER_ADDR&quot;</span>, <span class=\"string\">&quot;SERVER_ADMIN&quot;</span>,      </span><br><span class=\"line\">        <span class=\"string\">&quot;SERVER_NAME&quot;</span>,<span class=\"string\">&quot;SERVER_PORT&quot;</span>,<span class=\"string\">&quot;SERVER_PROTOCOL&quot;</span>,     </span><br><span class=\"line\">        <span class=\"string\">&quot;SERVER_SIGNATURE&quot;</span>,<span class=\"string\">&quot;SERVER_SOFTWARE&quot;</span> &#125;;   <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;CGI 环境变量&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;table border = \\&quot;0\\&quot; cellspacing = \\&quot;2\\&quot;&gt;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span> ( <span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">24</span>; i++ )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       cout &lt;&lt; <span class=\"string\">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span> &lt;&lt; ENV[ i ] &lt;&lt; <span class=\"string\">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 尝试检索环境变量的值</span></span><br><span class=\"line\">       <span class=\"type\">char</span> *value = <span class=\"built_in\">getenv</span>( ENV[ i ].<span class=\"built_in\">c_str</span>() );  </span><br><span class=\"line\">       <span class=\"keyword\">if</span> ( value != <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">         cout &lt;&lt; value;                                 </span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;环境变量不存在。&quot;</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       cout &lt;&lt; <span class=\"string\">&quot;&lt;/td&gt;&lt;/tr&gt;\\n&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/table&gt;&lt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"c-cgi-库\"><a class=\"markdownIt-Anchor\" href=\"#c-cgi-库\">#</a> C++ CGI 库</h2>\n<p>在真实的实例中，您需要通过 CGI 程序执行许多操作。这里有一个专为 C++ 程序而编写的 CGI 库，我们可以从 <span class=\"exturl\" data-url=\"ZnRwOi8vZnRwLmdudS5vcmcvZ251L2NnaWNjLw==\">ftp://ftp.gnu.org/gnu/cgicc/</span> 上下载这个 CGI 库，并按照下面的步骤安装库：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$tar xzf cgicc-X.X.X.tar.gz $cd cgicc-X.X.X/ $./configure --prefix=/usr $make$make install</span><br></pre></td></tr></table></figure>\n<p>您可以点击 C++ CGI Lib Documentation，查看相关的库文档。</p>\n<h2 id=\"get-和-post-方法\"><a class=\"markdownIt-Anchor\" href=\"#get-和-post-方法\">#</a> GET 和 POST 方法</h2>\n<p>您可能有遇到过这样的情况，当您需要从浏览器传递一些信息到 Web 服务器，最后再传到 CGI 程序。通常浏览器会使用两种方法把这个信息传到 Web 服务器，分别是 GET 和 POST 方法。</p>\n<h2 id=\"使用-get-方法传递信息\"><a class=\"markdownIt-Anchor\" href=\"#使用-get-方法传递信息\">#</a> 使用 GET 方法传递信息</h2>\n<p>GET 方法发送已编码的用户信息追加到页面请求中。页面和已编码信息通过？字符分隔开，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http:<span class=\"comment\">//www.test.com/cgi-bin/cpp.cgi?key1=value1&amp;key2=value2</span></span><br></pre></td></tr></table></figure>\n<p>GET 方法是默认的从浏览器向 Web 服务器传信息的方法，它会在浏览器的地址栏中生成一串很长的字符串。当您向服务器传密码或其他一些敏感信息时，不要使用 GET 方法。GET 方法有大小限制，在一个请求字符串中最多可以传 1024 个字符。</p>\n<p>当使用 GET 方法时，是使用 QUERY_STRING http 头来传递信息，在 CGI 程序中可使用 QUERY_STRING 环境变量来访问。</p>\n<p>您可以通过在 URL 后跟上简单连接的键值对，也可以通过使用 HTML <FORM> 标签的 GET 方法来传信息。</p>\n<h2 id=\"简单的-url-实例get-方法\"><a class=\"markdownIt-Anchor\" href=\"#简单的-url-实例get-方法\">#</a> 简单的 URL 实例：Get 方法</h2>\n<p>下面是一个简单的 URL，使用 GET 方法传递两个值给 hello_get.py 程序。</p>\n<p>/cgi-bin/cpp_get.cgi?first_name=ZARA&amp;last_name=ALI</p>\n<p>下面的实例生成 <strong>cpp_get.cgi</strong> CGI 程序，用于处理 Web 浏览器给出的输入。通过使用 C++ CGI 库，可以很容易地访问传递的信息：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span>  using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc formData;</span><br><span class=\"line\">   </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;使用 GET 和 POST 方法&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   form_iterator fi = formData.<span class=\"built_in\">getElement</span>(<span class=\"string\">&quot;first_name&quot;</span>);  </span><br><span class=\"line\">   <span class=\"keyword\">if</span>( !fi-&gt;<span class=\"built_in\">isEmpty</span>() &amp;&amp; fi != (*formData).<span class=\"built_in\">end</span>()) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;名：&quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;No text entered for first name&quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   fi = formData.<span class=\"built_in\">getElement</span>(<span class=\"string\">&quot;last_name&quot;</span>);  </span><br><span class=\"line\">   <span class=\"keyword\">if</span>( !fi-&gt;<span class=\"built_in\">isEmpty</span>() &amp;&amp;fi != (*formData).<span class=\"built_in\">end</span>()) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;姓：&quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;No text entered for last name&quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，编译上面的程序，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$g++ -o cpp_get.cgi cpp_get.cpp -lcgicc</span><br></pre></td></tr></table></figure>\n<p>生成 cpp_get.cgi，并把它放在 CGI 目录中，并尝试使用下面的链接进行访问：</p>\n<p>/cgi-bin/cpp_get.cgi?first_name=ZARA&amp;last_name=ALI</p>\n<p>这会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">名：ZARA 姓：ALI</span><br></pre></td></tr></table></figure>\n<h2 id=\"简单的表单实例get-方法\"><a class=\"markdownIt-Anchor\" href=\"#简单的表单实例get-方法\">#</a> 简单的表单实例：GET 方法</h2>\n<p>下面是一个简单的实例，使用 HTML 表单和提交按钮传递两个值。我们将使用相同的 CGI 脚本 cpp_get.cgi 来处理输入。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=<span class=\"string\">&quot;/cgi-bin/cpp_get.cgi&quot;</span> method=<span class=\"string\">&quot;get&quot;</span>&gt;名：&lt;input type=<span class=\"string\">&quot;text&quot;</span> name=<span class=\"string\">&quot;first_name&quot;</span>&gt;  &lt;br /&gt; 姓：&lt;input type=<span class=\"string\">&quot;text&quot;</span> name=<span class=\"string\">&quot;last_name&quot;</span> /&gt;&lt;input type=<span class=\"string\">&quot;submit&quot;</span> value=<span class=\"string\">&quot;提交&quot;</span> /&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n<p>下面是上述表单的实际输出，请输入名和姓，然后点击提交按钮查看结果。</p>\n<h2 id=\"使用-post-方法传递信息\"><a class=\"markdownIt-Anchor\" href=\"#使用-post-方法传递信息\">#</a> 使用 POST 方法传递信息</h2>\n<p>一个更可靠的向 CGI 程序传递信息的方法是 POST 方法。这种方法打包信息的方式与 GET 方法相同，不同的是，它不是把信息以文本字符串形式放在 URL 中的？之后进行传递，而是把它以单独的消息形式进行传递。该消息是以标准输入的形式传给 CGI 脚本的。</p>\n<p>我们同样使用 cpp_get.cgi 程序来处理 POST 方法。让我们以同样的例子，通过使用 HTML 表单和提交按钮来传递两个值，只不过这次我们使用的不是 GET 方法，而是 POST 方法，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=<span class=\"string\">&quot;/cgi-bin/cpp_get.cgi&quot;</span> method=<span class=\"string\">&quot;post&quot;</span>&gt;名：&lt;input type=<span class=\"string\">&quot;text&quot;</span> name=<span class=\"string\">&quot;first_name&quot;</span>&gt;&lt;br /&gt;姓：&lt;input type=<span class=\"string\">&quot;text&quot;</span> name=<span class=\"string\">&quot;last_name&quot;</span> /&gt; &lt;input type=<span class=\"string\">&quot;submit&quot;</span> value=<span class=\"string\">&quot;提交&quot;</span> /&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"向-cgi-程序传递复选框数据\"><a class=\"markdownIt-Anchor\" href=\"#向-cgi-程序传递复选框数据\">#</a> 向 CGI 程序传递复选框数据</h2>\n<p>当需要选择多个选项时，我们使用复选框。</p>\n<p>下面的 HTML 代码实例是一个带有两个复选框的表单：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;/cgi-bin/cpp_checkbox.cgi&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">method</span>=<span class=\"string\">&quot;POST&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">target</span>=<span class=\"string\">&quot;_blank&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;maths&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;on&quot;</span> /&gt;</span> 数学<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;physics&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;on&quot;</span> /&gt;</span> 物理<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;选择学科&quot;</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>下面的 C++ 程序会生成 cpp_checkbox.cgi 脚本，用于处理 Web 浏览器通过复选框给出的输入。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span> using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc formData;</span><br><span class=\"line\">   <span class=\"type\">bool</span> maths_flag, physics_flag;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;向 CGI 程序传递复选框数据&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   maths_flag = formData.<span class=\"built_in\">queryCheckbox</span>(<span class=\"string\">&quot;maths&quot;</span>);</span><br><span class=\"line\">   <span class=\"keyword\">if</span>( maths_flag ) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Maths Flag: ON &quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Maths Flag: OFF &quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   physics_flag = formData.<span class=\"built_in\">queryCheckbox</span>(<span class=\"string\">&quot;physics&quot;</span>);</span><br><span class=\"line\">   <span class=\"keyword\">if</span>( physics_flag ) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Physics Flag: ON &quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Physics Flag: OFF &quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"向-cgi-程序传递单选按钮数据\"><a class=\"markdownIt-Anchor\" href=\"#向-cgi-程序传递单选按钮数据\">#</a> 向 CGI 程序传递单选按钮数据</h2>\n<p>当只需要选择一个选项时，我们使用单选按钮。</p>\n<p>下面的 HTML 代码实例是一个带有两个单选按钮的表单：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=<span class=\"string\">&quot;/cgi-bin/cpp_radiobutton.cgi&quot;</span> </span><br><span class=\"line\">         method=<span class=\"string\">&quot;post&quot;</span> </span><br><span class=\"line\">         target=<span class=\"string\">&quot;_blank&quot;</span>&gt;&lt;input type=<span class=\"string\">&quot;radio&quot;</span> name=<span class=\"string\">&quot;subject&quot;</span> value=<span class=\"string\">&quot;maths&quot;</span> </span><br><span class=\"line\">                                    checked=<span class=\"string\">&quot;checked&quot;</span>/&gt; 数学 </span><br><span class=\"line\">&lt;input type=<span class=\"string\">&quot;radio&quot;</span> name=<span class=\"string\">&quot;subject&quot;</span> value=<span class=\"string\">&quot;physics&quot;</span> /&gt; 物理&lt;input type=<span class=\"string\">&quot;submit&quot;</span> value=<span class=\"string\">&quot;选择学科&quot;</span> /&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n<p>下面的 C++ 程序会生成 cpp_radiobutton.cgi 脚本，用于处理 Web 浏览器通过单选按钮给出的输入。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span> using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc formData;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;向 CGI 程序传递单选按钮数据&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   form_iterator fi = formData.<span class=\"built_in\">getElement</span>(<span class=\"string\">&quot;subject&quot;</span>);  </span><br><span class=\"line\">   <span class=\"keyword\">if</span>( !fi-&gt;<span class=\"built_in\">isEmpty</span>() &amp;&amp; fi != (*formData).<span class=\"built_in\">end</span>()) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Radio box selected: &quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"向-cgi-程序传递文本区域数据\"><a class=\"markdownIt-Anchor\" href=\"#向-cgi-程序传递文本区域数据\">#</a> 向 CGI 程序传递文本区域数据</h2>\n<p>当需要向 CGI 程序传递多行文本时，我们使用 TEXTAREA 元素。</p>\n<p>下面的 HTML 代码实例是一个带有 TEXTAREA 框的表单：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=&quot;/cgi-bin/cpp_textarea.cgi&quot; </span><br><span class=\"line\">         method=&quot;post&quot; </span><br><span class=\"line\">         target=&quot;_blank&quot;&gt;&lt;textarea name=&quot;textcontent&quot; cols=&quot;40&quot; rows=&quot;4&quot;&gt;请在这里输入文本...&lt;/textarea&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n<p>下面的 C++ 程序会生成 cpp_textarea.cgi 脚本，用于处理 Web 浏览器通过文本区域给出的输入。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span> using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc formData;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;向 CGI 程序传递文本区域数据&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   form_iterator fi = formData.<span class=\"built_in\">getElement</span>(<span class=\"string\">&quot;textcontent&quot;</span>);  </span><br><span class=\"line\">   <span class=\"keyword\">if</span>( !fi-&gt;<span class=\"built_in\">isEmpty</span>() &amp;&amp; fi != (*formData).<span class=\"built_in\">end</span>()) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Text Content: &quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;No text entered&quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"向-cgi-程序传递下拉框数据\"><a class=\"markdownIt-Anchor\" href=\"#向-cgi-程序传递下拉框数据\">#</a> 向 CGI 程序传递下拉框数据</h2>\n<p>当有多个选项可用，但只能选择一个或两个选项时，我们使用下拉框。</p>\n<p>下面的 HTML 代码实例是一个带有下拉框的表单：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=<span class=\"string\">&quot;/cgi-bin/cpp_dropdown.cgi&quot;</span> </span><br><span class=\"line\">                       method=<span class=\"string\">&quot;post&quot;</span> target=<span class=\"string\">&quot;_blank&quot;</span>&gt;&lt;select name=<span class=\"string\">&quot;dropdown&quot;</span>&gt;&lt;option value=<span class=\"string\">&quot;Maths&quot;</span> selected&gt;数学&lt;/option&gt;&lt;option value=<span class=\"string\">&quot;Physics&quot;</span>&gt;物理&lt;/option&gt;&lt;/select&gt;&lt;input type=<span class=\"string\">&quot;submit&quot;</span> value=<span class=\"string\">&quot;提交&quot;</span>/&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n<p>下面的 C++ 程序会生成 cpp_dropdown.cgi 脚本，用于处理 Web 浏览器通过下拉框给出的输入。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span> using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc formData;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;向 CGI 程序传递下拉框数据&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   form_iterator fi = formData.<span class=\"built_in\">getElement</span>(<span class=\"string\">&quot;dropdown&quot;</span>);  </span><br><span class=\"line\">   <span class=\"keyword\">if</span>( !fi-&gt;<span class=\"built_in\">isEmpty</span>() &amp;&amp; fi != (*formData).<span class=\"built_in\">end</span>()) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Value Selected: &quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"在-cgi-中使用-cookies\"><a class=\"markdownIt-Anchor\" href=\"#在-cgi-中使用-cookies\">#</a> 在 CGI 中使用 Cookies</h2>\n<p>HTTP 协议是一种无状态的协议。但对于一个商业网站，它需要在不同页面间保持会话信息。例如，一个用户在完成多个页面的步骤之后结束注册。但是，如何在所有网页中保持用户的会话信息。</p>\n<p>在许多情况下，使用 cookies 是记忆和跟踪有关用户喜好、购买、佣金以及其他为追求更好的游客体验或网站统计所需信息的最有效的方法。</p>\n<h3 id=\"它是如何工作的\"><a class=\"markdownIt-Anchor\" href=\"#它是如何工作的\">#</a> 它是如何工作的</h3>\n<p>服务器以 cookie 的形式向访客的浏览器发送一些数据。如果浏览器接受了 cookie，则 cookie 会以纯文本记录的形式存储在访客的硬盘上。现在，当访客访问网站上的另一个页面时，会检索 cookie。一旦找到 cookie，服务器就知道存储了什么。</p>\n<p>cookie 是一种纯文本的数据记录，带有 5 个可变长度的字段：</p>\n<ul>\n<li><strong>Expires :</strong> cookie 的过期日期。如果此字段留空，cookie 会在访客退出浏览器时过期。</li>\n<li><strong>Domain :</strong> 网站的域名。</li>\n<li><strong>Path :</strong> 设置 cookie 的目录或网页的路径。如果您想从任意的目录或网页检索 cookie，此字段可以留空。</li>\n<li><strong>Secure :</strong> 如果此字段包含单词 “secure”，那么 cookie 只能通过安全服务器进行检索。如果此字段留空，则不存在该限制。</li>\n<li><strong>Name=Value :</strong> cookie 以键值对的形式被设置和获取。</li>\n</ul>\n<h3 id=\"设置-cookies\"><a class=\"markdownIt-Anchor\" href=\"#设置-cookies\">#</a> 设置 Cookies</h3>\n<p>向浏览器发送 cookies 是非常简单的。这些 cookies 会在 Content-type 字段之前，与 HTTP 头一起被发送。假设您想设置 UserID 和 Password 为 cookies，设置 cookies 的步骤如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main ()&#123;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Set-Cookie:UserID=XYZ;\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Set-Cookie:Password=XYZ123;\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Set-Cookie:Domain=www.w3cschool.cc;\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Set-Cookie:Path=/perl;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;CGI 中的 Cookies&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;设置 cookies&quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>从这个实例中，我们了解了如何设置 cookies。我们使用 <strong>Set-Cookie</strong> HTTP 头来设置 cookies。</p>\n<p>在这里，有一些设置 cookies 的属性是可选的，比如 Expires、Domain 和 Path。值得注意的是，cookies 是在发送行 <strong>&quot;Content-type:text/html\\r\\n\\r\\n</strong> 之前被设置的。</p>\n<p>编译上面的程序，生成 setcookies.cgi，并尝试使用下面的链接设置 cookies。它会在您的计算机上设置四个 cookies：</p>\n<p>/cgi-bin/setcookies.cgi</p>\n<h3 id=\"获取-cookies\"><a class=\"markdownIt-Anchor\" href=\"#获取-cookies\">#</a> 获取 Cookies</h3>\n<p>检索所有设置的 cookies 是非常简单的。cookies 被存储在 CGI 环境变量 HTTP_COOKIE 中，且它们的形式如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key1=value1;key2=value2;key3=value3....</span><br></pre></td></tr></table></figure>\n<p>下面的实例演示了如何获取 cookies。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span>using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc cgi;</span><br><span class=\"line\">   const_cookie_iterator cci;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;CGI 中的 Cookies&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;table border = \\&quot;0\\&quot; cellspacing = \\&quot;2\\&quot;&gt;&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 获取环境变量</span></span><br><span class=\"line\">   <span class=\"type\">const</span> CgiEnvironment&amp; env = cgi.<span class=\"built_in\">getEnvironment</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span>( cci = env.<span class=\"built_in\">getCookieList</span>().<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">        cci != env.<span class=\"built_in\">getCookieList</span>().<span class=\"built_in\">end</span>(); </span><br><span class=\"line\">        ++cci )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span> &lt;&lt; cci-&gt;<span class=\"built_in\">getName</span>() &lt;&lt; <span class=\"string\">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>;</span><br><span class=\"line\">      cout &lt;&lt; cci-&gt;<span class=\"built_in\">getValue</span>();                                 </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;&lt;/td&gt;&lt;/tr&gt;\\n&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/table&gt;&lt;\\n&quot;</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，编译上面的程序，生成 getcookies.cgi，并尝试使用下面的链接获取您的计算机上所有可用的 cookies：</p>\n<p>/cgi-bin/getcookies.cgi</p>\n<p>这会产生一个列表，显示了上一节中设置的四个 cookies 以及您的计算机上所有其他的 cookies：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UserID XYZ Password XYZ123 Domain www.w3cschool.cc Path /perl</span><br></pre></td></tr></table></figure>\n<h2 id=\"文件上传实例\"><a class=\"markdownIt-Anchor\" href=\"#文件上传实例\">#</a> 文件上传实例</h2>\n<p>为了上传一个文件，HTML 表单必须把 enctype 属性设置为 <strong>multipart/form-data</strong>。带有文件类型的 input 标签会创建一个 “Browse” 按钮。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;&lt;body&gt;</span><br><span class=\"line\">   &lt;form enctype=<span class=\"string\">&quot;multipart/form-data&quot;</span> </span><br><span class=\"line\">            action=<span class=\"string\">&quot;/cgi-bin/cpp_uploadfile.cgi&quot;</span> </span><br><span class=\"line\">            method=<span class=\"string\">&quot;post&quot;</span>&gt;</span><br><span class=\"line\">   &lt;p&gt;文件：&lt;input type=<span class=\"string\">&quot;file&quot;</span> name=<span class=\"string\">&quot;userfile&quot;</span> /&gt;&lt;/p&gt;</span><br><span class=\"line\">   &lt;p&gt;&lt;input type=<span class=\"string\">&quot;submit&quot;</span> value=<span class=\"string\">&quot;上传&quot;</span> /&gt;&lt;/p&gt;</span><br><span class=\"line\">   &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>这段代码的结果是下面的表单：</p>\n<p>文件：</p>\n<p>** 注意：** 上面的实例已经故意禁用了保存上传的文件在我们的服务器上。您可以在自己的服务器上尝试上面的代码。</p>\n<p>下面是用于处理文件上传的脚本 <strong>cpp_uploadfile.cpp</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span>using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc cgi;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;CGI 中的文件上传&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 获取要被上传的文件列表</span></span><br><span class=\"line\">   const_file_iterator file = cgi.<span class=\"built_in\">getFile</span>(<span class=\"string\">&quot;userfile&quot;</span>);</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(file != cgi.<span class=\"built_in\">getFiles</span>().<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在 cout 中发送数据类型</span></span><br><span class=\"line\">      cout &lt;&lt; <span class=\"built_in\">HTTPContentHeader</span>(file-&gt;<span class=\"built_in\">getDataType</span>());</span><br><span class=\"line\">      <span class=\"comment\">// 在 cout 中写入内容</span></span><br><span class=\"line\">      file-&gt;<span class=\"built_in\">writeToStream</span>(cout);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;文件上传成功&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的实例是在 <strong>cout</strong> 流中写入内容，但您可以打开文件流，并把上传的文件内容保存在目标位置的某个文件中。</p>\n<h1 id=\"c-stl-教程\"><a class=\"markdownIt-Anchor\" href=\"#c-stl-教程\">#</a> C++ STL 教程</h1>\n<p>在前面的章节中，我们已经学习了 C++ 模板的概念。C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。</p>\n<p>C++ 标准模板库的核心包括以下三个组件：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">组件</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">容器（Containers）</td>\n<td style=\"text-align:left\">容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">算法（Algorithms）</td>\n<td style=\"text-align:left\">算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">迭代器（iterators）</td>\n<td style=\"text-align:left\">迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</td>\n</tr>\n</tbody>\n</table>\n<p>这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务。</p>\n<p>下面的程序演示了向量容器（一个 C++ 标准的模板），它与数组十分相似，唯一不同的是，向量在需要扩展大小的时候，会自动处理它自己的存储需求：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 创建一个向量存储 int</span></span><br><span class=\"line\">   vector&lt;<span class=\"type\">int</span>&gt; vec; </span><br><span class=\"line\">   <span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 显示 vec 的原始大小</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;vector size = &quot;</span> &lt;&lt; vec.<span class=\"built_in\">size</span>() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 推入 5 个值到向量中</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">      vec.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 显示 vec 扩展后的大小</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;extended vector size = &quot;</span> &lt;&lt; vec.<span class=\"built_in\">size</span>() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 访问向量中的 5 个值</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;value of vec [&quot;</span> &lt;&lt; i &lt;&lt; <span class=\"string\">&quot;] = &quot;</span> &lt;&lt; vec[i] &lt;&lt; endl;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 使用迭代器 iterator 访问值</span></span><br><span class=\"line\">   vector&lt;<span class=\"type\">int</span>&gt;::iterator v = vec.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">   <span class=\"keyword\">while</span>( v != vec.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;value of v = &quot;</span> &lt;&lt; *v &lt;&lt; endl;</span><br><span class=\"line\">      v++;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector size = <span class=\"number\">0</span>extended vector size = <span class=\"number\">5</span>value of vec [<span class=\"number\">0</span>] = <span class=\"number\">0</span>value of vec [<span class=\"number\">1</span>] = <span class=\"number\">1</span>value of vec [<span class=\"number\">2</span>] = <span class=\"number\">2</span>value of vec [<span class=\"number\">3</span>] = <span class=\"number\">3</span>value of vec [<span class=\"number\">4</span>] = <span class=\"number\">4</span>value of v = <span class=\"number\">0</span>value of v = <span class=\"number\">1</span>value of v = <span class=\"number\">2</span>value of v = <span class=\"number\">3</span>value of v = <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>关于上面实例中所使用的各种函数，有几点要注意：</p>\n<ul>\n<li>push_back ( ) 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小。</li>\n<li>size ( ) 函数显示向量的大小。</li>\n<li>begin ( ) 函数返回一个指向向量开头的迭代器。</li>\n<li>end ( ) 函数返回一个指向向量末尾的迭代器。</li>\n</ul>\n<h1 id=\"c-标准库\"><a class=\"markdownIt-Anchor\" href=\"#c-标准库\">#</a> C++ 标准库</h1>\n<p>C++ 标准库可以分为两部分：</p>\n<ul>\n<li><strong>标准函数库：</strong> 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。</li>\n<li><strong>面向对象类库：</strong> 这个库是类及其相关函数的集合。</li>\n</ul>\n<p>C++ 标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改。</p>\n<h2 id=\"标准函数库\"><a class=\"markdownIt-Anchor\" href=\"#标准函数库\">#</a> 标准函数库</h2>\n<p>标准函数库分为以下几类：</p>\n<ul>\n<li>输入 / 输出 I/O</li>\n<li>字符串和字符处理</li>\n<li>数学</li>\n<li>时间、日期和本地化</li>\n<li>动态分配</li>\n<li>其他</li>\n<li>宽字符函数</li>\n</ul>\n<h2 id=\"面向对象类库\"><a class=\"markdownIt-Anchor\" href=\"#面向对象类库\">#</a> 面向对象类库</h2>\n<p>标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入 / 输出 I/O、字符串处理、数值处理。面向对象类库包含以下内容：</p>\n<ul>\n<li>标准的 C++ I/O 类</li>\n<li>String 类</li>\n<li>数值类</li>\n<li>STL 容器类</li>\n<li>STL 算法</li>\n<li>STL 函数对象</li>\n<li>STL 迭代器</li>\n<li>STL 分配器</li>\n<li>本地化库</li>\n<li>异常处理类</li>\n<li>杂项支持库</li>\n</ul>\n<h1 id=\"参考资料\"><a class=\"markdownIt-Anchor\" href=\"#参考资料\">#</a> 参考资料</h1>\n<p>来源：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tLzB2b2ljZS9jcHBfbmV3X2ZlYXR1cmVz\">https://github.com/0voice/cpp_new_features</span></p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/02/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "url": "http://example.com/2023/07/02/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "title": "C++学习笔记",
            "date_published": "2023-07-02T10:28:09.000Z",
            "content_html": "<h1 id=\"c学习笔记\"><a class=\"markdownIt-Anchor\" href=\"#c学习笔记\">#</a> C++ 学习笔记</h1>\n<h2 id=\"一-基础知识\"><a class=\"markdownIt-Anchor\" href=\"#一-基础知识\">#</a> 一、基础知识</h2>\n<h3 id=\"1-goto-语句不建议使用\"><a class=\"markdownIt-Anchor\" href=\"#1-goto-语句不建议使用\">#</a> 1、goto 语句 (不建议使用)</h3>\n<p><strong>作用：</strong> 可以无条件的跳转语句</p>\n<p><strong>语法：</strong>  <code>goto 标记;</code></p>\n<p><strong>解释：</strong> 如果标记的名称存在，执行到 goto 语句时，会跳转到标记的位置</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"number\">1</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"number\">2</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> FLAG;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"number\">3</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"number\">4</span> &lt;&lt; endl;</span><br><span class=\"line\">    FLAG:</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"number\">5</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-一维数组\"><a class=\"markdownIt-Anchor\" href=\"#2-一维数组\">#</a> 2、一维数组</h3>\n<p>一维数组名称的<strong>用途</strong></p>\n<ol>\n<li>可以统计整个数组在内存中的长度</li>\n<li>可以获取数组在内存中的首地址</li>\n</ol>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//数组名用途</span></span><br><span class=\"line\">\t<span class=\"comment\">//1、可以获取整个数组占用内存空间大小</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> arr[<span class=\"number\">10</span>] = &#123; <span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;整个数组所占内存空间为： &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;每个元素所占内存空间为： &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(arr[<span class=\"number\">0</span>]) &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;数组的元素个数为： &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(arr) / <span class=\"built_in\">sizeof</span>(arr[<span class=\"number\">0</span>]) &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//2、可以通过数组名获取到数组首地址</span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;数组首地址为： &quot;</span> &lt;&lt; (<span class=\"type\">int</span>)arr &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;数组中第一个元素地址为： &quot;</span> &lt;&lt; (<span class=\"type\">int</span>)&amp;arr[<span class=\"number\">0</span>] &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;数组中第二个元素地址为： &quot;</span> &lt;&lt; (<span class=\"type\">int</span>)&amp;arr[<span class=\"number\">1</span>] &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//arr = 100; 错误，数组名是常量，因此不可以赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：数组名是常量，不可以赋值</p>\n<p>总结 1：直接打印数组名，可以查看数组所占内存的首地址</p>\n<p>总结 2：对数组名进行 sizeof，可以获取整个数组占内存空间的大小</p>\n<h3 id=\"3-二维数组\"><a class=\"markdownIt-Anchor\" href=\"#3-二维数组\">#</a> 3、二维数组</h3>\n<p>二维数组定义的四种方式：</p>\n<ol>\n<li><code>数据类型 数组名[ 行数 ][ 列数 ];</code></li>\n<li><code>数据类型 数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</code></li>\n<li><code>数据类型 数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li>\n<li><code>数据类型 数组名[ ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li>\n</ol>\n<ul>\n<li>查看二维数组所占内存空间</li>\n<li>获取二维数组首地址</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//二维数组数组名</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> arr[<span class=\"number\">2</span>][<span class=\"number\">3</span>] =</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;二维数组大小： &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;二维数组一行大小： &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(arr[<span class=\"number\">0</span>]) &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;二维数组元素大小： &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(arr[<span class=\"number\">0</span>][<span class=\"number\">0</span>]) &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;二维数组行数： &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(arr) / <span class=\"built_in\">sizeof</span>(arr[<span class=\"number\">0</span>]) &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;二维数组列数： &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(arr[<span class=\"number\">0</span>]) / <span class=\"built_in\">sizeof</span>(arr[<span class=\"number\">0</span>][<span class=\"number\">0</span>]) &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//地址</span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;二维数组首地址：&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;二维数组第一行地址：&quot;</span> &lt;&lt; arr[<span class=\"number\">0</span>] &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;二维数组第二行地址：&quot;</span> &lt;&lt; arr[<span class=\"number\">1</span>] &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;二维数组第一个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class=\"number\">0</span>][<span class=\"number\">0</span>] &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;二维数组第二个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class=\"number\">0</span>][<span class=\"number\">1</span>] &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结 1：二维数组名就是这个数组的首地址</p>\n<p>总结 2：对二维数组名进行 sizeof 时，可以获取整个二维数组占用的内存空间大小</p>\n<h3 id=\"4-函数中的值传递\"><a class=\"markdownIt-Anchor\" href=\"#4-函数中的值传递\">#</a> 4、函数中的值传递</h3>\n<ul>\n<li>所谓值传递，就是函数调用时实参将数值传入给形参</li>\n<li>值传递时，如果形参发生，并不会影响实参 (注意：和 Java 中不同)</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"type\">int</span> num1, <span class=\"type\">int</span> num2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> temp = num1;</span><br><span class=\"line\">\tnum1 = num2;</span><br><span class=\"line\">\tnum2 = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//return ; 当函数声明时候，不需要返回值，可以不写return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> b = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">swap</span>(a, b);</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;mian中的 a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;mian中的 b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结： 值传递时，形参是修饰不了实参的</p>\n<h3 id=\"5-函数的声明\"><a class=\"markdownIt-Anchor\" href=\"#5-函数的声明\">#</a> 5、函数的声明</h3>\n<p><strong>作用：</strong> 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>\n<ul>\n<li>函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong></li>\n</ul>\n<p><strong>(在 C 中，如果不自定义函数在 main 方法之后定义，如果 main 方法调用了此函数，则 main 方法找不到此函数，因此需要提前声明)</strong></p>\n<p>和 Java 中不同</p>\n<h3 id=\"6-函数的分文件编写\"><a class=\"markdownIt-Anchor\" href=\"#6-函数的分文件编写\">#</a> 6、函数的分文件编写</h3>\n<p><strong>作用：</strong> 让代码结构更加清晰</p>\n<p>函数分文件编写一般有 4 个步骤</p>\n<ol>\n<li>\n<p>创建后缀名为.h 的头文件</p>\n</li>\n<li>\n<p>创建后缀名为.cpp 的源文件</p>\n</li>\n<li>\n<p>在头文件中写函数的声明</p>\n</li>\n<li>\n<p>在源文件中写函数的定义</p>\n</li>\n</ol>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//swap.h文件</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现两个数字交换的函数声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//swap.cpp文件</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;swap.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> temp = a;</span><br><span class=\"line\">\ta = b;</span><br><span class=\"line\">\tb = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//main函数文件</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;swap.h&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> b = <span class=\"number\">200</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">swap</span>(a, b);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-指针\"><a class=\"markdownIt-Anchor\" href=\"#7-指针\">#</a> 7、指针</h3>\n<h4 id=\"71-指针的基本概念\"><a class=\"markdownIt-Anchor\" href=\"#71-指针的基本概念\">#</a> 7.1 指针的基本概念</h4>\n<p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p>\n<ul>\n<li>内存编号是从 0 开始记录的，一般用十六进制数字表示</li>\n<li>可以利用指针变量保存地址</li>\n</ul>\n<h4 id=\"72-指针变量的定义和使用\"><a class=\"markdownIt-Anchor\" href=\"#72-指针变量的定义和使用\">#</a> 7.2 指针变量的定义和使用</h4>\n<p>指针变量定义语法：  <code>数据类型 * 变量名;</code></p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//1、指针的定义</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">10</span>; <span class=\"comment\">//定义整型变量a</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//指针定义语法： 数据类型 * 变量名 ;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> * p;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//指针变量赋值</span></span><br><span class=\"line\">\tp = &amp;a; <span class=\"comment\">//指针指向变量a的地址</span></span><br><span class=\"line\">\tcout &lt;&lt; &amp;a &lt;&lt; endl; <span class=\"comment\">//打印数据a的地址</span></span><br><span class=\"line\">\tcout &lt;&lt; p &lt;&lt; endl;  <span class=\"comment\">//打印指针变量p</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//2、指针的使用</span></span><br><span class=\"line\">\t<span class=\"comment\">//通过*操作指针变量指向的内存</span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>指针变量和普通变量的区别</p>\n<ul>\n<li>普通变量存放的是数据，指针变量存放的是地址</li>\n<li>指针变量可以通过 &quot;*&quot; 操作符，操作指针变量指向的内存空间，这个过程称为解引用</li>\n</ul>\n<p>总结 1： 我们可以通过 &amp; 符号 获取变量的地址</p>\n<p>总结 2：利用指针可以记录地址</p>\n<p>总结 3：对指针变量解引用，可以操作指针指向的内存</p>\n<h4 id=\"73-指针所占内存空间\"><a class=\"markdownIt-Anchor\" href=\"#73-指针所占内存空间\">#</a> 7.3 指针所占内存空间</h4>\n<p>提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> * p;</span><br><span class=\"line\">\tp = &amp;a; <span class=\"comment\">//指针指向数据a的地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; *p &lt;&lt; endl; <span class=\"comment\">//* 解引用</span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">sizeof</span>(p) &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">char</span> *) &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span> *) &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">double</span> *) &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结：所有指针类型在 32 位操作系统下是 4 个字节，64 位操作系统为 8 个字节</p>\n<h4 id=\"74-空指针和野指针\"><a class=\"markdownIt-Anchor\" href=\"#74-空指针和野指针\">#</a> 7.4 空指针和野指针</h4>\n<p><strong>空指针</strong>：指针变量指向内存中编号为 0 的空间</p>\n<p><strong>用途：</strong> 初始化指针变量</p>\n<p><strong>注意：</strong> 空指针指向的内存是不可以访问的</p>\n<p><strong>示例 1：空指针</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//指针变量p指向内存地址编号为0的空间</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> * p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//访问空指针报错 </span></span><br><span class=\"line\">\t<span class=\"comment\">//内存编号0 ~255为系统占用内存，不允许用户访问</span></span><br><span class=\"line\">\tcout &lt;&lt; *p &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>野指针</strong>：指针变量指向非法的内存空间</p>\n<p><strong>示例 2：野指针</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//指针变量p指向内存地址编号为0x1100的空间</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> * p = (<span class=\"type\">int</span> *)<span class=\"number\">0x1100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//访问野指针报错 </span></span><br><span class=\"line\">\tcout &lt;&lt; *p &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</p>\n<h4 id=\"75-const修饰指针\"><a class=\"markdownIt-Anchor\" href=\"#75-const修饰指针\">#</a> 7.5 const 修饰指针</h4>\n<p>const 修饰指针有三种情况</p>\n<ol>\n<li>\n<p>const 修饰指针   — 常量指针</p>\n</li>\n<li>\n<p>const 修饰常量   — 指针常量</p>\n</li>\n<li>\n<p>const 既修饰指针，又修饰常量</p>\n</li>\n</ol>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">int</span> * p1 = &amp;a; </span><br><span class=\"line\">\tp1 = &amp;b; <span class=\"comment\">//正确</span></span><br><span class=\"line\">\t<span class=\"comment\">//*p1 = 100;  报错</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> * <span class=\"type\">const</span> p2 = &amp;a;</span><br><span class=\"line\">\t<span class=\"comment\">//p2 = &amp;b; //错误</span></span><br><span class=\"line\">\t*p2 = <span class=\"number\">100</span>; <span class=\"comment\">//正确</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//const既修饰指针又修饰常量</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">int</span> * <span class=\"type\">const</span> p3 = &amp;a;</span><br><span class=\"line\">\t<span class=\"comment\">//p3 = &amp;b; //错误</span></span><br><span class=\"line\">\t<span class=\"comment\">//*p3 = 100; //错误</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>技巧：看 const 右侧紧跟着的是指针还是常量，是指针就是常量指针，是常量就是指针常量</p>\n<h4 id=\"76-指针和数组\"><a class=\"markdownIt-Anchor\" href=\"#76-指针和数组\">#</a> 7.6 指针和数组</h4>\n<p><strong>作用：</strong> 利用指针访问数组中元素</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> arr[] = &#123; <span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> * p = arr;  <span class=\"comment\">//指向数组的指针</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;第一个元素： &quot;</span> &lt;&lt; arr[<span class=\"number\">0</span>] &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;指针访问第一个元素： &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//利用指针遍历数组</span></span><br><span class=\"line\">\t\tcout &lt;&lt; *p &lt;&lt; endl;</span><br><span class=\"line\">\t\tp++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"77-指针和函数\"><a class=\"markdownIt-Anchor\" href=\"#77-指针和函数\">#</a> 7.7 指针和函数</h4>\n<p><strong>作用：</strong> 利用指针作函数参数，可以修改实参的值 (和前边形参相反)</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//值传递</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">swap1</span><span class=\"params\">(<span class=\"type\">int</span> a ,<span class=\"type\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> temp = a;</span><br><span class=\"line\">\ta = b; </span><br><span class=\"line\">\tb = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//地址传递</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">swap2</span><span class=\"params\">(<span class=\"type\">int</span> * p1, <span class=\"type\">int</span> *p2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> temp = *p1;</span><br><span class=\"line\">\t*p1 = *p2;</span><br><span class=\"line\">\t*p2 = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> b = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">swap1</span>(a, b); <span class=\"comment\">// 值传递不会改变实参</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">swap2</span>(&amp;a, &amp;b); <span class=\"comment\">//地址传递会改变实参</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p>\n<h4 id=\"78-指针-数组-函数\"><a class=\"markdownIt-Anchor\" href=\"#78-指针-数组-函数\">#</a> 7.8 指针、数组、函数</h4>\n<p><strong>案例描述：</strong> 封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p>\n<p>例如数组：int arr [10] = { 4,3,6,9,1,2,10,8,7,5 };</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//冒泡排序函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"type\">int</span> * arr, <span class=\"type\">int</span> len)</span>  <span class=\"comment\">//int * arr 也可以写为int arr[]</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; len - <span class=\"number\">1</span> - i; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">int</span> temp = arr[j];</span><br><span class=\"line\">\t\t\t\tarr[j] = arr[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t\tarr[j + <span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//打印数组函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printArray</span><span class=\"params\">(<span class=\"type\">int</span> arr[], <span class=\"type\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> arr[<span class=\"number\">10</span>] = &#123; <span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">10</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">\t<span class=\"type\">int</span> len = <span class=\"built_in\">sizeof</span>(arr) / <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">bubbleSort</span>(arr, len);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printArray</span>(arr, len);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-结构体\"><a class=\"markdownIt-Anchor\" href=\"#8-结构体\">#</a> 8、结构体</h3>\n<h4 id=\"81-结构体基本概念\"><a class=\"markdownIt-Anchor\" href=\"#81-结构体基本概念\">#</a> 8.1 结构体基本概念</h4>\n<p>结构体属于用户 自定义的数据类型，允许用户存储不同的数据类型</p>\n<p>(跟 Java 中的对象比较像，但是只有属性，没有方法。下面其他的结构体使用，都可以类比 Java 中对象的使用)</p>\n<h4 id=\"82-结构体定义和使用\"><a class=\"markdownIt-Anchor\" href=\"#82-结构体定义和使用\">#</a> 8.2 结构体定义和使用</h4>\n<p><strong>语法：</strong>  <code>struct 结构体名 &#123; 结构体成员列表 &#125;；</code></p>\n<p>通过结构体创建变量的方式有三种：</p>\n<ul>\n<li>\n<p>struct 结构体名 变量名</p>\n</li>\n<li 成员1值=\"\" ，=\"\" 成员2值...=\"\">\n<p>struct 结构体名 变量名 =</p>\n</li>\n<li>\n<p>定义结构体时顺便创建变量</p>\n</li>\n<li></li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//结构体定义</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">student</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//成员列表</span></span><br><span class=\"line\">\tstring name;  <span class=\"comment\">//姓名</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> age;      <span class=\"comment\">//年龄</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> score;    <span class=\"comment\">//分数</span></span><br><span class=\"line\">&#125;stu3; <span class=\"comment\">//结构体变量创建方式3 </span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//结构体变量创建方式1</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">student</span> stu1; <span class=\"comment\">//struct 关键字可以省略</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tstu1.name = <span class=\"string\">&quot;张三&quot;</span>;</span><br><span class=\"line\">\tstu1.age = <span class=\"number\">18</span>;</span><br><span class=\"line\">\tstu1.score = <span class=\"number\">100</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;姓名：&quot;</span> &lt;&lt; stu1.name &lt;&lt; <span class=\"string\">&quot; 年龄：&quot;</span> &lt;&lt; stu1.age  &lt;&lt; <span class=\"string\">&quot; 分数：&quot;</span> &lt;&lt; stu1.score &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//结构体变量创建方式2</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">student</span> stu2 = &#123; <span class=\"string\">&quot;李四&quot;</span>,<span class=\"number\">19</span>,<span class=\"number\">60</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;姓名：&quot;</span> &lt;&lt; stu2.name &lt;&lt; <span class=\"string\">&quot; 年龄：&quot;</span> &lt;&lt; stu2.age  &lt;&lt; <span class=\"string\">&quot; 分数：&quot;</span> &lt;&lt; stu2.score &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tstu3.name = <span class=\"string\">&quot;王五&quot;</span>;</span><br><span class=\"line\">\tstu3.age = <span class=\"number\">18</span>;</span><br><span class=\"line\">\tstu3.score = <span class=\"number\">80</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;姓名：&quot;</span> &lt;&lt; stu3.name &lt;&lt; <span class=\"string\">&quot; 年龄：&quot;</span> &lt;&lt; stu3.age  &lt;&lt; <span class=\"string\">&quot; 分数：&quot;</span> &lt;&lt; stu3.score &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结 1：定义结构体时的关键字是 struct，不可省略</p>\n<p>总结 2：创建结构体变量时，关键字 struct 可以省略</p>\n<p>总结 3：结构体变量利用操作符 ‘’.‘’  访问成员</p>\n<h4 id=\"83-结构体数组\"><a class=\"markdownIt-Anchor\" href=\"#83-结构体数组\">#</a> 8.3 结构体数组</h4>\n<p><strong>作用：</strong> 将自定义的结构体放入到数组中方便维护</p>\n<p><strong>语法：</strong>  <code>struct  结构体名 数组名[元素个数] = &#123;  &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125;</code></p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//结构体定义</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">student</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//成员列表</span></span><br><span class=\"line\">\tstring name;  <span class=\"comment\">//姓名</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> age;      <span class=\"comment\">//年龄</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> score;    <span class=\"comment\">//分数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//结构体数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">student</span> arr[<span class=\"number\">3</span>]=</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t&#123;<span class=\"string\">&quot;张三&quot;</span>,<span class=\"number\">18</span>,<span class=\"number\">80</span> &#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"string\">&quot;李四&quot;</span>,<span class=\"number\">19</span>,<span class=\"number\">60</span> &#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"string\">&quot;王五&quot;</span>,<span class=\"number\">20</span>,<span class=\"number\">70</span> &#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;姓名：&quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class=\"string\">&quot; 年龄：&quot;</span> &lt;&lt; arr[i].age &lt;&lt; <span class=\"string\">&quot; 分数：&quot;</span> &lt;&lt; arr[i].score &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"84-结构体指针\"><a class=\"markdownIt-Anchor\" href=\"#84-结构体指针\">#</a> 8.4 结构体指针</h4>\n<p><strong>作用：</strong> 通过指针访问结构体中的成员</p>\n<ul>\n<li>利用操作符  <code>-&gt;</code>  可以通过结构体指针访问结构体属性</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//结构体定义</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">student</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//成员列表</span></span><br><span class=\"line\">\tstring name;  <span class=\"comment\">//姓名</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> age;      <span class=\"comment\">//年龄</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> score;    <span class=\"comment\">//分数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">student</span> stu = &#123; <span class=\"string\">&quot;张三&quot;</span>,<span class=\"number\">18</span>,<span class=\"number\">100</span>, &#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">struct</span> <span class=\"title class_\">student</span> * p = &amp;stu;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tp-&gt;score = <span class=\"number\">80</span>; <span class=\"comment\">//指针通过 -&gt; 操作符可以访问成员</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class=\"string\">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class=\"string\">&quot; 分数：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</p>\n<h4 id=\"85-结构体嵌套结构体\"><a class=\"markdownIt-Anchor\" href=\"#85-结构体嵌套结构体\">#</a> 8.5 结构体嵌套结构体</h4>\n<p><strong>作用：</strong> 结构体中的成员可以是另一个结构体</p>\n<p><strong>例如：</strong> 每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//学生结构体定义struct student&#123;\t//成员列表\tstring name;  //姓名\tint age;      //年龄\tint score;    //分数&#125;;//教师结构体定义struct teacher&#123;    //成员列表\tint id; //职工编号\tstring name;  //教师姓名\tint age;   //教师年龄\tstruct student stu; //子结构体 学生&#125;;int main() &#123;\tstruct teacher t1;\tt1.id = 10000;\tt1.name = &quot;老王&quot;;\tt1.age = 40;\tt1.stu.name = &quot;张三&quot;;\tt1.stu.age = 18;\tt1.stu.score = 100;\tcout &lt;&lt; &quot;教师 职工编号： &quot; &lt;&lt; t1.id &lt;&lt; &quot; 姓名： &quot; &lt;&lt; t1.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; t1.age &lt;&lt; endl;\t\tcout &lt;&lt; &quot;辅导学员 姓名： &quot; &lt;&lt; t1.stu.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; t1.stu.age &lt;&lt; &quot; 考试分数： &quot; &lt;&lt; t1.stu.score &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>总结：</strong> 在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p>\n<h4 id=\"86-结构体做函数参数\"><a class=\"markdownIt-Anchor\" href=\"#86-结构体做函数参数\">#</a> 8.6 结构体做函数参数</h4>\n<p><strong>作用：</strong> 将结构体作为参数向函数中传递</p>\n<p>传递方式有两种：</p>\n<ul>\n<li>值传递</li>\n<li>地址传递</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//学生结构体定义</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">student</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//成员列表</span></span><br><span class=\"line\">\tstring name;  <span class=\"comment\">//姓名</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> age;      <span class=\"comment\">//年龄</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> score;    <span class=\"comment\">//分数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//值传递</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printStudent</span><span class=\"params\">(student stu )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tstu.age = <span class=\"number\">28</span>;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class=\"string\">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class=\"string\">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//地址传递</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printStudent2</span><span class=\"params\">(student *stu)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tstu-&gt;age = <span class=\"number\">28</span>;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class=\"string\">&quot; 年龄： &quot;</span> &lt;&lt; stu-&gt;age  &lt;&lt; <span class=\"string\">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstudent stu = &#123; <span class=\"string\">&quot;张三&quot;</span>,<span class=\"number\">18</span>,<span class=\"number\">100</span>&#125;;</span><br><span class=\"line\">\t<span class=\"comment\">//值传递</span></span><br><span class=\"line\">\t<span class=\"built_in\">printStudent</span>(stu);</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class=\"string\">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class=\"string\">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//地址传递</span></span><br><span class=\"line\">\t<span class=\"built_in\">printStudent2</span>(&amp;stu);</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class=\"string\">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class=\"string\">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p>\n<h4 id=\"87-结构体中-const使用场景\"><a class=\"markdownIt-Anchor\" href=\"#87-结构体中-const使用场景\">#</a> 8.7 结构体中 const 使用场景</h4>\n<p><strong>作用：</strong> 用 const 来防止误操作</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//学生结构体定义</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">student</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//成员列表</span></span><br><span class=\"line\">\tstring name;  <span class=\"comment\">//姓名</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> age;      <span class=\"comment\">//年龄</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> score;    <span class=\"comment\">//分数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//const使用场景</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printStudent</span><span class=\"params\">(<span class=\"type\">const</span> student *stu)</span> <span class=\"comment\">//加const防止函数体中的误操作</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//stu-&gt;age = 100; //操作失败，因为加了const修饰</span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class=\"string\">&quot; 年龄：&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class=\"string\">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstudent stu = &#123; <span class=\"string\">&quot;张三&quot;</span>,<span class=\"number\">18</span>,<span class=\"number\">100</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printStudent</span>(&amp;stu);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二-核心编程\"><a class=\"markdownIt-Anchor\" href=\"#二-核心编程\">#</a> 二、核心编程</h2>\n<p>C++ 中的面向对象编程（笑）</p>\n<h3 id=\"1-内存分区模型\"><a class=\"markdownIt-Anchor\" href=\"#1-内存分区模型\">#</a> 1、内存分区模型</h3>\n<p>C++ 程序在执行时，将内存大方向划分为<strong> 4 个区域</strong></p>\n<ul>\n<li>\n<p>代码区：存放函数体的二进制代码，由操作系统进行管理的</p>\n</li>\n<li>\n<p>全局区：存放全局变量和静态变量以及常量</p>\n</li>\n<li>\n<p>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</p>\n</li>\n<li>\n<p>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</p>\n</li>\n</ul>\n<p><strong>内存四区意义：</strong></p>\n<p>不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程</p>\n<h4 id=\"11-程序运行前\"><a class=\"markdownIt-Anchor\" href=\"#11-程序运行前\">#</a> 1.1 程序运行前</h4>\n<p>在程序编译后，生成了 exe 可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>\n<ul>\n<li>\n<p>代码区：</p>\n</li>\n<li>\n<ul>\n<li>存放 CPU 执行的机器指令</li>\n<li>代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</li>\n</ul>\n</li>\n<li>\n<p>全局区：</p>\n</li>\n<li>\n<ul>\n<li>全局变量和静态变量存放在此</li>\n<li>全局区还包含了常量区，字符串常量和其他常量也存放在此</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>该区域的数据在程序结束后由操作系统释放</li>\n</ul>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//全局变量</span></span><br><span class=\"line\"><span class=\"type\">int</span> g_a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> g_b = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//全局常量</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> c_g_a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> c_g_b = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//局部变量</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//打印地址</span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class=\"type\">int</span>)&amp;a &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class=\"type\">int</span>)&amp;b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class=\"type\">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class=\"type\">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//静态变量</span></span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> s_a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> s_b = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class=\"type\">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class=\"type\">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class=\"type\">int</span>)&amp;<span class=\"string\">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class=\"type\">int</span>)&amp;<span class=\"string\">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class=\"type\">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class=\"type\">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">int</span> c_l_a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">int</span> c_l_b = <span class=\"number\">10</span>;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class=\"type\">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class=\"type\">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://cdn.nlark.com/yuque/0/2021/png/2797977/1627450152945-bd009327-0c74-498d-8950-d300ec297b88.png\" alt=\"img\"></p>\n<p>总结：</p>\n<ul>\n<li>\n<p>C++ 中在程序运行前分为全局区和代码区</p>\n</li>\n<li>\n<p>代码区特点是共享和只读</p>\n</li>\n<li>\n<p>全局区中存放全局变量、静态变量、常量</p>\n</li>\n<li>\n<p>常量区中存放 const 修饰的全局常量  和 字符串常量</p>\n</li>\n</ul>\n<h4 id=\"12-程序运行后\"><a class=\"markdownIt-Anchor\" href=\"#12-程序运行后\">#</a> 1.2 程序运行后</h4>\n<p><strong>栈区：</strong></p>\n<ul>\n<li>由编译器自动分配释放，存放函数的参数值，局部变量等</li>\n<li>注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> * <span class=\"title\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> *p = <span class=\"built_in\">func</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; *p &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; *p &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>堆区：</strong></p>\n<ul>\n<li>由程序员分配释放，若程序员不释放，程序结束时由操作系统回收</li>\n<li>在 C++ 中主要利用 new 在堆区开辟内存</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span>* <span class=\"title\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span>* a = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> *p = <span class=\"built_in\">func</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; *p &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; *p &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>总结：</strong></p>\n<ul>\n<li>堆区数据由程序员管理开辟和释放</li>\n<li>堆区数据利用 new 关键字进行开辟内存</li>\n</ul>\n<h4 id=\"13-new操作符\"><a class=\"markdownIt-Anchor\" href=\"#13-new操作符\">#</a> 1.3 new 操作符</h4>\n<ul>\n<li>\n<p>C++ 中利用 new 操作符在堆区开辟数据</p>\n</li>\n<li>\n<p>堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 delete</p>\n</li>\n<li>\n<p>语法： <code>new 数据类型</code></p>\n</li>\n<li>\n<p>利用 new 创建的数据，会返回该数据对应的类型的指针</p>\n</li>\n</ul>\n<p><strong>示例 1： 基本语法</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span>* <span class=\"title\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span>* a = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> *p = <span class=\"built_in\">func</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; *p &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; *p &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//利用delete释放堆区数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> p;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：开辟数组</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//堆区开辟数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span>* arr = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tarr[i] = i + <span class=\"number\">100</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//释放数组 delete 后加 []</span></span><br><span class=\"line\">\t<span class=\"keyword\">delete</span>[] arr;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-引用\"><a class=\"markdownIt-Anchor\" href=\"#2-引用\">#</a> 2、引用</h3>\n<h4 id=\"21-引用的基本使用\"><a class=\"markdownIt-Anchor\" href=\"#21-引用的基本使用\">#</a> 2.1 引用的基本使用</h4>\n<p><strong>作用：</strong> 给变量起别名</p>\n<p><strong>语法：</strong>  <code>数据类型 &amp;别名 = 原名</code></p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> &amp;b = a;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\tb = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"22-引用注意事项\"><a class=\"markdownIt-Anchor\" href=\"#22-引用注意事项\">#</a> 2.2 引用注意事项</h4>\n<ul>\n<li>引用必须初始化</li>\n<li>引用在初始化后，不可以改变</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> b = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//int &amp;c; //错误，引用必须初始化</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> &amp;c = a; <span class=\"comment\">//一旦初始化后，就不可以更改</span></span><br><span class=\"line\">\tc = b; <span class=\"comment\">//这是赋值操作，不是更改引用</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"23-引用做函数参数\"><a class=\"markdownIt-Anchor\" href=\"#23-引用做函数参数\">#</a> 2.3 引用做函数参数</h4>\n<p><strong>作用：</strong> 函数传参时，可以利用引用的技术让形参修饰实参</p>\n<p><strong>优点：</strong> 可以简化指针修改实参</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1. 值传递</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mySwap01</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> temp = a;</span><br><span class=\"line\">\ta = b;</span><br><span class=\"line\">\tb = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2. 地址传递</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mySwap02</span><span class=\"params\">(<span class=\"type\">int</span>* a, <span class=\"type\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> temp = *a;</span><br><span class=\"line\">\t*a = *b;</span><br><span class=\"line\">\t*b = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3. 引用传递</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mySwap03</span><span class=\"params\">(<span class=\"type\">int</span>&amp; a, <span class=\"type\">int</span>&amp; b)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> temp = a;</span><br><span class=\"line\">\ta = b;</span><br><span class=\"line\">\tb = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> b = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">mySwap01</span>(a, b);</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class=\"string\">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">mySwap02</span>(&amp;a, &amp;b);</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class=\"string\">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">mySwap03</span>(a, b);</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class=\"string\">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>\n<h4 id=\"24-引用做函数返回值\"><a class=\"markdownIt-Anchor\" href=\"#24-引用做函数返回值\">#</a> 2.4 引用做函数返回值</h4>\n<p><strong>作用：</strong> 引用是可以作为函数的返回值存在的</p>\n<p><strong>注意：</strong> <strong>不要返回局部变量引用</strong></p>\n<p><strong>用法：</strong> 函数调用作为左值</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//返回局部变量引用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span>&amp; <span class=\"title\">test01</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">10</span>; <span class=\"comment\">//局部变量</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回静态变量引用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span>&amp; <span class=\"title\">test02</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> a = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//不能返回局部变量的引用</span></span><br><span class=\"line\">\t<span class=\"type\">int</span>&amp; ref = <span class=\"built_in\">test01</span>();</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//如果函数做左值，那么必须返回引用</span></span><br><span class=\"line\">\t<span class=\"type\">int</span>&amp; ref2 = <span class=\"built_in\">test02</span>();</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">test02</span>() = <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"25-引用的本质\"><a class=\"markdownIt-Anchor\" href=\"#25-引用的本质\">#</a> 2.5 引用的本质</h4>\n<p>本质：<strong>引用的本质在 c++ 内部实现是一个指针常量.</strong></p>\n<p>讲解示例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span>&amp; ref)</span></span>&#123;</span><br><span class=\"line\">\tref = <span class=\"number\">100</span>; <span class=\"comment\">// ref是引用，转换为*ref = 100</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class=\"line\">\t<span class=\"type\">int</span>&amp; ref = a; </span><br><span class=\"line\">\tref = <span class=\"number\">20</span>; <span class=\"comment\">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"built_in\">func</span>(a);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结论：C++ 推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>\n<h4 id=\"26-常量引用\"><a class=\"markdownIt-Anchor\" href=\"#26-常量引用\">#</a> 2.6 常量引用</h4>\n<p><strong>作用：</strong> 常量引用主要用来修饰形参，防止误操作</p>\n<p>在函数形参列表中，可以加 const 修饰形参，防止形参改变实参</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//引用使用的场景，通常用来修饰形参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">showValue</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">int</span>&amp; v)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//v += 10;</span></span><br><span class=\"line\">\tcout &lt;&lt; v &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class=\"line\">\t<span class=\"comment\">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">int</span>&amp; ref = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class=\"line\">\tcout &lt;&lt; ref &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//函数中利用常量引用防止误操作修改实参</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">showValue</span>(a);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-函数\"><a class=\"markdownIt-Anchor\" href=\"#3-函数\">#</a> 3、函数</h3>\n<h4 id=\"31-函数默认参数\"><a class=\"markdownIt-Anchor\" href=\"#31-函数默认参数\">#</a> 3.1 函数默认参数</h4>\n<p>在 C++ 中，函数的形参列表中的形参是可以有默认值的。</p>\n<p>语法： <code>返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b = <span class=\"number\">10</span>, <span class=\"type\">int</span> c = <span class=\"number\">10</span>)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a + b + c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class=\"line\"><span class=\"comment\">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">func2</span><span class=\"params\">(<span class=\"type\">int</span> a = <span class=\"number\">10</span>, <span class=\"type\">int</span> b = <span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">func2</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;ret = &quot;</span> &lt;&lt; <span class=\"built_in\">func</span>(<span class=\"number\">20</span>, <span class=\"number\">20</span>) &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;ret = &quot;</span> &lt;&lt; <span class=\"built_in\">func</span>(<span class=\"number\">100</span>) &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"32-函数占位参数\"><a class=\"markdownIt-Anchor\" href=\"#32-函数占位参数\">#</a> 3.2 函数占位参数</h4>\n<p>C++ 中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>\n<p><strong>语法：</strong>  <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span>)</span> </span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">func</span>(<span class=\"number\">10</span>,<span class=\"number\">10</span>); <span class=\"comment\">//占位参数必须填补</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"33-函数重载\"><a class=\"markdownIt-Anchor\" href=\"#33-函数重载\">#</a> 3.3 函数重载</h4>\n<h5 id=\"331-函数重载概述\"><a class=\"markdownIt-Anchor\" href=\"#331-函数重载概述\">#</a> 3.3.1 函数重载概述</h5>\n<p><strong>作用：</strong> 函数名可以相同，提高复用性</p>\n<p><strong>函数重载满足条件：</strong></p>\n<ul>\n<li>\n<p>同一个作用域下</p>\n</li>\n<li>\n<p>函数名称相同</p>\n</li>\n<li>\n<p>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></p>\n</li>\n</ul>\n<p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数重载需要函数都在同一个作用域下</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">double</span> a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> a ,<span class=\"type\">double</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">double</span> a ,<span class=\"type\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数返回值不可以作为函数重载条件</span></span><br><span class=\"line\"><span class=\"comment\">//int func(double a, int b)</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\tcout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">func</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">func</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">func</span>(<span class=\"number\">3.14</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">func</span>(<span class=\"number\">10</span>,<span class=\"number\">3.14</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">func</span>(<span class=\"number\">3.14</span> , <span class=\"number\">10</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"332-函数重载注意事项\"><a class=\"markdownIt-Anchor\" href=\"#332-函数重载注意事项\">#</a> 3.3.2 函数重载注意事项</h5>\n<ul>\n<li>引用作为重载条件</li>\n<li>函数重载碰到函数默认参数</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数重载注意事项</span></span><br><span class=\"line\"><span class=\"comment\">//1、引用作为重载条件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> &amp;a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">int</span> &amp;a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2、函数重载碰到函数默认参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func2</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b = <span class=\"number\">10</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func2</span><span class=\"params\">(<span class=\"type\">int</span> a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">func</span>(a); <span class=\"comment\">//调用无const</span></span><br><span class=\"line\">\t<span class=\"built_in\">func</span>(<span class=\"number\">10</span>);<span class=\"comment\">//调用有const</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//func2(10); //碰到默认参数产生歧义，需要避免</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"参考资料\"><a class=\"markdownIt-Anchor\" href=\"#参考资料\">#</a> 参考资料</h1>\n<p>来源：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tLzB2b2ljZS9jcHBfbmV3X2ZlYXR1cmVz\">https://github.com/0voice/cpp_new_features</span></p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/02/Markdown%E8%AF%AD%E6%B3%95%E6%A6%82%E8%BF%B0/",
            "url": "http://example.com/2023/07/02/Markdown%E8%AF%AD%E6%B3%95%E6%A6%82%E8%BF%B0/",
            "title": "Markdown语法概述",
            "date_published": "2023-07-02T10:06:40.000Z",
            "content_html": "<p>[TOC]</p>\n<h1 id=\"markdowntyporavscode-超全教程\"><a class=\"markdownIt-Anchor\" href=\"#markdowntyporavscode-超全教程\">#</a> [Markdown+Typora/VSCode 超全教程]</h1>\n<p>Sakiyary 2022/7/16</p>\n<h2 id=\"简要介绍\"><a class=\"markdownIt-Anchor\" href=\"#简要介绍\">#</a> 😂 简要介绍</h2>\n<p><strong>Markdown</strong> 是一种轻量型标记语言，是一种语法。以  <code>.md</code>  结尾的文本文件就是 Markdown 文件。相较于 <strong>Word</strong>, 它更加像是 <strong>HTML</strong> 语言或是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding=\"application/x-tex\">\\LaTeX</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8988em;vertical-align:-0.2155em;\"></span><span class=\"mord text\"><span class=\"mord textrm\">L</span><span class=\"mspace\" style=\"margin-right:-0.36em;\"></span><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6833em;\"><span style=\"top:-2.905em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"mord\"><span class=\"mord textrm mtight sizing reset-size6 size3\">A</span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:-0.15em;\"></span><span class=\"mord text\"><span class=\"mord textrm\">T</span><span class=\"mspace\" style=\"margin-right:-0.1667em;\"></span><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4678em;\"><span style=\"top:-2.7845em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord textrm\">E</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2155em;\"><span></span></span></span></span><span class=\"mspace\" style=\"margin-right:-0.125em;\"></span><span class=\"mord textrm\">X</span></span></span></span></span></span>, 并不是最淳朴的那种 &quot;所见即所得&quot;. 它处处透露着一种极简主义。高效简洁清晰的同时，又很简单。看起来舒服，语法简单，尤其在处理纯文本上有很大的优势.</p>\n<p>它相较于 <strong>Word</strong>, 兼容性非常高，可以跨平台使用，不用担心奇奇怪怪的版本兼容问题。同时，有许多网站都支持或正在使用 <strong>Markdown</strong> 语法。如 <strong>Github</strong> (等一系列代码托管平台), StackOverflow (等答疑平台), 简书，语雀 (等一系列笔记平台).</p>\n<h2 id=\"实际应用\"><a class=\"markdownIt-Anchor\" href=\"#实际应用\">#</a> 📐 实际应用</h2>\n<p>所有要写文本的时候都可以用上 <strong>Markdown</strong>!</p>\n<p>它可以让你不再纠结什么字体，什么样式，什么排版。而且逻辑清晰，层次分明.</p>\n<p>像我大一的时候就用 Markdown 来写各种笔记，演讲稿，课程论文，实验报告，代码的  <code>README.md</code>  … 包括本教程文档.</p>\n<h2 id=\"工具\"><a class=\"markdownIt-Anchor\" href=\"#工具\">#</a> 🍴 工具</h2>\n<p>Markdown 只是一种语法。那么用来写 Markdown 的文本编辑器呢？我推荐的是 <strong>Typora</strong> 或者 <strong>VS Code</strong></p>\n<h3 id=\"typora\"><a class=\"markdownIt-Anchor\" href=\"#typora\">#</a> Typora</h3>\n<p>Typora 应该是被广泛用于写 Markdown 的文本软件，就和 Markdown 语法一样高效。而且它还有很实用的扩展语法与自定义样式的功能。其能将  <code>.md</code>  导出成多种文件，如  <code>.pdf</code> ,  <code>.html</code> ,  <code>.docx</code>  (没想到吧，能导出到 Word)</p>\n<p>但是现在 Typora 已经发布正式版并且变为收费软件。中文官网在此 <span class=\"exturl\" data-url=\"aHR0cHM6Ly90eXBvcmFpby5jbi8=\">Typora 官方中文站 </span>.</p>\n<p>我当然是推荐大家都用正版啦。不过价格是永久版￥89, 好在可以用在 3 台设备上。如果和你的两位同学 / 舍友均摊一下，每人就只要￥30, 和一张游戏月卡差不多.</p>\n<p>至于盗版以及破解方法<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cub25seTQud29yay9ibG9nLz9pZD0zNzk=\">在此随便找一种改注册表时间方法的</span><s>不介绍 (还挺多的其实)</s>.</p>\n<p><s>还有一种免费白嫖的方法就是安装测试版 / Beta 版。官网有历史版本的下载链接 <span class=\"exturl\" data-url=\"aHR0cHM6Ly90eXBvcmFpby5jbi93aW5kb3dzL2Rldl9yZWxlYXNlLmh0bWw=\">Typora 历史版本下载页</span></s></p>\n<p>白嫖 Beta 版已经寄了，要么支持正版要么去学习一下破解方法吧 (还是忍不住啦，看上面的链接👆)</p>\n<h3 id=\"vs-code\"><a class=\"markdownIt-Anchor\" href=\"#vs-code\">#</a> VS Code</h3>\n<p>这是微软家的开源文本编辑器，理论上来说所有代码，语言，都可以用 VS Code 来写，同样是非常的简洁好用。在下载插件 <strong>Markdown All in One</strong> 后对 Markdown 的基础支持也是非常的好。若在 VS Code 下载 Markdown 各种附加扩展，就能获得比 Typora 更加丰富的扩展语法与操作.</p>\n<h3 id=\"其他\"><a class=\"markdownIt-Anchor\" href=\"#其他\">#</a> 其他</h3>\n<p>大部分 IDE, 像 Jetbrain 的全家桶里应该每一款，都支持 Markdown 语法，在此不多赘述.</p>\n<p>本文档主要使用 Typora 进行演示，同时会介绍许多 Typora 所包含的扩展语法.</p>\n<h2 id=\"基础教程\"><a class=\"markdownIt-Anchor\" href=\"#基础教程\">#</a> 🍭 基础教程</h2>\n<p>当有多种标记方法时我会倾向其中一种.</p>\n<p>标题有  <code>*</code>  表示该为扩展语法，仅在 Typora 或 添加了扩展的 VS Code <strong>本地生效</strong>，在大多数平台上<strong>并不认可</strong>.</p>\n<h3 id=\"0-写-markdown-的第零步\"><a class=\"markdownIt-Anchor\" href=\"#0-写-markdown-的第零步\">#</a> 0. 写 Markdown 的第零步</h3>\n<p>我们写文本的时候大多写的是中文，可是输入法在输中文时使用的标点为全角标点，如  <code>，。？！（）【】：；“”</code> . 这些标点是不被 Markdown 所认可的，也是无法转义的.</p>\n<p>我建议大家写 Markdown 的时候都用半角标点，即英文标点，如  <code>,.?!()[]:;&quot;&quot;</code> . 且每个半角标点在文本使用时加上后置空格，符合英文标点的书写规范，也更加美观.</p>\n<p>以微软自带输入法举例，在使用中文输入法时按下  <code>Ctrl</code>  +  <code>.(这是个句号)</code> , 切换标点的全角与半角。这样即可中文输入 + 半角标点.</p>\n<h3 id=\"1-标题-数个-空格-前置\"><a class=\"markdownIt-Anchor\" href=\"#1-标题-数个-空格-前置\">#</a> 1. 标题 [数个 “#” + 空格 前置]</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 一级标题</span><br><span class=\"line\">## 二级标题</span><br><span class=\"line\">### 三级标题</span><br><span class=\"line\">#### 四级标题</span><br><span class=\"line\">##### 五级标题</span><br><span class=\"line\">###### 六级标题</span><br></pre></td></tr></table></figure>\n<p>标题会在目录与大纲分级显示，可以跳转.</p>\n<p>在 Typora 中建议开启  <code>严格模式</code> ，即不应为  <code>#标题</code> ，应为  <code># 标题</code> .</p>\n<p>应该要手动补上空格，使得 Markdown 语法在其他文本编辑器上兼容.</p>\n<h3 id=\"2-强调-用-或-__-包围\"><a class=\"markdownIt-Anchor\" href=\"#2-强调-用-或-__-包围\">#</a> 2. 强调 [用 “**” 或 “__” 包围]</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">**欢迎报考南京大学!** (我喜欢用这种)</span><br><span class=\"line\">__欢迎报考南京大学!__</span><br></pre></td></tr></table></figure>\n<p>或者选中想要强调的文字按下  <code>Ctrl</code>  +  <code>B</code> .</p>\n<p>E.G.</p>\n<p><strong>欢迎报考南京大学！</strong></p>\n<h3 id=\"3-斜体-用-或-_-包围\"><a class=\"markdownIt-Anchor\" href=\"#3-斜体-用-或-_-包围\">#</a> 3. 斜体 [用 “*” 或 “_” 包围]</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*欢迎大佬来浇浇我各种知识* (我喜欢用这种)</span><br><span class=\"line\">_欢迎大佬来浇浇我各种知识_</span><br></pre></td></tr></table></figure>\n<p>或者选中想要强调的文字按下  <code>Ctrl</code>  +  <code>I</code> .</p>\n<p>E.G.</p>\n<p><em>欢迎大佬来浇浇我各种知识</em></p>\n<p>(P.S. <em><strong>斜体并强调</strong></em> [用 “***” 或 “___” 包围])</p>\n<h3 id=\"4-删除线-用-~~-包围\"><a class=\"markdownIt-Anchor\" href=\"#4-删除线-用-~~-包围\">#</a> 4. 删除线 [用 “~~” 包围]</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~~我宣布个事儿, 我是Sabiyary!~~</span><br></pre></td></tr></table></figure>\n<p>E.G.</p>\n<p><s>我宣布个事儿，我是 Sabiyary!</s></p>\n<h3 id=\"5-高亮-用-包围\"><a class=\"markdownIt-Anchor\" href=\"#5-高亮-用-包围\">#</a> 5. * 高亮 [用 “==” 包围]</h3>\n<p><strong>(注意：此为扩展语法)</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==我喜欢黄色, 也喜欢绿色==</span><br></pre></td></tr></table></figure>\n<p>==E.G. ==</p>\n<p><mark>我喜欢黄色，也喜欢绿色</mark></p>\n<h3 id=\"6-代码-用-包围\"><a class=\"markdownIt-Anchor\" href=\"#6-代码-用-包围\">#</a> 6. 代码 [用 “`” 包围]</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`sudo rm -rf /*`</span><br></pre></td></tr></table></figure>\n<p><em><strong>E.G.</strong></em></p>\n<p><code>sudo rm -rf /*</code>  (没事别乱敲这个！)</p>\n<p><s>“请输入管理员密码: (闪烁的光标)”</s></p>\n<h3 id=\"7-代码块-按三个-并敲回车\"><a class=\"markdownIt-Anchor\" href=\"#7-代码块-按三个-并敲回车\">#</a> 7. 代码块 [按三个 “`” 并敲回车]</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\"><span class=\"comment\">// 这里就可以开始输入你要的代码了</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">mian</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    print（“Hello, world!\\n<span class=\"string\">&quot;）;</span></span><br><span class=\"line\"><span class=\"string\">    retrun O;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">``` // (这三个&quot;</span>`<span class=\"string\">&quot;文本编辑器会帮你自动补全 一般不用手动输)</span></span><br></pre></td></tr></table></figure>\n<p>(我之前都是用这个来展示各种语法的，应该不用举例了吧)</p>\n<p>要想显示行数的话，一般要在 Typora 的设置里勾上这个显示行数的选项.</p>\n<p>代码块里可以选择语言，其会根据语言来自动高亮各个语句。在选择语言后， <code>```</code>  会变为  <code>````</code>  +  <code>对应语言</code> .</p>\n<h3 id=\"8-引用-空格-前置\"><a class=\"markdownIt-Anchor\" href=\"#8-引用-空格-前置\">#</a> 8. 引用 [“&gt;” + 空格 前置]</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 24岁, 是学生.</span><br><span class=\"line\">&gt; &gt; 学生特有的无处不在(恼)</span><br></pre></td></tr></table></figure>\n<p>引用是可以嵌套的！</p>\n<p>E.G.</p>\n<blockquote>\n<p>24 岁，是学生.</p>\n<blockquote>\n<p>学生特有的无处不在 (恼)</p>\n</blockquote>\n</blockquote>\n<h3 id=\"9-无序列表-或-空格-前置\"><a class=\"markdownIt-Anchor\" href=\"#9-无序列表-或-空格-前置\">#</a> 9. 无序列表 [“-” 或  “+” + 空格 前置]</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 一颗是枣树 (我喜欢用这种)</span><br><span class=\"line\">+ 另一颗还是枣树</span><br><span class=\"line\">* (其实这种也可以, 不过由于在 Typora 中很难单个输入, 故不常用)</span><br></pre></td></tr></table></figure>\n<p>三种前置符都可以，敲回车会自动补全，可在 Typora 设置中调整补全的符号，敲回车后按下  <code>Tab</code>  会缩进一级.</p>\n<p><strong>E.G.</strong></p>\n<ul>\n<li>一颗是枣树</li>\n<li>另一颗还是枣树</li>\n</ul>\n<h3 id=\"10-有序列表-数字-空格-前置\"><a class=\"markdownIt-Anchor\" href=\"#10-有序列表-数字-空格-前置\">#</a> 10. 有序列表 [数字 + “.” + 空格 前置]</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我来这里就为了三件事:</span><br><span class=\"line\">1. 公平</span><br><span class=\"line\">2. 公平</span><br><span class=\"line\">3. 还是tm的公平!</span><br></pre></td></tr></table></figure>\n<p>敲回车会自动补全，敲回车后按下  <code>Tab</code>  会缩进一级.</p>\n<p>E.G.</p>\n<p>我来这里就为了三件事:</p>\n<ol>\n<li>\n<p>公平</p>\n</li>\n<li>\n<p>公平</p>\n</li>\n<li>\n<p>还是 tm 的公平！</p>\n</li>\n</ol>\n<h3 id=\"11-上标-用-包围\"><a class=\"markdownIt-Anchor\" href=\"#11-上标-用-包围\">#</a> 11. * 上标 [用 “^” 包围]</h3>\n<p><strong>(注意：此为扩展语法)</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C语言中int的上限是 2^31^ - 1 = 2147483647</span><br></pre></td></tr></table></figure>\n<p>E.G.</p>\n<p>C 语言中  <code>int</code>  的上限是 2<sup>31</sup> - 1 = 2147483647</p>\n<h3 id=\"12-下标-用-~-包围\"><a class=\"markdownIt-Anchor\" href=\"#12-下标-用-~-包围\">#</a> 12. * 下标 [用 “~” 包围]</h3>\n<p><strong>(注意：此为扩展语法)</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">H~2~O 是剧毒的!</span><br></pre></td></tr></table></figure>\n<p>E.G.</p>\n<p>H<sub>2</sub>O 是剧毒的！</p>\n<h3 id=\"13-注释-后置\"><a class=\"markdownIt-Anchor\" href=\"#13-注释-后置\">#</a> 13. * 注释 [“[^]” 后置]</h3>\n<p><strong>(注意：此为扩展语法)</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 今日我们相聚于此, 是为了学习 Markdown 的使用, 它的教程对于全体「观众」而言, 值得足足两个硬币的支持鼓励![^1]</span><br><span class=\"line\"></span><br><span class=\"line\">[^1]: 沃兹·基·硕德 改编自「公鸡」普契涅拉.</span><br></pre></td></tr></table></figure>\n<p>需要在文末写上注释对应的内容</p>\n<p>E.G.</p>\n<blockquote>\n<p>今日我们相聚于此，是为了学习 Markdown 的使用，它的教程对于全体「观众」而言，值得足足两个硬币的支持鼓励！<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></p>\n</blockquote>\n<h3 id=\"14-链接-常用-分别包围文本与链接\"><a class=\"markdownIt-Anchor\" href=\"#14-链接-常用-分别包围文本与链接\">#</a> 14. 链接 [常用 “[]” + “( )” 分别包围文本与链接]</h3>\n<p><strong>(注意：文内跳转为扩展用法)</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[来看看我贫瘠的仓库罢](https://github.com/Sakiyary)</span><br><span class=\"line\">[基础教程: 12. 下标](#12. 下标 [用 &quot;~&quot; 包围])</span><br></pre></td></tr></table></figure>\n<p>支持网页链接与文内跳转，按住  <code>Ctrl</code>  并  <code>单击鼠标左键</code>  即可跳转.</p>\n<p>E.G.</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1Nha2l5YXJ5\">来看看我贫瘠的仓库罢</span></p>\n<p>[基础教程: 12. 下标](#12. 下标 [用 “~” 包围])</p>\n<h3 id=\"15-任务列表-空格-前置\"><a class=\"markdownIt-Anchor\" href=\"#15-任务列表-空格-前置\">#</a> 15. 任务列表 [“- []” + 空格 前置]</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TodoList:</span><br><span class=\"line\">- [ ] 刷B站</span><br><span class=\"line\">- [ ] 写代码</span><br><span class=\"line\">- [x] 起床</span><br></pre></td></tr></table></figure>\n<p>用  <code>x</code>  代替  <code>[ ]</code>  中的空格来勾选任务列表。在 Typora 中可以直接用鼠标左键单击勾选框.</p>\n<p>E.G. TodoList:</p>\n<ul class=\"task-list\">\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_0\" disabled=\"true\"><label for=\"cbx_0\"> 刷 B 站</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_1\" disabled=\"true\"><label for=\"cbx_1\"> 刷 B 站</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_2\" disabled=\"true\"><label for=\"cbx_2\"> 写代码</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_3\" checked=\"true\" disabled=\"true\"><label for=\"cbx_3\"> 起床</label></p>\n</li>\n</ul>\n<h3 id=\"16-表格-用-绘制表格边框\"><a class=\"markdownIt-Anchor\" href=\"#16-表格-用-绘制表格边框\">#</a> 16. 表格 [用 “|” 绘制表格边框]</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| 学号 | 姓名  | 年龄 |</span><br><span class=\"line\">| :--- | :---: | ---: | (引号的位置代表着 左对齐, 居中, 右对齐)</span><br><span class=\"line\">|114514|田所|24|</span><br><span class=\"line\">|1919810|浩三|25|</span><br></pre></td></tr></table></figure>\n<p>第一行为表头，并由第二行分割线决定对齐方式与长度，第三行及之后即表格数据</p>\n<p>E.G.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">学号</th>\n<th style=\"text-align:center\">姓名</th>\n<th style=\"text-align:right\">年龄</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">114514</td>\n<td style=\"text-align:center\">田所</td>\n<td style=\"text-align:right\">24</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1919810</td>\n<td style=\"text-align:center\">浩三</td>\n<td style=\"text-align:right\">25</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"17-图片-直接拖进来或者复制粘贴\"><a class=\"markdownIt-Anchor\" href=\"#17-图片-直接拖进来或者复制粘贴\">#</a> 17. 图片 [直接拖进来或者复制粘贴]</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![图片](图片的位置)</span><br></pre></td></tr></table></figure>\n<p>我还是会选择拖进来或者复制粘贴啦～在 Typora 的设置里也可以改图片的储存方式.</p>\n<h3 id=\"18-分割线-按三个-或-或-_-并敲回车\"><a class=\"markdownIt-Anchor\" href=\"#18-分割线-按三个-或-或-_-并敲回车\">#</a> 18. 分割线 [按三个 “*” 或 “-” 或 “_” 并敲回车]</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">***</span><br><span class=\"line\">--- (我喜欢用这种)</span><br><span class=\"line\">___</span><br><span class=\"line\">// (其实按三个及以上都可以)</span><br></pre></td></tr></table></figure>\n<p>由于  <code>*</code>  与  <code>_</code>  均会自动补全，所以我觉得  <code>-</code>  最为方便.</p>\n<p>E.G.</p>\n<hr>\n<hr>\n<hr>\n<h3 id=\"19-emoji表情-前置\"><a class=\"markdownIt-Anchor\" href=\"#19-emoji表情-前置\">#</a> 19. Emoji 表情 [“:” 前置]</h3>\n<p><strong>(注意：英文输入为扩展语法)</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:sweat_smile: </span><br><span class=\"line\">:drooling_face:</span><br><span class=\"line\">:clown_face:</span><br><span class=\"line\">// (敲回车或者鼠标点击, 后置的&quot;:&quot;一般不需要手动输)</span><br></pre></td></tr></table></figure>\n<p>这个功能唯一的要求就是英语水平要高，或者大概记得各个 Emoji 的英文名.</p>\n<p>E.G.</p>\n<p>😅<br>\n🤤<br>\n🤡</p>\n<p>对于其余普通的 Markdown 文本编辑器，可以直接将 Emoji 表情复制进来，这是直接<strong>硬编码</strong>的 (<s>刻进 DNA 里</s>)</p>\n<p>E.G.</p>\n<p>😅🤤🤡</p>\n<p>用好这个功能可以让你的文本非常的可爱！<s>太抽象了</s></p>\n<p>这里分享一个可以复制<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbW9qaXBlZGlhLm9yZy9hcHBsZS8=\">全 Emoji 的网站</span>，非常好用！我之前的 C 语言大作业也是从这里下载的资源！</p>\n<h2 id=\"进阶教程\"><a class=\"markdownIt-Anchor\" href=\"#进阶教程\">#</a> 🔥 进阶教程</h2>\n<h3 id=\"1-目录-自动生成\"><a class=\"markdownIt-Anchor\" href=\"#1-目录-自动生成\">#</a> 1. 目录 [自动生成]</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[TOC] (此为 Typora 特有的, 如本文档开头)</span><br></pre></td></tr></table></figure>\n<p>若使用 VS Code 搭配 Markdown All in One 扩展，可在 VS Code 的 <code>命令面板</code>  (即 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vZG9jcy9nZXRzdGFydGVkL3VzZXJpbnRlcmZhY2UjX2NvbW1hbmQtcGFsZXR0ZQ==\">VS Code Command Palette</span>) 输入  <code>Create Table of Contents</code>  自动生成目录，且可在扩展设置中细调目录参数.</p>\n<h3 id=\"2-内联-html-代码-用-包围\"><a class=\"markdownIt-Anchor\" href=\"#2-内联-html-代码-用-包围\">#</a> 2. 内联 HTML 代码 [用 “&lt;&gt; &lt;/&gt;” 包围]</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div style=&quot;text-align:center&quot;&gt;</span><br><span class=\"line\">  &lt;font style=&quot;color:red&quot;&gt;我不会 HTML 呜呜呜... 浇浇我&lt;/font&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;center&gt;简单的文字居中也可以这样&lt;/center&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;u&gt;我差点忘了还有下划线这东西...&lt;/u&gt;</span><br></pre></td></tr></table></figure>\n<p>只要你会写，你完全可以把 Markdown 当作 <strong>HTML</strong> 来写.</p>\n<p>同时， <code>.md</code>  文件可以直接导出成一个网页.</p>\n<p>下划线可以选中想要下划的文字按下  <code>Ctrl</code>  +  <code>U</code> .</p>\n<p><u>E.G.</u></p>\n<div style=\"text-align:center\">\n  <font style=\"color:red\">我不会 HTML 呜呜呜... 浇浇我</font>\n</div>\n<center>简单的文字居中也可以这样</center>\n<p><u>我差点忘了还有下划线这东西…</u></p>\n<h3 id=\"3-内联-latex-公式-用-包围\"><a class=\"markdownIt-Anchor\" href=\"#3-内联-latex-公式-用-包围\">#</a> 3. 内联 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding=\"application/x-tex\">\\LaTeX</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8988em;vertical-align:-0.2155em;\"></span><span class=\"mord text\"><span class=\"mord textrm\">L</span><span class=\"mspace\" style=\"margin-right:-0.36em;\"></span><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6833em;\"><span style=\"top:-2.905em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"mord\"><span class=\"mord textrm mtight sizing reset-size6 size3\">A</span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:-0.15em;\"></span><span class=\"mord text\"><span class=\"mord textrm\">T</span><span class=\"mspace\" style=\"margin-right:-0.1667em;\"></span><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4678em;\"><span style=\"top:-2.7845em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord textrm\">E</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2155em;\"><span></span></span></span></span><span class=\"mspace\" style=\"margin-right:-0.125em;\"></span><span class=\"mord textrm\">X</span></span></span></span></span></span> 公式 [用 “$” 包围]</h3>\n<p><strong>(注意：部分编译器会不识别部分符号)</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$\\LaTeX$ 是最好用的论文排版语言! 不信你看!</span><br><span class=\"line\"></span><br><span class=\"line\">$a^n+b^n=c^n$</span><br><span class=\"line\"></span><br><span class=\"line\">$$</span><br><span class=\"line\">%\\usepackage&#123;unicode-math&#125;</span><br><span class=\"line\">\\displaystyle \\ointctrclockwise\\mathcal&#123;D&#125;[x(t)]</span><br><span class=\"line\">\\sqrt&#123;\\frac&#123;\\displaystyle3\\uppi^2-\\sum_&#123;q=0&#125;^&#123;\\infty&#125;(z+\\hat L)^&#123;q&#125;</span><br><span class=\"line\">\\exp(\\symrm&#123;i&#125;q^2 \\hbar x)&#125;&#123;\\displaystyle (\\symsfup&#123;Tr&#125;\\symbfcal&#123;A&#125;)</span><br><span class=\"line\">\\left(\\symbf\\Lambda_&#123;j_1j_2&#125;^&#123;i_1i_2&#125;\\Gamma_&#123;i_1i_2&#125;^&#123;j_1j_2&#125;</span><br><span class=\"line\">\\hookrightarrow\\vec D\\cdot \\symbf P \\right)&#125;&#125;</span><br><span class=\"line\">=\\underbrace&#123;\\widetilde&#123;\\left\\langle \\frac&#123;\\notin \\emptyset&#125;</span><br><span class=\"line\">&#123;\\varpi\\alpha_&#123;k\\uparrow&#125;&#125;\\middle\\vert</span><br><span class=\"line\">\\frac&#123;\\partial_\\mu T_&#123;\\mu\\nu&#125;&#125;&#123;2&#125;\\right\\rangle&#125;&#125;_&#123;\\mathrm&#123;K&#125;_3</span><br><span class=\"line\">\\mathrm&#123;Fe&#125;(\\mathrm&#123;CN&#125;)_6&#125; ,\\forall z \\in \\mathbb&#123;R&#125;</span><br><span class=\"line\">$$</span><br></pre></td></tr></table></figure>\n<p>用  <code>$</code>  包围为单条公式，按下两个  <code>$</code>  并敲回车即生成公式块.</p>\n<p>E.G.</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding=\"application/x-tex\">\\LaTeX</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8988em;vertical-align:-0.2155em;\"></span><span class=\"mord text\"><span class=\"mord textrm\">L</span><span class=\"mspace\" style=\"margin-right:-0.36em;\"></span><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6833em;\"><span style=\"top:-2.905em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"mord\"><span class=\"mord textrm mtight sizing reset-size6 size3\">A</span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:-0.15em;\"></span><span class=\"mord text\"><span class=\"mord textrm\">T</span><span class=\"mspace\" style=\"margin-right:-0.1667em;\"></span><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4678em;\"><span style=\"top:-2.7845em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord textrm\">E</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2155em;\"><span></span></span></span></span><span class=\"mspace\" style=\"margin-right:-0.125em;\"></span><span class=\"mord textrm\">X</span></span></span></span></span></span> 是最好用的论文排版语言！不信你看！</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mo>+</mo><msup><mi>b</mi><mi>n</mi></msup><mo>=</mo><msup><mi>c</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">a^n+b^n=c^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7477em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6644em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></p>\n%\\usepackage{unicode-math}\n\\displaystyle \\ointctrclockwise\\mathcal{D}[x(t)]\n\\sqrt{\\frac{\\displaystyle3\\uppi^2-\\sum_{q=0}^{\\infty}(z+\\hat L)^{q}\n\\exp(\\symrm{i}q^2 \\hbar x)}{\\displaystyle (\\symsfup{Tr}\\symbfcal{A})\n\\left(\\symbf\\Lambda_{j_1j_2}^{i_1i_2}\\Gamma_{i_1i_2}^{j_1j_2}\n\\hookrightarrow\\vec D\\cdot \\symbf P \\right)}}\n=\\underbrace{\\widetilde{\\left\\langle \\frac{\\notin \\emptyset}\n{\\varpi\\alpha_{k\\uparrow}}\\middle\\vert\n\\frac{\\partial_\\mu T_{\\mu\\nu}}{2}\\right\\rangle}}_{\\mathrm{K}_3\n\\mathrm{Fe}(\\mathrm{CN})_6} ,\\forall z \\in \\mathbb{R}\n\n<h3 id=\"4-网络图床\"><a class=\"markdownIt-Anchor\" href=\"#4-网络图床\">#</a> 4. * 网络图床</h3>\n<p>(这是学长给我的网络图床教程，我并未实践过…)</p>\n<p>分享一个 Typora 搭配腾讯云 COS / 阿里云 OSS 图床的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b19yaWRnZXBvbGUvYXJ0aWNsZS9kZXRhaWxzLzEwODI1NzI3Nw==\">例子</span>。新用户免费试用 6 个月，另外还可选择七牛云或者路过图床.</p>\n<h3 id=\"5-typora-的常用快捷键\"><a class=\"markdownIt-Anchor\" href=\"#5-typora-的常用快捷键\">#</a> 5. *Typora 的常用快捷键</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">按键</th>\n<th style=\"text-align:center\">效果</th>\n<th style=\"text-align:center\">按键</th>\n<th style=\"text-align:center\">效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>Ctrl</code>  +  <code>D</code></td>\n<td style=\"text-align:center\">选中当前词</td>\n<td style=\"text-align:center\"><code>Ctrl</code>  +  <code>L</code></td>\n<td style=\"text-align:center\">选中当前句 / 行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>Ctrl</code>  +  <code>E</code></td>\n<td style=\"text-align:center\">选中当前区块</td>\n<td style=\"text-align:center\"><code>Ctrl</code>  +  <code>F</code></td>\n<td style=\"text-align:center\">搜索当前选中</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>Ctrl</code>  +  <code>B</code></td>\n<td style=\"text-align:center\">加粗当前选中</td>\n<td style=\"text-align:center\"><code>Ctrl</code>  +  <code>H</code></td>\n<td style=\"text-align:center\">替换当前选中</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>Ctrl</code>  +  <code>I</code></td>\n<td style=\"text-align:center\">倾斜当前选中</td>\n<td style=\"text-align:center\"><code>Ctrl</code>  +  <code>U</code></td>\n<td style=\"text-align:center\">下划当前选中</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>Ctrl</code>  +  <code>K</code></td>\n<td style=\"text-align:center\">将当前选中生成链接</td>\n<td style=\"text-align:center\"><code>Ctrl</code>  +  <code>J</code></td>\n<td style=\"text-align:center\">滚动屏幕将选中滚至顶部</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>Ctrl</code>  +  <code>W</code></td>\n<td style=\"text-align:center\">关闭当前窗口</td>\n<td style=\"text-align:center\"><code>Ctrl</code>  +  <code>N</code></td>\n<td style=\"text-align:center\">打开新窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>Ctrl</code>  +  <code>O</code></td>\n<td style=\"text-align:center\">打开文件</td>\n<td style=\"text-align:center\"><code>Ctrl</code>  +  <code>P</code></td>\n<td style=\"text-align:center\">搜索文件并打开</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>Ctrl</code>  +  <code>回车</code></td>\n<td style=\"text-align:center\">表格下方插入行</td>\n<td style=\"text-align:center\"><code>Ctrl</code>  +  <code>,</code></td>\n<td style=\"text-align:center\">打开偏好设置</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>Ctrl</code>  +  <code>.</code></td>\n<td style=\"text-align:center\">切换全角 / 半角标点</td>\n<td style=\"text-align:center\"><code>Ctrl</code>  +  <code>/</code></td>\n<td style=\"text-align:center\">切换正常 / 源代码视图</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>Ctrl</code>  +  <code>Shift</code>  +  <code>-</code></td>\n<td style=\"text-align:center\">缩小视图缩放</td>\n<td style=\"text-align:center\"><code>Ctrl</code>  +  <code>Shift</code>  +  <code>+</code></td>\n<td style=\"text-align:center\">放大视图缩放</td>\n</tr>\n</tbody>\n</table>\n<p>还有一些不常用的 / 三键的快捷键不在此列出.</p>\n<h3 id=\"6-typora-的主题样式与检查元素\"><a class=\"markdownIt-Anchor\" href=\"#6-typora-的主题样式与检查元素\">#</a> 6. *Typora 的主题样式与检查元素</h3>\n<p>Markdown 在编译后约等于 HTML. 而 Typora 的正常视图就是编译后的 Markdown, 故 Typora 的主题样式本质就是 CSS 文件.</p>\n<p>可以下载各种好看的主题给 Typora 换上，同时也可以自己调整对应的 CSS 文件，或者自己手搓.</p>\n<p>在 Typora 设置中开启  <code>调试模式</code>  后即可在正常视图右击打开  <code>检查元素</code> ，在其中就可以完全将 Markdown 文件当成 HTML 来编辑.</p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 💯 总结</h2>\n<p>至此，<strong>Markdown + Typora / VSCode</strong> 的手册教程也告一段落.</p>\n<p>不知你看完这么长的教程 / 手册，是否能体会到 Markdown 的精妙简洁之处呢？</p>\n<p>其实 Markdown 只是标记语言的最开始，我的感受是会了 Markdown 之后对于理解 HTML 也有帮助，对于用 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding=\"application/x-tex\">\\LaTeX</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8988em;vertical-align:-0.2155em;\"></span><span class=\"mord text\"><span class=\"mord textrm\">L</span><span class=\"mspace\" style=\"margin-right:-0.36em;\"></span><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6833em;\"><span style=\"top:-2.905em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"mord\"><span class=\"mord textrm mtight sizing reset-size6 size3\">A</span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:-0.15em;\"></span><span class=\"mord text\"><span class=\"mord textrm\">T</span><span class=\"mspace\" style=\"margin-right:-0.1667em;\"></span><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4678em;\"><span style=\"top:-2.7845em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord textrm\">E</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2155em;\"><span></span></span></span></span><span class=\"mspace\" style=\"margin-right:-0.125em;\"></span><span class=\"mord textrm\">X</span></span></span></span></span></span> 来写论文也有帮助。标记语言正是为了摆脱 Word 那种虽然 &quot;所见即所得&quot;, 但又过于花哨浮华，很差的兼容性与闭源的编码的缺陷。当你能掌握这样的 &quot;所写即所得&quot; 时，你肯定会感受到用 Markdown 这类语言来处理文本的妙处！</p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>沃兹・基・硕德 改编自「公鸡」普契涅拉. <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
            "tags": []
        }
    ]
}